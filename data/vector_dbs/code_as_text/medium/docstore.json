{"docstore/metadata": {"all_interval_medium": {"doc_hash": "4343d2eee6c08ad33ebc0972b40e662fce98595b530f61884391b2ed126b32b8"}, "assign_medium": {"doc_hash": "7f736fcf8d6cb0af7667104309075d1ea074205f76a9368766d2ae42d1833005"}, "aust_color_medium": {"doc_hash": "9a8b50f16ea047ce43cb445bdc36015cc29b91b72209d3b826172afed3a6b74b"}, "bibd_medium": {"doc_hash": "ce8044193a2fac2b94ee57d11ae448530b2495739d410dfed59baaac0cc0c341"}, "bus_scheduling_csplib_medium": {"doc_hash": "fb600763756eabcc20c51c44e195cb770be9e6d5d9790ecbdf527bc1f5873e76"}, "car_medium": {"doc_hash": "5b14bdea8da86fff307ea24601d96c4ae65a0f8a09f254c7a96d52cbd0d06282"}, "carpet_cutting_medium": {"doc_hash": "5c9ab3d8796f36bd5253a83fd0e3982e355eb391bacc418093f2228a73a4b86f"}, "cell_block_medium": {"doc_hash": "9c669adb7ee7bff79b5636993cc48943b83c2b23ea65591c7d9ab5c92cf4396a"}, "clique_medium": {"doc_hash": "ed0b6547b5c7af10d3c9ec910c5985952ce6b5b7a93c52a8c02049d0d7a8f923"}, "cluster_medium": {"doc_hash": "16fe1074ba0c3d229b3491e93339e81147aaaa9ca26b9975d2d4a8c0637afbf2"}, "compatible_assignment_medium": {"doc_hash": "d03ecb1d233d58d2534d52dc4420f4f0ad8f8735fce0183ad6f3a1fc0a0f2737"}, "constrained_connected_medium": {"doc_hash": "bf81d7fe72a1d76b70b433288c40419ceae3710c159510998a619442716fd0d7"}, "crazy_sets_medium": {"doc_hash": "0f7ba6d1b1957caad577f5afa62708e7c647d14387ab229e6782f607cfdca493"}, "crossfigure_medium": {"doc_hash": "df53bc2b1b4635ddb005f0d716529f8839f2af4e40cd1350df542caa12698543"}, "curriculum_medium": {"doc_hash": "b02d342dd639dff764ea0be8f5d71357ac36d29af207b9883c82103b7d5a95f2"}, "diamond_free_degree_sequence_medium": {"doc_hash": "d74e757be3fa5fc51f197ca508f92a3dfe7738aebe40aa012e04e3f39dde0081"}, "doublechannel_medium": {"doc_hash": "8ceca8569f3d88fbd7f8646adab0c64e187b0bb8630d99cc84a2d7659c0c1486"}, "fractions_medium": {"doc_hash": "65e1926440cc707a0c700ff6a45bd637d809982ad8a9ad0f8f30aeace5b7833f"}, "golfers_medium": {"doc_hash": "ca9e0d18ad28e8abed569f6a1258f26f8c9439e1d74df8dcfb3f814f0280d343"}, "golomb_medium": {"doc_hash": "d3abf932a02a0e766acf382eafe858189ce803d79c72e51a631a8dc6e80877a2"}, "graph_medium": {"doc_hash": "2e14510bee2bfd37d47031756b567269d7edea5d175e2af187f406e3b3bb6c78"}, "itemset_mining_medium": {"doc_hash": "20e03232eb8a60310fc55acfaf802daa156606b7689b9b67817e07b402c073af"}, "jobshop_medium": {"doc_hash": "8605374b68594b4203d4a7999948df06827a1cf1d5570e5fc6d14bd7f5751daf"}, "K4xP2Graceful_medium": {"doc_hash": "837f26fbf3d0e640c8c957190953f9459740d3dbf059dbee93aef01b5d1c4511"}, "killer_sudoku_medium": {"doc_hash": "bd035d6eee8b1c755e4d2dd716f55bba73489f22082bb47fffb3eb7b56f310d7"}, "knapsack_medium": {"doc_hash": "cc932f3ea3a20fccba7a251567bfe6faf7c21642246bf1c9060c88b42e69efaf"}, "langford_medium": {"doc_hash": "b17aa2d09e8dd882facdc22671829a9f853bbb85715b4df87b53b70fc2eb6e6c"}, "loan_medium": {"doc_hash": "ea0a18c84c7d227949fb0096ceb60abf2609ff146f4b3c50546158504a3110ec"}, "ltsp_medium": {"doc_hash": "b60d6665bc7c90643ef9640d5d81cc8a37914c0ec9f9f1d8b71bfae7f883668b"}, "magic_hexagon_medium": {"doc_hash": "33bcf600391c8b7b906c2f0a1f6dcd39e16165738f86f1ad9f7f1e369f912a76"}, "magic_sequence_medium": {"doc_hash": "1c3e5523e10b945d38288e597d12adca3318a71660bece4710d99b24379f1db9"}, "maximum_density_still_life_medium": {"doc_hash": "0abdfafe795714784b19f6496a2cf15de8b83ec28094092bff52824bf8d4043d"}, "mip_medium": {"doc_hash": "2af6bac97519dbaee7a3c0406044c0b3609ee24464bcb709bc81a6ad741e31f7"}, "missing_solution_medium": {"doc_hash": "7bb4d3447e9072db52bb0403979c9544b5aeff70569def1b63d933ec28c81714"}, "nonogram_create_automaton2_medium": {"doc_hash": "689f0391e0b82a75ecbe2fd7e40a89e05d7d5d21410cf4654fe1710ac0d75844"}, "nurses_medium": {"doc_hash": "51aa8780dec6507ef4be075804242a0dcda53168c713a7d52398fab348b443b4"}, "opd_medium": {"doc_hash": "345e3e00a0036f816359804d7c48a227150e11df27631c5e261a5d40319b6a59"}, "partition_medium": {"doc_hash": "563247862ea64a3112505f5861ef6b3f84e91a92026857b11a97107b6c2f9a8b"}, "photo_medium": {"doc_hash": "745d0eee2e94e5dea32c9e9b109305038ec28a4d9589fea62f92b6af90f3fb37"}, "project_scheduling_medium": {"doc_hash": "431a0ee9f10c2e9de4bac0f456973e676912b79149b06394338d2c37ef688f45"}, "QuasigroupCompletion_medium": {"doc_hash": "703640cf28aac12efa85aecb6f1268aa3b7d71fac9c6688123b59f19eb9916bb"}, "QuasiGroupExistence_medium": {"doc_hash": "db85db73bd3ff38111418809e4a162429b169f8f49fc8fc586ad41514baf36ce"}, "queens_medium": {"doc_hash": "dfb9e75c68b56675eb82deda9db733904937e40d81593896eb23c211bc57f113"}, "rcpsp_medium": {"doc_hash": "d309de77cf05432241b00f15555bedebd4709101c5bbcfdbaeca48b7f99d3514"}, "rehearsal_medium": {"doc_hash": "168fd95da485b05668f93a08de33b0a0f71896556da0d875bcf6fcbbe477376e"}, "restart_medium": {"doc_hash": "798052963e0dd4b80299bf57840cc21aa61657fb4b2f1b0ca8d81a4344b070d0"}, "RosteringProblem_medium": {"doc_hash": "ed97a920bf97807fad9cfcbdc2dea547f8f54d52c1eaa451b38d8b1b1e49e377"}, "sb_medium": {"doc_hash": "c44a8e865e6edf781e7ffaf20d73c794d347f80723edc04edc4304a0b8af6967"}, "schur_medium": {"doc_hash": "ce87c88f28fda99964b7ef840d4a2855a09684a3d87e541272586bac931ecd6d"}, "setselect_medium": {"doc_hash": "46eb5c102d2648ffeb399498f61d3a0f9faf53372930a83031a7af4cf876f2e2"}, "shipping_medium": {"doc_hash": "d4017d9832dd57f4996c064af485303c99843215854115d875b31ff3e5385a32"}, "simple-prod-planning_medium": {"doc_hash": "7fddd3cfabf57a433ceb9d6511c4d43857e6daeaf548c74ae143671cbbbaa757"}, "sonet_problem_medium": {"doc_hash": "4747816d58cff87e792ce38ff03c96db94e9a90c4e71dbef42bb697c48a72716"}, "square_pack_medium": {"doc_hash": "7679462377010c1c4d174a3ad4393e78591b4fba32e7cde76307fa81b6a0d2ca"}, "stableroommates_medium": {"doc_hash": "e4a4a36570b89b42f3d21f9b8f88c8de6d548ac0757a22d59aafb5845eb18b6e"}, "steiner_medium": {"doc_hash": "054b9f4d5413aea65acf5e2ad91df36137134bf677da03074e2a42965e077307"}, "stoch_fjsp_medium": {"doc_hash": "64b6b487782af24915e49051decd80ce13f5e6aaf372ece4a7658d387206fe6e"}, "submultisetsum_medium": {"doc_hash": "f745979d716b405dd9eef8313b8532bbf264828dacb30e64c224f6434d747e9a"}, "table_seating_medium": {"doc_hash": "a6dcb2e8a6f86b185c8c43d95a05753c5abaedec5846e6a89d42ace761f4f4af"}, "teamselect_medium": {"doc_hash": "65ce7108b2362af73b7ee1847bcf3c04fe17a8ffe8ac9dd1cdc75b0a50e4a45d"}, "template_design_medium": {"doc_hash": "996da4f9196344357fae08148955a2779e1bb42ca4c0030b92b0b6106c067962"}, "toomany_medium": {"doc_hash": "c160b1044b80e3302ae3161777c9e1fe65b7ee96da2c9216dc64f54f897c55ad"}, "traffic_lights_table_medium": {"doc_hash": "d2919f51a8f2ffabd657560ff499091cbeb00edc3ccbf75cb97ac2d023101d62"}, "TTPPV_medium": {"doc_hash": "d1b95f4bccb13b841fb14f6aa3f6032240c61f069ad453f83eaf8eaa8ec96f03"}, "vessel-loading_medium": {"doc_hash": "aed297c4a380753ea06480da5644bd9d8962c5d527d3299b3d3541c3cc6668dc"}, "warehouses_medium": {"doc_hash": "0082f00ad83fce8bd5acfc99dd12e9a6901fe8fceda9d3e4fddf412a9f028056"}, "water_buckets1_medium": {"doc_hash": "e3212fe2a8e34cca83016a04f0b2c7469bee1031268775a366cc1508991f4a9d"}, "a72b4934-9cf8-469a-a3a7-9539883b39bc": {"doc_hash": "4343d2eee6c08ad33ebc0972b40e662fce98595b530f61884391b2ed126b32b8", "ref_doc_id": "all_interval_medium"}, "cc78401b-3da2-4142-8254-8e14a7141665": {"doc_hash": "7f736fcf8d6cb0af7667104309075d1ea074205f76a9368766d2ae42d1833005", "ref_doc_id": "assign_medium"}, "222e4ed0-395e-45c3-929c-71d810329edf": {"doc_hash": "9a8b50f16ea047ce43cb445bdc36015cc29b91b72209d3b826172afed3a6b74b", "ref_doc_id": "aust_color_medium"}, "06ce707c-e4a9-4683-841d-2e24832d3c82": {"doc_hash": "ce8044193a2fac2b94ee57d11ae448530b2495739d410dfed59baaac0cc0c341", "ref_doc_id": "bibd_medium"}, "13b22c23-05d1-4ce8-95c5-768e78551724": {"doc_hash": "fb600763756eabcc20c51c44e195cb770be9e6d5d9790ecbdf527bc1f5873e76", "ref_doc_id": "bus_scheduling_csplib_medium"}, "95b1973f-37a4-4a4a-bc30-339306938e44": {"doc_hash": "5b14bdea8da86fff307ea24601d96c4ae65a0f8a09f254c7a96d52cbd0d06282", "ref_doc_id": "car_medium"}, "e4e15d83-baf1-4de5-92c0-28ba91c370a9": {"doc_hash": "5c9ab3d8796f36bd5253a83fd0e3982e355eb391bacc418093f2228a73a4b86f", "ref_doc_id": "carpet_cutting_medium"}, "0afdbb52-009b-43fe-b472-cd0415773b83": {"doc_hash": "9c669adb7ee7bff79b5636993cc48943b83c2b23ea65591c7d9ab5c92cf4396a", "ref_doc_id": "cell_block_medium"}, "d1c37052-b7ac-4468-baff-d6affba82235": {"doc_hash": "ed0b6547b5c7af10d3c9ec910c5985952ce6b5b7a93c52a8c02049d0d7a8f923", "ref_doc_id": "clique_medium"}, "114c1571-5c1b-4895-917a-8343db2888ff": {"doc_hash": "16fe1074ba0c3d229b3491e93339e81147aaaa9ca26b9975d2d4a8c0637afbf2", "ref_doc_id": "cluster_medium"}, "3a132428-04d7-4535-9d12-395164ce7983": {"doc_hash": "d03ecb1d233d58d2534d52dc4420f4f0ad8f8735fce0183ad6f3a1fc0a0f2737", "ref_doc_id": "compatible_assignment_medium"}, "98942ef1-1e48-46e8-b6e2-67c76b4dee52": {"doc_hash": "bf81d7fe72a1d76b70b433288c40419ceae3710c159510998a619442716fd0d7", "ref_doc_id": "constrained_connected_medium"}, "fea02433-bf7b-48f3-b8b2-83490a9181c0": {"doc_hash": "0f7ba6d1b1957caad577f5afa62708e7c647d14387ab229e6782f607cfdca493", "ref_doc_id": "crazy_sets_medium"}, "2ecae988-03e5-4962-a35d-5caa3d3b976a": {"doc_hash": "df53bc2b1b4635ddb005f0d716529f8839f2af4e40cd1350df542caa12698543", "ref_doc_id": "crossfigure_medium"}, "07947d3f-064b-4460-acd2-2a3ba8b66406": {"doc_hash": "b02d342dd639dff764ea0be8f5d71357ac36d29af207b9883c82103b7d5a95f2", "ref_doc_id": "curriculum_medium"}, "9883aa5f-a9e9-4813-bb49-4fa54f27093d": {"doc_hash": "d74e757be3fa5fc51f197ca508f92a3dfe7738aebe40aa012e04e3f39dde0081", "ref_doc_id": "diamond_free_degree_sequence_medium"}, "dce3168c-6c0e-41e3-9a07-4ca75eea2e46": {"doc_hash": "8ceca8569f3d88fbd7f8646adab0c64e187b0bb8630d99cc84a2d7659c0c1486", "ref_doc_id": "doublechannel_medium"}, "1f5fa0a6-7402-4e15-9c57-3678cd2adfe2": {"doc_hash": "65e1926440cc707a0c700ff6a45bd637d809982ad8a9ad0f8f30aeace5b7833f", "ref_doc_id": "fractions_medium"}, "f2e9acf2-2385-4fcf-96ef-f8b686d5b134": {"doc_hash": "ca9e0d18ad28e8abed569f6a1258f26f8c9439e1d74df8dcfb3f814f0280d343", "ref_doc_id": "golfers_medium"}, "0bfdcc06-3681-4f03-90db-185ec73ef379": {"doc_hash": "d3abf932a02a0e766acf382eafe858189ce803d79c72e51a631a8dc6e80877a2", "ref_doc_id": "golomb_medium"}, "1e804c9f-6691-439a-a60c-fa57e7352b0e": {"doc_hash": "2e14510bee2bfd37d47031756b567269d7edea5d175e2af187f406e3b3bb6c78", "ref_doc_id": "graph_medium"}, "665b3538-25ff-4224-a32e-49c4bf2d4751": {"doc_hash": "20e03232eb8a60310fc55acfaf802daa156606b7689b9b67817e07b402c073af", "ref_doc_id": "itemset_mining_medium"}, "e5132c48-019e-48fa-ad12-c3621a767a65": {"doc_hash": "8605374b68594b4203d4a7999948df06827a1cf1d5570e5fc6d14bd7f5751daf", "ref_doc_id": "jobshop_medium"}, "b297af9e-e77e-4388-9020-19cd8c68158f": {"doc_hash": "837f26fbf3d0e640c8c957190953f9459740d3dbf059dbee93aef01b5d1c4511", "ref_doc_id": "K4xP2Graceful_medium"}, "9c5ac543-196b-44de-aeb6-e3bd7b74ebdf": {"doc_hash": "bd035d6eee8b1c755e4d2dd716f55bba73489f22082bb47fffb3eb7b56f310d7", "ref_doc_id": "killer_sudoku_medium"}, "79a76e35-3375-403d-b124-efd3d225b0cf": {"doc_hash": "cc932f3ea3a20fccba7a251567bfe6faf7c21642246bf1c9060c88b42e69efaf", "ref_doc_id": "knapsack_medium"}, "2e652a58-feb7-47c7-968c-4fb9c2fa760d": {"doc_hash": "b17aa2d09e8dd882facdc22671829a9f853bbb85715b4df87b53b70fc2eb6e6c", "ref_doc_id": "langford_medium"}, "20ad5802-aad7-4f58-be33-4cdccdc4ff64": {"doc_hash": "ea0a18c84c7d227949fb0096ceb60abf2609ff146f4b3c50546158504a3110ec", "ref_doc_id": "loan_medium"}, "a23399d9-df60-4fda-95a9-216063cdbb68": {"doc_hash": "b60d6665bc7c90643ef9640d5d81cc8a37914c0ec9f9f1d8b71bfae7f883668b", "ref_doc_id": "ltsp_medium"}, "f322f351-2471-4a69-8de0-c3cc211c7348": {"doc_hash": "33bcf600391c8b7b906c2f0a1f6dcd39e16165738f86f1ad9f7f1e369f912a76", "ref_doc_id": "magic_hexagon_medium"}, "f5fce463-340d-4bb3-a4a8-3d9850d3f0ea": {"doc_hash": "1c3e5523e10b945d38288e597d12adca3318a71660bece4710d99b24379f1db9", "ref_doc_id": "magic_sequence_medium"}, "3498e6d5-39c2-4d27-826b-135eb1d9c675": {"doc_hash": "0abdfafe795714784b19f6496a2cf15de8b83ec28094092bff52824bf8d4043d", "ref_doc_id": "maximum_density_still_life_medium"}, "ebee6287-9ad5-4905-9de2-72b3ac45e0a3": {"doc_hash": "2af6bac97519dbaee7a3c0406044c0b3609ee24464bcb709bc81a6ad741e31f7", "ref_doc_id": "mip_medium"}, "7725bcc1-a254-493d-adad-3fb35071b461": {"doc_hash": "7bb4d3447e9072db52bb0403979c9544b5aeff70569def1b63d933ec28c81714", "ref_doc_id": "missing_solution_medium"}, "1e425c9e-9938-4587-8c9d-ad1840abecaa": {"doc_hash": "689f0391e0b82a75ecbe2fd7e40a89e05d7d5d21410cf4654fe1710ac0d75844", "ref_doc_id": "nonogram_create_automaton2_medium"}, "734342bc-864f-4eca-83e6-ae23ca1c845a": {"doc_hash": "51aa8780dec6507ef4be075804242a0dcda53168c713a7d52398fab348b443b4", "ref_doc_id": "nurses_medium"}, "431c391f-5e56-4a7d-b6d8-4f6a1c2a597e": {"doc_hash": "345e3e00a0036f816359804d7c48a227150e11df27631c5e261a5d40319b6a59", "ref_doc_id": "opd_medium"}, "f5b53da2-946f-47af-aec7-62d51bf2cf0f": {"doc_hash": "563247862ea64a3112505f5861ef6b3f84e91a92026857b11a97107b6c2f9a8b", "ref_doc_id": "partition_medium"}, "c61099b8-0c95-4b0f-9ec0-c70318a5a483": {"doc_hash": "745d0eee2e94e5dea32c9e9b109305038ec28a4d9589fea62f92b6af90f3fb37", "ref_doc_id": "photo_medium"}, "92170cef-c48d-4b0f-b77c-70b0f217fec6": {"doc_hash": "431a0ee9f10c2e9de4bac0f456973e676912b79149b06394338d2c37ef688f45", "ref_doc_id": "project_scheduling_medium"}, "e5657726-7cac-48ef-add0-74b048554e58": {"doc_hash": "703640cf28aac12efa85aecb6f1268aa3b7d71fac9c6688123b59f19eb9916bb", "ref_doc_id": "QuasigroupCompletion_medium"}, "1ed6abe4-0c61-4c7c-9895-8448198d4552": {"doc_hash": "db85db73bd3ff38111418809e4a162429b169f8f49fc8fc586ad41514baf36ce", "ref_doc_id": "QuasiGroupExistence_medium"}, "7c45ec2b-dbc4-4a32-aeb8-9ca7fb2b7fa2": {"doc_hash": "dfb9e75c68b56675eb82deda9db733904937e40d81593896eb23c211bc57f113", "ref_doc_id": "queens_medium"}, "1f8ca28d-8abc-431a-b176-62d717e7b559": {"doc_hash": "d309de77cf05432241b00f15555bedebd4709101c5bbcfdbaeca48b7f99d3514", "ref_doc_id": "rcpsp_medium"}, "a97ff742-622d-470f-8ed9-5e0b619abbaa": {"doc_hash": "168fd95da485b05668f93a08de33b0a0f71896556da0d875bcf6fcbbe477376e", "ref_doc_id": "rehearsal_medium"}, "807bd6c6-e1e4-421e-ba08-bf9ff126b086": {"doc_hash": "798052963e0dd4b80299bf57840cc21aa61657fb4b2f1b0ca8d81a4344b070d0", "ref_doc_id": "restart_medium"}, "dbfbc2c8-52a8-4e71-b71e-e75f2cf2fc66": {"doc_hash": "ed97a920bf97807fad9cfcbdc2dea547f8f54d52c1eaa451b38d8b1b1e49e377", "ref_doc_id": "RosteringProblem_medium"}, "0503c332-73a3-48b2-934c-19e9e5e4dce5": {"doc_hash": "c44a8e865e6edf781e7ffaf20d73c794d347f80723edc04edc4304a0b8af6967", "ref_doc_id": "sb_medium"}, "5da2a39a-e81d-4e64-8946-a31b2e1d6277": {"doc_hash": "ce87c88f28fda99964b7ef840d4a2855a09684a3d87e541272586bac931ecd6d", "ref_doc_id": "schur_medium"}, "02ab9b15-6c33-4ba7-8fad-e4c4acc3afef": {"doc_hash": "46eb5c102d2648ffeb399498f61d3a0f9faf53372930a83031a7af4cf876f2e2", "ref_doc_id": "setselect_medium"}, "8e62d1f8-da2a-4e70-870d-c6fb52e1a2ac": {"doc_hash": "d4017d9832dd57f4996c064af485303c99843215854115d875b31ff3e5385a32", "ref_doc_id": "shipping_medium"}, "1e6cd72e-cdc2-4215-bf8a-c7ede3a1032a": {"doc_hash": "7fddd3cfabf57a433ceb9d6511c4d43857e6daeaf548c74ae143671cbbbaa757", "ref_doc_id": "simple-prod-planning_medium"}, "b910294d-0bff-49cb-8f9b-8e103aaba2e1": {"doc_hash": "4747816d58cff87e792ce38ff03c96db94e9a90c4e71dbef42bb697c48a72716", "ref_doc_id": "sonet_problem_medium"}, "db4e21b9-6eef-48a6-b01b-80ce7b513304": {"doc_hash": "7679462377010c1c4d174a3ad4393e78591b4fba32e7cde76307fa81b6a0d2ca", "ref_doc_id": "square_pack_medium"}, "471b24e4-1b83-4bcf-9ce9-154edc2f925f": {"doc_hash": "e4a4a36570b89b42f3d21f9b8f88c8de6d548ac0757a22d59aafb5845eb18b6e", "ref_doc_id": "stableroommates_medium"}, "166928f7-8fcc-4ed6-865d-42433243481b": {"doc_hash": "054b9f4d5413aea65acf5e2ad91df36137134bf677da03074e2a42965e077307", "ref_doc_id": "steiner_medium"}, "7a875155-596d-418c-9ca5-caf9e5fa7be1": {"doc_hash": "64b6b487782af24915e49051decd80ce13f5e6aaf372ece4a7658d387206fe6e", "ref_doc_id": "stoch_fjsp_medium"}, "9e54b495-0011-4112-95ce-003b97f227da": {"doc_hash": "f745979d716b405dd9eef8313b8532bbf264828dacb30e64c224f6434d747e9a", "ref_doc_id": "submultisetsum_medium"}, "f9e738d4-2e94-4dcc-acf0-7f305bff42ad": {"doc_hash": "a6dcb2e8a6f86b185c8c43d95a05753c5abaedec5846e6a89d42ace761f4f4af", "ref_doc_id": "table_seating_medium"}, "378d7795-20d1-455f-988f-6f1ae9a42b7f": {"doc_hash": "65ce7108b2362af73b7ee1847bcf3c04fe17a8ffe8ac9dd1cdc75b0a50e4a45d", "ref_doc_id": "teamselect_medium"}, "6889ccfc-cc05-409a-8497-ad1a4bfa4b92": {"doc_hash": "996da4f9196344357fae08148955a2779e1bb42ca4c0030b92b0b6106c067962", "ref_doc_id": "template_design_medium"}, "8705a544-fa8b-432b-9e6d-033b0898c878": {"doc_hash": "c160b1044b80e3302ae3161777c9e1fe65b7ee96da2c9216dc64f54f897c55ad", "ref_doc_id": "toomany_medium"}, "dc4f424b-ef96-4a7d-ba3d-3740874bc1ee": {"doc_hash": "d2919f51a8f2ffabd657560ff499091cbeb00edc3ccbf75cb97ac2d023101d62", "ref_doc_id": "traffic_lights_table_medium"}, "811e8b37-84b5-4762-a9b6-f95e0a372796": {"doc_hash": "d1b95f4bccb13b841fb14f6aa3f6032240c61f069ad453f83eaf8eaa8ec96f03", "ref_doc_id": "TTPPV_medium"}, "7625bff0-00f7-44d4-9edb-f91ba6f42633": {"doc_hash": "aed297c4a380753ea06480da5644bd9d8962c5d527d3299b3d3541c3cc6668dc", "ref_doc_id": "vessel-loading_medium"}, "0dfad1fb-865f-41a8-9e64-eb08e0746fbf": {"doc_hash": "0082f00ad83fce8bd5acfc99dd12e9a6901fe8fceda9d3e4fddf412a9f028056", "ref_doc_id": "warehouses_medium"}, "419875f9-94c0-4277-bb92-1883305ec7b4": {"doc_hash": "e3212fe2a8e34cca83016a04f0b2c7469bee1031268775a366cc1508991f4a9d", "ref_doc_id": "water_buckets1_medium"}}, "docstore/data": {"a72b4934-9cf8-469a-a3a7-9539883b39bc": {"__data__": {"id_": "a72b4934-9cf8-469a-a3a7-9539883b39bc", "embedding": null, "metadata": {"model_name": "all_interval"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "all_interval_medium", "node_type": "4", "metadata": {"model_name": "all_interval"}, "hash": "4343d2eee6c08ad33ebc0972b40e662fce98595b530f61884391b2ed126b32b8", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 : \n\n\n%\n% All interval problem in MiniZinc\n%\n% \"\"\"\n% Given the twelve standard pitch-classes (c, c%, d, ...), represented by\n% numbers 0,1,...,11, find a series in which each pitch-class occurs exactly\n% once and in which the musical intervals between neighbouring notes cover\n% the full set of intervals from the minor second (1 semitone) to the major\n% seventh (11 semitones). That is, for each of the intervals, there is a\n% pair of neigbhouring pitch-classes in the series, between which this\n% interval appears. The problem of finding such a series can be easily\n% formulated as an instance of a more general arithmetic problem on Z_n,\n% the set of integer residues modulo n. Given n in N, find a vector\n% s = (s_1, ..., s_n), such that (i) s is a permutation of\n% Z_n = {0,1,...,n-1}; and (ii) the interval vector\n% v = (|s_2-s_1|, |s_3-s_2|, ... |s_n-s_{n-1}|) is a permutation of\n% Z_n-{0} = {1,2,...,n-1}. A vector v satisfying these conditions is\n% called an all-interval series of size n; the problem of finding such\n% a series is the all-interval series problem of size n. We may also be\n% interested in finding all possible series of a given size.\n\ninclude \"globals.mzn\";\n\nint: n = 12;\n% array[1..n] of var 1..n: x;\narray[1..n] of var 1..n: x;\narray[1..n-1] of var 1..n-1: diffs;\nint: sum_distinct = ((n+1)*n) div 2;\n\n% max_regret seems to be quite good....\nsolve :: int_search(x, max_regret, indomain_split, complete) satisfy;\n\nconstraint      \n  all_different(diffs) :: domain\n  /\\  \n  all_different(x) :: domain\n  /\\ \n  forall(k in 1..n-1) (\n      diffs[k] = abs(x[k+1] - x[k])\n  )\n  /\\ % symmetry breaking\n  x[1] < x[n-1]\n  /\\\n  diffs[1] < diffs[2]\n;\n\n\noutput [\n       show(x) ++ \",\" % , \" \", show(sum_distinct), \" diffs: \", show(diffs)\n]\n\n\nModel 2 : \n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n%    all_different(series) /\\\n\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i != j)  (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n;\n\noutput\n[  show(series)\n];\n\n\nModel 3 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   %  C1: Each pitch class occurs exactly once\n   forall(i, j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i!=j) (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput\n[ show(series)\n];\n\n\nModel 4 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[differ] of var differ: differences;\n\nsolve satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 1..n-2) (\n       differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in differ where i != j) (\n       differences[i] != differences[j]\n   )\n;\n\noutput [\n  show(series)\n];\n\n\nModel 5 : \n\n\ninclude \"globals.mzn\";\n\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_median, complete) satisfy;\n\nconstraint\n  % C1: Each pitch class occurs exactly once\n  % GCAD: Exploitation of alldifferent() global constraint\n  all_different(series)\n  /\\\n\n  % C2: Differences between neighbouring notes are all different\n  % GCAD: Exploitation of alldifferent() global constraint\n  % alldifferent(all (i in classes: i <> n-1) abs(series[i+1] - series[i]));\n  all_different( \n         [ abs(series[i+1] - series[i]) | i in classes where i != n-1]\n  )\n  \n;\n\noutput [\n  show(series)\n];\n\n\nModel 6 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\n% solve satisfy;\nsolve :: int_search(series, occurrence, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n      differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in 0..n-2 where i != j) (\n      differences[i] != differences[j]\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\noutput [\n  show(series)\n];\n\n\nModel 7 : \n\n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\nsolve ::int_search(series, first_fail, indomain_max, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(series)\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n          differences[i] = abs(series[i+1] - series[i])\n   )\n   /\\\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(differences)\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput [\n   \"series: \" ++ show(series) ++ \"\\n\" ++\n   \"differences: \" ++ show(differences) \n];\n                    ======\n                    Description:\n                    ---------\n                    The problem is the All-Interval Series Problem.\n\nThe All-Interval Series Problem is a classic constraint programming problem that involves finding a series of pitch classes (represented by numbers 0 to 11) such that each pitch class occurs exactly once, and the musical intervals between neighboring notes cover the full set of intervals from the minor second (1 semitone) to the major seventh (11 semitones).\n\nThe main decision variables in this problem are the pitch classes, represented by an array `x` or `series` in the models, which is a permutation of the set of integers from 0 to 11.\n\nThe key constraints in this problem are:\n\n* Each pitch class occurs exactly once (i.e., the array `x` or `series` is a permutation of the set of integers from 0 to 11).\n* The differences between neighboring notes are all different (i.e., the intervals between consecutive pitch classes are all unique).\n\nThe objective of this problem is to find a series that satisfies these constraints.\n\nNote that there is no explicit objective function to minimize or maximize in this problem. The goal is to find a feasible solution that satisfies the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 8042, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cc78401b-3da2-4142-8254-8e14a7141665": {"__data__": {"id_": "cc78401b-3da2-4142-8254-8e14a7141665", "embedding": null, "metadata": {"model_name": "assign"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "assign_medium", "node_type": "4", "metadata": {"model_name": "assign"}, "hash": "7f736fcf8d6cb0af7667104309075d1ea074205f76a9368766d2ae42d1833005", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\nint: n;\nset of int: WORK = 1..n;\nint: m;\nset of int: TASK = 1..m;\narray[WORK,TASK] of int: profit;\narray[WORK] of var TASK: x;\n% new\narray[WORK] of var int: px =\n     [ profit[w,x[w]] | w in WORK ];\nvar int: obj = sum(w in WORK)(px[w]);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\n\nann: varselect;\nann: valselect;\n\nsolve :: int_search(px, varselect, valselect, complete)\n      maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x);\\n\"];\n\n\nvarselect = largest;\nvalselect = indomain_min;\n\n\nModel 2 : \n\n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[DOM] of var COD: task;\narray[COD] of var DOM: worker;\n\ninclude \"inverse.mzn\";\nconstraint inverse(task,worker);\n\n\nsolve maximize sum(w in COD)\n            (profit[w,task[w]]);\n\noutput [show(task)];\n\n\n\nModel 3 : \n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[COD] of var DOM: worker;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(worker);\n\n\nsolve maximize sum(t in COD)\n            (profit[worker[t],t]);\n\noutput [show(worker)];\n\n                    ======\n                    Description:\n                    ---------\n                    The problem is the **Assignment Problem**.\n\nThe Assignment Problem is a classic constraint programming problem that involves assigning a set of tasks to a set of workers in such a way that each task is assigned to exactly one worker and each worker is assigned to exactly one task. The goal is to maximize the total profit or value obtained from the assignments.\n\nThe main decision variables in this problem are:\n\n* `x` or `task` or `worker`: These variables represent the assignment of tasks to workers. For example, `x[w]` represents the task assigned to worker `w`.\n\nThe key constraints in this problem are:\n\n* Each task is assigned to exactly one worker.\n* Each worker is assigned to exactly one task.\n* The assignments must be unique, meaning that no two workers can be assigned the same task, and no two tasks can be assigned to the same worker.\n\nThe objective of the problem is to maximize the total profit obtained from the assignments. The profit is calculated as the sum of the profits obtained from each task-worker pair.\n\nIn the provided models, the profit is represented by the `profit` array, where `profit[w,t]` represents the profit obtained from assigning task `t` to worker `w`. The objective is to maximize the sum of these profits.\n\nThe models use different constraints and search strategies to solve the problem. Model 1 uses the `alldifferent` constraint to ensure that the assignments are unique, while Model 2 uses the `inverse` constraint to achieve the same goal. Model 3 is similar to Model 1 but uses a different search strategy.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2839, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "222e4ed0-395e-45c3-929c-71d810329edf": {"__data__": {"id_": "222e4ed0-395e-45c3-929c-71d810329edf", "embedding": null, "metadata": {"model_name": "aust_color"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aust_color_medium", "node_type": "4", "metadata": {"model_name": "aust_color"}, "hash": "9a8b50f16ea047ce43cb445bdc36015cc29b91b72209d3b826172afed3a6b74b", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n% Colouring Australia using 4 colors \nint: nc = 4;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n\n\n Model 2 :\n\n % Colouring Australia using nc colors \nint: nc;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the Graph Colouring Problem, specifically the Australian Map Colouring Problem.\n\nThis problem is about assigning colours to different regions of a map, such that no two adjacent regions have the same colour. In this case, the map is of Australia, and the regions are the six states and territories: Western Australia (wa), Northern Territory (nt), South Australia (sa), Queensland (q), New South Wales (nsw), and Victoria (v), as well as Tasmania (t).\n\nThe main decision variables are the colours assigned to each region, represented by the variables wa, nt, sa, q, nsw, v, and t. Each variable can take an integer value between 1 and nc, where nc is the number of colours available.\n\nThe key constraints are that adjacent regions must have different colours. For example, Western Australia and Northern Territory must have different colours, as must Western Australia and South Australia, and so on. These constraints are represented by the \"!=\" constraints in the model, which ensure that the colours assigned to adjacent regions are not equal.\n\nThe objective of the problem is to find a feasible assignment of colours to the regions, such that all the constraints are satisfied. In other words, the goal is to find a colouring of the Australian map using the available colours, such that no two adjacent regions have the same colour. There is no objective to minimize or maximize in this problem; the goal is simply to find a valid solution.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2646, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "06ce707c-e4a9-4683-841d-2e24832d3c82": {"__data__": {"id_": "06ce707c-e4a9-4683-841d-2e24832d3c82", "embedding": null, "metadata": {"model_name": "bibd"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bibd_medium", "node_type": "4", "metadata": {"model_name": "bibd"}, "hash": "ce8044193a2fac2b94ee57d11ae448530b2495739d410dfed59baaac0cc0c341", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % bibd.mzn\n% vim: ft=zinc ts=4 sw=4 et tw=0\n% Ralph Becket <rafe@csse.unimelb.edu.au>\n% Tue Oct 23 11:28:06 EST 2007\n%\n% Balanced incomplete block designs.  See the following:\n% http://mathworld.wolfram.com/BlockDesign.html\n% http://www.dcs.st-and.ac.uk/~ianm/CSPLib/prob/prob028/spec.html\n%\n%\n%\n% A BIBD (v, b, r, k, lambda) problem is to find a binary matrix of v rows\n% of b columns such that each row sums to r, each column sums to k, and\n% the dot product beween any pair of distinct rows is lambda.\n\ninclude \"lex_lesseq.mzn\";\n\nint: v;\nint: k;\nint: lambda;\n\nint: b = (lambda * v * (v - 1)) div (k * (k - 1));\nint: r = (lambda * (v - 1)) div (k - 1);\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\narray [rows, cols] of var bool: m;\n\n    % Every row must sum to r.\n    %\nconstraint forall (i in rows) (sum (j in cols) (bool2int(m[i, j])) = r);\n\n    % Every column must sum to k.\n    %\nconstraint forall (j in cols) (sum (i in rows) (bool2int(m[i, j])) = k);\n\n    % The dot product of every pair of distinct rows must be lambda.\n    %\nconstraint\n    forall (i_a, i_b in rows where i_a < i_b) (\n        sum (j in cols) (bool2int(m[i_a, j] /\\ m[i_b, j])) = lambda\n    );\n\n    % Break row symmetry in the incidence matrix.\n    %\nconstraint forall(i in rows diff {max(rows)})(\n        lex_lesseq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    );\n\n    % Break column symmetry in the incidence matrix.\n    %\nconstraint forall(j in cols diff {max(cols)})(\n        lex_lesseq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    );\n\nsolve :: bool_search([m[i, j] | i in rows, j in cols],\n    input_order, indomain_min, complete)\n    satisfy;\n\noutput  [\"bibd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r),\n        \", k = \", show(k), \", lambda = \", show(lambda), \")\\n\\n\"] ++\n        [ ( if j > b then \"\\n\" else show(bool2int(m[i, j])) endif )\n        | i in rows, j in 1..(b + 1)\n        ];\n\n%----------------------------------------------------------------------------%\n%----------------------------------------------------------------------------%\n\n                    ======\n                    Description:\n                    ---------\n                    Balanced Incomplete Block Design (BIBD)\n\nA Balanced Incomplete Block Design is a classic problem in combinatorial design theory. It involves arranging a set of elements (called \"treatments\") into subsets (called \"blocks\") such that each treatment appears in a fixed number of blocks, each block contains a fixed number of treatments, and each pair of treatments appears together in a fixed number of blocks.\n\nDecision Variables:\nThe main decision variables in this problem are the elements of a binary matrix `m`, where `m[i, j]` represents whether treatment `i` is included in block `j` or not.\n\nKey Constraints:\n\n* Each treatment appears in a fixed number of blocks (`r`).\n* Each block contains a fixed number of treatments (`k`).\n* Each pair of treatments appears together in a fixed number of blocks (`lambda`).\n\nObjective:\nThe objective of the problem is to find a binary matrix `m` that satisfies the above constraints.\n\nIn this model, the problem is formulated as a constraint satisfaction problem, where the goal is to find a feasible solution that satisfies all the constraints. The `solve` statement uses a boolean search strategy to find a solution, and the `output` statement is used to print the solution in a human-readable format.\n\nNote that the model also includes some symmetry-breaking constraints to reduce the search space and improve the efficiency of the solver. These constraints ensure that the solution is lexicographically smaller than any other possible solution, which helps to avoid duplicate solutions.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3764, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "13b22c23-05d1-4ce8-95c5-768e78551724": {"__data__": {"id_": "13b22c23-05d1-4ce8-95c5-768e78551724", "embedding": null, "metadata": {"model_name": "bus_scheduling_csplib"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bus_scheduling_csplib_medium", "node_type": "4", "metadata": {"model_name": "bus_scheduling_csplib"}, "hash": "fb600763756eabcc20c51c44e195cb770be9e6d5d9790ecbdf527bc1f5873e76", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    %\n% Bus driver scheduling problem (prob022 in CSPLib) in MiniZinc.\n%\n% Specification\n% Bus driver scheduling can be formulated as a set paritioning problem.\n% We propose 12 set partitioning problems derived from small bus driver\n% scheduling problems. These consist of a given set of tasks (pieces of\n% work) to cover and a large set of possible shifts, where each shift\n% covers a subset of the tasks and has an associated cost. We must select\n% a subset of possible shifts that covers each piece of work once and\n% only once: this is called a partition. Further,\n%\n% In the driver scheduling (unlike air crew scheduling) the main aim is\n% to reduce the number of shifts used in the solution partition and the\n% total cost of the partition is secondary. To simplify the problem we have\n% made the cost of each shift the same. This means that the goal is to\n% minimise the number of shifts.\n%\n% The problems come from four different bus companies:\n% Reading (r1 to r5a),\n% CentreWest Ealing area (c1, c1a, c2),\n% the former London Transport (t1 and t2).\n%\n% The problems have differing regulations and features (e.g. urban and\n% short distance rural bus schedules can have very different features). Note\n% that r1 and r1a are the same problem, but have different numbers of\n% generated shifts. Similarly with the problems: c1, c1a and r5, r5a.\n%\n% Problems are presented in the same format as the set partitioning\n% examples in ORLIB. The first line gives the number of rows (pieces of work),\n% columns (shifts) and the minimum number of columns need for a partition.\n% Then each line after that corresponds to one column. It starts with\n% the cost (which is always 1 in our case) then the number of rows it\n% covers, followed by the rows it covers.\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \nint: num_work;\nint: num_shifts;\nint: min_num_shifts;\narray[1..num_shifts] of set of int: shifts;\n\narray[1..num_shifts] of var 0..1: x;\nvar 0..num_shifts: tot_shifts;\n\n% solve minimize tot_shifts;\nsolve :: int_search(\n        x ++ [tot_shifts], \n        first_fail, \n        indomain_min, \n        complete) \n    minimize tot_shifts;\n    % satisfy;\n\nconstraint\n   tot_shifts = sum(x)\n   /\\\n   forall(j in 0..num_work-1) (\n       sum(i in 1..num_shifts) (x[i]*bool2int(j in shifts[i])) = 1\n   )\n   /\\\n   tot_shifts >= min_num_shifts\n\n   % /\\ % for solve satisfy (t1)\n   % tot_shifts = 7\n;\n\n\noutput [\n  \"tot_shifts: \" ++ show(tot_shifts) ++ \"\\n\" ++ \n  \"x: \" ++ show(x) ++ \"\\n\"\n] ++ \n[\n  if fix(x[i]) = 1 then show(shifts[i]) else \"\" endif\n  | i in 1..num_shifts\n] ++ \n[\"\\n\"] ++\n[\n  if fix(x[i]) = 1 then show(i) ++ \" \" else \"\" endif\n  | i in 1..num_shifts\n] ++ [\"\\n\"];\n\n                    ======\n                    Description:\n                    ---------\n                    **Bus Driver Scheduling Problem**\n\nThe Bus Driver Scheduling Problem is a classic constraint programming problem that involves assigning bus drivers to shifts to cover a set of tasks (pieces of work) while minimizing the number of shifts used.\n\n**Decision Variables:**\n\n* `x[i]`: a binary variable that represents whether shift `i` is selected (1) or not (0)\n* `tot_shifts`: an integer variable that represents the total number of shifts used in the solution\n\n**Key Constraints:**\n\n* Each task (piece of work) must be covered by exactly one shift.\n* The total number of shifts used must be greater than or equal to the minimum number of shifts required to cover all tasks.\n* The cost of each shift is the same, so the goal is to minimize the total number of shifts used.\n\n**Objective:**\n\nThe objective is to minimize the total number of shifts used (`tot_shifts`) to cover all tasks while satisfying the constraints.\n\nIn summary, the Bus Driver Scheduling Problem is a set partitioning problem that involves selecting a subset of shifts to cover a set of tasks while minimizing the number of shifts used. The problem has applications in real-world bus driver scheduling, where the goal is to reduce the number of shifts and associated costs while ensuring that all tasks are covered.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4102, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "95b1973f-37a4-4a4a-bc30-339306938e44": {"__data__": {"id_": "95b1973f-37a4-4a4a-bc30-339306938e44", "embedding": null, "metadata": {"model_name": "car"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "car_medium", "node_type": "4", "metadata": {"model_name": "car"}, "hash": "5b14bdea8da86fff307ea24601d96c4ae65a0f8a09f254c7a96d52cbd0d06282", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    %\n% Car sequencing in MiniZinc.\n% include \"globals.mzn\";\n\nint: numclasses;\nint: numoptions;\nint: numcars;\nset of int: Classes = 1..numclasses;\nset of int: Options = 1..numoptions;\nset of int: Slots = 1..numcars;\n\narray[Classes] of int: numberPerClass;\n\narray[Classes,Options] of int: optionsRequired;\narray[Options] of int: windowSize;\narray[Options] of int: optMax;\n\narray[Options] of int: optionNumberPerClass = [sum(j in Classes) (numberPerClass[j] * optionsRequired[j,i]) | i in Options];\n\n% decision variables\n\narray[Slots] of var Classes: slot;\narray[Options, Slots] of var 0..1: setup;\n\n\nvar int: z = sum(s in Classes) (s*slot[s]);\n\n% solve minimize z;\nsolve :: int_search(slot, input_order, indomain_min, complete)\n  satisfy;\n\nconstraint\n  forall(c in Classes ) (\n    sum(s in Slots ) (bool2int(slot[s] = c)) = numberPerClass[c]\n  )\n  /\\\n  forall(o in Options, s in 1..numcars - windowSize[o] + 1) (\n    sum(j in s..s + windowSize[o]- 1) (setup[o,j]) <= optMax[o]\n  )\n  /\\\n  forall(o in Options, s in Slots ) (\n    setup[o,s] = optionsRequired[slot[s],o]\n  )\n  /\\\n  forall(o in Options, i in 1..optionNumberPerClass[o]) (\n    sum(s in 1..(numcars - i * windowSize[o])) (setup[o,s]) >=\n           (optionNumberPerClass[o] - i * optMax[o])\n  )\n;\n\n% for solve satisfy\n% constraint z = 82;\n\n\noutput [\n \"z: \" ++ show(z) ++ \"\\n\" ++\n \"slot: \" ++ show(slot) ++ \"\\n\"\n] ++\n[\n  if j = 1 then \"\\n\" else \" \" endif ++ \n    show(setup[i,j])\n  | i in Options, j in Slots\n];\n\n                    ======\n                    Description:\n                    ---------\n                    **Car Sequencing Problem**\n\nThe Car Sequencing Problem is a classic constraint programming problem that involves scheduling the production of cars with different options and classes.\n\n**Description**\n\nIn this problem, we have a set of cars to be produced, each belonging to a specific class (e.g., sedan, SUV, etc.). Each class has a certain number of cars to be produced, and each car can have multiple options (e.g., sunroof, navigation system, etc.). The problem is to sequence the production of cars in a way that minimizes the total \"cost\" or \"penalty\" associated with the production process.\n\n**Decision Variables**\n\nThe main decision variables in this problem are:\n\n* `slot`: an array of variables that assigns each car to a specific class.\n* `setup`: a 2D array of variables that indicates whether a specific option is set up for a particular car.\n\n**Key Constraints**\n\nThe key constraints in this problem are:\n\n* Each class of cars must be produced in the correct quantity.\n* For each option, there is a limited window of cars within which the option can be set up (i.e., a \"window size\" constraint).\n* The number of cars with a specific option set up must not exceed a certain maximum limit.\n* The setup of options must be consistent with the class of car being produced.\n\n**Objective**\n\nThe objective of the problem is to minimize the total \"cost\" or \"penalty\" associated with the production sequence, which is represented by the variable `z`. The cost is calculated based on the sequence of cars produced, with higher costs associated with producing cars with more options or switching between different classes of cars.\n\nIn summary, the Car Sequencing Problem is a complex scheduling problem that involves optimizing the production sequence of cars with different options and classes, subject to various constraints and limitations.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3482, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e4e15d83-baf1-4de5-92c0-28ba91c370a9": {"__data__": {"id_": "e4e15d83-baf1-4de5-92c0-28ba91c370a9", "embedding": null, "metadata": {"model_name": "carpet_cutting"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "carpet_cutting_medium", "node_type": "4", "metadata": {"model_name": "carpet_cutting"}, "hash": "5c9ab3d8796f36bd5253a83fd0e3982e355eb391bacc418093f2228a73a4b86f", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\narray[ROOM] of var ROT: rot;\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)(shape[i,rot[i]] != {});\n\nconstraint forall(i in ROOM)(forall(r in ROFF)\n  (r in shape[i,rot[i]] -> \n  (x[i] + d[r,1] + d[r,3] <= l /\\\n   y[i] + d[r,2] + d[r,4] <= h)));\n\nconstraint forall(i,j in ROOM where i < j)\n  (forall(r1,r2 in ROFF)\n (r1 in shape[i,rot[i]] /\\ \n  r2 in shape[j,rot[j]] -> \n(x[i] + d[r1,1] + d[r1,3] <= x[j] + d[r2,1]\n                   \\/\n x[j] + d[r2,1] + d[r2,3] <= x[i] + d[r1,1]\n                   \\/\n y[i] + d[r1,2] + d[r1,4] <= y[j] + d[r2,2]\n                   \\/\ny[j] + d[r2,2] + d[r2,4] <= y[i] + d[r1,2])\n   ));\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nrot = \\(rot);\\n\"];\n\n\n\nModel 2 :\n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: DIM = 1..2;\narray[ROFF,DIM] of int: rect_size = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 3..4]);\narray[ROFF,DIM] of int: rect_offset = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 1..2]);\narray[int] of set of ROFF: shapes = [ {1,3,4}, {2,5,6}, {1}, {7} ];\nset of int: SHAPE = index_set(shapes);\n%array[int] of set of RECT: s = sort([shapes[i,j] | i in 1..n, j in 1..4]);\n\narray[ROOM] of var SHAPE: kind;\narray[ROOM,DIM] of var int: coords =\n      array2d(ROOM,DIM, [ if j = 1 then x[i] else y[i] endif\n                         | i in ROOM, j in 1..2 ]);\n\n\n\ninclude \"geost.mzn\";\n\nconstraint geost_bb(2,\n                    rect_size,\n                    rect_offset,\n                    shapes,\n                    coords,\n                    kind,\n                    [0,0],\n                    [l,h]);\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)\n                 (exists(r in ROT where shape[i,r] != {})\n                        (shapes[kind[i]] = shape[i,r]));\n\n\noutput [\"rect_size = \\(rect_size);\\nrect_offset = \\(rect_offset);\\n\"] ++\n       [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];\n\n\n\nModel 3 : \n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: SHAPE = 1..4;\narray[ROOM] of var SHAPE: kind;\n\nconstraint geost_bb(2,\n       [| 3,4 | 4,3 | 1,1 | 1,2 | 1,1 | 2,1 | 4,3 |],\n       [| 0,0 | 0,1 | 1,4 | 3,1 | 4,2 | 1,0 | 0,0 |],\n       [ {1,3,4}, {2,5,6}, {1}, {7} ],\n       [| x[1], y[1] | x[2],y[2] | x[3],y[3] |],\n       kind,\n       [ 0,0 ],\n       [ l, h]);\n\nconstraint kind[1] in {1,2};\nconstraint kind[2] in {1,2};\nconstraint kind[3] in {3,4}; \ninclude \"geost.mzn\";\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the \"2D Rectangular Cutting Stock Problem\" or \"2D Bin Packing Problem\".\n\nThis problem is about cutting rectangular pieces from a roll of carpet to cover a set of rooms with different shapes and sizes. The goal is to minimize the total length of carpet used.\n\nThe main decision variables are:\n\n* `x` and `y`: the coordinates of the top-left corner of each room on the carpet\n* `rot`: the rotation of each room (0, 90, 180, or 270 degrees)\n* `kind`: the shape of each room (which set of rectangles to use)\n* `l`: the total length of carpet used\n\nThe key constraints are:\n\n* Each room must be placed within the carpet roll, without exceeding its boundaries.\n* No two rooms can overlap.\n* Each room must be placed according to its rotation and shape.\n* The total length of carpet used must be minimized.\n\nThe objective is to minimize the total length of carpet used (`l`).", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 5390, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0afdbb52-009b-43fe-b472-cd0415773b83": {"__data__": {"id_": "0afdbb52-009b-43fe-b472-cd0415773b83", "embedding": null, "metadata": {"model_name": "cell_block"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cell_block_medium", "node_type": "4", "metadata": {"model_name": "cell_block"}, "hash": "9c669adb7ee7bff79b5636993cc48943b83c2b23ea65591c7d9ab5c92cf4396a", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\n%constraint forall(p1, p2 in PRISONER where p1 < p2)\n%                 (abs(r[p1] - r[p2]) + abs(c[p1] - c[p2]) > 0); \ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nconstraint forall(p in PRISONER, d in danger where p != d)\n                 ( abs(r[p] - r[d]) + abs(c[p] - c[d]) > 1 );\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n\n\n\nModel 2 : \n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nfunction var int: \n     manhattan(var int:x1, var int:y1,\n               var int:x2, var int:y2) =\n     abs(x2 - x1) + abs(y2 - y1);\n\nconstraint forall(p in PRISONER, d in danger where p != d) \n                 (manhattan(r[p],c[p],r[d],c[d]) > 1);\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n\n                    ======\n                    Description:\n                    ---------\n                    The Prisoner Allocation Problem.\n\nThis problem involves allocating prisoners to cells in a prison, where each prisoner has a specific cost associated with their allocation. The goal is to minimize the total cost of allocating all prisoners to cells.\n\nThe main decision variables are `r` and `c`, which represent the row and column of the cell assigned to each prisoner, respectively.\n\nThe key constraints are:\n\n* Each prisoner must be assigned a unique cell (i.e., no two prisoners can be in the same cell).\n* Prisoners deemed \"dangerous\" must be separated from each other by at least one cell in either the row or column direction.\n* Female prisoners must be allocated to cells in the top half of the prison, while male prisoners must be allocated to cells in the bottom half.\n\nThe objective is to minimize the total cost of allocating all prisoners to cells, where the cost of allocating a prisoner to a cell is given by the `cost` array.\n\nIn essence, this problem involves finding an optimal assignment of prisoners to cells that satisfies the constraints and minimizes the total cost.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3275, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d1c37052-b7ac-4468-baff-d6affba82235": {"__data__": {"id_": "d1c37052-b7ac-4468-baff-d6affba82235", "embedding": null, "metadata": {"model_name": "clique"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "clique_medium", "node_type": "4", "metadata": {"model_name": "clique"}, "hash": "ed0b6547b5c7af10d3c9ec910c5985952ce6b5b7a93c52a8c02049d0d7a8f923", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % Maximum Clique Problem\n\nint: n = 5;\narray[1..n, 1..n] of int: adj =\n    [| 0, 1, 0, 1, 0\n     | 1, 0, 1, 0, 0\n     | 0, 1, 0, 1, 1\n     | 1, 0, 1, 0, 1\n     | 0, 0, 1, 1, 0 |];\n\n% --- naive model ---\n\n% decision variables: which vertices are in the clique?\narray[1..n] of var bool: c;\nvar int: size;\n\n% how many vertices have we selected?\nconstraint size = sum(c);\n\n% we can only pick one of any non-adjacent pair of vertices\nconstraint forall (i, j in 1..n where i < j /\\ 0 == adj[i,j]) (bool2int(c[i]) + bool2int(c[j]) <= 1);\n\nsolve maximize size;\n\n\n                    ======\n                    Description:\n                    ---------\n                    Maximum Clique Problem\n\nThe Maximum Clique Problem is a classic problem in computer science and graph theory that involves finding the largest subset of vertices in a graph such that every pair of vertices in the subset is connected by an edge.\n\nThe main decision variables in this problem are the boolean variables `c[i]`, which represent whether vertex `i` is included in the clique or not. The integer variable `size` represents the total number of vertices in the clique.\n\nThe key constraints in this problem are:\n\n* Each pair of non-adjacent vertices cannot both be included in the clique.\n* The size of the clique is equal to the sum of the vertices included in it.\n\nThe objective of the problem is to maximize the size of the clique, i.e., to find the largest subset of vertices that are all connected to each other.\n\nIn simpler terms, imagine you have a social network where people are represented by vertices, and friendships are represented by edges between vertices. The Maximum Clique Problem is about finding the largest group of friends where everyone is friends with each other.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1817, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "114c1571-5c1b-4895-917a-8343db2888ff": {"__data__": {"id_": "114c1571-5c1b-4895-917a-8343db2888ff", "embedding": null, "metadata": {"model_name": "cluster"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cluster_medium", "node_type": "4", "metadata": {"model_name": "cluster"}, "hash": "16fe1074ba0c3d229b3491e93339e81147aaaa9ca26b9975d2d4a8c0637afbf2", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    int: n; % points to be clustered\nset of int: POINT = 1..n;\narray[POINT,POINT] of int: dist; % distance between two points\nint: maxdist = max([ dist[i,j] | i,j in POINT]);\n\n\nint: k; % number of clusters\nset of int: CLUSTER = 1..k;\n\nint: maxdiam;\n\narray[POINT] of var CLUSTER: x;\n\nconstraint forall(i,j in POINT where i < j /\\ x[i] = x[j])\n                 (dist[i,j] <= maxdiam);\n\nconstraint forall(i in 1..k-1)\n                 (  min([ j | j in POINT where x[j] = i])\n                  < min([ j | j in POINT where x[j] = i+1]));\n\nvar 0..maxdist: obj = min( i,j in POINT where i < j )\n                         ( dist[i,j] + maxdist * (x[i] != x[j]) );\n\ninclude \"value_precede_chain.mzn\";\nconstraint value_precede_chain([ i | i in 1..k ],x);\n\nsolve maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x)\\n\"];\n\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the \"Clustering Problem\" or \"Facility Location Problem\".\n\nThis problem is about dividing a set of points into clusters such that the points within each cluster are close to each other and the clusters are well-separated. The goal is to find the optimal assignment of points to clusters that minimizes the maximum distance between any two points in the same cluster.\n\nThe main decision variables are:\n\n* `x`: an array of variables, where `x[i]` represents the cluster assignment of point `i`.\n\nThe key constraints are:\n\n* Each pair of points in the same cluster must be within a certain distance (`maxdiam`) of each other.\n* The clusters must be contiguous, meaning that the points in cluster `i` must have smaller indices than the points in cluster `i+1`.\n\nThe objective is to maximize the minimum distance between any two points in different clusters, which is represented by the variable `obj`. This is achieved by minimizing the sum of distances between points in the same cluster and penalizing assignments that put points in different clusters.\n\nIn essence, the problem is trying to find the best way to group points into clusters such that the points within each cluster are close together, and the clusters are well-separated from each other.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2245, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3a132428-04d7-4535-9d12-395164ce7983": {"__data__": {"id_": "3a132428-04d7-4535-9d12-395164ce7983", "embedding": null, "metadata": {"model_name": "compatible_assignment"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "compatible_assignment_medium", "node_type": "4", "metadata": {"model_name": "compatible_assignment"}, "hash": "d03ecb1d233d58d2534d52dc4420f4f0ad8f8735fce0183ad6f3a1fc0a0f2737", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(task);\nconstraint forall(w1, w2 in W)\n                 (task[w1] != m /\\ task[w2] = task[w1] + 1 ->\n                   compatible[w1,w2]);\n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ \"task = \\(task)\\n\" ] ;\n\n\nModel 2 : \n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\narray[T] of var opt W: worker;\n\nconstraint inverse(task,worker);\nconstraint forall(t in T where t mod m != 0)\n                 (compatible[worker[t],worker[t+1]]);\n           \n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ if fix(occurs(worker[t])) then show(worker[t]) else \" \" endif ++ \" \"\n       | t in T ] \n       ++ [ show(task), \"\\n\" ]\n       ;\n\npredicate inverse(array[int] of var opt int: f, array[int] of var opt int: g) = \n          forall(i in index_set(f), j in index_set(g))\n                (occurs(f[i]) /\\ occurs(g[j]) ->\n                 (deopt(f[i]) = j <-> deopt(g[j]) = i)); \n\n                    ======\n                    Description:\n                    ---------\n                    **Problem Name:** Task Scheduling with Compatibility Constraints\n\n**Description:** This problem involves scheduling tasks to workers while ensuring that certain compatibility constraints are met. Each task has a profit associated with it, and the goal is to maximize the total profit earned by assigning tasks to workers.\n\n**Decision Variables:**\n\n* `task`: an array of variables representing the task assigned to each worker. Each element `task[w]` represents the task assigned to worker `w`.\n* `worker`: an array of variables representing the worker assigned to each task. Each element `worker[t]` represents the worker assigned to task `t`.\n\n**Key Constraints:**\n\n* Each task is assigned to a unique worker (ensured by the `alldifferent` constraint).\n* If two tasks are compatible, they must be assigned to adjacent time slots (ensured by the `compatible` array and the constraint `task[w1] != m /\\ task[w2] = task[w1] + 1 -> compatible[w1,w2]`).\n* If a task is assigned to a worker, the next task in the sequence must be assigned to the same worker (ensured by the constraint `compatible[worker[t],worker[t+1]]`).\n\n**Objective:**\nThe objective is to maximize the total profit earned by assigning tasks to workers, calculated as the sum of profits for each task assigned to a worker.\n\nIn summary, this problem involves scheduling tasks to workers while ensuring compatibility constraints are met, with the goal of maximizing the total profit earned.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2823, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "98942ef1-1e48-46e8-b6e2-67c76b4dee52": {"__data__": {"id_": "98942ef1-1e48-46e8-b6e2-67c76b4dee52", "embedding": null, "metadata": {"model_name": "constrained_connected"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "constrained_connected_medium", "node_type": "4", "metadata": {"model_name": "constrained_connected"}, "hash": "bf81d7fe72a1d76b70b433288c40419ceae3710c159510998a619442716fd0d7", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % constrained clustering \n% Pick a maximal subset of edges so that no two nodes\n% given by the pairs (first[i],second[i]) \n% are connected.\n\nint: n;\nset of int: NODE = 1..n;\nint: m;\nset of int: EDGE = 1..m;\narray[EDGE] of NODE: pre;\narray[EDGE] of NODE: suc;\nint: d;\nset of int: DPAIR = 1..d;\narray[DPAIR] of NODE: first;\narray[DPAIR] of NODE: second;\n\nvar set of EDGE: selected;\n% a representative for each cluster\narray[NODE] of var NODE: rep;\n\n%constraint forall(e in selected)\n%                 (rep[pre[e]] = rep[suc[e]]);\nconstraint forall(e in EDGE)\n                 (e in selected -> rep[pre[e]] = rep[suc[e]]);\n\nconstraint forall(d in DPAIR)\n                 (rep[first[d]] != rep[second[d]]);\n\nsolve maximize card(selected);\n\noutput [ \"(\" ++ show(pre[e]) ++ \",\" ++ show(suc[e]) ++ \")\\n\"\n       | e in fix(selected) ]\n       ++ [show(rep),\"\\n\"]\n       ;\n\n\n\n                 \n\n                    ======\n                    Description:\n                    ---------\n                    Constrained Clustering Problem\n\nThe Constrained Clustering Problem is a classic constraint programming problem that involves dividing a set of nodes into clusters such that certain constraints are satisfied.\n\nThe problem is about grouping nodes into clusters in a way that no two nodes in the same cluster are connected by a forbidden edge. The goal is to find the largest possible subset of edges that do not violate these constraints.\n\nThe main decision variables in this problem are:\n\n* `selected`: a set of edges that are selected to form the clusters\n* `rep`: an array of node representatives, where `rep[i]` represents the cluster that node `i` belongs to\n\nThe key constraints in this problem are:\n\n* Each selected edge must connect two nodes that belong to the same cluster (i.e., have the same representative)\n* No two nodes that are connected by a forbidden edge can belong to the same cluster\n\nThe objective of the problem is to maximize the number of selected edges, which means finding the largest possible subset of edges that satisfy the constraints.\n\nIn other words, the goal is to find the largest possible clustering of nodes such that no two nodes connected by a forbidden edge are in the same cluster.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2275, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fea02433-bf7b-48f3-b8b2-83490a9181c0": {"__data__": {"id_": "fea02433-bf7b-48f3-b8b2-83490a9181c0", "embedding": null, "metadata": {"model_name": "crazy_sets"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crazy_sets_medium", "node_type": "4", "metadata": {"model_name": "crazy_sets"}, "hash": "0f7ba6d1b1957caad577f5afa62708e7c647d14387ab229e6782f607cfdca493", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m] of var set of NUMBER: s;\n\nconstraint forall(i,j,k in 1..m where i < j /\\ j < k)\n     ( s[i] intersect s[j] intersect s[k] = {} );\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\nconstraint forall(i in 1..m, o in NUMBER)\n      (o in s[i] \n       -> exists(j in 1..c)(x[i,j] = o));\nconstraint forall(i in 1..m, j in 1..c)(x[i,j] in s[i]);\n\nsolve satisfy;\n\noutput [show(s)];\n\nn = 10;\nc = 4;\nm = 4;\n\n\n\nModel 2 : \n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint global_cardinality_low_up( [ x[i,j] | i in 1..m, j in 1..c ],\n                              [ i | i in 1..n ],\n                              [ 0 | i in 1..n ],\n                              [ 2 | i in 1..n ]);\n\n\nsolve satisfy;\n\n   output [ if j = 1 then \"{\" else \"\" endif ++\n   show(x[i,j])\n   ++ if j = c then \"}\" else \", \" endif\n   ++ if j = c /\\ i < m then \", \" else \"\" endif\n   | i in 1..m, j in 1..c ];\n   \n\nn = 10;\nc = 4;\nm = 4;\n\n                    ======\n                    Description:\n                    ---------\n                    **The Problem:**\n\nThe problem is known as the \"Triple-Free Set\" or \"Triple-Free Family\" problem.\n\n**Description:**\n\nThe Triple-Free Set problem is a classic constraint programming problem that involves finding a collection of sets, each containing a certain number of elements, such that no three sets have any elements in common.\n\n**Decision Variables:**\n\nThe main decision variables in this problem are:\n\n* `s[i]`: a set of elements, where `i` represents the index of the set.\n* `x[i, j]`: an element in the `i`-th set, where `j` represents the index of the element within the set.\n\n**Key Constraints:**\n\nThe key constraints in this problem can be described as follows:\n\n* No three sets have any elements in common. This is ensured by the constraint that the intersection of any three sets is empty.\n* Each set contains a certain number of elements, and these elements are distinct and in increasing order.\n* Each element in a set is also an element in the overall universe of elements.\n\n**Objective:**\n\nThe objective of this problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function. In other words, the goal is to find a collection of sets that meet the specified conditions, rather than minimizing or maximizing a particular value.\n\nIn summary, the Triple-Free Set problem is a classic constraint programming problem that involves finding a collection of sets with certain properties, such as distinct elements and no triple intersections, and the objective is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3222, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2ecae988-03e5-4962-a35d-5caa3d3b976a": {"__data__": {"id_": "2ecae988-03e5-4962-a35d-5caa3d3b976a", "embedding": null, "metadata": {"model_name": "crossfigure"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crossfigure_medium", "node_type": "4", "metadata": {"model_name": "crossfigure"}, "hash": "df53bc2b1b4635ddb005f0d716529f8839f2af4e40cd1350df542caa12698543", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % Crossfigure problem in MiniZinc.\n% \"\"\"\n% Crossfigures are the numerical equivalent of crosswords. You have a grid and some\n% clues with numerical answers to place on this grid. Clues come in several different\n% forms (for example: Across 1. 25 across times two, 2. five dozen, 5. a square number,\n% 10. prime, 14. 29 across times 21 down ...).\n% \"\"\"\n\n\nint: n = 9;\narray[1..n, 1..n] of var 0..9: M;\n\nset of int: D = 0..9999; % the max length of the numbers in this problem is 4\nvar D: A1;\nvar D: A4;\nvar D: A7;\nvar D: A8;\nvar D: A9;\nvar D: A10;\nvar D: A11;\nvar D: A13;\nvar D: A15;\nvar D: A17;\nvar D: A20;\nvar D: A23;\nvar D: A24;\nvar D: A25;\nvar D: A27;\nvar D: A28;\nvar D: A29;\nvar D: A30;\n\nvar D: D1;\nvar D: D2;\nvar D: D3;\nvar D: D4;\nvar D: D5;\nvar D: D6;\nvar D: D10;\nvar D: D12;\nvar D: D14;\nvar D: D16;\nvar D: D17;\nvar D: D18;\nvar D: D19;\nvar D: D20;\nvar D: D21;\nvar D: D22;\nvar D: D26;\nvar D: D28;\n\n\n%\n% across(Matrix, Across, Len, Row, Col)\n%\tConstrains 'Across' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding across.\n%\npredicate across(array[int, int] of var D: Matrix, var D: Across, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Across)\n   /\\\n   forall(i in 0..Len-1) (\n\n       Matrix[Row,Col+i] = tmp[i+1]\n   )\n;\n\n%\n% down(Matrix, Down, Len, Row, Col):\n%\tConstrains 'Down' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding down.\n%\npredicate down(array[int,int] of var D: Matrix, var D: Down, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Down)\n   /\\\n   forall(i in 0..Len-1) (\n      Matrix[Row+i,Col] = tmp[i+1]\n   )\n;\n\n\n%\n% converts a number <-> array\n%\npredicate toNum10(array[int] of var D: a, var D: n) =\n          let { int: len = length(a) }\n          in\n          n = sum(i in 1..len) (\n            ceil(pow(10.0, int2float(len-i))) * a[i]\n          )\n          /\\ forall(i in 1..len) (a[i] >= 0)\n;\n\n\n%\n% x is a square\n% \npredicate square(var D: x) =\n   exists(y in D) (\n      y*y = x\n   )\n;\n\n\n%\n% very simple primality test\n%\npredicate is_prime(var int: x) =\n   forall(i in 2..ceil(sqrt(9999.0))) ( \n        (i < x) -> (x mod i > 0)\n   )\n;\n\n\nsolve :: int_search(\n         [M[i,j] | i,j in 1..n] ++\n         [A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n         D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28],\n         occurrence,\n         indomain_min,\n         complete\n         ) \n     satisfy;\n\n\nconstraint\n\n   % Set up the constraints between the matrix elements and the\n   % clue numbers.\n   across(M, A1, 4, 1, 1)  /\\ \n   across(M, A4, 4, 1, 6)  /\\ \n   across(M, A7, 2, 2, 1)  /\\ \n   across(M, A8, 3, 2, 4)  /\\ \n   across(M, A9, 2, 2, 8)  /\\ \n   across(M, A10, 2, 3, 3) /\\ \n   across(M, A11, 2, 3, 6) /\\ \n   across(M, A13, 4, 4, 1) /\\ \n   across(M, A15, 4, 4, 6) /\\ \n   across(M, A17, 4, 6, 1) /\\ \n   across(M, A20, 4, 6, 6) /\\ \n   across(M, A23, 2, 7, 3) /\\ \n   across(M, A24, 2, 7, 6) /\\ \n   across(M, A25, 2, 8, 1) /\\ \n   across(M, A27, 3, 8, 4) /\\ \n   across(M, A28, 2, 8, 8) /\\ \n   across(M, A29, 4, 9, 1) /\\ \n   across(M, A30, 4, 9, 6) /\\ \n\n   down(M, D1, 4, 1, 1)  /\\ \n   down(M, D2, 2, 1, 2)  /\\ \n   down(M, D3, 4, 1, 4)  /\\ \n   down(M, D4, 4, 1, 6)  /\\ \n   down(M, D5, 2, 1, 8)  /\\ \n   down(M, D6, 4, 1, 9)  /\\ \n   down(M, D10, 2, 3, 3) /\\ \n   down(M, D12, 2, 3, 7) /\\ \n   down(M, D14, 3, 4, 2) /\\ \n   down(M, D16, 3, 4, 8) /\\ \n   down(M, D17, 4, 6, 1) /\\ \n   down(M, D18, 2, 6, 3) /\\ \n   down(M, D19, 4, 6, 4) /\\ \n   down(M, D20, 4, 6, 6) /\\ \n   down(M, D21, 2, 6, 7) /\\ \n   down(M, D22, 4, 6, 9) /\\ \n   down(M, D26, 2, 8, 2) /\\ \n   down(M, D28, 2, 8, 8) /\\ \n\n\n   % Set up the clue constraints.\n%  Across\n%  1 27 across times two\n%  4 4 down plus seventy-one\n%  7 18 down plus four\n%  8 6 down divided by sixteen\n%  9 2 down minus eighteen\n% 10 Dozen in six gross\n% 11 5 down minus seventy\n% 13 26 down times 23 across\n% 15 6 down minus 350\n% 17 25 across times 23 across\n% 20 A square number\n% 23 A prime number\n% 24 A square number\n% 25 20 across divided by seventeen\n% 27 6 down divided by four\n% 28 Four dozen\n% 29 Seven gross\n% 30 22 down plus 450 \n\n   A1 = 2 * A27         /\\ \n   A4 = D4 + 71         /\\ \n   A7 = D18 + 4         /\\ \n   A8 = D6 div 16       /\\ \n   A9 = D2 - 18         /\\ \n   A10 = 6 * 144 div 12 /\\ \n   A11 = D5 - 70        /\\ \n   A13 = D26 * A23      /\\ \n   A15 = D6 - 350       /\\ \n   A17 = A25 * A23      /\\ \n   square(A20)          /\\ \n   is_prime(A23)        /\\\n   square(A24)          /\\ \n   A25 = A20 div 17     /\\ \n   A27 = D6 div 4       /\\ \n   A28 = 4 * 12         /\\ \n   A29 = 7 * 144        /\\ \n   A30 = D22 + 450      /\\ \n\n   % Down\n   %\n   %  1 1 across plus twenty-seven\n   %  2 Five dozen\n   %  3 30 across plus 888\n   %  4 Two times 17 across\n   %  5 29 across divided by twelve\n   %  6 28 across times 23 across\n   % 10 10 across plus four\n   % 12 Three times 24 across\n   % 14 13 across divided by sixteen\n   % 16 28 down times fifteen\n   % 17 13 across minus 399\n   % 18 29 across divided by eighteen\n   % 19 22 down minus ninety-four\n   % 20 20 across minus nine\n   % 21 25 across minus fifty-two\n   % 22 20 down times six\n   % 26 Five times 24 across\n   % 28 21 down plus twenty-seven \n\n   D1 = A1 + 27     /\\ \n   D2 = 5 * 12      /\\ \n   D3 = A30 + 888   /\\ \n   D4 = 2 * A17     /\\ \n   D5 = A29 div 12  /\\ \n   D6 = A28 * A23   /\\ \n   D10 = A10 + 4    /\\ \n   D12 = A24 * 3    /\\ \n   D14 = A13 div 16 /\\ \n   D16 = 15 * D28   /\\ \n   D17 = A13 - 399  /\\ \n   D18 = A29 div 18 /\\ \n   D19 = D22 - 94   /\\ \n   D20 = A20 - 9    /\\ \n   D21 = A25 - 52   /\\ \n   D22 = 6 * D20    /\\ \n   D26 = 5 * A24    /\\ \n   D28 = D21 + 27\n\n\n   % Fix the blackboxes\n   /\\\n   M[1,5] = 0 /\\\n   M[2,3] = 0 /\\\n   M[2,7] = 0 /\\\n   M[3,2] = 0 /\\\n   M[3,5] = 0 /\\\n   M[3,8] = 0 /\\\n   M[4,5] = 0 /\\\n   M[5,1] = 0 /\\\n   M[5,3] = 0 /\\\n   M[5,4] = 0 /\\\n   M[5,5] = 0 /\\\n   M[5,6] = 0 /\\\n   M[5,7] = 0 /\\\n   M[5,9] = 0 /\\\n   M[6,5] = 0 /\\\n   M[7,2] = 0 /\\\n   M[7,5] = 0 /\\\n   M[7,8] = 0 /\\\n   M[8,3] = 0 /\\\n   M[8,7] = 0 /\\\n   M[9,5] = 0\n;\n\n\noutput [\n show([A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n       D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28]), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(M[i,j])\n  | i,j  in 1..n\n] ++ [\"\\n\"];\n                    ======\n                    Description:\n                    ---------\n                    The problem is called the Crossfigure problem.\n\nThe Crossfigure problem is a classic constraint programming problem that involves placing numerical answers to clues in a grid, similar to a crossword puzzle. The clues come in different forms, such as arithmetic operations, prime numbers, and square numbers.\n\nThe main decision variables in this problem are:\n\n* `M`: a 9x9 grid of variables, where each cell can take a value between 0 and 9.\n* `A1`, `A4`, ..., `A30`: variables representing the answers to the across clues.\n* `D1`, `D2`, ..., `D28`: variables representing the answers to the down clues.\n\nThe key constraints in this problem are:\n\n* The `across` and `down` predicates, which ensure that the answers to the clues are correctly placed in the grid.\n* The arithmetic constraints, such as `A1 = 2 * A27` and `D1 = A1 + 27`, which relate the answers to each other.\n* The constraints on prime numbers and square numbers, such as `is_prime(A23)` and `square(A20)`.\n* The constraints on the black boxes, which fix certain cells in the grid to be 0.\n\nThe objective of this problem is to find a solution that satisfies all the constraints.\n\nNote that this problem does not have an objective function to minimize or maximize, as it is a satisfaction problem. The goal is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 7966, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "07947d3f-064b-4460-acd2-2a3ba8b66406": {"__data__": {"id_": "07947d3f-064b-4460-acd2-2a3ba8b66406", "embedding": null, "metadata": {"model_name": "curriculum"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "curriculum_medium", "node_type": "4", "metadata": {"model_name": "curriculum"}, "hash": "b02d342dd639dff764ea0be8f5d71357ac36d29af207b9883c82103b7d5a95f2", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % The balanced academic curriculum problem:\n%\n% A curriculum is a set of courses with prerequisites.\n% Each course must be assigned within a set number of periods.\n% A course cannot be scheduled before its prerequisites.\n% Each course confers a number of academic credits (it's \"load\").\n% Students have lower and upper bounds on the number of credits they can study for in a given period.\n% Students have lower and upper bounds on the number of courses they can study for in a given period.\n% The goal is to assign a period to every course satisfying these criteria, minimising the load for all periods.\n\ninclude \"globals.mzn\";\n\nint: n_courses;\nint: n_periods;\nint: load_per_period_lb;\nint: load_per_period_ub;\nint: courses_per_period_lb;\nint: courses_per_period_ub;\narray [1..n_courses] of int: course_load;\nint: max_course_load = sum(c in courses)(course_load[c]);\n\nset of int: courses = 1..n_courses;\nset of int: periods = 1..n_periods;\n\n% period course is assigned to\narray [courses] of var periods: course_period;\n% whether period i has course j assigned\narray [periods, courses] of var 0..1: x;\n% total load for each period\narray [periods] of var load_per_period_lb..load_per_period_ub: load;\n% optimisation target\nvar load_per_period_lb..load_per_period_ub: objective;\n\nconstraint forall(p in periods) (\n    forall(c in courses) (x[p,c] = bool2int(course_period[c] = p)) /\\\n    sum(i in courses) (x[p,i]) >= courses_per_period_lb /\\\n    sum(i in courses) (x[p,i]) <= courses_per_period_ub /\\\n    load[p] = sum(c in courses) (x[p,c] * course_load[c]) /\\\n    load[p] >= load_per_period_lb /\\\n    load[p] <= objective\n);\n\n% prerequisite(a, b) means \"course a has prerequisite course b\".\n\npredicate prerequisite(courses: a, courses: b) =\n    course_period[b] < course_period[a];\n\n% add some redundant linear constraints\n\nconstraint forall(p in 0..n_periods-1) (\n    let {\n\t\tvar 0..max_course_load: l = sum(c in courses) (bool2int(course_period[c] > p) * course_load[c])\n\t} in \n        l >= (n_periods-p) * load_per_period_lb /\\\n        l <= (n_periods-p) * objective\n    );\n\nsolve :: seq_search([\n      int_search([x[i,j] | i in periods, j in courses], input_order, indomain_max, complete),\n      int_search([objective], input_order, indomain_min, complete)\n    ]) minimize objective;\n\noutput \n    [show(c) ++ \"-\" ++ show(course_period[c]) ++ \"\\t\" | c in courses ] ++ [\"\\n\"] ++\n    [\"objective = \", show(objective)];\n\n                    ======\n                    Description:\n                    ---------\n                    The Balanced Academic Curriculum Problem.\n\nThis problem is about assigning courses to periods in a curriculum while satisfying various constraints and minimizing the total load across all periods.\n\nThe main decision variables are:\n\n* `course_period`: an array that assigns each course to a period\n* `x`: a 2D array that indicates whether a course is assigned to a particular period\n* `load`: an array that represents the total load for each period\n* `objective`: the overall objective value to be minimized, which represents the maximum load across all periods\n\nThe key constraints are:\n\n* Each course must be assigned to a period\n* A course cannot be scheduled before its prerequisites\n* Each period has a minimum and maximum number of courses that can be assigned\n* Each period has a minimum and maximum total load (academic credits) that can be assigned\n* The total load for each period must be within the allowed bounds\n* The objective is to minimize the maximum load across all periods\n\nThe problem's objective is to minimize the maximum load across all periods, while ensuring that all courses are assigned to periods and all constraints are satisfied.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3749, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9883aa5f-a9e9-4813-bb49-4fa54f27093d": {"__data__": {"id_": "9883aa5f-a9e9-4813-bb49-4fa54f27093d", "embedding": null, "metadata": {"model_name": "diamond_free_degree_sequence"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "diamond_free_degree_sequence_medium", "node_type": "4", "metadata": {"model_name": "diamond_free_degree_sequence"}, "hash": "d74e757be3fa5fc51f197ca508f92a3dfe7738aebe40aa012e04e3f39dde0081", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    %\n% Diamond-free Degree Sequence (CSPLib #50) in MiniZinc.\n%\n% Given a simple undirected graph G=(V,E), where V is the set of vertices and E the set of\n% undirected edges, the edge {u,v} is in E if and only if vertex u is adjacent to vertex v\u2208G.\n% The graph is simple in that there are no loop edges, i.e. we have no edges of the form {v,v}.\n% Each vertex v\u2208V has a degree dv i.e. the number of edges incident on that vertex. Consequently\n% a graph has a degree sequence d1,\u2026,dn, where di>=di+1. A diamond is a set of four vertices\n% in V such that there are at least five edges between those vertices. Conversely, a graph is\n% diamond-free if it has no diamond as an induced subgraph, i.e. for every set of four vertices\n% the number of edges between those vertices is at most four.\n%\n% In our problem we have additional properties required of the degree sequences of the graphs,\n% in particular that the degree of each vertex is greater than zero (i.e. isolated vertices\n% are disallowed), the degree of each vertex is modulo 3, and the sum of the degrees is\n% modulo 12 (i.e. |E| is modulo 6).\n%\n% The problem is then for a given value of n, produce all unique degree sequences d1,\u2026,dn such\n% that\n%\n%  * di\u2265di+1\n%  * each degree di>0 and di is modulo 3\n%  * the sum of the degrees is modulo 12\n%  * there exists a simple diamond-free graph with that degree sequence\n\n\ninclude \"globals.mzn\"; \n\nint: n = 11;\n\n% decision variables\narray[1..n,1..n] of var 0..1: x;\narray[1..n] of var 1..n: degrees;\n\n\n% solve satisfy;\nsolve :: int_search(degrees, first_fail, indomain_split, complete) satisfy;\n\nconstraint\n  forall(i,j,k,l in 1..n where i < j /\\ j < k /\\ k < l) (\n     x[i,j] + x[i,k] + x[i,l] + x[j,k] + x[j,l] + x[k,l] <= 4\n  )\n  /\\\n  forall(i in 1..n) (\n     degrees[i] = sum([x[i,j] | j in 1..n])\n     /\\ degrees[i] mod 3 = 0\n     % no loops\n     /\\ x[i,i] = 0\n  ) \n  /\\ % undirected graph\n  forall(i,j in 1..n) (\n    x[i,j] = x[j,i]\n  )\n  /\\ sum(degrees) mod 12 = 0\n\n  % symmetry breaking\n  /\\ decreasing(degrees)\n  /\\ lex2(x)\n;\n\noutput \n[ \"degrees: \", show(degrees), \"\\n\"]\n% ++\n% [\n%   if j = 1 then \"\\n\" else \" \" endif ++\n%     show(x[i,j])\n%   | i,j in 1..n\n% ]\n;\n\n\n                    ======\n                    Description:\n                    ---------\n                    The problem is called the Diamond-free Degree Sequence problem.\n\nThis problem is about finding all possible degree sequences of a simple, undirected graph that satisfies certain properties. A degree sequence is a list of numbers, where each number represents the number of edges connected to a vertex in the graph. The graph is simple, meaning it has no loop edges (edges that connect a vertex to itself), and undirected, meaning that if there is an edge between two vertices, it can be traversed in both directions.\n\nThe main decision variables in this problem are:\n\n* `x[i,j]`: a binary variable that represents whether there is an edge between vertices `i` and `j` in the graph.\n* `degrees[i]`: an integer variable that represents the degree of vertex `i`, i.e., the number of edges connected to vertex `i`.\n\nThe key constraints in this problem are:\n\n* The graph is diamond-free, meaning that for any four vertices, there are at most four edges between them.\n* The degree of each vertex is greater than zero and is a multiple of 3.\n* The sum of the degrees of all vertices is a multiple of 12.\n* The graph is undirected, meaning that if there is an edge between two vertices, it can be traversed in both directions.\n* There are no loop edges, meaning that a vertex cannot be connected to itself.\n\nThe objective of this problem is to find all possible degree sequences that satisfy these constraints, without optimizing any particular objective function. In other words, the goal is to enumerate all possible solutions that meet the given constraints.\n\nNote that the problem also includes some symmetry-breaking constraints to reduce the number of duplicate solutions.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4014, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dce3168c-6c0e-41e3-9a07-4ca75eea2e46": {"__data__": {"id_": "dce3168c-6c0e-41e3-9a07-4ca75eea2e46", "embedding": null, "metadata": {"model_name": "doublechannel"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "doublechannel_medium", "node_type": "4", "metadata": {"model_name": "doublechannel"}, "hash": "8ceca8569f3d88fbd7f8646adab0c64e187b0bb8630d99cc84a2d7659c0c1486", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % scheduling ships entering and leaving a port through k channels\nset of int: TYPE = 1..3;\nint: entering = 1;\nint: leaving  = 2;\nint: dummy = 3;\n\nint: nC; % number of channels\nset of int: CHANNEL = 1..nC;\narray[CHANNEL] of int: len;    % length in 100m units\n\nint: nS; % number of ships\nset of int: SHIP = 1..nS; % ships ENTER then LEAVE\nset of int: SHIPE = 1..nS+nC; % ships ENTER then LEAVE then nC dummy ships\n\narray[SHIP] of int: speed;   % time in minutes to traverse 100m\narray[SHIP] of int: desired; % desired time to start to enter/leave \narray[SHIP] of entering..leaving: dirn;   % entering or leaving\n\nint: leeway;  % leeway between 2 ships in 100m units\nint: maxt;    % maximum time\nset of int: TIME = 0..maxt;\n\narray[SHIPE] of var TYPE: kind = dirn ++ [ dummy | i in 1..nC];\narray[SHIPE] of var TIME:    start; % when ships enter the channel \narray[SHIPE] of var TIME:     end; % when ships leave the channel \narray[SHIPE] of var CHANNEL: channel; % which channel a ship is assigned to\n\narray[SHIP] of var SHIPE:   next;  % the next ship in the same channel (or a dummy)\n\n% dummy ships\nconstraint forall(s in nS + 1 .. nS + nC)(start[s] = maxt /\\ end[s] = maxt);\nconstraint forall(s in nS + 1 .. nS + nC)(channel[s] = s - nS);\n\n% relationships between start and ends\nconstraint forall(s in SHIP)(end[s] = start[s] + len[channel[s]]*speed[s]);\n\n\n% the next ship are all different\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(next);\n\n% no clashes in channel\nconstraint forall(s in SHIP)(if kind[s] + kind[next[s]] = entering+leaving then\n                                end[s] <= start[next[s]]\n                             else\n                                start[s] + speed[s]*leeway <= start[next[s]] /\\\n                                end[s] + speed[s]*leeway <= end[next[s]]\n                             endif);\n\n% next ship is in same channel\nconstraint forall(s in SHIP)(channel[next[s]] = channel[s]);\n\nsolve minimize sum(s in SHIP)(abs(start[s] - desired[s]));\n\noutput [ \"start = \",show(start),\n         \";\\nend = \", show(end),\n         \";\\nchannel = \", show(channel),\n         \";\\nnext = \", show(next),\n         \";\\n\" ];\n\n\n                    ======\n                    Description:\n                    ---------\n                    **Ship Scheduling Problem**\n\nThe Ship Scheduling Problem is a classic constraint programming problem that involves scheduling ships entering and leaving a port through multiple channels.\n\n**Decision Variables:**\n\n* `kind`: represents the type of ship movement (entering or leaving) for each ship\n* `start`: represents the start time for each ship to enter or leave the channel\n* `end`: represents the end time for each ship to enter or leave the channel\n* `channel`: represents the channel assignment for each ship\n* `next`: represents the next ship in the same channel (or a dummy ship)\n\n**Key Constraints:**\n\n* Each ship must enter and leave the channel without clashes with other ships in the same channel.\n* The start and end times of each ship are related by the length of the channel and the ship's speed.\n* The next ship in the same channel must be different from the current ship.\n* Ships must maintain a safe distance (leeway) between each other when entering or leaving the channel.\n\n**Objective:**\n\nThe objective is to minimize the total absolute difference between the desired start time and the actual start time for all ships. In other words, the goal is to schedule the ships to enter and leave the channel as close as possible to their desired times.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3588, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1f5fa0a6-7402-4e15-9c57-3678cd2adfe2": {"__data__": {"id_": "1f5fa0a6-7402-4e15-9c57-3678cd2adfe2", "embedding": null, "metadata": {"model_name": "fractions"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fractions_medium", "node_type": "4", "metadata": {"model_name": "fractions"}, "hash": "65e1926440cc707a0c700ff6a45bd637d809982ad8a9ad0f8f30aeace5b7833f", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    %\n% Fractions problem in MiniZinc.\n%\n% Prolog benchmark problem (BProlog)\n% \"\"\"\n% Find distinct non-zero digits such that the following equation holds:\n%        A        D        G\n%     ------  + ----- + ------  = 1\n%       B*C      E*F      H*I\n\ninclude \"globals.mzn\"; \n\nvar 1..9: A;\nvar 1..9: B;\nvar 1..9: C;\nvar 1..9: D;\nvar 1..9: E;\nvar 1..9: F;\nvar 1..9: G;\nvar 1..9: H;\nvar 1..9: I;\narray[1..9] of var 1..9: Vars=[A,B,C,D,E,F,G,H,I];\n\nvar 1..81: D1;\nvar 1..81: D2;\nvar 1..81: D3;\n\n\n\n% solve satisfy;\nsolve :: int_search(Vars ++ [D1,D2,D3], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   all_different(Vars) /\\\n   D1 = 10*B+C /\\\n   D2 = 10*E+F /\\\n   D3 = 10*H+I /\\\n   A*D2*D3 + D*D1*D3 + G*D1*D2 = D1*D2*D3 /\\\n   % break the symmetry\n   A*D2 >= D*D1 /\\\n   D*D3 >= G*D2 /\\\n   %redundant constraints\n   3*A >= D1 /\\\n   3*G <= D2\n\n;\n\noutput [\n  show(Vars), \"\\n\"\n]\n;\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the \"Fractions Problem\" or \"Einstein's Fractions Problem\".\n\nThis problem is about finding distinct non-zero digits (from 1 to 9) that satisfy a specific equation involving three fractions. The equation is:\n\n(A / (B*C)) + (D / (E*F)) + (G / (H*I)) = 1\n\nThe main decision variables are the digits A, B, C, D, E, F, G, H, and I, which represent the numerators and denominators of the three fractions.\n\nThe key constraints are:\n\n* Each digit must be distinct and non-zero.\n* The equation above must hold.\n* Some symmetry-breaking constraints are added to reduce the search space:\n\t+ A*D2 >= D*D1 (to avoid swapping the first two fractions)\n\t+ D*D3 >= G*D2 (to avoid swapping the last two fractions)\n* Some redundant constraints are added to help the solver:\n\t+ 3*A >= D1 (to reduce the possible values of A)\n\t+ 3*G <= D2 (to reduce the possible values of G)\n\nThe objective of the problem is to find a solution that satisfies all the constraints, rather than to minimize or maximize a specific objective function. The problem is a classic example of a constraint satisfaction problem, where the goal is to find a feasible solution that meets all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2233, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f2e9acf2-2385-4fcf-96ef-f8b686d5b134": {"__data__": {"id_": "f2e9acf2-2385-4fcf-96ef-f8b686d5b134", "embedding": null, "metadata": {"model_name": "golfers"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golfers_medium", "node_type": "4", "metadata": {"model_name": "golfers"}, "hash": "ca9e0d18ad28e8abed569f6a1258f26f8c9439e1d74df8dcfb3f814f0280d343", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n\n% The social golfers problem\n% A club has a number of golfers that play rounds in groups (the number of\n% golfers is a multiple of the number of groups).  Each round, a golfer\n% plays with a group of different people, such that the same pair of golfers\n% never play together twice.\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\nset of int: places = 1..n_golfers;\n\narray [rounds, places] of var golfers: round_place_golfer;\narray [golfers, golfers] of var 0..n_rounds: golfer_golfer_round;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (p in places) (round_place_golfer[r, p])\n    );\n\n    % Break some symmetry by strictly ordering each group in each round.\n    %\nconstraint\n    forall (r in rounds, p in places) (\n        if p mod n_per_group != 0\n        then round_place_golfer[r, p] < round_place_golfer[r, p + 1]\n        else true\n        endif\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (r in rounds, g in 0..(n_groups - 1), i, j in 1..n_per_group\n            where i < j) (\n        golfer_golfer_round[\n            round_place_golfer[r, n_per_group * g + i],\n            round_place_golfer[r, n_per_group * g + j]\n        ] = r\n    );\n\nsolve\n    :: int_search([round_place_golfer[r, p] | r in rounds, p in places],\n        first_fail, indomain_min, complete)\n    satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if p = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif ) ++\n    ( if p mod n_per_group = 1 then \"   \" else \" \" endif ) ++\n    show_int(2, round_place_golfer[r, p]) | r in rounds, p in places\n];\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups, group] of var golfers: round_group_i_golfer;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (g in groups, i in group) (round_group_i_golfer[r, g, i])\n    );\n\n    % We also break some symmetry\n    % here by strictly ordering each group.\n    %\nconstraint\n    forall (r in rounds, g in groups, i in group where i < n_per_group) (\n        round_group_i_golfer[r, g, i] < round_group_i_golfer[r, g, i + 1]\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups, i, j in group where i < j) (\n            bool2int(\n                round_group_i_golfer[r, g, i] = a\n            /\\  round_group_i_golfer[r, g, j] = b\n            )\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if g = 1 /\\ i = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif) ++\n    ( if i = 1 then \"   \" else \" \" endif) ++\n    show_int(2, round_group_i_golfer[r, g, i]) \n    |  r in rounds, g in groups, i in group\n];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups] of var set of golfers: round_group_golfers;\n\n    % Each group has to have the right size.\n    %\nconstraint\n    forall (r in rounds, g in groups) (\n        card(round_group_golfers[r, g]) = n_per_group\n    );\n\n    % Each group in each round has to be disjoint.\n    %\nconstraint\n    forall (r in rounds) (\n        all_disjoint (g in groups) (round_group_golfers[r, g])\n    );\n\n    % Symmetry breaking.\n    %\n% constraint\n%     forall (r in rounds, g in groups where g < n_groups) (\n%         round_group_golfers[r, g] < round_group_golfers[r, g + 1]\n%     );\n\n    % Each pair may play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups) (\n            bool2int({a, b} subset round_group_golfers[r, g])\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [    ( if   g = 1\n              then \"\\nround \" ++ show(r) ++ \":   \"\n              else \"   \"\n              endif\n            ) ++\n            show(round_group_golfers[r, g])\n       |    r in rounds, g in groups\n       ];\n\n\nModel 4 :\n\n\nint: weeks = 4;\nint: groups = 3;\nint: groupSize = 3;\nint: golfers = groups * groupSize;\n\nset of int: Golfer = 1..golfers;\nset of int: Week = 1..weeks;\nset of int: Group = 1..groups;\n\n% Search space: The set of all possible group assignments to all \n% players in each of the weeks\narray[Golfer, Week] of var Group: assign;\n\n% solve satisfy;\n% solve :: int_search([assign[i,j] | i in Golfer, j in Week ], \"first_fail\", \"indomain\", \"complete\") satisfy;\nsolve :: int_search([assign[i,j] | i in Golfer, j in Week ], \n        first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each group has exactly groupSize players\n   forall (gr in Group, w in Week)( % c1\n     sum (g in Golfer) (bool2int(assign[g,w] = gr)) = groupSize\n   )\n   /\\\n   % C2: Each pair of players only meets at most once\n   forall (g1, g2 in Golfer, w1, w2 in Week  where g1 != g2 /\\ w1 != w2) (\n     (bool2int(assign[g1,w1] = assign[g2,w1]) + bool2int(assign[g1,w2] = assign[g2,w2])) <= 1\n   )\n  /\\\n  % SBSA: Symmetry-breaking by selective assignment\n  % On the first week, the first groupSize golfers play in group 1, the \n  % second groupSize golfers play in group 2, etc. On the second week, \n  % golfer 1 plays in group 1, golfer 2 plays in group 2, etc.\n  forall(g in Golfer) (\n    assign[g,1]=((g-1) div groupSize) + 1 % \n  )\n  /\\\n  forall(g in Golfer where g <= groupSize)(\n    assign[g,2]=g\n  )\n\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n  show(assign[i,j])\n  | i in Golfer, j in Week\n] ++ [\"\\n\"];\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the Social Golfers Problem.\n\nThe Social Golfers Problem is about scheduling golfers into groups for multiple rounds of golf, such that each golfer plays with a different set of people in each round, and no two golfers play together more than once.\n\nThe main decision variables in this problem are:\n\n* `round_place_golfer` (in Model 1) or `round_group_i_golfer` (in Model 2) or `round_group_golfers` (in Model 3) or `assign` (in Model 4), which represent the assignment of golfers to groups in each round.\n\nThe key constraints in this problem are:\n\n* Each group in each round must have a distinct set of golfers.\n* Each pair of golfers can play together at most once across all rounds.\n* Symmetry-breaking constraints to reduce the search space and avoid duplicate solutions.\n\nThe objective of this problem is to find a feasible assignment of golfers to groups in each round, satisfying the above constraints.\n\nNote that the problem does not have an explicit objective function to minimize or maximize, but rather aims to find a feasible solution that satisfies the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 8023, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0bfdcc06-3681-4f03-90db-185ec73ef379": {"__data__": {"id_": "0bfdcc06-3681-4f03-90db-185ec73ef379", "embedding": null, "metadata": {"model_name": "golomb"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golomb_medium", "node_type": "4", "metadata": {"model_name": "golomb"}, "hash": "d3abf932a02a0e766acf382eafe858189ce803d79c72e51a631a8dc6e80877a2", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % Golomb rulers\n% From csplib:\n% A Golomb ruler may be defined as a set of m integers 0 = a_1 < a_2 <\n% ... < a_m such that the m(m-1)/2 differences a_j - a_i, 1 <= i < j\n% <= m are distinct. Such a ruler is said to contain m marks and is of\n% length a_m. The objective is to find optimal (minimum length) or\n% near optimal rulers.\n%\n% This is the \"ternary constraints and an alldifferent\" model\n\ninclude \"globals.mzn\";\n\nint: m;\nint: n = m*m;\n\narray[1..m] of var 0..n: mark;\n\narray[1..(m*(m-1)) div 2] of var 0..n: differences =\n    [ mark[j] - mark[i] | i in 1..m, j in i+1..m];\n\nconstraint mark[1] = 0;\n\nconstraint forall ( i in 1..m-1 ) ( mark[i] < mark[i+1] );\n\nconstraint alldifferent(differences);\n\n    % Symmetry breaking\nconstraint differences[1] < differences[(m*(m-1)) div 2];\n\nsolve :: int_search(mark, input_order, indomain, complete)\n    minimize mark[m];\n\noutput [show(mark)];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%\n\n                    ======\n                    Description:\n                    ---------\n                    Golomb Ruler Problem\n\nThe Golomb Ruler Problem is a classic constraint programming problem that involves finding a set of marks on a ruler such that the differences between all pairs of marks are distinct.\n\nThe main decision variables in this problem are the `mark` array, which represents the positions of the marks on the ruler, and the `differences` array, which represents the differences between all pairs of marks.\n\nThe key constraints in this problem are:\n\n* The first mark is at position 0.\n* Each mark is to the right of the previous mark.\n* All differences between pairs of marks are distinct.\n* A symmetry-breaking constraint to ensure that the solution is not mirrored.\n\nThe objective of the problem is to minimize the length of the ruler, which is represented by the position of the last mark (`mark[m]`).\n\nIn essence, the Golomb Ruler Problem is about finding the shortest ruler that can measure all distances up to a certain length, with the constraint that all distances must be unique.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2225, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1e804c9f-6691-439a-a60c-fa57e7352b0e": {"__data__": {"id_": "1e804c9f-6691-439a-a60c-fa57e7352b0e", "embedding": null, "metadata": {"model_name": "graph"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "graph_medium", "node_type": "4", "metadata": {"model_name": "graph"}, "hash": "2e14510bee2bfd37d47031756b567269d7edea5d175e2af187f406e3b3bb6c78", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % a strange graph numbering problem\nvar 1..8: a;\nvar 1..8: b;\nvar 1..8: c;\nvar 1..8: d;\nvar 1..8: e;\nvar 1..8: f;\nvar 1..8: g;\nvar 1..8: h;\n\n% Each number is used exactly once\nconstraint a != b;\nconstraint a != c;\nconstraint a != d;\nconstraint a != e;\nconstraint a != f;\nconstraint a != g;\nconstraint a != h;\nconstraint b != c;\nconstraint b != d;\nconstraint b != e;\nconstraint b != f;\nconstraint b != g;\nconstraint b != h;\nconstraint c != d;\nconstraint c != e;\nconstraint c != f;\nconstraint c != g;\nconstraint c != h;\nconstraint d != e;\nconstraint d != f;\nconstraint d != g;\nconstraint d != h;\nconstraint e != f;\nconstraint e != g;\nconstraint e != h;\nconstraint f != g;\nconstraint f != h;\nconstraint g != h;\n\n% Adjacent vertices differ by at most two\nconstraint abs(a - b) >= 2;\nconstraint abs(a - c) >= 2;\nconstraint abs(a - d) >= 2;\nconstraint abs(b - c) >= 2;\nconstraint abs(b - e) >= 2;\nconstraint abs(b - f) >= 2;\nconstraint abs(c - d) >= 2;\nconstraint abs(c - e) >= 2;\nconstraint abs(c - f) >= 2;\nconstraint abs(c - g) >= 2;\nconstraint abs(d - f) >= 2;\nconstraint abs(d - g) >= 2;\nconstraint abs(e - f) >= 2;\nconstraint abs(e - h) >= 2;\nconstraint abs(f - g) >= 2;\nconstraint abs(f - h) >= 2;\nconstraint abs(g - h) >= 2;\n\nsolve satisfy;\n\noutput [\"  \\(b)-\\(e)\\n\",\n        \" /|*|\\\\\\n\",\n        \"\\(a)-\\(c)-\\(f)-\\(h)\\n\",\n        \" \\\\|*|/\\n\",\n        \"  \\(d)-\\(g)\\n\"] ++\n       [\"\\na = \\(a); b = \\(b); c = \\(c); d = \\(d);\",\n        \" e = \\(e); f = \\(f); g = \\(g); h = \\(h);\\n\"] \n\n\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the \"Graph Numbering Problem\" or \"Graph Labeling Problem\".\n\nThis problem is about assigning unique numbers from 1 to 8 to the vertices of a specific graph, such that each number is used exactly once, and the numbers assigned to adjacent vertices differ by at most two.\n\nThe main decision variables are `a` to `h`, which represent the numbers assigned to each vertex of the graph.\n\nThe key constraints are:\n\n* Each number is used exactly once, which means that no two vertices can have the same number.\n* Adjacent vertices (connected by an edge) must have numbers that differ by at least two. This is represented by the absolute difference constraints, such as `abs(a - b) >= 2`.\n\nThe objective of the problem is to find a feasible assignment of numbers to the vertices that satisfies all the constraints, which is achieved by using the `solve satisfy` statement.\n\nThe output of the model is a graphical representation of the graph with the assigned numbers, as well as a list of the assigned numbers for each vertex.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2692, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "665b3538-25ff-4224-a32e-49c4bf2d4751": {"__data__": {"id_": "665b3538-25ff-4224-a32e-49c4bf2d4751", "embedding": null, "metadata": {"model_name": "itemset_mining"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "itemset_mining_medium", "node_type": "4", "metadata": {"model_name": "itemset_mining"}, "hash": "20e03232eb8a60310fc55acfaf802daa156606b7689b9b67817e07b402c073af", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    int : NrI ; \nint : NrT ; \nint : Freq ;\narray [ 1..NrT ] of set of 1..NrI : TDB;\nvar set of 1..NrI : Items ;\nconstraint card ( cover ( Items ,TDB ) ) >= Freq ;\nsolve satisfy ; \n\nfunction var set of int : cover (\n         var set of int : Items ,\n         array [ int ] of var set of int : D) = \n         let {\n                          var set of index_set (D): Trans ;\n                          constraint forall ( t in index_set (D) )\n                          ( t in Trans <-> Items subset D[ t ] );\n         } in Trans;\n\narray[1.. NrI] of int: itemprice;\nint: minUtility;\n\nconstraint sum(i in Items)(itemprice[i]) >= minUtility;\n\nNrI = 6;\nint: bread = 1;\nint: butter = 2;\nint: cheese = 3;\nint: cocoa = 4;\nint: milk = 5;\nint: vegemite = 6;\narray[1..NrI] of string: name = [\"bread\",\"butter\",\"cheese\",\"cocoa\",\"milk\",\"vegemite\"];\nitemprice = [1,2,1,2,1,1];\n\nNrT = 7;\nTDB = [ { butter, cheese, milk, vegemite },\n        { butter, cocoa, milk, vegemite },\n\t{ bread, cocoa, cheese, milk },\n\t{ bread, butter, cheese, vegemite }, \n\t{ bread, cheese, milk, vegemite },\n\t{ bread, butter, cheese, cocoa, milk },\n\t{ bread, cheese, milk }];\n\nFreq = 4;\nminUtility = 3;\n\noutput [ name[i] ++ \" \" | i in fix(Items) ];\n\n                    ======\n                    Description:\n                    ---------\n                    **Market Basket Analysis Problem**\n\nThe Market Basket Analysis Problem is a classic constraint programming problem that involves identifying a set of items that frequently appear together in a dataset of transactions.\n\n**Decision Variables:**\n\nThe main decision variable is `Items`, which represents a set of items (e.g., products) that are frequently purchased together.\n\n**Key Constraints:**\n\n1. **Frequency constraint**: The set of items `Items` must appear together in at least `Freq` transactions (i.e., baskets).\n2. **Transaction database constraint**: Each transaction in the dataset `TDB` contains a subset of items, and the set of items `Items` must be a subset of at least one transaction.\n3. **Minimum utility constraint**: The total price of the items in `Items` must be at least `minUtility`.\n\n**Objective:**\n\nThe objective is to find a set of items that satisfies the constraints, without optimizing any specific objective function (i.e., `solve satisfy`). The goal is to identify a set of items that frequently appear together in the transactions and meet the minimum utility requirement.\n\nIn this specific model, the problem is instantiated with 6 items (bread, butter, cheese, cocoa, milk, and vegemite) and 7 transactions. The frequency threshold is set to 4, and the minimum utility is set to 3. The model aims to find a set of items that appears together in at least 4 transactions and has a total price of at least 3.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2811, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e5132c48-019e-48fa-ad12-c3621a767a65": {"__data__": {"id_": "e5132c48-019e-48fa-ad12-c3621a767a65", "embedding": null, "metadata": {"model_name": "jobshop"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "jobshop_medium", "node_type": "4", "metadata": {"model_name": "jobshop"}, "hash": "8605374b68594b4203d4a7999948df06827a1cf1d5570e5fc6d14bd7f5751daf", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\n% only one task on any machine at one time\n%constraint forall(ma in MACH)\n%                 (forall(j1,j2 in JOB where j1 < j2)\n%                       (forall(t1,t2 in TASK where mc[j1,t1] = ma /\\ mc[j2,t2] = ma)\n%                              (nonoverlap(s[j1,t1],d[j1,t1],s[j2,t2],d[j2,t2]))));\n\nconstraint forall(j1, j2 in JOB, t1, t2 in TASK \n       where j1 < j2 /\\ mc[j1,t1] = mc[j2,t2])\n      (nonoverlap(s[j1,t1],d[j1,t1],\n                  s[j2,t2],d[j2,t2]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve :: int_search([s[j,t] | j in JOB, t in TASK], input_order, indomain_min, complete)\n      minimize makespan;\n\noutput [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 2 : \n\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n   %:: int_search([s[j,t]|j in JOB,t in TASK],input_order,indomain_min,complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],smallest, indomain_min, complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],dom_w_deg, indomain_min, complete)\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 3 : \n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n%      ::\n%      seq_search([ int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete),\n%                  int_search([makespan], input_order, indomain_min, complete)])\n%      seq_search([ int_search([makespan], input_order, indomain_min, complete),\n%                   int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete)])\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n                    ======\n                    Description:\n                    ---------\n                    **Flowshop Scheduling Problem**\n\nThe Flowshop Scheduling Problem is a classic constraint programming problem that involves scheduling a set of jobs on a set of machines in a specific order.\n\n**Decision Variables:**\n\n* `s[j,t]`: the start time of task `t` in job `j`\n* `makespan`: the maximum completion time of all jobs\n\n**Key Constraints:**\n\n* Each task in a job must be performed in order, meaning that the start time of a task must be after the completion time of the previous task in the same job.\n* Only one task can be performed on a machine at a time, meaning that two tasks on the same machine cannot overlap in time.\n\n**Objective:**\n\nThe objective of the problem is to minimize the `makespan`, which is the maximum completion time of all jobs.\n\nIn summary, the Flowshop Scheduling Problem involves scheduling a set of jobs on a set of machines in a specific order, subject to constraints on the order of tasks within each job and the availability of machines, with the goal of minimizing the overall completion time.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 5111, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b297af9e-e77e-4388-9020-19cd8c68158f": {"__data__": {"id_": "b297af9e-e77e-4388-9020-19cd8c68158f", "embedding": null, "metadata": {"model_name": "K4xP2Graceful"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "K4xP2Graceful_medium", "node_type": "4", "metadata": {"model_name": "K4xP2Graceful"}, "hash": "837f26fbf3d0e640c8c957190953f9459740d3dbf059dbee93aef01b5d1c4511", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % K4P2 Graceful Graph in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: m = 16;\nint: n = 8;\narray[1..n] of var 0..m: nodes;\narray[1..m, 1..2] of var 1..n: graph;\narray[1..m] of var 1..m: edges;\n\n\n\nsolve :: int_search(nodes, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..m) (\n    abs(nodes[graph[i,1]] - nodes[graph[i,2]]) = edges[i]  \n  )\n  /\\\n  all_different(edges) \n  /\\ \n  all_different(nodes)\n;\n\ngraph =\narray2d(1..m, 1..2,\n[1, 2,\n1, 3,\n1, 4,\n2, 3,\n2, 4,\n3, 4,\n\n5, 6,\n5, 7,\n5, 8,\n6, 7,\n6, 8,\n7, 8,\n\n1, 5,\n2, 6,\n3, 7,\n4, 8]);\n\noutput\n[\n  \"nodes: \" ++ show(nodes) ++ \"\\n\" ++\n  \"edges: \" ++ show(edges) ++ \"\\n\"\n];\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the \"Graceful Graph\" problem.\n\nThe Graceful Graph problem is about labeling the nodes of a graph with integers from 1 to m, such that the absolute difference between the labels of two adjacent nodes is equal to the edge label connecting them. The goal is to find a labeling that satisfies this condition for all edges in the graph.\n\nThe main decision variables in this problem are:\n\n* `nodes`: an array of variables representing the labels assigned to each node in the graph.\n* `edges`: an array of variables representing the labels assigned to each edge in the graph.\n* `graph`: a 2D array representing the adjacency matrix of the graph, where `graph[i,1]` and `graph[i,2]` represent the nodes connected by the `i`-th edge.\n\nThe key constraints in this problem are:\n\n* For each edge, the absolute difference between the labels of the two nodes it connects must be equal to the edge label.\n* All edge labels must be distinct.\n* All node labels must be distinct.\n\nThe objective of the problem is to find a feasible solution that satisfies all these constraints, rather than optimizing a specific objective function.\n\nIn this specific model, the graph is fixed and represented by the `graph` array, and the goal is to find a labeling of the nodes and edges that satisfies the graceful graph condition.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2130, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9c5ac543-196b-44de-aeb6-e3bd7b74ebdf": {"__data__": {"id_": "9c5ac543-196b-44de-aeb6-e3bd7b74ebdf", "embedding": null, "metadata": {"model_name": "killer_sudoku"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "killer_sudoku_medium", "node_type": "4", "metadata": {"model_name": "killer_sudoku"}, "hash": "bd035d6eee8b1c755e4d2dd716f55bba73489f22082bb47fffb3eb7b56f310d7", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n%\n% Killer Sudoku in MiniZinc.\n\n%   Killer sudoku (also killer su doku, sumdoku, sum doku, addoku, or\n%   samunamupure) is a puzzle that combines elements of sudoku and kakuro.\n%   Despite the name, the simpler killer sudokus can be easier to solve\n%   than regular sudokus, depending on the solver's skill at mental arithmetic;\n%   the hardest ones, however, can take hours to crack.\n \n%   The objective is to fill the grid with numbers from 1 to 9 in a way that\n%   the following conditions are met:\n \n%     * Each row, column, and nonet contains each number exactly once.\n%     * The sum of all numbers in a cage must match the small number printed\n%       in its corner.\n%     * No number appears more than once in a cage. (This is the standard rule\n%       for killer sudokus, and implies that no cage can include more\n%       than 9 cells.)\n \n%   In 'Killer X', an additional rule is that each of the long diagonals\n%   contains each number once.\n%   \"\"\"\n \n\nint: num_p = 29; % number of segments\nint: num_hints = 4;  % number of hints per segments (that's max number of hints)\nint: max_val = 100;\narray[1..num_p, 1..2*num_hints+1] of 0..max_val: P =\n  array2d(1..num_p, 1..2*num_hints+1, [\n    1,1,  1,2, 0,0, 0,0,   3,\n    1,3,  1,4, 1,5, 0,0,  15,\n    1,6,  2,5, 2,6, 3,5,  22,\n    1,7,  2,7, 0,0, 0,0,   4,\n    1,8,  2,8, 0,0, 0,0,  16,\n    1,9,  2,9, 3,9, 4,9,  15,\n    2,1,  2,2, 3,1, 3,2,  25,\n    2,3,  2,4, 0,0, 0,0,  17,\n    3,3,  3,4, 4,4, 0,0,   9,\n    3,6,  4,6, 5,6, 0,0,   8,\n    3,7,  3,8, 4,7, 0,0,  20,\n    4,1,  5,1, 0,0, 0,0,   6,\n    4,2,  4,3, 0,0, 0,0,  14,\n    4,5,  5,5, 6,5, 0,0,  17,\n    4,8,  5,7, 5,8, 0,0,  17,\n    5,2,  5,3, 6,2, 0,0,  13,\n    5,4,  6,4, 7,4, 0,0,  20,\n    5,9,  6,9, 0,0, 0,0,  12,\n    6,1,  7,1, 8,1, 9,1,  27,\n    6,3,  7,2, 7,3, 0,0,   6,\n    6,6,  7,6, 7,7, 0,0,  20,\n    6,7,  6,8, 0,0, 0,0,   6,\n    7,5,  8,4, 8,5, 9,4,  10,\n    7,8,  7,9, 8,8, 8,9,  14,\n    8,2,  9,2, 0,0, 0,0,   8,\n    8,3,  9,3, 0,0, 0,0,  16,\n    8,6,  8,7, 0,0, 0,0,  15,\n    9,5,  9,6, 9,7, 0,0,  13,\n    9,8,  9,9, 0,0, 0,0,  17\n   ]);\n\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n \n  forall(i in 1..n) (\n        all_different([x[i,j] | j in 1..n]) /\\\n        all_different([x[j,i] | j in 1..n])\n  )\n  /\\\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n  /\\ % calculate the hints\n  forall(p in 1..num_p) (\n     sum(i in 1..num_hints where P[p,2*(i-1)+1] > 0) (x[  P[p, 2*(i-1)+1], P[p,2*(i-1)+2]  ]) = P[p, 2*num_hints+1]\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\"; \nint: n = 9;\narray[1..n, 1..n] of var 1..9: x;\n\nint: num_segments = 29; % number of segments\n\narray[1..n, 1..n] of int: segments =\narray2d(1..n, 1..n,\n[\n  1, 1, 2, 2, 2, 3, 4, 5, 6, % 1\n  7, 7, 8, 8, 3, 3, 4, 5, 6, % 2\n  7, 7, 9, 9, 3,10,11,11, 6, % 3\n 13,14,14, 9,15,10,11,12, 6, % 4\n 13,16,16,17,15,10,12,12,18, % 5\n 19,16,20,17,15,21,22,22,18, % 6\n 19,20,20,17,23,21,21,24,24, % 7\n 19,25,26,23,23,27,27,24,24, % 8\n 19,25,26,23,28,28,28,29,29, % 9\n]);\n\narray[1..num_segments] of int: segment_sums =\n[\n   3, % 1\n  15, % 2\n  22, % 3\n   4, % 4\n  16, % 5\n  15, % 6\n  25, % 7\n  17, % 8\n   9, % 9\n   8, % 10\n  20, % 11\n  17, % 12\n   6, % 13\n  14, % 14\n  17, % 15\n  13, % 16\n  20, % 17\n  12, % 18\n  27, % 19\n   6, % 20\n  20, % 21\n   6, % 22\n  10, % 23\n  14, % 24\n   8, % 25\n  16, % 26\n  15, % 27\n  13, % 28\n  17  % 29\n];\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\n% Standard Sudoku constraints\nconstraint\n  % rows and columns\n  forall(i in 1..n) (\n     all_different([x[i,j] | j in 1..n]) /\\\n     all_different([x[j,i] | j in 1..n])\n  )\n  /\\ % blocks\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n;\n\n% Handle the segments\nconstraint\n  forall(p in 1..num_segments) (\n    segment_sums[p] = sum([x[i,j] | i,j in 1..n where segments[i,j] = p])\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];\n                    ======\n                    Description:\n                    ---------\n                    The problem is called Killer Sudoku.\n\nKiller Sudoku is a puzzle that combines elements of Sudoku and Kakuro. The objective is to fill a 9x9 grid with numbers from 1 to 9, such that each row, column, and nonet (a 3x3 sub-grid) contains each number exactly once. Additionally, the puzzle is divided into \"cages\" or \"segments\" which are groups of cells that must add up to a specific total value. Each cage must contain each number only once, and no number can be repeated within a cage.\n\nThe main decision variables in this problem are the values of the cells in the 9x9 grid, represented by the `x` array in the model. Each `x[i,j]` represents the value of the cell at row `i` and column `j`.\n\nThe key constraints in this problem are:\n\n* Each row, column, and nonet must contain each number exactly once.\n* The sum of the values in each cage must equal the specified total value for that cage.\n* No number can be repeated within a cage.\n\nThe objective of the problem is to find a solution that satisfies all these constraints.\n\nIn the provided models, the `solve` statement is set to `satisfy`, which means that the objective is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 5592, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "79a76e35-3375-403d-b124-efd3d225b0cf": {"__data__": {"id_": "79a76e35-3375-403d-b124-efd3d225b0cf", "embedding": null, "metadata": {"model_name": "knapsack"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "knapsack_medium", "node_type": "4", "metadata": {"model_name": "knapsack"}, "hash": "cc932f3ea3a20fccba7a251567bfe6faf7c21642246bf1c9060c88b42e69efaf", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 : \n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\narray[OBJ] of var int: x; % how many of each object\n\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in OBJ)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\nModel 2 : \n\n\nint: n;    set of int: OBJ = 1..n;\narray[OBJ] of int: size;\narray[OBJ] of int: value;\nint: limit;\narray[OBJ] of var int: x;\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i]*x[i])<= limit;\nsolve maximize sum(i in OBJ)(value[i]*x[i]);\nn = 4;\nsize = [5,8,9,12];\nvalue = [3,5,7,8];\nlimit = 29;\n\n\n\nModel 3 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var 0..1: x; \n\nconstraint sum(i in 1..n)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 4 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var bool: x; \n\nconstraint sum(i in 1..n)(size[i] * bool2int(x[i])) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(x[i]));\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 5 : \n\n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\nvar set of OBJ: x; \n\n\nconstraint sum(i in x)(size[i]) <= capacity;\n\nsolve maximize sum(i in x)(profit[i]);\n\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 6 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\nvar set of 1..n: x;\n\nconstraint sum(i in 1..n)(size[i] * bool2int(i in x)) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(i in x));\n\noutput [\"x = \", show(x), \"\\n\"];\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the 0/1 Knapsack Problem.\n\nThis problem is about selecting a subset of items to include in a knapsack of limited capacity, with the goal of maximizing the total value of the selected items. Each item has a size and a profit, and the knapsack has a limited capacity.\n\nThe main decision variables are the `x` variables, which represent whether each item is included in the knapsack (1) or not (0).\n\nThe key constraints are:\n\n* Each item can only be included once (or not at all), which is ensured by the `x` variables being binary.\n* The total size of the included items must not exceed the knapsack's capacity.\n\nThe objective is to maximize the total profit of the included items.\n\nIn other words, the problem is to find the optimal selection of items to put in the knapsack, given the capacity constraint, to maximize the total value of the selected items.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2896, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2e652a58-feb7-47c7-968c-4fb9c2fa760d": {"__data__": {"id_": "2e652a58-feb7-47c7-968c-4fb9c2fa760d", "embedding": null, "metadata": {"model_name": "langford"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "langford_medium", "node_type": "4", "metadata": {"model_name": "langford"}, "hash": "b17aa2d09e8dd882facdc22671829a9f853bbb85715b4df87b53b70fc2eb6e6c", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n                 (x[d,c+1] = x[d,c] + d + 1);\n\nsolve satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ if fix(x[d,c]) = p then show(d) ++ \" \" else \"\" endif\n          | p in POS, d in DIG, c in COPY ]\n       ;\n\n\n\nModel 2 : \n\n\n% Langford's number problem in MiniZinc.\n%\n% Arrange 2 sets of positive integers 1..k to a sequence,\n% such that, following the first occurence of an integer i,\n% each subsequent occurrence of i, appears i+1 indices later\n% than the last.\n% For example, for k=4, a solution would be 41312432\n\ninclude \"globals.mzn\";\n\nint: k;\nset of int: positionDomain = 1..2*k;\n\narray[positionDomain] of var positionDomain: position;\n% better presentation:\narray[positionDomain] of var 1..k: solution;\n\nsolve :: int_search(position, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..k) (\n     position[i+k] = position[i] + i+1 /\\\n     % hakank: added this\n     solution[position[i]] = i /\\ \n     solution[position[k+i]] = i\n  )\n  /\\   \n  all_different(position)\n  /\\ % symmetry breaking\n  solution[1] < solution[2*k]\n;\n\n\noutput [\n  show(solution), \"\\n\"\n\n];\n\n%\n% data\n%\nk = 4;\n% k = 7;\n% k = 8;\n% k = 10;\n% k = 20;\n\n\n\nModel 3 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"inverse.mzn\";\nconstraint inverse([x[d,c] | d in DIG, c in COPY], y);\n\n%include \"alldifferent.mzn\";\n%constraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n      (x[d,c+1] = x[d,c] + d + 1);\n\n%constraint forall(d in DIG, c in 1..m-1, p in POS)\n%                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve \n      %:: int_search(y, input_order, indomain_min, complete) \n      %:: int_search([x[d,c] | d in DIG, c in COPY], input_order, indomain_min, complete) \n      satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n\n\nModel 4 :\n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\nconstraint forall(d in DIG, c in 1..m-1, p in POS)\n                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve satisfy;\n\noutput [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n\n                    ======\n                    Description:\n                    ---------\n                    Langford's Problem.\n\nLangford's Problem is a classic constraint programming problem that involves arranging a sequence of digits in a specific way. The problem is defined as follows: given two positive integers `m` and `n`, create a sequence of `m` copies of the digits from 1 to `n`, such that any two consecutive copies of a digit `k` are separated by exactly `k` other digits.\n\nThe main decision variables in this problem are the positions of the digits in the sequence, represented by the `x` or `y` arrays in the models. These variables represent the indices at which each digit appears in the sequence.\n\nThe key constraints in this problem are:\n\n* Each digit appears exactly `m` times in the sequence.\n* Any two consecutive copies of a digit `k` are separated by exactly `k` other digits.\n* The sequence must contain all digits from 1 to `n` exactly `m` times.\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints.\n\nIn simpler terms, the problem is about creating a sequence of digits where each digit appears a certain number of times, and the distance between consecutive appearances of the same digit is equal to the digit's value. For example, if we have two copies of the digits 1 to 4, a valid solution would be `41312432`, where each digit appears twice, and the distance between consecutive appearances of the same digit is equal to the digit's value.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4687, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "20ad5802-aad7-4f58-be33-4cdccdc4ff64": {"__data__": {"id_": "20ad5802-aad7-4f58-be33-4cdccdc4ff64", "embedding": null, "metadata": {"model_name": "loan"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "loan_medium", "node_type": "4", "metadata": {"model_name": "loan"}, "hash": "ea0a18c84c7d227949fb0096ceb60abf2609ff146f4b3c50546158504a3110ec", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % variables\nvar float: R;        % quarterly repayment\nvar float: P;        % principal initially borrowed\nvar 0.0 .. 10.0: I;  % interest rate\n\n% intermediate variables\nvar float: B1; % balance after one quarter\nvar float: B2; % balance after two quarters\nvar float: B3; % balance after three quarters\nvar float: B4; % balance owing at end\n\nconstraint B1 = P * (1.0 + I) - R;\nconstraint B2 = B1 * (1.0 + I) - R;\nconstraint B3 = B2 * (1.0 + I) - R; \nconstraint B4 = B3 * (1.0 + I) - R;\n\nsolve satisfy;\n\noutput [\n \"Borrowing \", show_float(0, 2, P), \" at \", show(I*100.0), \n \"% interest, and repaying \", show_float(0, 2, R), \n  \"\\nper quarter for 1 year leaves \", show_float(0, 2, B4), \" owing\\n\"\n];\n\n\n                    ======\n                    Description:\n                    ---------\n                    Loan Repayment Problem.\n\nThis problem is about finding the optimal loan repayment plan for a borrower who takes out a loan with a certain interest rate and repays it over four quarters.\n\nThe main decision variables are:\n\n* R: the quarterly repayment amount\n* P: the principal amount borrowed\n* I: the interest rate\n\nThese variables represent the key aspects of the loan: how much is borrowed, how much interest is charged, and how much is repaid each quarter.\n\nThe key constraints are:\n\n* The balance after each quarter is calculated by adding the interest accrued and subtracting the repayment made.\n* The balance owing at the end of the four quarters is calculated similarly.\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function. In other words, the goal is to find a loan repayment plan that works, rather than minimizing or maximizing a particular aspect of the plan.\n\nIn essence, the problem is about finding a loan repayment schedule that takes into account the interest rate and the borrower's quarterly repayments, and ensures that the loan is repaid over the course of a year.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2052, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a23399d9-df60-4fda-95a9-216063cdbb68": {"__data__": {"id_": "a23399d9-df60-4fda-95a9-216063cdbb68", "embedding": null, "metadata": {"model_name": "ltsp"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ltsp_medium", "node_type": "4", "metadata": {"model_name": "ltsp"}, "hash": "b60d6665bc7c90643ef9640d5d81cc8a37914c0ec9f9f1d8b71bfae7f883668b", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    int: n; % number of cities\nset of int: CITY = 1..n;\nset of int: POS = 1..n;\narray[CITY] of int: coord; % coordinate of city \nint: m; % number of precedences\nset of int: PREC = 1..m;\narray[PREC] of CITY: left;\narray[PREC] of CITY: right;\n\narray[CITY] of var POS: order;\narray[POS] of var CITY: city;\n\ninclude \"inverse.mzn\";\nconstraint inverse(order,city);\n\nconstraint forall(i in PREC)(order[left[i]] < order[right[i]]);\n\nsolve minimize sum(i in 1..n-1)(abs(coord[city[i]] - coord[city[i+1]]));\n\n\n\n                    ======\n                    Description:\n                    ---------\n                    Traveling Salesman Problem (TSP)\n\nThe Traveling Salesman Problem is a classic constraint programming problem that involves finding the shortest possible tour that visits a set of cities and returns to the starting city.\n\nThe main decision variables in this problem are:\n\n* `order`: an array of variables that represents the order in which the cities are visited\n* `city`: an array of variables that represents the city at each position in the tour\n\nThese variables are used to determine the sequence of cities that the salesman will visit.\n\nThe key constraints in this problem are:\n\n* Each city must be visited exactly once\n* The order of visitation must satisfy the precedence constraints, which specify that certain cities must be visited before others\n* The tour must start and end at the same city\n\nThe objective of the problem is to minimize the total distance traveled by the salesman, which is calculated as the sum of the absolute differences between the coordinates of consecutive cities in the tour.\n\nIn other words, the goal is to find the shortest possible route that visits all the cities and returns to the starting point, while satisfying the precedence constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1848, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f322f351-2471-4a69-8de0-c3cc211c7348": {"__data__": {"id_": "f322f351-2471-4a69-8de0-c3cc211c7348", "embedding": null, "metadata": {"model_name": "magic_hexagon"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_hexagon_medium", "node_type": "4", "metadata": {"model_name": "magic_hexagon"}, "hash": "33bcf600391c8b7b906c2f0a1f6dcd39e16165738f86f1ad9f7f1e369f912a76", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % Magic Hexagon in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nset of int: N = 1..19;\nvar N: a;\nvar N: b;\nvar N: c;\nvar N: d;\nvar N: e;\nvar N: f;\nvar N: g;\nvar N: h;\nvar N: i;\nvar N: j;\nvar N: k;\nvar N: l;\nvar N: m;\nvar N: n;\nvar N: o;\nvar N: p;\nvar N: q;\nvar N: r;\nvar N: s;\n\narray[N] of var N: LD = [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s];\n\nsolve satisfy;\n\nconstraint\n  all_different(LD) /\\\n\n  a + b + c =  38 /\\\n  d + e + f + g =  38 /\\\n  h + i + j + k + l =  38 /\\ \n  m + n + o + p =  38 /\\ \n  q + r + s =  38 /\\ \n  a + d + h =  38 /\\ \n  b + e + i + m =  38 /\\ \n  c + f + j + n + q =  38 /\\ \n  g + k + o + r =  38 /\\ \n  l + p + s =  38 /\\ \n  c + g + l =  38 /\\ \n  b + f + k + p =  38 /\\ \n  a + e + j + o + s =  38 /\\ \n  d + i + n + r =  38 /\\ \n  h + m + q =  38 /\\ \n\n  a < c /\\\n  a < h /\\\n  a < l /\\\n  a < q /\\\n  a < s /\\\n  c < h\n;\n\noutput\n[\n  show(LD)\n];\n                    ======\n                    Description:\n                    ---------\n                    **Magic Hexagon Problem**\n\nThe Magic Hexagon problem is a classic constraint programming problem that involves arranging numbers in a specific pattern to satisfy certain conditions.\n\n**Description**\n\nThe problem is about creating a hexagonal arrangement of 19 numbers from 1 to 19, such that the sum of the numbers in each row, column, and diagonal is equal to 38. The arrangement is subject to certain constraints, making it a challenging problem to solve.\n\n**Decision Variables**\n\nThe main decision variables in this problem are the 19 variables `a` to `s`, which represent the numbers to be arranged in the hexagonal pattern. These variables are integers between 1 and 19.\n\n**Key Constraints**\n\nThe key constraints in this problem can be described as follows:\n\n* Each number from 1 to 19 must be used exactly once in the arrangement (all_different constraint).\n* The sum of the numbers in each row, column, and diagonal must be equal to 38.\n* Certain numbers must be less than or equal to others (e.g., `a` must be less than `c`, `h`, `l`, `q`, and `s`).\n\n**Objective**\n\nThe objective of this problem is to find a feasible arrangement of the numbers that satisfies all the constraints. There is no explicit objective function to minimize or maximize; the goal is to find a solution that meets all the conditions.\n\nIn summary, the Magic Hexagon problem is a challenging constraint programming problem that requires finding a specific arrangement of numbers to satisfy a set of constraints, with no explicit objective function to optimize.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2580, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f5fce463-340d-4bb3-a4a8-3d9850d3f0ea": {"__data__": {"id_": "f5fce463-340d-4bb3-a4a8-3d9850d3f0ea", "embedding": null, "metadata": {"model_name": "magic_sequence"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_sequence_medium", "node_type": "4", "metadata": {"model_name": "magic_sequence"}, "hash": "1c3e5523e10b945d38288e597d12adca3318a71660bece4710d99b24379f1db9", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n% Magic sequence in MiniZinc.\n% A magic sequence of length n is a sequence of integers x0 . . xn-1 between 0 and n-1, such that for all i in 0 to n-1, the number i occurs exactly xi times in the sequence. For instance, 6,2,1,0,0,0,1,0,0,0 is a magic sequence since 0 occurs 6 times in it, 1 occurs twice, ...\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n  forall(i in 0..n-1) (\n    s[i] = sum(j in 0..n-1) (bool2int(s[j] = i))\n  )\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 2 : \n\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n        forall(i in 0..n-1) (\n                s[i] = sum(j in 0..n-1) (bool2int(s[j]=i))\n        )\n        /\\ \n        sum(i in 0..n-1) (s[i])=n \n        /\\\n        sum(i in 0..n-1) (s[i]*i) =n\n;\n\n\noutput [\n       show(s), \"\\n\",\n];\n\n\n\nModel 3 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  10;\narray[0..n-1] of var 0..n-1: s;\narray[0..n-1] of int: value = array1d(0..n-1, [i | i in 0..n-1]); % helper for distribute\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   distribute(s, value, s)         /\\ \n   sum(i in 0..n-1) (s[i])   = n   /\\\n   sum(i in 0..n-1) (s[i]*i) = n\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 4 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  100;\narray[0..n-1] of var 0..n-1: s;\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   global_cardinality(s,array1d(0..n-1, set2array(index_set(s))), s) :: domain\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\nModel 5 : \n\n\n% Magic squares in MiniZinc\n\ninclude \"globals.mzn\";\n\nint: n = 3;\n\nint: total = ( n * (n*n + 1)) div 2;\narray[1..n,1..n] of var 1..n*n: magic;\n\n\n% solve satisfy;\nsolve :: int_search(\n        [magic[i,j] | i in 1..n, j in 1..n], \n        first_fail,\n        indomain_min,\n        complete) \n    satisfy;\n\n\nconstraint\n\n        all_different([magic[i,j] | i in 1..n, j in 1..n]) :: domain\n        /\\\n        forall(k in 1..n) (\n           sum(i in 1..n) (magic[k,i]) = total % :: domain\n           /\\\n           sum(i in 1..n) (magic[i,k]) = total %:: domain\n        )\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,i]) = total  %:: domain\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,n-i+1]) = total %:: domain\n;\n\n% symmetry breaking\n% Activating all these constraints we get the\n% \"standard\" way of counting the number of solutions:\n%    1, 0, 1, 880, 275305224\n% i.e. this sequence: http://oeis.org/A006052\n%\n% Without the constraints the number of solutions are:\n%  N  #solutions\n%  -------------\n%  1     1\n%  2     0\n%  3     8\n%  4  7040\n%  5  many... \n%\n% constraint\n%    magic[1,1] < magic[1,n]\n%    /\\ magic[1,n] < magic[n,1]\n%    /\\ magic[1,1] < magic[n,n]\n% ;\n\n\noutput [\n  \"Total: \" ++ show(total) ++ \"\\n\"\n] ++\n[\n    %   show(magic)\n  if j = 1 then \"\\n\" else \"\" endif ++\n    if fix(magic[i,j]) < 10 then \" \" else \"\" endif ++\n    show(magic[i,j]) ++ \" \"\n  | i,j in 1..n\n] \n++ \n[\"\\n\"];\n\n\nModel 6 : \n\n\n% Magic square integer programming version in MiniZinc.\n% In recreational mathematics, a magic square of order n is an\n% arrangement of n^2 numbers, usually distinct integers, in a square,\n% such that n numbers in all rows, all columns, and both diagonals sum\n% to the same constant. A normal magic square contains the integers\n% from 1 to n^2.\n\n\n% square order\nint: n = 3; \n\n% integers to be placed\nset of 1..n*n: N = 1..n*n;\n\n% x[i,j,k] = 1 means that cell (i,j) contains integer k\narray[1..n, 1..n, N] of var 0..1: x;\n\narray[1..n, 1..n] of var 1..n*n: square;\n\nvar int: s; % the magic sum\n\nsolve :: int_search(\n        [x[i,j,k] | i,j in 1..n, k in N] ++ \n        [square[i,j] | i,j in 1..n] ++\n        [s],\n        first_fail,\n        indomain_min, \n        complete % \"credit(640, bbs(5))\" % \"complete\"\n      ) \n    satisfy;\n\nconstraint \n  s >= 0 \n  /\\\n  s <= n*n*n\n  /\\\n  % each cell must be assigned exactly one integer\n  forall(i in 1..n, j in 1..n) (\n     sum(k in N) (x[i,j,k]) = 1\n  )\n  /\\\n  % each integer must be assigned exactly to one cell\n  forall(k in N) (\n     sum(i in 1..n, j in 1..n) (x[i,j,k]) = 1\n  )\n\n  /\\\n  % the sum in each row must be the magic sum \n  forall(i in 1..n) (\n     sum(j in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in each column must be the magic sum\n  forall(j in 1..n) (\n     sum(i in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in the diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,i,k]) = s\n\n  /\\\n  % the sum in the co-diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,n-i+1,k]) = s\n\n  /\\\n  % for output\n  forall(i,j in 1..n) ( square[i,j] = sum(k in N) (k * x[i,j,k]))\n;\n\n\noutput [ \n   \"\\ns: \", show(s)\n] ++\n[\n  if  j = 1 then \"\\n\" else \" \" endif ++\n    show(square[i,j]) \n  | i,j in 1..n\n\n] ++ [\"\\n\"];\n\n% printf \"\\n\";\n% printf \"Magic sum is %d\\n\", s;\n% printf \"\\n\";\n% for{i in 1..n}\n% {  printf{j in 1..n} \"%3d\", sum{k in N} k * x[i,j,k];\n%    printf \"\\n\";\n% }\n% printf \"\\n\";\n                    ======\n                    Description:\n                    ---------\n                    The problem represented by these Minizinc models is the Magic Sequence/Magic Square problem.\n\n**Problem Description:**\nA Magic Sequence/Magic Square is an arrangement of integers in a sequence or square grid, such that each integer from 0 to n-1 appears exactly i times in the sequence, where i is the value of the integer. For example, the sequence 6, 2, 1, 0, 0, 0, 1, 0, 0, 0 is a Magic Sequence of length 10, because 0 appears 6 times, 1 appears twice, and 2 appears once.\n\n**Decision Variables:**\nThe main decision variables in these models are arrays of integers, representing the Magic Sequence or Magic Square. In the sequence models, the array `s` represents the Magic Sequence, where `s[i]` is the value of the i-th element in the sequence. In the square models, the array `magic` or `square` represents the Magic Square, where `magic[i, j]` or `square[i, j]` is the value of the cell at row i and column j.\n\n**Key Constraints:**\nThe key constraints in these models are:\n\n* Each integer from 0 to n-1 appears exactly i times in the sequence (or square).\n* The sum of the values in each row, column, and diagonal of the square is equal to a constant magic sum.\n\n**Objective:**\nThe objective of these models is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.\n\nNote that Models 1-4 represent the Magic Sequence problem, while Models 5 and 6 represent the Magic Square problem. Model 5 uses a more concise representation of the Magic Square, while Model 6 uses a more explicit representation with binary variables.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 6725, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3498e6d5-39c2-4d27-826b-135eb1d9c675": {"__data__": {"id_": "3498e6d5-39c2-4d27-826b-135eb1d9c675", "embedding": null, "metadata": {"model_name": "maximum_density_still_life"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "maximum_density_still_life_medium", "node_type": "4", "metadata": {"model_name": "maximum_density_still_life"}, "hash": "0abdfafe795714784b19f6496a2cf15de8b83ec28094092bff52824bf8d4043d", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % Maximum density still life in MiniZinc.\n\n% include \"globals.mzn\"; \nint: size = 7; % to change\n\nset of int: objFunctionBoardCoord      = 2..size+1;\nset of int: checkConstraintsBoardCoord = 1..size+2;\nset of int: augmentedBoardCoord        = 0..size+3;\n\n% Search space: The set of all possible assignments of 0s (dead) and 1s (live) \n% to the cells of the board section. However, to be able to easily express \n% constraints on \"boundary\" cells, we take as search space the set of 0/1 \n% boards of size n+4 by n+4: the actual stable pattern appears in the sub-board \n% defined by ignoring the first/last two rows/columns.\narray[augmentedBoardCoord,augmentedBoardCoord] of var 0..1: grid;\n\nvar int: z = sum(r in objFunctionBoardCoord, c in objFunctionBoardCoord) (grid[r,c]);\n\n% Objective function: Maximize the number of live cells in the sub-board defined \n% by ignoring the first/last two/ rows/columns.\n\n\n% solve maximize z;\nsolve :: int_search(\n        [grid[i,j] | i,j in augmentedBoardCoord], \n        smallest, \n        indomain_max, \n        complete) \n    maximize z;\n\nconstraint\n\n  % C1: Cells in the first/last two rows/columns are all 0 (dead)\n  forall(x in augmentedBoardCoord) (\n    grid[0,x] = 0 /\\\n    grid[1,x] = 0 /\\\n    grid[size+2,x] = 0 /\\  \n    grid[size+3,x] = 0 /\\\n    grid[x,0] == 0 /\\       \n    grid[x,1] == 0 /\\\n    grid[x,size+2] = 0 /\\  \n    grid[x,size+3] = 0 \n  )\n  /\\\n  forall(r in checkConstraintsBoardCoord,c in checkConstraintsBoardCoord) (\n    % C2: Each cell of the board (except those of the first/last row/column) \n    %     that has exactly three live neighbors is alive. \n    %     Together with constraint C1, this implies that cells in the\n    %     second/last-but-one row/column cannot have three live neighbors.\n    (\n      ( ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] + \n          grid[r,c-1] + grid[r,c+1] + \n          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1]\n          ) = 3 \n       ) -> (grid[r,c] = 1)\n    )\n    /\\    \n\n    % C3: Each live cell must have 2 or 3 live neighbors (cells of the first/last \n    % row/column may be ignored by this constraint)\n    (\n       (grid[r,c] = 1) -> \n                      (\n                        2 <= \n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          )\n                        /\\\n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          ) <= 3\n                      )\n    )\n  )\n  \n  /\\\n  % SBSO: Symmetry-breaking by selective ordering\n  % The assignment is forced to respect an ordering on the values that occur in corner entries\n  % of the board. In particular:  \n  % - if the NW-corner cell is dead, the SE-corner cell\n  % must be dead too \n  % - if the NE-corner cell is dead, the SW-corner cell must be dead too\n  % \n  grid[2,2] >= grid[size+1,size+1] /\\\n  grid[2,size+1] >= grid[size+1,2]\n;\n\n\noutput [\n  if j = 0 then \"\\n\" else \" \" endif ++\n    show(grid[i,j])\n  | i,j in augmentedBoardCoord\n];\n\n                    ======\n                    Description:\n                    ---------\n                    **Still Life Problem**\n\nThe Still Life problem is a classic constraint programming problem that involves finding a stable pattern of live and dead cells in a grid, where live cells are represented by 1s and dead cells are represented by 0s.\n\n**Decision Variables**\n\nThe main decision variables are the elements of the `grid` array, which represents the assignment of live (1) or dead (0) cells to each position in the grid.\n\n**Key Constraints**\n\nThe key constraints in the problem are:\n\n* **Boundary constraints**: Cells in the first and last two rows and columns of the grid are all dead (0).\n* **Live cell constraints**: A cell is alive (1) if it has exactly three live neighbors. A live cell must have 2 or 3 live neighbors.\n* **Symmetry-breaking constraints**: The assignment of live and dead cells is forced to respect an ordering on the values that occur in corner entries of the grid.\n\n**Objective**\n\nThe objective of the problem is to **maximize** the number of live cells in the grid, subject to the constraints.\n\nIn essence, the problem is to find a stable pattern of live and dead cells in a grid, where live cells are sustained by having exactly three live neighbors, and dead cells are sustained by not having three live neighbors. The goal is to find the pattern with the maximum number of live cells.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4724, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ebee6287-9ad5-4905-9de2-72b3ac45e0a3": {"__data__": {"id_": "ebee6287-9ad5-4905-9de2-72b3ac45e0a3", "embedding": null, "metadata": {"model_name": "mip"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "mip_medium", "node_type": "4", "metadata": {"model_name": "mip"}, "hash": "2af6bac97519dbaee7a3c0406044c0b3609ee24464bcb709bc81a6ad741e31f7", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.0*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 2 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\n\nsolve maximize 1.0*B - 1.0*C + 1.0*D;\nconstraint 2.0*B - 1.0*C + 2.0*D <=  4.0;\nconstraint 2.0*B - 3.0*C + 1.0*D <= -5.0;\nconstraint -1.0*B + 1.0*C - 2.0*D <= -1.0;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 3 :\n\n\nvar int: B;\nvar int: C;\nvar int: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.5*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 4 :\n\n\nsolve maximize 21*x + 11*y;\n\nvar int: x;\nvar int: y;\nconstraint 7*x + 4*y <= 13;\nconstraint x >= 0 /\\ y >= 0; \n\n\n\nModel 5 : \n\n\nsolve maximize 8*x + 5*y;\n\nvar int: x;\nvar int: y;\nconstraint x + y <= 6;\nconstraint 9*x + 5*y <= 45;\nconstraint x >= 0 /\\ y >= 0; \n\n                    ======\n                    Description:\n                    ---------\n                    The problem is a classic Linear Programming (LP) problem, specifically a Resource Allocation problem.\n\n**Description:**\nThe problem involves allocating resources to different activities or products to maximize profit or minimize cost, while satisfying certain constraints. In this case, we have three variables, B, C, and D, which represent the quantities of three different products or activities.\n\n**Decision Variables:**\nThe decision variables are B, C, and D, which represent the quantities of the three products or activities. These variables can take on non-negative values, indicating the amount of each product or activity to allocate.\n\n**Key Constraints:**\nThe constraints can be described as follows:\n\n* The total amount of resources used by the three products or activities cannot exceed certain limits (e.g., 30, 25, and 20 units).\n* Each product or activity has a specific resource requirement, and the total resource usage must not exceed the available resources.\n\n**Objective:**\nThe objective is to maximize the total profit or value obtained from the allocation of resources to the three products or activities. The profit or value is calculated as a linear combination of the quantities of each product or activity, with different coefficients (e.g., 3, 1, and 3) representing the profit or value per unit of each product or activity.\n\nIn summary, the problem involves finding the optimal allocation of resources to three products or activities to maximize profit or value, while satisfying resource constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2751, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7725bcc1-a254-493d-adad-3fb35071b461": {"__data__": {"id_": "7725bcc1-a254-493d-adad-3fb35071b461", "embedding": null, "metadata": {"model_name": "missing_solution"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "missing_solution_medium", "node_type": "4", "metadata": {"model_name": "missing_solution"}, "hash": "7bb4d3447e9072db52bb0403979c9544b5aeff70569def1b63d933ec28c81714", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % Missing Solutions\nint: n; % no of people\nset of int: PERSON = 1..n;\nint: male = 1; int: female = 2;\nset of int: GENDER = male..female;\narray[PERSON] of GENDER: gender;\narray[PERSON] of int: age;\n\narray[1..n] of var PERSON: order;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(order);\n\n% males and females alternate\nconstraint forall(i in 1..n)\n                 (i mod 2 = 0 <-> gender[order[i]] = female);\n\n% age does not grow bu more than 10\nconstraint forall(i in 1..n-1)\n                 (age[order[i+1]] - age[order[i]] <= 10);\n\nsolve satisfy;\n\noutput [ show(order), \"\\n\"] ++\n       [\"[\"] ++ [ show(age[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                | i in 1..n ] ++\n       [\"[\"] ++ [ show(gender[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                 | i in 1..n ];\n\n\n%n = 6;\n%gender = [male,male,male,female,female,female];\n%age = [13, 25, 34, 40, 16, 13];\n\nn = 5;\ngender = [male,male,female,female,female];\nage = [13,25,34,40,16];\n\n%order = [4,2,3,1,5];\n\n                    ======\n                    Description:\n                    ---------\n                    The Social Golfer Problem.\n\nThis problem is about arranging a group of people, with different genders and ages, into a sequence or order, subject to certain constraints.\n\nThe main decision variables are:\n\n* `order`: an array of variables representing the sequence of people.\n* `gender`: an array of constants representing the gender of each person (male or female).\n* `age`: an array of constants representing the age of each person.\n\nThe key constraints are:\n\n* The sequence of people must be a permutation of the original group (i.e., each person appears exactly once).\n* Males and females must alternate in the sequence.\n* The age difference between consecutive people in the sequence cannot exceed 10 years.\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function. In other words, the goal is to find a valid sequence of people that meets the given constraints.\n\nIn this specific model, the problem is formulated as a satisfaction problem, where the goal is to find a solution that satisfies all the constraints, without any optimization objective.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2318, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1e425c9e-9938-4587-8c9d-ad1840abecaa": {"__data__": {"id_": "1e425c9e-9938-4587-8c9d-ad1840abecaa", "embedding": null, "metadata": {"model_name": "nonogram_create_automaton2"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "nonogram_create_automaton2_medium", "node_type": "4", "metadata": {"model_name": "nonogram_create_automaton2"}, "hash": "689f0391e0b82a75ecbe2fd7e40a89e05d7d5d21410cf4654fe1710ac0d75844", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n% Nonoram solver using regular and is written in all-MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: rows;\nint: row_rule_len;\narray[1..rows, 1..row_rule_len] of int: row_rules;\nint: cols;\nint: col_rule_len;\narray[1..cols, 1..col_rule_len] of int: col_rules;\n\n\narray[1..rows, 1..cols] of var 1..2: x;\n\nsolve :: int_search(\n     [x[i,j] | j in 1..cols, i in 1..rows], \n     first_fail, \n     indomain_min, \n     complete) \nsatisfy;\n\n%\n% The approach is rather simple:\n%  - zero_positions is a set of the positions in the state table where the \n%    state 0 should be, which also correspond to the state of the pattern \"0\"\n%  - when this have been identified everything else comes to rest\n%\n% On the other hand, the calculation of the states is hairy, very hairy.\n%\npredicate make_automaton(array[int] of var int: x, array[int] of int: pattern) =\n    let {\n        int: n = length(pattern),\n        % fix for \"zero clues\"\n        int: len = max(length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern),1),\n        int: leading_zeros = sum(i in 1..n) (bool2int(pattern[i] = 0)),\n        set of int: zero_positions = {sum(j in 1..i) (pattern[j]+1) -leading_zeros | i in 1..n where pattern[i] > 0},\n       array[1..2*len] of 0..len*2: states = \n     if (length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern)) = 0 then \n       [1,1]  % fix for \"zero clues\"\n     else \n    [1, 2] ++\n    [\n       if i div 2 in zero_positions then\n           if i mod 2 = 0 then\n            0\n           else\n            (i div 2) + 1\n           endif\n       elseif (i-1) div 2 in zero_positions then\n           if i mod 2 = 0 then\n            (i div 2)+1\n           else\n            (i div 2)+2\n           endif\n       else\n         if not( (((i-1) div 2) - 1) in zero_positions) then\n            if i mod 2 = 0 then\n               (i div 2) + 1\n            else \n              if (i div 2) + 1 in zero_positions then\n                  (i div 2) + 2\n              else \n                  0\n              endif\n            endif\n          else\n             if i mod 2 = 0 then\n                 (i div 2) + 1\n             else \n                if not((i div 2) + 1 in zero_positions) then\n                   0\n                else \n                   (i div 2) + 2 \n                endif\n             endif\n          endif\n       endif\n    | i in 3..2*(len-1)]\n    ++\n    [len, 0]\n    endif\n    } \n    in\n    regular(\n       x,\n       len, \n       2, \n       array2d(1..len, 1..2, states),\n       1, \n       {len}) % :: domain\n;\n\nconstraint\n\n      forall(j in 1..cols) (\n        make_automaton([x[i,j] | i in 1..rows], [col_rules[j,k] | k in 1..col_rule_len])\n      )\n      /\\\n      forall(i in 1..rows) (\n        make_automaton([x[i,j] | j in 1..cols], [row_rules[i,k] | k in 1..row_rule_len])\n      )\n\n;\n\noutput \n[\n  if j = 1 then \"\\n\" else \"\" endif ++\n     if fix(x[i,j]) = 1 then \" \" else \"#\" endif\n    \n  | i in 1..rows, j in 1..cols\n] \n++ \n[\n  \"\\n\"\n];\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\nint: X;\nint: Y;\n\nint: maxlen;\n\narray [1..Y,1..maxlen] of int: rows;\n\narray [1..X,1..maxlen] of int: cols;\n\narray[1..2, 1..2, 1..2] of 0..1: nonmul = \n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 1, 1,\n         1, 0, 0, 1]\n    );\n\narray[1..2, 1..2, 1..2] of 0..1: nonadd =\n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 0, 1,\n         1, 0, 0, 1]\n    );\n\n% variables\n%\narray[1..Y, 1..X] of var 1..2: A;\n\n% All variables in a region must be different\n% Ordering to ensure each variable is handled exactly once\npredicate nonogram_row(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: row) =\n    nonogram([A[row, v] | v in 1..X], cons);\n\npredicate nonogram_col(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: col) = \n    nonogram([A[v,col] | v in 1..Y], cons);\n\npredicate nonogram(array[int] of var 1..2: A, array [int] of int: cons) = \n    let {\n          int: n = if cons[1] = 0 then 0 else max(index_set(cons)) endif,\n          array [1..n + 1, 1..2] of int: consarr =\n              if cons[1] = 0 then [|1, 0|] \n              else array2d(1..n + 1, 1..2,\n                [1, 2] ++\n                [    i * nonmul[cons[i - 1] + 1, cons[i] + 1, s] + \n                     nonadd[cons[i - 1] + 1, cons[i] + 1, s] \n                     | i in 2..n, s in 1..2 \n                ] ++ \n                [n+1,0]\n              )\n              endif\n     } in (\n         regular(A, n + 1, 2, consarr, 1, {n + 1})\n     );\n\nconstraint forall(i in 1..Y) (\n    nonogram_row(A, [rows[i, j] | j in 1..maxlen where rows[i, j] >= 0], i)\n);\n\nconstraint forall(i in 1..X) (\n    nonogram_col(A, [cols[i, j] | j in 1..maxlen where cols[i, j] >= 0], i)\n);\n\nsolve :: int_search(array1d(1..X*Y,A),input_order,indomain_max,complete) satisfy;\n\noutput [\n    if fix(A[r, c]) = 1 then \" \" else \".\" endif ++ \n    if c = Y then \"\\n\" else \" \" endif\n    | r in 1..X, c in 1..Y\n];\n                    ======\n                    Description:\n                    ---------\n                    The problem is called the Nonogram problem.\n\nThe Nonogram problem is a classic constraint programming problem that involves solving a puzzle where a set of clues are given to determine the state of a grid. The grid is divided into rows and columns, and each row and column has a set of clues that specify the pattern of states in that row or column. The goal is to determine the state of each cell in the grid such that the clues are satisfied.\n\nThe main decision variables in this problem are the states of each cell in the grid, which are represented by the `x` or `A` arrays in the models. These variables can take on two values, typically 0 and 1, or \" \" and \"#\", which represent the two possible states of a cell.\n\nThe key constraints in this problem are the clues, which are specified by the `row_rules` and `col_rules` arrays in the models. These clues specify the pattern of states in each row and column, and the constraints ensure that the states of the cells in each row and column satisfy these patterns.\n\nThe objective of the problem is to find a solution that satisfies all the clues, and there is no explicit objective function to minimize or maximize.\n\nIn simpler terms, the Nonogram problem is like solving a puzzle where you have to figure out the state of each cell in a grid based on clues about the patterns of states in each row and column. The clues are like hints that help you determine the solution, and the goal is to find a solution that satisfies all the clues.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 6585, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "734342bc-864f-4eca-83e6-ae23ca1c845a": {"__data__": {"id_": "734342bc-864f-4eca-83e6-ae23ca1c845a", "embedding": null, "metadata": {"model_name": "nurses"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "nurses_medium", "node_type": "4", "metadata": {"model_name": "nurses"}, "hash": "51aa8780dec6507ef4be075804242a0dcda53168c713a7d52398fab348b443b4", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 : \n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint forall(d in DAY)\n                 (global_cardinality_low_up([x[n,d] | n in NURSE ],                                               [ day, night ], [ o, l ], [o, u])); \n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n\n\nModel 2 :\n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\nconstraint forall(d in DAY)\n                 (let {var int: on = sum(n in NURSE)\n                                        (bool2int(x[n,d]=night))        \n                      } in l <= on /\\ on <= u);\n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n\n                    ======\n                    Description:\n                    ---------\n                    **Nurse Rostering Problem**\n\nThe Nurse Rostering Problem is a classic constraint programming problem that involves creating a schedule for a set of nurses to work on different days and shifts.\n\n**Decision Variables:**\n\nThe main decision variables in this problem are the assignments of nurses to shifts on different days, represented by a 2D array `x` where `x[n,d]` represents the shift assigned to nurse `n` on day `d`. The shifts can be one of three types: day, night, or day off.\n\n**Key Constraints:**\n\n1. **Consecutive Night Shifts:** A nurse cannot work two consecutive night shifts without a day off in between.\n2. **Night Shift Followed by Day Off:** If a nurse works a night shift, they cannot work a day shift the next day.\n3. **Shift Coverage:** The number of nurses working night shifts on each day must be within a specified range (lower bound `l` and upper bound `u`).\n4. **Day Shift Coverage:** The number of nurses working day shifts on each day must be at least `o`.\n\n**Objective:**\n\nThe objective of the problem is to find a feasible schedule that satisfies all the constraints, rather than optimizing a specific objective function. The goal is to assign shifts to nurses in a way that meets the requirements and rules of the problem.\n\nIn summary, the Nurse Rostering Problem involves creating a schedule for nurses to work on different days and shifts, subject to constraints on consecutive night shifts, shift coverage, and day shift coverage. The problem is typically solved using constraint programming techniques, and the goal is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3690, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "431c391f-5e56-4a7d-b6d8-4f6a1c2a597e": {"__data__": {"id_": "431c391f-5e56-4a7d-b6d8-4f6a1c2a597e", "embedding": null, "metadata": {"model_name": "opd"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "opd_medium", "node_type": "4", "metadata": {"model_name": "opd"}, "hash": "345e3e00a0036f816359804d7c48a227150e11df27631c5e261a5d40319b6a59", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    %% Design of Collateralised Debt Obligations Squared (CDO^2) Transactions\n% An OPD (v, b, r) problem is to find a binary matrix of v rows\n% and b columns such that each row sums to r, and\n% the dot product beween any pair of distinct rows is minimal.\n\n%Requires MiniZinc >= 2.0.2 for the symmetry_breaking_constraint predicate\n\ninclude \"lex_greatereq.mzn\";\n\n%instance data\nint: v;\nint: b;\nint: r;\n\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\n\n%computing a lower bound for lambda\nint: rv = r*v;\nint: rvmodb = rv mod b;\nint: floorrv = rv div b;\nint: ceilrv = rv div b + bool2int(rv mod b != 0);\nint: num = (ceilrv*ceilrv*rvmodb+floorrv*floorrv*(b-rvmodb)-rv);\nint: denom = v*(v-1);\nint: lb_lambda = num div denom + bool2int( num mod denom !=0);\n\n% This line is there for debugging purposes, it can be safely removed\nint: tmp = trace(\"Computed lower bound for lambda: \"++show(lb_lambda)++\"\\n\",lb_lambda);\n\n\n% lambda is called objective for the MiniZinc Challenge\nvar lb_lambda..b: objective;\n\n\narray [rows, cols] of var 0..1: m;\n\n\n% Every row must sum to r.\nconstraint forall (i in rows) (sum (j in cols) (m[i, j]) = r);\n\n% The dot product of every pair of distinct rows must be at most lambda for an OPD and a PD, and equal to lambda for a BIBD\nconstraint forall (i_a, i_b in rows where i_a < i_b) (\n    sum (j in cols) (m[i_a, j] * m[i_b, j]) <= objective\n);\n\n\n% Break row symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(i in rows diff {max(rows)})(\n        lex_greatereq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    )\n);\n% Break column symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(j in cols diff {max(cols)})(\n        lex_greatereq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    )\n);\n\n\nsolve \n    :: seq_search([int_search([m[i, j] | i in rows, j in cols], input_order, indomain_max, complete),\n       \t\t   int_search([objective], input_order,indomain_min,complete)])\n    minimize objective; \n\n\n% Disabled the full solution. Printing only the objective value, lower bound, and parameters.\noutput  [\"opd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r), \"). Found lambda = \", show(objective),\"\\tlb: \", show(lb_lambda)]\n%       ++[\"\\n\\n\"] ++ \n%\t[ ( if j > b then \"\\n\" else \n%\t        if fix(m[i,j])=1 then \"*\" else \" \" endif\n%\t    endif )\n%       | i in rows, j in 1..(b + 1) ]\n;\n                    ======\n                    Description:\n                    ---------\n                    **Orthogonal Pairs of Designs (OPD) Problem**\n\nThe OPD problem is a classic constraint programming problem that involves designing a binary matrix with specific properties.\n\n**Problem Description**\n\nGiven three integers `v`, `b`, and `r`, the goal is to find a binary matrix `m` with `v` rows and `b` columns, where each row sums to `r`. The matrix should be designed such that the dot product between any pair of distinct rows is minimal.\n\n**Decision Variables**\n\nThe main decision variables are the elements of the binary matrix `m`, where `m[i, j]` represents the value (0 or 1) at row `i` and column `j`.\n\n**Key Constraints**\n\n1. **Row Sum Constraint**: Each row of the matrix must sum to `r`.\n2. **Dot Product Constraint**: The dot product between any pair of distinct rows must be less than or equal to a minimum value, represented by the variable `objective`.\n3. **Symmetry Breaking Constraints**: These constraints are used to break the symmetry of the matrix, ensuring that the solution is unique and not duplicated.\n\n**Objective**\n\nThe objective of the problem is to minimize the dot product between any pair of distinct rows, represented by the variable `objective`. This is equivalent to finding the minimum value of lambda (\u03bb) that satisfies the dot product constraint.\n\nIn summary, the OPD problem involves designing a binary matrix with specific properties, where each row sums to a fixed value, and the dot product between any pair of distinct rows is minimal. The goal is to find the minimum value of lambda that satisfies these constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4111, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f5b53da2-946f-47af-aec7-62d51bf2cf0f": {"__data__": {"id_": "f5b53da2-946f-47af-aec7-62d51bf2cf0f", "embedding": null, "metadata": {"model_name": "partition"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "partition_medium", "node_type": "4", "metadata": {"model_name": "partition"}, "hash": "563247862ea64a3112505f5861ef6b3f84e91a92026857b11a97107b6c2f9a8b", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 : \n\n% Partitioning problem\n% Partition 2*n numbers into two groups, each of size n, such that\n% their sums are equal and the sums of their squares are equal.\n\ninclude \"globals.mzn\";\n\n% Instance\n\nn = 32;\n\n% Model\n\nint: n;\n\narray[1..n] of var 1..2*n: x;\narray[1..n] of var 1..2*n: y;\n\nconstraint true\n    %   Break symmetries by ordering numbers in each group\n    /\\  forall (i in 2..n) (x[i-1] < x[i] /\\ y[i-1] < y[i])\n    %   Break symmetries by ordering the groups\n    /\\  x[1] < y[1]\n    \n    %   Partition the numbers\n    /\\  (alldifferent(x++y)) :: bounds\n    \n    %   The sums are equal\n    /\\  sum (x) = 2*n*(2*n+1) div 4\n    /\\  sum (y) = 2*n*(2*n+1) div 4\n    \n    %   The sums of the squares are equal\n    /\\  let {\n            array[1..n] of var 1..4*n*n: sx,\n            array[1..n] of var 1..4*n*n: sy\n        } in\n        forall (i in 1..n) (sx[i]=x[i]*x[i] /\\ sy[i] = y[i]*y[i])\n    /\\  sum (sx) = 2*n*(2*n+1)*(4*n+1) div 12\n    /\\  sum (sy) = 2*n*(2*n+1)*(4*n+1) div 12\n;\n\nsolve ::int_search(x++y,first_fail,indomain_min,complete) satisfy;\n\noutput\n    [\"x = \",show(x),\"\\n\",\"y = \",show(y),\"\\n\",\n     \"sum = \",show(2*n*(2*n+1) div 4),\"\\n\",\n     \"sum of squares = \", show(2*n*(2*n+1)*(4*n+1) div 12), \"\\n\"\n     ];\n\n\n\nModel 2 :\n\n\n\n%\n% Set partition problem in Minizinc.\n%\n%  This is a partition problem.\n%  Given the set S = {1, 2, ..., n},\n%  it consists in finding two sets A and B such that:\n%  <ul>\n%  <li>A U B = S,</li>\n%  <li>|A| = |B|,</li>\n%  <li>sum(A) = sum(B),</li>\n%  <li>sum_squares(A) = sum_squares(B).</li>\n%  </ul>\n \n%\ninclude \"globals.mzn\";\n \nint: n = 16;\nset of 1..n: S = 1..n;\nint: num_sets = 2;\narray[1..num_sets] of var set of S: a;\narray[1..num_sets] of var 0..n*n: sums;\narray[1..num_sets] of var 0..n*n*n*n: sum_squared;\n \n \n%\n% set_sum\n% sums the elements in the set s\n%\npredicate set_sum(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i)\n;\n \npredicate set_sum_squared(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i*i)\n;\n \n \nsolve :: set_search(a, first_fail, indomain_min, complete) satisfy;\n% solve maximize sums[1];\n \nconstraint\n  assert(n mod 4 == 0, \"n must be a multiple of 4\")\n;\n \nconstraint\n   % use all the elements in S and it should be disjoint sets\n   partition_set(a, S)\n   /\\\n   forall(i in 1..num_sets) (  \n     a[i] `set_sum` sums[i]\n     /\\ a[i] `set_sum_squared` sum_squared[i]\n   )\n   /\\\n   forall(i in 2..num_sets) (\n     card(a[i]) > 0 /\\ % this is needed by eclipse\n     card(a[i]) = card(a[i-1]) /\\\n     sums[i] = sums[i-1]\n     /\\ sum_squared[i] = sum_squared[i-1]\n   )\n \n  % symmetry breaking\n  /\\ 1 in a[1]\n \n;\n \noutput [\n   \"a: \" ++ show(a) ++ \"\\n\" ++\n   \"sums: \" ++ show(sums) ++ \"\\n\" ++\n   \"sum_squared: \" ++ show(sum_squared) ++ \"\\n\"\n];\n \n% For model seeker\n% output [\n%    show(set2array(fix(a[i]))) ++ \",\"\n%   | i in 1..num_sets\n% ];\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the Partition Problem.\n\nThis problem is about dividing a set of 2n numbers into two groups, each of size n, such that the sums of the numbers in each group are equal, and the sums of the squares of the numbers in each group are also equal.\n\nThe main decision variables are x and y, which represent the two groups of numbers. Each element of x and y is a variable that takes a value from 1 to 2n, representing the numbers in each group.\n\nThe key constraints are:\n\n* Each group must contain n numbers, and all numbers from 1 to 2n must be used exactly once.\n* The sums of the numbers in each group must be equal.\n* The sums of the squares of the numbers in each group must be equal.\n* To break symmetries, the numbers in each group are ordered, and the groups themselves are also ordered.\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints.\n\nNote that the problem does not have an objective function to minimize or maximize, it is a satisfaction problem where the goal is to find a solution that meets all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4150, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c61099b8-0c95-4b0f-9ec0-c70318a5a483": {"__data__": {"id_": "c61099b8-0c95-4b0f-9ec0-c70318a5a483", "embedding": null, "metadata": {"model_name": "photo"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "photo_medium", "node_type": "4", "metadata": {"model_name": "photo"}, "hash": "745d0eee2e94e5dea32c9e9b109305038ec28a4d9589fea62f92b6af90f3fb37", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    int:n ;\nset of int: PERSON = 1..n;\nset of int: POS = 1..n;\narray[PERSON,PERSON] of int: friend;\n\n%array[PERSON] of var POS: x;\narray[POS] of var PERSON: y;\n\n%include \"inverse.mzn\";\n%constraint inverse(x,y);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\n%constraint alldifferent(x);\n\n%y[i] = sum(j in 1..n)(bool2int(x[j] = i) * j);\n\nsolve maximize sum(i in 1..n-1)(friend[y[i],y[i+1]]);\n\n\n                    ======\n                    Description:\n                    ---------\n                    Social Golfer Problem.\n\nThe Social Golfer Problem is a classic constraint programming problem that involves scheduling golf games for a group of golfers over a series of weeks. The goal is to create a schedule that maximizes the social interaction among the golfers.\n\nThe main decision variables in this problem are `x` and `y`. `x` represents the assignment of golfers to positions in each game, while `y` represents the assignment of positions to golfers. In other words, `x[i]` represents the position of golfer `i`, and `y[j]` represents the golfer assigned to position `j`.\n\nThe key constraints in this problem are:\n\n* Each golfer must be assigned a unique position in each game (alldifferent constraint on `y`).\n* Each position in each game must be assigned to a unique golfer (inverse constraint between `x` and `y`).\n* The objective is to maximize the total number of friendships between golfers playing together in consecutive games.\n\nThe problem's objective is to maximize the sum of friendships between golfers playing together in consecutive games. This is achieved by summing up the friendships between golfers `y[i]` and `y[i+1]` for each game `i`. The `friend` array represents the friendships between golfers, where `friend[i, j]` is 1 if golfers `i` and `j` are friends, and 0 otherwise.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1874, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "92170cef-c48d-4b0f-b77c-70b0f217fec6": {"__data__": {"id_": "92170cef-c48d-4b0f-b77c-70b0f217fec6", "embedding": null, "metadata": {"model_name": "project_scheduling"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "project_scheduling_medium", "node_type": "4", "metadata": {"model_name": "project_scheduling"}, "hash": "431a0ee9f10c2e9de4bac0f456973e676912b79149b06394338d2c37ef688f45", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\nconstraint forall(i in PREC)\n                 (start[pre[i,1]] + duration[pre[i,1]] <= start[pre[i,2]]);\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n\n\n\nModel 2 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\npredicate precedes(var int:s1, var int:d1, var int:s2)=\n          s1 + d1 <= s2; \n\nconstraint forall(i in PREC)\n                 (precedes(start[pre[i,1]],duration[pre[i,1]],start[pre[i,2]]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nset of TASK: CARPENTRY = { interior_walls, exterior_walls, roof };\nconstraint forall(t1, t2 in CARPENTRY where t1 < t2)\n      (nonoverlap(start[t1],duration[t1],start[t2],duration[t2]));\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n\n                    ======\n                    Description:\n                    ---------\n                    The problem is called the \"Resource-Constrained Project Scheduling Problem\" (RCPSP).\n\nThis problem is about scheduling a set of tasks with given durations and precedence constraints, where some tasks cannot start until others are finished. The goal is to find a schedule that minimizes the total duration of the project, also known as the \"makespan\".\n\nThe main decision variables are the start times of each task, represented by the `start` array. Each element `start[t]` represents the start time of task `t`.\n\nThe key constraints are:\n\n* Precedence constraints: each task can only start after its predecessors have finished. For example, the task \"interior walls\" cannot start until the task \"foundations\" has finished.\n* Non-overlap constraints: certain tasks, such as carpentry tasks, cannot overlap with each other. For example, the tasks \"interior walls\" and \"exterior walls\" cannot be performed at the same time.\n\nThe objective is to minimize the makespan, which is the maximum finish time of all tasks. In other words, the goal is to complete the project as quickly as possible.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3428, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e5657726-7cac-48ef-add0-74b048554e58": {"__data__": {"id_": "e5657726-7cac-48ef-add0-74b048554e58", "embedding": null, "metadata": {"model_name": "QuasigroupCompletion"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasigroupCompletion_medium", "node_type": "4", "metadata": {"model_name": "QuasigroupCompletion"}, "hash": "703640cf28aac12efa85aecb6f1268aa3b7d71fac9c6688123b59f19eb9916bb", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n% Quasigroup with Holes (aka Latin Square Completion)\n\ninclude \"alldifferent.mzn\";\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n\narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N] of var PuzzleRange: puzzle;\n\n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j] = start[i,j] else true endif );\n\n% All different in rows\nconstraint forall (i in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | j in PuzzleRange ] ) );\n\n% All different in columns.\nconstraint forall (j in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | i in PuzzleRange ] ) );\n\nsolve satisfy;\n\noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n \narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N, 1..N] of var 0..1: puzzle;\n \n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j, start[i,j]] = 1 else true endif );\n \n% All different in rows\nconstraint forall (i,k in PuzzleRange) (\n        sum(j in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% All different in columns\nconstraint forall (j,k in PuzzleRange) (\n        sum(i in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% Each cell must have a number assigned\nconstraint forall (i,j in PuzzleRange) (\n        sum(k in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\nsolve satisfy;\n \noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the Quasigroup with Holes or Latin Square Completion problem.\n\nThis problem is about completing a partially filled N x N grid with numbers from 1 to N, such that each row, column, and cell contains each number exactly once. The grid may have some initial values already filled in, and the goal is to fill in the remaining empty cells to satisfy the constraints.\n\nThe main decision variables in this problem are the `puzzle` variables, which represent the values to be assigned to each cell in the grid.\n\nThe key constraints in this problem are:\n\n* Each row must contain each number from 1 to N exactly once.\n* Each column must contain each number from 1 to N exactly once.\n* Each cell must contain exactly one number from 1 to N.\n* The initial values in the grid must be preserved.\n\nThe objective of this problem is to find a solution that satisfies all the constraints, rather than minimizing or maximizing a specific objective function. The `solve satisfy` statement in the model indicates that the goal is to find a feasible solution that meets all the constraints.\n\nIn essence, the Quasigroup with Holes problem is a classic constraint satisfaction problem that requires finding a solution that satisfies a set of constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3239, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1ed6abe4-0c61-4c7c-9895-8448198d4552": {"__data__": {"id_": "1ed6abe4-0c61-4c7c-9895-8448198d4552", "embedding": null, "metadata": {"model_name": "QuasiGroupExistence"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasiGroupExistence_medium", "node_type": "4", "metadata": {"model_name": "QuasiGroupExistence"}, "hash": "db85db73bd3ff38111418809e4a162429b169f8f49fc8fc586ad41514baf36ce", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n\n% Quasigroup problem in MiniZinc.\n% The quasiGroup existence problem\n% An m order quasigroup  is an mxm multiplication table of integers 1..m,\n% where each element occurrs exactly once in each row and column and certain\n% multiplication axioms hold (in this case, we want axiom 7 to hold).\n%\n% QG7.m problems are order m quasigroups for which (b*a)*b = a*(b*a).\n\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n% solve satisfy;\n \nconstraint\n      \n     % assign the \"reflected\" quasigroup to qGColumns to access its columns\n     %  forall row,col : nDomain .\n     %    quasiGroupColumns[col,row] = quasiGroup[row,col],\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % all values in the diagonals\n     forall( i in nDomain ) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n \n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row, col] | row in nDomain])\n     )\n     /\\\n \n     % this strange constraint\n     % corresponds to:\n     % quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i], j] \n     forall(i,j in nDomain) (\n              quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i],j]\n     )\n     /\\\n     % some implied? constraint\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n%\n% data\n%\nn = 5;\n\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 9; % solutions for n=5, n=9...\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n \nint: n = 4;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n \n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (i != j) ->\n         (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n \n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n \n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\n\nModel 4 :\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n \n     % Idempotency\n     % forall i : nDomain .\n     %     (quasiGroup[i,i] = i),\n \n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     % allDifferent(qgDiagonal) %,\n \n     % anti-Abelian\n     % forall i : nDomain .\n     %   forall j : nDomain .\n     %     (i != j) =>\n     %     (quasiGroup[i,j] != quasiGroup[j,i]),\n \n     % if (i*i)=j then (j*j) = i\n     % forall i : nDomain .\n     %  forall j : nDomain .\n     %    (quasiGroup[i,i]=j) => (quasiGroup[j,j]=i),\n \n \n     % Symmetry-breaking constraints   \n     % forall i : nDomain .\n     %      quasiGroup[i,n-1] + 2 >= i\n \n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n \n \n%\n% data\n%\nn = 4; % 4 works\n\n\nModel 5 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 6 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 5;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 7 :\n\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n                    ======\n                    Description:\n                    ---------\n                    The problem represented by these Minizinc models is the Quasigroup Existence Problem, also known as the Quasigroup Completion Problem.\n\nThe Quasigroup Existence Problem is a classic constraint satisfaction problem that involves finding a multiplication table for a quasigroup of a given order. A quasigroup is a mathematical structure that satisfies certain properties, similar to a group, but without the requirement of associativity.\n\nIn this problem, we are given an integer `n`, and we need to find an `n x n` multiplication table, represented by the `quasiGroup` array, such that each element in the table is an integer between 0 and `n-1`. The table must satisfy certain constraints, which are:\n\n* Each row and column must contain each integer between 0 and `n-1` exactly once (i.e., all rows and columns must be different).\n* The table must satisfy certain multiplication axioms, such as `(b*a)*b = a*(b*a)` or `(j*i)*(i*j) = i`.\n* The table must also satisfy some implied constraints, such as idempotency (i.e., `quasiGroup[i,i] = i`) and anti-Abelian properties (i.e., `quasiGroup[i,j] != quasiGroup[j,i]` for `i != j`).\n\nThe decision variables in this problem are the elements of the `quasiGroup` array, which represent the multiplication table.\n\nThe objective of this problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.\n\nThe problem is challenging because the constraints are complex and interconnected, making it difficult to find a solution that satisfies all of them. The Quasigroup Existence Problem has applications in various fields, including combinatorics, algebra, and computer science.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 12819, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7c45ec2b-dbc4-4a32-aeb8-9ca7fb2b7fa2": {"__data__": {"id_": "7c45ec2b-dbc4-4a32-aeb8-9ca7fb2b7fa2", "embedding": null, "metadata": {"model_name": "queens"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "queens_medium", "node_type": "4", "metadata": {"model_name": "queens"}, "hash": "dfb9e75c68b56675eb82deda9db733904937e40d81593896eb23c211bc57f113", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n% n queens problem in MiniZinc.\n\ninclude \"globals.mzn\";\n\nint: n;\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail, \n        indomain_min, \n        complete) \n    satisfy;\n\n% solve satisfy;\n\nconstraint all_different(queens);\n\nconstraint\n    forall(i, j in 1..n where i < j) (\n         queens[i] != queens[j] /\\\n         queens[i] + i != queens[j] + j /\\\n         queens[i] - i != queens[j] - j\n    ) \n ;\n\noutput [\n  show(queens) ++ \"\\n\"\n\n];\n\n% data\nn = 8;\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n;\n\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail,\n        indomain_median,\n        complete\n       )\n     satisfy;\n\n% solve satisfy;\nconstraint all_different(queens); %  :: domain;\nconstraint all_different([queens[i]+i | i in 1..n]) :: domain;\nconstraint all_different([queens[i]-i | i in 1..n]) :: domain;\n\noutput \n[\n  \"queens: \" ++ show(queens)\n] ++ \n% [\n%   if j = 1 then \"\\n\" else \"\" endif ++\n%      if fix(queens[i]) = j then          \n%         show_int(2,j)\n%      else\n%         \"__\"\n%      endif\n%   | i in 1..n, j in 1..n\n% ] ++\n[\"\\n\"]\n;\n\n% data\nn = 8;\n\n\nModel 3 :\n\n\n\nint: n;                                 % The number of queens.\n\narray [1..n] of var 1..n: q;\n\ninclude \"alldifferent.mzn\";\n\nconstraint alldifferent(q);\nconstraint alldifferent(i in 1..n)(q[i] + i);\nconstraint alldifferent(i in 1..n)(q[i] - i);\n\n\nsolve \n%      :: int_search(q, input_order, indomain_min, complete) \n%      :: int_search(q, first_fail, indomain_min, complete) \n%      :: int_search(q, smallest, indomain_min, complete)\n%      :: int_search(q, largest, indomain_min, complete)\n%      :: int_search(q, input_order, indomain_max, complete) \n%      :: int_search(q, first_fail, indomain_max, complete) \n%      :: int_search(q, smallest, indomain_max, complete)\n%      :: int_search(q, largest, indomain_max, complete)\n%      :: int_search(q, input_order, indomain_median, complete) \n%      :: int_search(q, first_fail, indomain_median, complete) \n%      :: int_search(q, smallest, indomain_median, complete)\n%      :: int_search(q, largest, indomain_median, complete)\n%      :: int_search(q, input_order, indomain_random, complete) \n%      :: int_search(q, first_fail, indomain_random, complete) \n%      :: int_search(q, smallest, indomain_random, complete)\n%      :: int_search(q, largest, indomain_random, complete)\n      satisfy;\n\n%output\t\n%%\t[\tif fix(q[i]) = j then \"Q \" else \". \" endif ++\n%\t \tif j = n then \"\\n\" else \"\" endif\n%\t|\ti, j in 1..n\n%\t];\n\n                    ======\n                    Description:\n                    ---------\n                    The problem is the N-Queens Problem.\n\nThe N-Queens Problem is a classic constraint satisfaction problem where we need to place N queens on an NxN chessboard such that no queen attacks another queen. A queen can attack another queen if they are in the same row, column, or diagonal.\n\nThe main decision variables in this problem are the positions of the queens on the chessboard, represented by the array `queens` of size N, where `queens[i]` represents the column number of the queen in the i-th row.\n\nThe key constraints in this problem are:\n\n* Each queen must be placed in a different column (ensured by the `all_different` constraint).\n* No two queens can be in the same diagonal (ensured by the constraints `queens[i] + i != queens[j] + j` and `queens[i] - i != queens[j] - j`).\n\nThe objective of this problem is to find a feasible solution that satisfies all the constraints, i.e., to find a way to place N queens on an NxN chessboard such that no queen attacks another queen.\n\nNote that there is no objective function to minimize or maximize in this problem, as the goal is simply to find a feasible solution.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3826, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1f8ca28d-8abc-431a-b176-62d717e7b559": {"__data__": {"id_": "1f8ca28d-8abc-431a-b176-62d717e7b559", "embedding": null, "metadata": {"model_name": "rcpsp"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rcpsp_medium", "node_type": "4", "metadata": {"model_name": "rcpsp"}, "hash": "d309de77cf05432241b00f15555bedebd4709101c5bbcfdbaeca48b7f99d3514", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    int: n; % number of tasks\nset of int: TASK = 1..n;\narray[TASK] of int: d; % duration\n\nint: m; % number of resources\nset of int: RESOURCE = 1..m;\narray[RESOURCE] of int: L; % resource limit\narray[RESOURCE,TASK] of int: res; % usage\n\nint: l; % number of precedences\nset of int: PREC = 1..l;\narray[PREC,1..2] of TASK: pre; % predecessor/successor pairs\n\nint: maxt; % maximum time\nset of int: TIME = 0..maxt;\n\narray[TASK] of var TIME: s; % start time\n\nconstraint forall(p in PREC)(s[pre[p,1]]+d[pre[p,1]] <= s[pre[p,2]]);\n\ninclude \"cumulative.mzn\";\nconstraint forall(r in RESOURCE)\n                 (cumulative(s,d,[res[r,t]|t in TASK],L[r]));\n%constraint forall(r in RESOURCE) \n%                 ( let { array[int] of var int: ss = \n%                              [ s[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: dd = \n%                              [ d[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: rr = \n%                              [ res[r,t] | t in TASK where res[r,t] > 0 ]; } in\n%                   cumulative(ss,dd,rr,L[r]));\n\nsolve minimize max(t in TASK)(s[t] + d[t]);\n\noutput [show(s)];\n\n\n\n                    ======\n                    Description:\n                    ---------\n                    Resource-Constrained Project Scheduling Problem (RCPSP)\n\nThe Resource-Constrained Project Scheduling Problem is a classic constraint programming problem that involves scheduling a set of tasks with given durations and resource requirements, subject to resource availability and precedence constraints.\n\nThe main decision variables in this problem are the start times of each task, represented by the array `s` of variables. Each `s[t]` represents the start time of task `t`.\n\nThe key constraints in this problem are:\n\n* Precedence constraints: Each task can only start after its predecessors have finished. This is ensured by the constraint `s[pre[p,1]] + d[pre[p,1]] <= s[pre[p,2]]`, which states that the start time of a task plus its duration must be less than or equal to the start time of its successor.\n* Resource constraints: The total resource usage of all tasks at any given time must not exceed the available resource limit. This is ensured by the cumulative constraint, which is implemented using the `cumulative` function from the `cumulative.mzn` library.\n\nThe objective of the problem is to minimize the maximum completion time of all tasks, which is equivalent to minimizing the project duration. This is achieved by minimizing the maximum value of `s[t] + d[t]` across all tasks `t`.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2649, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a97ff742-622d-470f-8ed9-5e0b619abbaa": {"__data__": {"id_": "a97ff742-622d-470f-8ed9-5e0b619abbaa", "embedding": null, "metadata": {"model_name": "rehearsal"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rehearsal_medium", "node_type": "4", "metadata": {"model_name": "rehearsal"}, "hash": "168fd95da485b05668f93a08de33b0a0f71896556da0d875bcf6fcbbe477376e", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    %\n% Scheduling a Rehearsal in MiniZinc.\n% A concert is to consist of nine pieces of music of different durations\n% each involving a different combination of the five members of the orchestra.\n% Players can arrive at rehearsals immediately before the first piece in which\n% they are involved and depart immediately after the last piece in which\n% they are involved. The problem is to devise an order in which the pieces\n% can be rehearsed so as to minimize the total time that players are waiting\n% to play, i.e. the total time when players are present but not currently\n% playing. In the table below, 1 means that the player is required for\n% the corresponding piece, 0 otherwise. The duration (i.e. rehearsal time)\n% is in some unspecified time units.\n%\n%    Piece       1    2   3    4    5  6    7   8    9\n%    Player 1    1    1   0    1    0  1    1   0    1\n%    Player 2    1    1   0    1    1  1    0   1    0\n%    Player 3    1    1   0    0    0  0    1   1    0\n%    Player 4    1    0   0    0    1  1    0   0    1\n%    Player 5    0    0   1    0    1  1    1   1    0\n%    Duration    2    4   1    3    3  2    5   7    6\n%\n% For example, if the nine pieces were rehearsed in numerical order as\n% given above, then the total waiting time would be:\n%       Player 1: 1+3+7=11\n%       Player 2: 1+5=6\n%       Player 3: 1+3+3+2=9\n%       Player 4: 4+1+3+5+7=20\n%       Player 5: 3\n% giving a total of 49 units. The optimal sequence, as we shall see,\n% is much better than this.\n%\n% ...\n%\n% The minimum waiting time for the rehearsal problem is 17 time units, and\n% an optimal sequence is 3, 8, 2, 7, 1, 6, 5, 4, 9.\n%\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \n\n\nint: num_pieces;\nint: num_players;\narray[1..num_pieces] of int: duration;\narray[1..num_players, 1..num_pieces] of 0..1: rehearsal;\n\n\n%\n% Decision variables\n%\narray[1..num_pieces] of var 1..num_pieces: rehearsal_order;\narray[1..num_players] of var 0..sum(duration): waiting_time; % waiting time for players\narray[1..num_players] of var 1..num_pieces: p_from; % first rehearsal\narray[1..num_players] of var 1..num_pieces: p_to;   % last rehearsal\nvar 0..sum(duration): total_waiting_time = sum(waiting_time); % objective\n\nsolve :: int_search(\n         rehearsal_order % ++ waiting_time% ++ p_from ++ p_to ++ [total_waiting_time]\n         , \n         first_fail, % occurrence, % max_regret, % first_fail, \n         indomain_max, % indomain_max, \n         complete) \n     minimize total_waiting_time;\n     % satisfy;\n\n% solve :: labelling_ff minimize total_waiting_time;\n\nconstraint\n  all_different(rehearsal_order) :: domain\n  /\\\n\n  % This solution is my own without glancing at Smith's models...\n  forall(p in 1..num_players) (\n     % This versions is much faster than using exists (see below)\n     % fix the range from..to, i.e. don't count all that start with 0 \n     % or ends with 0.\n     % This means that we collect the rehearsals with many 0 at the ends\n     %\n     p_from[p] < p_to[p]\n     /\\\n     % skipping rehearsal at start (don't come yet)\n     forall(i in 1..num_pieces) (\n        i < p_from[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\\n     % skipping rehearsal at end (go home after last rehearsal)\n     forall(i in 1..num_pieces) (\n        i > p_to[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\ % and now: count the waiting time for from..to\n     waiting_time[p] = \n         sum(i in 1..num_pieces) (\n              duration[rehearsal_order[i]] * bool2int(\n                                             i >= p_from[p] /\\ i <= p_to[p] \n                                             /\\\n                                             rehearsal[p,rehearsal_order[i]] = 0\n                                )\n     ) \n\n%      % alternative solution with exists. \n%      %  More elegant (= declarative) in my book but slower.\n%      exists(from, to in 1..num_pieces) ( \n%         % skipping rehearsal at start (don't come yet)\n%         forall(i in 1..from-1) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\\n%         % skipping rehearsal at end (go home after last rehearsal)\n%         forall(i in to+1..num_pieces) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\ % and now: count the waiting time for from..to\n%         waiting_time[p] = \n%             sum(i in from..to) (\n%                  duration[rehearsal_order[i]]*\n%                                  bool2int(\n%                                       rehearsal[p,rehearsal_order[i]] = 0\n%                                   )\n%          ) \n%      )\n\n\n  )\n\n  /\\ % symmetry breaking\n  rehearsal_order[1] < rehearsal_order[num_pieces]\n\n  % for all solutions\n  % /\\ total_waiting_time = 17\n;\n\n\n%\n% data\n%\n%\n% num_pieces = 9;\n% num_players = 5;\n% duration = [2, 4, 1, 3, 3, 2, 5, 7, 6];\n% rehearsal = array2d(1..num_players, 1..num_pieces, \n%     [\n%      1,1,0,1,0,1,1,0,1,\n%      1,1,0,1,1,1,0,1,0,\n%      1,1,0,0,0,0,1,1,0,\n%      1,0,0,0,1,1,0,0,1,\n%      0,0,1,0,1,1,1,1,0\n%   ]);\n\n%\n% This is the problem from the Choco v 2.1 example \n% num_pieces = 5;\n% num_players = 3;\n% duration = [4,6,3,5,7];\n% rehearsal =  array2d(1..num_players, 1..num_pieces, \n%         [\n%         1,1,0,1,0,\n%         0,1,1,0,1,\n%         1,1,0,1,1   \n%   ]);\n\n\noutput[\n  \"order: \" , show(rehearsal_order), \"\\n\",\n  \"waiting_time: \", show(waiting_time), \"\\n\",\n  \"total_waiting_time: \" , show(total_waiting_time), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(rehearsal[p, rehearsal_order[j]]) ++ \" \"\n  | p in 1..num_players, j in 1..num_pieces, \n] ++ \n[\"\\n\"]\n;\n\n\n                    ======\n                    Description:\n                    ---------\n                    The problem is called the \"Rehearsal Scheduling Problem\".\n\nThis problem is about scheduling a rehearsal for a concert where nine pieces of music need to be rehearsed by five orchestra players. Each piece has a different duration and requires a different combination of players. The goal is to find an order in which the pieces can be rehearsed to minimize the total time that players are waiting to play, i.e., the total time when players are present but not currently playing.\n\nThe main decision variables are:\n\n* `rehearsal_order`: an array of variables representing the order in which the pieces are rehearsed.\n* `waiting_time`: an array of variables representing the total waiting time for each player.\n* `p_from` and `p_to`: arrays of variables representing the first and last pieces that each player is involved in.\n\nThe key constraints are:\n\n* Each piece is rehearsed exactly once (all_different constraint).\n* Each player arrives at the rehearsal immediately before the first piece they are involved in and departs immediately after the last piece they are involved in.\n* The waiting time for each player is calculated as the sum of the durations of the pieces they are not playing in, but are present for.\n\nThe objective is to minimize the total waiting time for all players.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 7022, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "807bd6c6-e1e4-421e-ba08-bf9ff126b086": {"__data__": {"id_": "807bd6c6-e1e4-421e-ba08-bf9ff126b086", "embedding": null, "metadata": {"model_name": "restart"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "restart_medium", "node_type": "4", "metadata": {"model_name": "restart"}, "hash": "798052963e0dd4b80299bf57840cc21aa61657fb4b2f1b0ca8d81a4344b070d0", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 : \n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n\nModel 2 :\n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_max, complete)\n      satisfy;\n\n\nModel 3 : \n\n\narray[1..10] of var 1..10:x;\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n\n                    ======\n                    Description:\n                    ---------\n                    The Social Golfer Problem.\n\nThis problem is about scheduling a group of golfers into pairs to play golf over a series of weeks, subject to certain constraints.\n\nThe main decision variables are an array of 10 variables, x, where each x[i] represents the golfing partner of golfer i.\n\nThe key constraints are:\n\n* Each golfer must have a different partner each week (i.e., no golfer can play with the same partner more than once).\n* Golfers 2-10 can only play with partners 1-9 (i.e., golfer 1 is the most popular golfer and can play with anyone, while the others have limited options).\n* Golfer 1 must play with a partner 9 or higher (i.e., golfer 1 is very popular and can only play with the top-ranked golfers).\n\nThe objective of the problem is to find a schedule that satisfies these constraints.\n\nNote that the three models are equivalent and represent the same problem. The differences between them are in the way the constraints are formulated and the search strategy used to solve the problem.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1931, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dbfbc2c8-52a8-4e71-b71e-e75f2cf2fc66": {"__data__": {"id_": "dbfbc2c8-52a8-4e71-b71e-e75f2cf2fc66", "embedding": null, "metadata": {"model_name": "RosteringProblem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "RosteringProblem_medium", "node_type": "4", "metadata": {"model_name": "RosteringProblem"}, "hash": "ed97a920bf97807fad9cfcbdc2dea547f8f54d52c1eaa451b38d8b1b1e49e377", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    include \"all_equal.mzn\";\ninclude \"global_cardinality.mzn\";\n\n% load parameters\ninclude \"parameters.dzn\";\n\nint: daysPerWeek = 7;\n\n% the number of weeks\nint: numberOfWeeks;\n\nint: numberOfDays = numberOfWeeks * daysPerWeek;\n\n% the minimum number of days in a row with the same shift\nint: s_min;\n\n% the maximum number of days in a row with the same shift\nint: s_max; \n\n% 3 shifts: early = 1, late = 2 and night shift = 3 + day off (rest day) = 0\nint: numberOfShifts = 3;\n\n% the shift requirement matrix, including at M_{i,j} the needed employees for day i and shift j\narray[1..daysPerWeek, 1..numberOfShifts+1] of int: shiftRequirements;\n\n\n% the variables X \narray[1..numberOfWeeks * daysPerWeek] of var 0..numberOfShifts: plan1d;\narray[1..numberOfWeeks,1..daysPerWeek] of var 0..numberOfShifts: plan2d;\narray[1..daysPerWeek,1..numberOfWeeks] of var 0..numberOfShifts: plan2dT;\n\n% helper arrays\narray[1..s_min,1..s_min] of var 0..numberOfShifts: s_min_arrays;\narray[1..s_max,1..s_max] of var 0..numberOfShifts: s_max_arrays;\n\n% convert the 2D plan into 1D\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan1d[(week-1) * daysPerWeek + day]\n           );  \n\n% transpose the 2D plan\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan2dT[day, week]\n           );\n\n% C_equalDays: constrains that weekend days (Saturday and Sunday) always have the same shift\nconstraint forall(week in 1..numberOfWeeks) (\n               plan2d[week, daysPerWeek - 1] == plan2d[week, daysPerWeek]\n           );                        \n\n                                                                                                                                \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_min, j in 1..s_min) (\n                 s_min_arrays[i, j] == plan1d[((numberOfDays - s_min - 1 + i + j) mod numberOfDays) + 1]\n           );                                            \n                                            \n% C_shiftRepetitions:for every shift type a minimum number of consecutive assignments to this shift is given\nconstraint forall(day in 1..numberOfDays - s_min) (\n               plan1d[day] != plan1d[day+1] -> all_equal(plan1d[day+1..day+s_min])\n           );     \n% the constraints over the array bounds           \nconstraint forall(d in 1..s_min) (\n               plan1d[d + numberOfDays - s_min] != plan1d[((d + numberOfDays - s_min) mod numberOfDays) +1] -> all_equal(s_min_arrays[d,1..s_min])\n           );                     \n\n           \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_max, j in 1..s_max) (\n                 s_max_arrays[i, j] == plan1d[((numberOfDays - s_max - 2 + i + j) mod numberOfDays) + 1]\n           );                      \n                                            \n% C_shiftRepetitions:for every shift type a maximum number of consecutive assignments to this shift is given           \nconstraint forall(day in 1..numberOfWeeks * daysPerWeek - s_max) (\n               (all_equal(plan1d[day..day+s_max])) -> (plan1d[day] != plan1d[day + s_max])\n           );               \n% the constraints over the array bounds             \nconstraint forall(d in 1..s_max) (\n               (all_equal(s_max_arrays[d, 1..s_max])) -> (plan1d[d + numberOfDays - s_max] != plan1d[d])\n           );                     \n\n                               \n                                                                                                   \n% C_restDays: at least 2 days must be rest days every 2 weeks.\nconstraint forall(day in 1..(numberOfWeeks - 2) * daysPerWeek) (\n               count(j in plan1d[day..day + daysPerWeek * 2])(j=0) >= 2                   \n           );            \nconstraint forall(i in 1..2 * daysPerWeek-1) (\n               count(j in plan1d[numberOfWeeks * daysPerWeek-i .. numberOfWeeks * daysPerWeek] ++ plan1d[1..2*daysPerWeek-i])(j=0) >= 2    \n           );         \n                                            \n% C_shiftOrder: restricts the order of shifts. There is a forward rotating principle. This means, that after an early shift there can only follow a shift with the same or a higher value, or a rest shift.\nconstraint forall(day in 2..numberOfWeeks * daysPerWeek - 1) (\n               plan1d[day] <= plan1d[day + 1] \\/ plan1d[day+1] == 0\n           );         \nconstraint plan1d[1] >= plan1d[numberOfDays] \\/ plan1d[1] == 0;\n                      \n% C_shiftRequirements: for every weekday for each shift the number of required staff is provided (e.g. usually less staff is required on the weekend) \nconstraint forall(day in 1..daysPerWeek) (\n              (global_cardinality(row(plan2dT,day),[0,1,2,3],row(shiftRequirements,day)))   \n           );    \n           \n% solve the problem           \nsolve :: int_search(plan1d, input_order, indomain_min, complete)\n      satisfy;           \n      \n% print the problem      \noutput [ show(row(plan2d,j)) ++ \"\\n\" | j in 1..numberOfWeeks ] ++ [\"\\n\"];      \n                    ======\n                    Description:\n                    ---------\n                    **Nurse Rostering Problem**\n\nThe Nurse Rostering Problem is a classic constraint programming problem that involves creating a schedule for nurses to work in a hospital. The goal is to assign nurses to shifts while satisfying various constraints, such as ensuring that each shift has the required number of staff, and that nurses get adequate rest days.\n\n**Decision Variables:**\n\nThe main decision variables in this problem are the `plan1d`, `plan2d`, and `plan2dT` arrays, which represent the assignment of nurses to shifts. Each element in these arrays corresponds to a specific day and shift, and its value indicates the type of shift assigned (early, late, night, or rest day).\n\n**Key Constraints:**\n\n1. **Weekend constraint**: Saturday and Sunday shifts must be the same for each week.\n2. **Shift repetition constraint**: Each shift type must have a minimum and maximum number of consecutive assignments.\n3. **Rest day constraint**: At least two rest days must be assigned every two weeks.\n4. **Shift order constraint**: The order of shifts must follow a forward-rotating principle, where an early shift can only be followed by a shift with the same or higher value, or a rest shift.\n5. **Shift requirement constraint**: The number of staff required for each shift must be satisfied.\n\n**Objective:**\n\nThe objective of this problem is to find a feasible schedule that satisfies all the constraints. There is no explicit objective function to minimize or maximize, as the goal is to find a valid solution that meets all the requirements.\n\nIn summary, the Nurse Rostering Problem is a complex constraint programming problem that involves assigning nurses to shifts while satisfying various constraints related to shift repetition, rest days, shift order, and staff requirements.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 7004, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0503c332-73a3-48b2-934c-19e9e5e4dce5": {"__data__": {"id_": "0503c332-73a3-48b2-934c-19e9e5e4dce5", "embedding": null, "metadata": {"model_name": "sb"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sb_medium", "node_type": "4", "metadata": {"model_name": "sb"}, "hash": "c44a8e865e6edf781e7ffaf20d73c794d347f80723edc04edc4304a0b8af6967", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % Solitaire Battleships is a puzzle where\n% we are given a partially filled in board and the number\n% of ships in each row and column and have to fill it with ships\n \n% \"Improved\" version does not introduce reified set_in\n\nint: width;   % height of board (usually 10)\nint: height;  % width of board (usually 10)\nint: maxship; % maximal length of ship (usually 4)\n\n\nset of int: ROWS = 1..width;\nset of int: COLS = 1..height;\nset of int: XROWS = 0..width+1;    % extended rows\nset of int: XCOLS = 0..height+1;   % extended cols\n\n%% ship types enumerated type\nset of int: SHIPS = 1..maxship;  % different ship types\nint: submarine = 1;\nint: destroyer = 2;\nint: cruiser = 3;\nint: battleship = 4;\n\n\n%% the PIECES enumerated type!\nset of int: PIECES = 1..7;\nint: w = 1; % water\nint: c = 2; % circle (submarine)\nint: l = 3; % left end of ship\nint: r = 4; % right end of ship\nint: t = 5; % top of ship\nint: b = 6; % bottom of ship\nint: m = 7; % middle of ship\narray[PIECES] of string: code = [\".\",\"c\",\"l\",\"r\",\"t\",\"b\",\"m\"];\n\narray[ROWS,COLS] of 0..7: hint; % the initial board configuration\narray[ROWS] of int: rowsum;     % sums for each row\narray[COLS] of int: colsum;     % sums for each col\narray[SHIPS] of int: ship; % the number of each type of ship (usually [4,3,2,1]).\n\n\n\n% variables \narray[XROWS,XCOLS] of var PIECES: board;  % the board\n \narray[XROWS,XCOLS] of var 0..1: fill;     % which pieces are ships\n\narray[PIECES] of var 0..width*height: npiece; % number of pieces of each type\n\n\n% model\n\n% ensure hints are respected\nconstraint forall(i in ROWS, j in COLS)(\n\t\t\t   if hint[i,j] != 0 then\n\t\t\t   \t\tboard[i,j] == hint[i,j]\n\t\t\t   else true endif\n\t       ); \n\n% make extended rows and cols empty\nconstraint forall(i in XROWS)(board[i,0] == w /\\ board[i,width+1] == w);\nconstraint forall(j in COLS)(board[0,j] == w /\\ board[height+1,j] == w);\n\n% ensure that the fill array matches the board\nconstraint forall(i in XROWS, j in XCOLS)(\n\t\t\t   fill[i,j] = bool2int(board[i,j] != w)\n\t       ); \n\n% spacing constraints: gaps betwen ships\nconstraint forall(i in ROWS, j in COLS)(\n\t   (board[i,j] == w \\/ board[i+1,j+1] == w)\n\t/\\ (board[i,j] == w \\/ board[i+1,j-1] == w)   % diagonal constraints\n            /\\ (board[i,j] in {c,l,r,t} -> board[i-1,j] == w)\n            /\\ (board[i,j] in {c,l,r,b} -> board[i+1,j] == w)\n            /\\ (board[i,j] in {c,l,t,b} -> board[i,j-1] == w)\n            /\\ (board[i,j] in {c,r,t,b} -> board[i,j+1] == w)\n           );\n               \t\t\t                       \n% ship shape constraints\nconstraint forall(i in ROWS, j in COLS)(\n               %% a left piece needs a right piece or middle to the right\n\t\t\t   (board[i,j] == l -> (board[i,j+1] == r \\/ board[i,j+1] == m))\n\t\t\t/\\ (board[i,j] == r -> (board[i,j-1] == l \\/ board[i,j-1] == m))\n\t\t\t/\\ (board[i,j] == t -> (board[i+1,j] == b \\/ board[i+1,j] == m))\n\t\t\t/\\ (board[i,j] == b -> (board[i-1,j] == t \\/ board[i-1,j] == m))\n\t\t\t   %% a middle piece has to have two opposite sides filled\n\t\t\t/\\ (board[i,j] == m -> (   fill[i-1,j] == fill[i+1,j]\n\t\t\t                        /\\ fill[i,j-1] == fill[i,j+1]\n\t\t\t                        /\\ fill[i-1,j] + fill[i,j-1] == 1))\n\t\t   );\n\t\t   \n% sum up pieces\nconstraint forall(p in PIECES)(\n\t\t\t   sum(i in ROWS, j in COLS)(bool2int(board[i,j] == p)) == npiece[p]\n\t\t   );\n\n% piece sum constraints\nconstraint npiece[c] == ship[submarine]; % submarines\nconstraint npiece[l] == npiece[r]; % left right (probably redundant)\nconstraint npiece[t] == npiece[b]; % top bottom\nconstraint npiece[l] + npiece[t] == sum(s in destroyer..maxship)(ship[s]); \n                                   % no of ends\nconstraint npiece[m] == sum(s in cruiser..maxship)(ship[s] * (s - 2)); \n                                   % no of middles \t\t   \n\t\t    \n% count number of bigger ships\n% at least for standard battleships you can probably simply\n% enforce this constraint for s in destroyer..destroyer\t\t\n% and still be guaranteed a correct solution    \nconstraint forall(s in destroyer..maxship)(\n\t           sum(i in ROWS,j in COLS)(bool2int(\n\t\t\t       if j + s - 1 <= width then\n\t\t\t          board[i,j] == l /\\ board[i,j+s-1] == r     % ship length s lr\n\t\t\t       /\\ forall(k in j+1..j+s-2)(board[i,k] == m)\n\t\t\t       else false endif\n\t\t\t    \\/\n\t\t\t       if i + s - 1 <= height then\n\t\t\t          board[i,j] == t /\\ board[i+s-1,j] == b     % ship length s tb\n\t\t\t       /\\ forall(k in i+1..i+s-2)(board[k,j] == m)\n\t\t\t       else false endif\n\t\t       )) = ship[s]\n\t\t   );\t\t    \n\t\t    \t\t    \n\n% row sums respected\nconstraint forall(i in ROWS)(\n               sum(j in COLS)(fill[i,j]) == rowsum[i]\n           );\n           \n% column sums respected           \nconstraint forall(j in COLS)(\n               sum(i in ROWS)(fill[i,j]) == colsum[j]\n           );           \n\n\nsolve :: int_search([ fill[i,j] | i in ROWS, j in COLS], \n      \t\t  input_order, indomain_min, complete)\n      satisfy;\n\noutput [ code[fix(board[i,j])] ++ \n\t\t if j == width then \" \" ++ show(rowsum[i]) ++ \"\\n\"\n\t\t else \"\" endif\n\t   | i in ROWS, j in COLS ]  ++\n\t   [ show(colsum[j]) | j in COLS ] ++ [\"\\n\"];\n\t   \n\n                    ======\n                    Description:\n                    ---------\n                    **Solitaire Battleships**\n\nSolitaire Battleships is a classic constraint programming problem that involves filling a partially filled board with ships, respecting certain constraints.\n\n**Decision Variables and Their Representation**\n\nThe main decision variables in this problem are:\n\n* `board`: a 2D array representing the board, where each cell can take one of 7 possible values (water, submarine, left/right/top/bottom of a ship, or middle of a ship).\n* `fill`: a 2D array indicating which pieces on the board are part of a ship.\n* `npiece`: an array representing the number of each type of piece on the board.\n\n**Key Constraints**\n\nThe key constraints in this problem are:\n\n* **Hints**: The initial board configuration must be respected, i.e., if a cell has a hint, it must be filled with the corresponding piece.\n* **Spacing**: There must be gaps between ships, and ships cannot touch each other diagonally.\n* **Ship Shape**: Each ship must have a valid shape, with left and right ends, top and bottom ends, and middle pieces.\n* **Piece Sums**: The number of each type of piece on the board must match the given sums.\n* **Row and Column Sums**: The number of filled cells in each row and column must match the given sums.\n\n**Objective**\n\nThe objective of the problem is to find a valid configuration of the board that satisfies all the constraints.\n\nIn essence, the problem is to fill a partially filled board with ships, respecting the given constraints, to create a valid Solitaire Battleships puzzle solution.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 6754, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5da2a39a-e81d-4e64-8946-a31b2e1d6277": {"__data__": {"id_": "5da2a39a-e81d-4e64-8946-a31b2e1d6277", "embedding": null, "metadata": {"model_name": "schur"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "schur_medium", "node_type": "4", "metadata": {"model_name": "schur"}, "hash": "ce87c88f28fda99964b7ef840d4a2855a09684a3d87e541272586bac931ecd6d", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    %% schurs numbers\n%%\n%% determine if n balls labelled 1..n\n%% can be placed in c boxes with no box containing a triple {x,y,z} where x+y=z\n \n\nint: n; %% number of balls\nint: c; %% number of boxes\n\narray[1..n] of var 1..c: box;\n\nconstraint forall(i in 1..n-1, j in i+1 .. n - i)(\n\t   \t    box[i] != box[j] \\/ \n\t\t    box[i] != box[i+j] \\/ \n\t\t    box[j] != box[i+j]);\n\nsolve satisfy;\n\noutput [\"n = \", show(n), \";\\nc = \", show(c), \";\\nbox = \",show(box),\";\\n\"];\n\n                    ======\n                    Description:\n                    ---------\n                    Schur's Numbers Problem\n\nSchur's Numbers Problem is a classic constraint programming problem that involves placing labeled balls into boxes subject to certain constraints.\n\nThe problem is about distributing `n` balls, labeled from 1 to `n`, into `c` boxes such that no box contains a triple of balls `{x, y, z}` where `x + y = z`. In other words, the problem seeks to find an assignment of balls to boxes that avoids any arithmetic progression of length three.\n\nThe main decision variables in this problem are the `box` array, where `box[i]` represents the box number that ball `i` is assigned to.\n\nThe key constraints in this problem are:\n\n* For any two balls `i` and `j`, if `i + j` is also a ball, then `i` and `j` cannot be in the same box, and `i` and `i + j` cannot be in the same box, and `j` and `i + j` cannot be in the same box. This ensures that no box contains a triple of balls that form an arithmetic progression.\n\nThe objective of this problem is to find a feasible assignment of balls to boxes that satisfies the constraints, rather than optimizing a specific objective function. The `solve satisfy` statement in the model indicates that the goal is to find a solution that satisfies all the constraints, rather than minimizing or maximizing a particular objective.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1909, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "02ab9b15-6c33-4ba7-8fad-e4c4acc3afef": {"__data__": {"id_": "02ab9b15-6c33-4ba7-8fad-e4c4acc3afef", "embedding": null, "metadata": {"model_name": "setselect"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "setselect_medium", "node_type": "4", "metadata": {"model_name": "setselect"}, "hash": "46eb5c102d2648ffeb399498f61d3a0f9faf53372930a83031a7af4cf876f2e2", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n\n% setselect\nint: n; % number of elements\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 2 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\nconstraint card(x) = u;\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 3 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 1..n: x;\n%constraint forall(i in 1..u-1)(x[i] < x[i+1]);\nconstraint forall(i,j in 1..u where i < j)(x[i] != x[j]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 4 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality bound of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 0..n: x;\nconstraint forall(i in 1..u-1)(x[i] >= (x[i] != 0) + x[i+1]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the Set Selection Problem.\n\nThe Set Selection Problem is about selecting a subset of elements from a larger set, subject to certain constraints. The goal is to maximize the sum of the selected elements.\n\nThe main decision variables in this problem are the elements that are selected, represented by the set `x` in the models. In some models, `x` is an array of variables, where each variable represents an element that may or may not be selected.\n\nThe key constraints in this problem are:\n\n* Each subset `s[i]` can have at most one element in common with the selected set `x`. This is represented by the constraint `card(x intersect s[i]) <= 1`.\n* In some models, the cardinality of the selected set `x` is fixed to `u`, represented by the constraint `card(x) = u`.\n* In other models, the selected set `x` is represented as an array of variables, and constraints are added to ensure that the variables are distinct and non-decreasing.\n\nThe objective of the problem is to maximize the sum of the selected elements, represented by the expression `sum(i in x)(i)` or `sum(x)`.\n\nIn summary, the Set Selection Problem is about selecting a subset of elements from a larger set, subject to constraints on the overlap with predefined subsets, and maximizing the sum of the selected elements.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2872, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8e62d1f8-da2a-4e70-870d-c6fb52e1a2ac": {"__data__": {"id_": "8e62d1f8-da2a-4e70-870d-c6fb52e1a2ac", "embedding": null, "metadata": {"model_name": "shipping"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "shipping_medium", "node_type": "4", "metadata": {"model_name": "shipping"}, "hash": "d4017d9832dd57f4996c064af485303c99843215854115d875b31ff3e5385a32", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    int: W; % number of Warehousse\nset of int: WARE = 1..W;\nint: F; % number of Factories\nset of int: FACT = 1..F;\n\narray[WARE] of int: demand;\narray[FACT] of int: production;\n\narray[FACT,WARE] of int: cost;\n\narray[FACT,WARE] of var int: ship;\n\n%int: m = max(demand);\n%array[FACT,WARE] of var 0..m: ship;\nconstraint forall(f in FACT, w in WARE)(ship[f,w] >= 0);\n\nconstraint forall(w in WARE)\n                 (sum(f in FACT)(ship[f,w]) >= demand[w]);\n\nconstraint forall(f in FACT)\n                 (sum(w in WARE)(ship[f,w]) <= production[f]);\n\nsolve minimize sum(f in FACT, w in WARE)\n                  (cost[f,w]*ship[f,w]);\n\n\noutput [ show_int(2,ship[f,w]) ++\n         if w == W then \"\\n\" else \" \" endif\n       | f in FACT, w in WARE ];\n                    ======\n                    Description:\n                    ---------\n                    The Transportation Problem.\n\nThis problem is about finding the most cost-effective way to transport goods from multiple factories to multiple warehouses, while meeting the demand of each warehouse and not exceeding the production capacity of each factory.\n\nThe main decision variables are the `ship` variables, which represent the quantity of goods to be shipped from each factory to each warehouse.\n\nThe key constraints are:\n\n* Each warehouse must receive at least as many goods as it demands.\n* Each factory cannot ship more goods than it produces.\n* The quantity of goods shipped from each factory to each warehouse must be non-negative.\n\nThe objective is to minimize the total transportation cost, which is calculated by multiplying the cost of shipping from each factory to each warehouse by the quantity of goods shipped.\n\nIn essence, the problem is about finding the optimal assignment of goods from factories to warehouses that meets the demand and production constraints while minimizing the total transportation cost.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1933, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1e6cd72e-cdc2-4215-bf8a-c7ede3a1032a": {"__data__": {"id_": "1e6cd72e-cdc2-4215-bf8a-c7ede3a1032a", "embedding": null, "metadata": {"model_name": "simple-prod-planning"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "simple-prod-planning_medium", "node_type": "4", "metadata": {"model_name": "simple-prod-planning"}, "hash": "7fddd3cfabf57a433ceb9d6511c4d43857e6daeaf548c74ae143671cbbbaa757", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % Number of different products\nint: nproducts; \nset of int: Products = 1..nproducts;  \n\n%profit per unit for each product\narray[Products] of int: profit;\narray[Products] of string: pname; \n\n%Number of resources\nint: nresources; \nset of int: Resources = 1..nresources; \n\n%amount of each resource available\narray[Resources] of int: capacity; \narray[Resources] of string: rname;\n\n%units of each resource required to produce 1 unit of product\narray[Products, Resources] of int: consumption; \nconstraint assert(forall (r in Resources, p in Products) \n           (consumption[p,r] >= 0), \"Error: negative consumption\");\n\n% bound on number of Products\nint: mproducts = max (p in Products) \n                     (min (r in Resources where consumption[p,r] > 0) \n                          (capacity[r] div consumption[p,r]));\n\n% Variables: how much should we make of each product\narray[Products] of var 0..mproducts: produce;\narray[Resources] of var 0..max(capacity): used;\n\n% Production cannot use more than the available Resources:\nconstraint forall (r in Resources) (     \n      used[r] = sum (p in Products)(consumption[p, r] * produce[p]) \n      /\\ used[r] <= capacity[r]\n);    \n\n% Maximize profit\nsolve maximize sum (p in Products) (profit[p]*produce[p]);\n\noutput [ show(pname[p]) ++ \" = \" ++ show(produce[p]) ++ \";\\n\" |\n         p in Products ] ++\n       [ show(rname[r]) ++ \" = \" ++ show(used[r]) ++ \";\\n\" |\n         r in Resources ];\n                    ======\n                    Description:\n                    ---------\n                    **Problem Name:** Production Planning Problem\n\n**Description:** The Production Planning Problem is a classic constraint programming problem that involves determining the optimal production quantities of different products to maximize profit, given limited resources and production constraints.\n\n**Decision Variables:**\n\n* `produce`: an array of variables representing the quantity of each product to produce.\n* `used`: an array of variables representing the amount of each resource used in production.\n\n**Key Constraints:**\n\n* The production of each product cannot exceed the available resources. This is ensured by the constraint that the total amount of each resource used (calculated by multiplying the production quantity of each product by its resource consumption) does not exceed the available capacity of that resource.\n* The production quantity of each product is bounded by the maximum possible production quantity, calculated based on the available resources and resource consumption.\n\n**Objective:**\n\nThe objective is to maximize the total profit, which is calculated by multiplying the production quantity of each product by its profit per unit.\n\nIn summary, the Production Planning Problem involves finding the optimal production quantities of different products to maximize profit, while ensuring that the production does not exceed the available resources and respecting the production constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3018, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b910294d-0bff-49cb-8f9b-8e103aaba2e1": {"__data__": {"id_": "b910294d-0bff-49cb-8f9b-8e103aaba2e1", "embedding": null, "metadata": {"model_name": "sonet_problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sonet_problem_medium", "node_type": "4", "metadata": {"model_name": "sonet_problem"}, "hash": "4747816d58cff87e792ce38ff03c96db94e9a90c4e71dbef42bb697c48a72716", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % The SONET problem is a network design problem: set up a network between\n% n nodes, where only certain nodes require a connection.\n% Nodes are connected by putting them on a ring, where all nodes\n% on a ring can communicate. Putting a node on a ring requires a so-called\n% ADM, and each ring has a capacity of nodes, i.e. ADMs. There is a certain\n% amount of rings, r, that is available. The objective is to set up a network\n% by using a minimal amount of ADMs.\n%\n%\n% About the problem model\n%\n% The problem model has the amount of rings ('r'), amount of nodes('n'),\n% the 'demand' (which nodes require communication) and node-capacity of each\n% ring ('capacity_nodes') as parameters.\n% The assignement of nodes to rings is modelled by a 2-dimensional matrix 'rings',\n% indexed by the amnount of rings and nodes. The matrix-domain is boolean:\n% If the node in column j is assigned to the ring in row i, then rings[i,j] = 1\n% and 0 otherwise. So all the '1's in the matrix 'rings' stand for an ADM.\n% Hence the objective is to minimise the sum over all columns and rows of matrix\n% 'rings'.\n% \"\"\"\n\nint: r;  % upper bound for amount of rings\nint: n;  % amount of clients\n\n\n% original comment: \n% we have double entries here because of the symmetric structure!\narray[1..n, 1..n] of 0..1: demand;\narray[1..r] of 1..n: capacity_nodes;\n\narray[1..r, 1..n] of var 0..1: rings;\nvar int: z =  sum(ring in 1..r, client in 1..n) (rings[ring, client]);\n\nsolve minimize z;\n% solve satisfy;\n\n\nconstraint\n%   z <= 7 % for solve satisfy\n%   /\\\n\n   % original comment:\n   % if there is a demand between 2 nodes, then there has to exist \n   % a ring, on which they are both installed\n   forall(client1,client2 in 1..n where client1 < client2) (\n      (demand[client1,client2] = 1) ->\n           exists(ring in 1..r) (\n                 rings[ring,client1] + rings[ring, client2] >= 2\n           )\n   )   \n   /\\\n   % original comment:\n   % capacity of each ring must not be exceeded     \n   forall(ring in 1..r) (\n        sum(client in 1..n) (\n              rings[ring, client]\n              ) <= capacity_nodes[ring] \n   )\n;\n\n\n%\n% data\n% (sonet_problem1nu.param)\n%\nr = 4;\nn = 5;\n\ndemand =\narray2d(1..n, 1..n,\n        [0,1,0,1,0,\n         1,0,1,0,0,\n         0,1,0,0,1,\n         1,0,0,0,0,\n         0,0,1,0,0])\n;\n\ncapacity_nodes = [3,2,2,1];\n\n\noutput \n[\n  \"z: \", show(z)\n] ++\n[\n  if client = 1 then \"\\n\" else \" \" endif ++\n    show(rings[ring, client])\n  | ring in 1..r, client in 1..n\n] ++ [\"\\n\"];\n\n                    ======\n                    Description:\n                    ---------\n                    SONET Problem\n\nThe SONET problem is a network design problem that involves setting up a network between a set of nodes, where only certain nodes require a connection. The goal is to minimize the number of Add-Drop Multiplexers (ADMs) needed to establish these connections.\n\nThe main decision variables in this problem are the `rings` matrix, which represents the assignment of nodes to rings. Each element `rings[i, j]` is a boolean value indicating whether node `j` is assigned to ring `i`.\n\nThe key constraints in this problem are:\n\n* If there is a demand for communication between two nodes, they must be assigned to the same ring.\n* The number of nodes assigned to each ring must not exceed the ring's capacity.\n\nThe objective of the problem is to minimize the total number of ADMs used, which is equivalent to minimizing the sum of all elements in the `rings` matrix.\n\nIn other words, the problem is to find the most efficient way to connect the nodes that require communication, using the minimum number of rings and ADMs, while ensuring that each ring does not exceed its capacity.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3737, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "db4e21b9-6eef-48a6-b01b-80ce7b513304": {"__data__": {"id_": "db4e21b9-6eef-48a6-b01b-80ce7b513304", "embedding": null, "metadata": {"model_name": "square_pack"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "square_pack_medium", "node_type": "4", "metadata": {"model_name": "square_pack"}, "hash": "7679462377010c1c4d174a3ad4393e78591b4fba32e7cde76307fa81b6a0d2ca", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    int: n; % number of squares\nset of int: SQUARE = 1..n;\nint: maxl = sum(i in SQUARE)(i);\nint: mina = sum(i in SQUARE)(i*i);\n\nvar n..maxl: height;\nvar n..maxl: width;\nvar mina .. n*maxl: area = height * width;\n\narray[SQUARE] of var 0..maxl: x;\narray[SQUARE] of var 0..maxl: y;\n\n% squares fit in the rectangle\nconstraint forall(s in SQUARE)(x[s] + s <= width);\nconstraint forall(s in SQUARE)(y[s] + s <= height);\n\n% non overlap\nconstraint forall(s1, s2 in SQUARE where s1 < s2)\n                 (x[s1] + s1 <= x[s2] \\/\n                  x[s2] + s2 <= x[s1] \\/  \n                  y[s1] + s1 <= y[s2] \\/ \n                  y[s2] + s2 <= y[s1]);\narray[SQUARE] of int: size = [ i | i in SQUARE ];\n\n% non overlap with global diffn\ninclude \"diffn.mzn\";\n%constraint diffn(x,y,size,size);\n\n% redundant cumulative constraints\ninclude \"cumulative.mzn\";\n%constraint cumulative(x,size,size,height);\n%constraint cumulative(y,size,size,width);\n\n% variables ordered in reverse size x[n], y[n], x[n-1], y[n-1], ..., x[1], y[1]\n%array[1..2*n] of var 0..maxl: vs = [ if i mod 2 = 0 then x[n+1 - i div 2] \n%                                     else y[n+1 - i div 2] endif | i in 2..2*n+1 ];\n\nsolve :: seq_search([\n         int_search([area,height,width], input_order, indomain_min, complete) \n         %,int_search(vs, input_order, indomain_min, complete)\n         ])\n      minimize area;\n\noutput [\"area = \",show(area), \"\\n\"] ++\n[\"height = \",show(height), \"\\n\"] ++\n[\"width = \",show(width), \"\\n\"] ++\n[\"x = \", show(x), \"\\n\"] ++\n[\"y = \", show(y), \"\\n\"];\n\n                    ======\n                    Description:\n                    ---------\n                    **The 2D Bin Packing Problem**\n\nThe 2D Bin Packing Problem is a classic constraint programming problem that involves packing a set of rectangular items of different sizes into a single rectangular container, called a bin, in a way that minimizes the area of the bin.\n\n**Decision Variables:**\n\n* `height` and `width`: the dimensions of the bin\n* `x` and `y`: arrays of variables representing the x and y coordinates of the top-left corner of each item in the bin\n* `area`: the area of the bin, calculated as the product of `height` and `width`\n\n**Key Constraints:**\n\n* Each item must fit within the bin, meaning its top-right corner must be within the bin's boundaries.\n* No two items can overlap, meaning that for any two items, one must be to the left of, above, or below the other.\n\n**Objective:**\n\nThe objective is to minimize the area of the bin, which is equivalent to minimizing the product of `height` and `width`.\n\nIn this model, the problem is formulated as a minimization problem, where the goal is to find the smallest bin that can accommodate all the items. The model uses various constraints to ensure that the items fit within the bin and do not overlap, and the objective is to minimize the area of the bin.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2923, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "471b24e4-1b83-4bcf-9ce9-154edc2f925f": {"__data__": {"id_": "471b24e4-1b83-4bcf-9ce9-154edc2f925f", "embedding": null, "metadata": {"model_name": "stableroommates"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "stableroommates_medium", "node_type": "4", "metadata": {"model_name": "stableroommates"}, "hash": "e4a4a36570b89b42f3d21f9b8f88c8de6d548ac0757a22d59aafb5845eb18b6e", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\nset of int: AGENT0 = 0..n;    % zero indicates no agent\narray[AGENT,1..n-1] of AGENT0: pref; % preference order for each agent\n     % the preference order is padded by zeros\narray[AGENT] of int: npref = [ sum(j in 1..n-1)(bool2int(pref[i,j] > 0))\n                             | i in AGENT ];\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..n-1)\n                               (pref[i,j] != i /\\ \n                                (pref[i,j] = 0 <-> j > npref[i])) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref[i,j1] != pref[i,j2]),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n%% ranking information: rank = 0 means not ranked\narray[AGENT,AGENT] of 0..n-1: rank = \n     array2d(AGENT,AGENT, [ max([bool2int(pref[i1,j] = i2) * j | j in 1..n-1])\n                          | i1, i2 in AGENT ]);\n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] > rank[i,j] -> a[j] < rank[j,i]\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] = rank[i,j] -> a[j] = rank[j,i]\n                 );\n\nsolve satisfy;\n\noutput  [ if i < fix(pref[i,a[i]]) then \"(\" ++ show(i) ++ \",\" ++ show(pref[i,a[i]]) ++ \")\\n\"\n          else \"\" endif\n        | i in AGENT ]\n       ++ [show(rank),\"\\n\"] \n %      ++ [show(npref),\"\\n\"] \n %      ++ [show(a),\"\\n\"]\n        ;\n       \n\n\nModel 2 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\n\narray[AGENT] of int: npref; % number of preferences of each agent\narray[AGENT] of int: cum_npref = [ sum(j in 1..i-1)(npref[j]) | i in AGENT];\narray[1..sum(npref)] of int: preferences;  % all preferences in one list\n\nfunction AGENT: pref(AGENT: i, 1..n-1: j) = \n         assert(j in 1..npref[i], \"Called pref(\" ++ show(i) ++ \",\" ++ show(j) ++ \") too large preference\\n\",\n         preferences[cum_npref[i] + j]);\n\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..npref[i])\n                               (pref(i,j) != i) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref(i,j1) != pref(i,j2)),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n\n\n%% ranking information: rank = 0 means not ranked but shoulnt occur!\nfunction 0..n-1: rank(AGENT: i1, AGENT: i2) = \n                 max([bool2int(pref(i1,j) = i2) * j | j in 1..npref[i1]]); \n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] > rank(i,j) -> a[j] < rank(j,i)\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] = rank(i,j) -> a[j] = rank(j,i)\n                 );\n\nsolve satisfy;\n\n   output  [ if fix(a[i]) < npref[i] /\\ i < pref(i,fix(a[i]))\n             then \"(\" ++ show(i) ++ \",\" ++ show(pref(i,fix(a[i]))) ++ \")\\n\"\n             else \"\" endif\n           | i in AGENT ]\n %      ++ [show(rank),\"\\n\"] \n       ++\n       [show(npref),\"\\n\"] \n       ++ [show(a),\"\\n\"]\n        ;\n       \n\n\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the **Stable Roommates Problem**.\n\nThis problem is about finding a stable matching between a set of agents, where each agent has a preference order over the other agents. The goal is to assign each agent to a roommate in a way that is stable, meaning that there is no pair of agents who would prefer to be roommates with each other rather than their current assignments.\n\nThe main decision variables in this problem are:\n\n* `a[i]`: the roommate assigned to agent `i`\n* `rank[i, j]`: the ranking of agent `j` in agent `i`'s preference order\n\nThe key constraints in this problem are:\n\n* Each agent is assigned to a roommate\n* An agent's roommate is one of their top preferences\n* If an agent prefers another agent to their current roommate, then the other agent must prefer their current roommate to the first agent\n* If an agent is indifferent between two roommates, then the two roommates must also be indifferent between each other\n\nThe objective of this problem is to find a stable matching, which means that there is no pair of agents who would prefer to be roommates with each other rather than their current assignments.\n\nIn other words, the problem is trying to find a way to assign roommates to each other in a way that is stable and respects the preferences of each agent.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 5128, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "166928f7-8fcc-4ed6-865d-42433243481b": {"__data__": {"id_": "166928f7-8fcc-4ed6-865d-42433243481b", "embedding": null, "metadata": {"model_name": "steiner"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "steiner_medium", "node_type": "4", "metadata": {"model_name": "steiner"}, "hash": "054b9f4d5413aea65acf5e2ad91df36137134bf677da03074e2a42965e077307", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % The ternary Steiner problem of order n is to find n(n-1)/6 sets of elements in {1,2,...,n}\n% such that each set contains three elements and any two sets have at most one element in common.\n% For example, the following shows a solution for size n=7:\n%\n%      {1,2,3}, {1,4,5}, {1,6,7}, {2,4,6}, {2,5,7}, {3,4,7}, {3,5,6}\n\ninclude \"globals.mzn\";\n\nint: N = 7; \nint: NB = N *(N-1) div 6;\narray[1..NB] of var set of 1..N: Sets;\n\n% solve satisfy;\nsolve::set_search(Sets, first_fail, indomain_min, complete) satisfy;\n\n\n\nconstraint\n   forall(i in index_set(Sets)) (\n      card(Sets[i]) = 3\n   )\n   /\\ \n   forall(i,j in index_set(Sets) where i < j) (\n      card( Sets[i] intersect Sets[j]) <= 1\n   )\n   /\\ % symmetry breaking\n   decreasing(Sets)\n\n;\n\noutput [\n       \"N: \", show(N), \" NB: \", show(NB), \"\\n\",\n       \"Sets: \", show(Sets)\n];\n\n\n                    ======\n                    Description:\n                    ---------\n                    The ternary Steiner problem.\n\nThis problem is about finding a collection of sets, each containing three elements, from a given set of `N` elements, such that any two sets have at most one element in common.\n\nThe main decision variables are the `Sets` array, which represents the collection of sets to be found. Each set is a subset of the `N` elements, and the model decides which elements to include in each set.\n\nThe key constraints are:\n\n* Each set must contain exactly three elements.\n* Any two sets must have at most one element in common.\n* The sets should be \"symmetrically broken\", meaning that the model should avoid duplicate solutions by imposing an ordering on the sets.\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.\n\nIn other words, the goal is to find a way to partition the `N` elements into `NB = N*(N-1)/6` sets of three elements each, such that no two sets share more than one element. The problem is often used as a benchmark for constraint programming solvers.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2088, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7a875155-596d-418c-9ca5-caf9e5fa7be1": {"__data__": {"id_": "7a875155-596d-418c-9ca5-caf9e5fa7be1", "embedding": null, "metadata": {"model_name": "stoch_fjsp"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "stoch_fjsp_medium", "node_type": "4", "metadata": {"model_name": "stoch_fjsp"}, "hash": "64b6b487782af24915e49051decd80ce13f5e6aaf372ece4a7658d387206fe6e", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % Stochastic General Assignment Problem \n% First stage:\n%    assign task to machines \n% Second stage:\n%    based on observed processign times, schedule taks on respective machines\n% Objective:\n%    minimise expected makespan\n\ninclude \"globals.mzn\";\n\n% Parameters\n\nint: no_mach;   % Number of machines\nint: no_jobs;   % Number of jobs\nint: no_task;   % Number of total tasks\nint: no_optt;   % Number of total optional tasks\n\nset of int: Mach  = 1..no_mach;\nset of int: Jobs  = 1..no_jobs;\nset of int: Tasks = 1..no_task;\nset of int: OptTs = 1..no_optt;\n\narray [Jobs] of set of int: tasks;\narray [Tasks] of set of int: optts;\n\narray [OptTs] of int: optt_mach;\narray [SCENARIOS1,OptTs] of int: optt_dur;\n\n\narray [Jobs] of int: last_task = [ max(tasks[j]) | j in Jobs ];\n%---------implications for multi scenarion solving ---------------\nint: nbScenarios;\nset of int: SCENARIOS1 = 1..nbScenarios;\nint: first_scen;\nint: last_scen;\nset of int: SCENARIOS = first_scen..last_scen;\narray[SCENARIOS1] of int: weights;\n\n%-------end of multi scenario addons ----------------\narray [Tasks] of int: task_job = \n    [ min(j in Jobs where t in tasks[j])(j) | t in Tasks ];\narray [SCENARIOS,Tasks] of int: task_mins =\n    array2d(SCENARIOS,Tasks,[ sum(k in tasks[task_job[t]])(if k < t then task_mind[s,k] else 0 endif)\n    |   s in SCENARIOS, t in Tasks ]);\narray [SCENARIOS,Tasks] of int: task_maxs =\n    array2d(SCENARIOS,Tasks,[ t_max[s] -\n        sum(k in tasks[task_job[t]])(if k < t then 0 else task_mind[s,k] endif)\n    |   s in SCENARIOS,  t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_mind =\n    array2d(SCENARIOS,Tasks,[ min(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS,t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_maxd = \n    array2d(SCENARIOS,Tasks,[ max(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS, t in Tasks ]);\n\n    % Additional deirved parameters for optional tasks\n    %\narray [OptTs] of int: optt_task =\n    [ min(t in Tasks where o in optts[t])(t) | o in OptTs ];\n\narray[SCENARIOS1] of int: min_dur = [ min([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\narray[SCENARIOS1] of int: max_dur = [ max([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\nset of int: Durs = min(min_dur)..max(max_dur);\n\n    % Parameters related to the planning horizon\n    %\narray[SCENARIOS1] of int: t_max = [sum(t in Tasks)(max(o in optts[t])(optt_dur[s,o])) | s in SCENARIOS1];\n\nset of int: Times = 0..max(t_max);\n\n%-----------------------------------------------------------------------------%\n% Variables\n\n    % Start time variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Times: start =\n    array2d(SCENARIOS,Tasks,[ let { var task_mins[s,t]..task_maxs[s,t]: k } in k | s in SCENARIOS, t in Tasks ]);\n\n    % Duration variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Durs: dur =\n    array2d(SCENARIOS,Tasks,[ if task_mind[s,t] = task_maxd[s,t] then task_mind[s,t] else\n        let { var task_mind[s,t]..task_maxd[s,t]: d } in d endif\n    |   s in SCENARIOS,t in Tasks ]);\n\n    % Variables whether an optional task is executed\n    %\narray [OptTs] of var bool: b;\n\narray[SCENARIOS] of var Times: de_objective;\n\nset of int: StochTimes = 0..sum(t_max);\nvar StochTimes: objective;\n%-----------------------------------------------------------------------------%\n% Constraints\n\n    % Precedence relations\n    %\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs, i in tasks[j] where i < last_task[j])(\n            start[s,i] + dur[s,i] <= start[s,i + 1]\n        )    \n    );\n\n    % Duration constraints\n    %\nconstraint\n    forall(o in OptTs,s in SCENARIOS)(\n        let { int: t = optt_task[o] } in (\n            if card(optts[t]) = 1 then\n                b[o] = true\n            else\n                b[o] -> dur[s,t] = optt_dur[s,o]\n            endif\n        )\n    );\n\n    % Optional tasks' constraints\n    %\nconstraint\n    forall(t in Tasks where card(optts[t]) > 1)(\n        ( sum(o in optts[t])(bool2int(b[o])) <= 1     )\n    /\\  ( exists(o in optts[t])(b[o])                 )\n    );\n\nconstraint\n    forall(t in Tasks where card(optts[t]) = 2)(\n        let {\n            int: o1 = min(optts[t]),\n            int: o2 = max(optts[t])\n        } in ( b[o1] <-> not(b[o2]) )\n    );\n\n    % Resource constraints\n    %\nconstraint\n    forall(m in Mach,s in SCENARIOS)(\n        let {\n            set of int: MTasks = { o | o in OptTs where optt_mach[o] = m }\n        } in (\n            cumulative(\n                [ start[s,optt_task[o]] | o in MTasks ],\n                [ optt_dur[s,o]         | o in MTasks ],\n                [ bool2int(b[o])      | o in MTasks ],\n                1\n            )\n        )\n    );\n\n% Objective constraint\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs)(start[s,last_task[j]] + dur[s,last_task[j]] <= de_objective[s])\n    );\nconstraint \n        objective = sum(s in SCENARIOS)(weights[s]*de_objective[s]);\n%-----------------------------------------------------------------------------%\n% Solve item\n\nsolve \n    :: search\n    minimize objective;\n\n%------------------------------------------------------------------------------%\n% Searches\n\nann: s_mindur   = int_search([dur[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_minstart = int_search([start[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_bool     = bool_search(b, input_order, indomain_max, complete);\nann: s_obj      = int_search(de_objective, input_order, indomain_min, complete);\n\nann: search = seq_search([s_mindur, s_bool, s_minstart, s_obj]);\n\n%-----------------------------------------------------------------------------%\n% Output\n\noutput \n[   \"objective = \", show(de_objective), \";\\n\",\n    \"stoch obj = \", show(objective), \";\\n\",\n    \"start = \", show(start), \";\\n\",\n    \"dur = \", show(dur), \";\\n\",\n    \"b = \", show(b), \";\\n\",\n];\n\n                    ======\n                    Description:\n                    ---------\n                    The Stochastic General Assignment Problem.\n\nThis problem is about assigning tasks to machines and scheduling them to minimize the expected makespan. The problem has two stages: in the first stage, tasks are assigned to machines, and in the second stage, the tasks are scheduled on the machines based on observed processing times.\n\nThe main decision variables are:\n\n* `start`: the start time of each task on each machine in each scenario\n* `dur`: the duration of each task on each machine in each scenario\n* `b`: a boolean variable indicating whether an optional task is executed or not\n\nThe key constraints are:\n\n* Precedence relations: each task must start after its predecessor has finished\n* Duration constraints: the duration of each task is determined by the observed processing time\n* Optional tasks' constraints: each optional task can be executed at most once, and if it is executed, its duration is fixed\n* Resource constraints: the total processing time of all tasks on each machine cannot exceed the machine's capacity\n\nThe objective is to minimize the expected makespan, which is the maximum completion time of all tasks across all scenarios.\n\nIn essence, this problem is about finding the best assignment and scheduling of tasks to machines to minimize the overall processing time, while taking into account the uncertainty in processing times and the availability of optional tasks.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 7397, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9e54b495-0011-4112-95ce-003b97f227da": {"__data__": {"id_": "9e54b495-0011-4112-95ce-003b97f227da", "embedding": null, "metadata": {"model_name": "submultisetsum"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "submultisetsum_medium", "node_type": "4", "metadata": {"model_name": "submultisetsum"}, "hash": "f745979d716b405dd9eef8313b8532bbf264828dacb30e64c224f6434d747e9a", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % subsetsum problem\narray[int] of int: number;\nint: target;\n\nset of int: NUMBER = index_set(number);\nvar set of NUMBER: selected;\n\nconstraint sum(i in selected)\n              (number[i]) = target;\nsolve satisfy;\n\noutput [show(selected)];\n                    ======\n                    Description:\n                    ---------\n                    The Subset Sum Problem.\n\nThis problem is about finding a subset of a given set of integers that adds up to a specific target sum.\n\nThe main decision variable is `selected`, which represents the subset of integers from the original set `number` that should be included to reach the target sum.\n\nThe key constraint is that the sum of the integers in the `selected` subset must equal the `target` value.\n\nThe objective of the problem is to find a feasible solution that satisfies the constraint, rather than minimizing or maximizing a specific objective function.\n\nIn other words, the goal is to find a subset of the given integers that adds up to the target sum, without considering any optimization criteria.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1115, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f9e738d4-2e94-4dcc-acf0-7f305bff42ad": {"__data__": {"id_": "f9e738d4-2e94-4dcc-acf0-7f305bff42ad", "embedding": null, "metadata": {"model_name": "table_seating"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "table_seating_medium", "node_type": "4", "metadata": {"model_name": "table_seating"}, "hash": "a6dcb2e8a6f86b185c8c43d95a05753c5abaedec5846e6a89d42ace761f4f4af", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n          forall(t in TABLE)(not ({p1,p2} subset table[t]));\n\nconstraint forall(t in TABLE)(card(table[t]) <= S);\n\nconstraint forall(p in PERSON)(exists(t in TABLE)(p in table[t]));\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))\n                  ( let { var TABLE: tn1 = sum(t in TABLE)(t * bool2int(couples[c,1] in table[t]));\n                          var TABLE: tn2 = sum(t in TABLE)(t * bool2int(couples[c,2] in table[t]));\n                    } in  tn1 + tn2);\n\n\n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n\n\n\nModel 2 : \n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\narray[PERSON] of var TABLE: seat;\n\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n                        seat[p1] != seat[p2];\n\nconstraint global_cardinality_low_up(seat, [t|t in TABLE], [0|t in TABLE], [S|t in TABLE]);\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))(seat[couples[c,1]] + seat[couples[c,2]]);\n\nconstraint forall(t in TABLE, p in PERSON)(p in table[t] <-> seat[p] = t);    \n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n\n                    ======\n                    Description:\n                    ---------\n                    The Social Golfer Problem.\n\nThis problem is about assigning golfers to tables for a social golfing event. The goal is to seat golfers in a way that maximizes social interaction while respecting certain constraints.\n\nThe main decision variables are:\n\n* `table`: a 2D array that represents the assignment of golfers to tables. Each element `table[t]` is a set of golfers assigned to table `t`.\n* `seat`: a 1D array that represents the assignment of golfers to tables. Each element `seat[p]` is the table number assigned to golfer `p`.\n\nThe key constraints are:\n\n* Each table can have at most `S` golfers.\n* Each golfer must be assigned to exactly one table.\n* Couples (defined in the `couples` array) must not be seated at the same table.\n* Golfers in the `key` set must not be seated at the same table.\n\nThe objective is to minimize the sum of table numbers assigned to couples. In other words, the goal is to seat couples at tables with the lowest possible numbers, while respecting the constraints.\n\nThe problem is a classic example of a constraint satisfaction problem, and the Minizinc models provided use a combination of set variables, array variables, and constraints to model the problem. The `not_same_table` predicate is used to ensure that couples and golfers in the `key` set are not seated at the same table. The `global_cardinality_low_up` constraint is used to ensure that each table has at most `S` golfers.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3735, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "378d7795-20d1-455f-988f-6f1ae9a42b7f": {"__data__": {"id_": "378d7795-20d1-455f-988f-6f1ae9a42b7f", "embedding": null, "metadata": {"model_name": "teamselect"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "teamselect_medium", "node_type": "4", "metadata": {"model_name": "teamselect"}, "hash": "65ce7108b2362af73b7ee1847bcf3c04fe17a8ffe8ac9dd1cdc75b0a50e4a45d", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\narray[CAPTAIN] of var set of PLAYER: team = [Xavier,Yuri,Zena];\n\nset of int: CAPTAIN = 1..3;\narray[CAPTAIN,PLAYER] of int: value;\n \nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |]; \n\nconstraint card(Xavier intersect GOALIE) >= 1;\nconstraint card(Xavier intersect DEFENCE) >= 2;\nconstraint card(Xavier intersect OFFENCE) >= 2;\nconstraint card(Xavier) = 6;\n\n\nconstraint card(Yuri intersect GOALIE) >= 1;\nconstraint card(Yuri intersect DEFENCE) >= 2;\nconstraint card(Yuri intersect OFFENCE) >= 2;\nconstraint card(Yuri) = 6;\n\nconstraint card(Zena intersect GOALIE) >= 1;\nconstraint card(Zena intersect DEFENCE) >= 2;\nconstraint card(Zena intersect OFFENCE) >= 2;\nconstraint card(Zena) = 6;\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nsolve maximize obj;\n\nvar int: obj = sum(c in CAPTAIN)(sum(p in team[c])(value[c,p]));\n\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n\n\nModel 2 :\n\n\n% team select problem\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\nset of int: CAPTAIN = 1..3;\nint: xavier = 1; int: yuri = 2; int: zena = 3;\narray[CAPTAIN,PLAYER] of int: value;\nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |];\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\npredicate correct_team(var set of PLAYER: team) = \n          card(team) = 6 /\\ \n          card(team intersect GOALIE) >= 1 /\\\n          card(team intersect DEFENCE) >= 2 /\\\n          card(team intersect OFFENCE) >= 2;\n\nconstraint correct_team(Xavier) /\\ correct_team(Yuri) /\\ correct_team(Zena);\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nvar int: obj = sum(p in Xavier)(value[xavier,p]) +\n               sum(p in Yuri)(value[yuri,p]) +\n               sum(p in Zena)(value[zena,p]);\n\nsolve maximize obj;\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the Team Selection Problem.\n\nThis problem is about selecting three teams, Xavier, Yuri, and Zena, from a pool of 11 players, where each team must have exactly 6 players, including at least one goalie, two defenders, and two offenders. The goal is to maximize the total value of the selected players across all three teams.\n\nThe main decision variables are Xavier, Yuri, and Zena, which represent the sets of players selected for each team.\n\nThe key constraints are:\n\n* Each team must have exactly 6 players.\n* Each team must have at least one goalie, two defenders, and two offenders.\n* The intersection of any two teams cannot have more than 2 players in common.\n\nThe objective is to maximize the total value of the selected players across all three teams, where the value of each player is given by the value array.\n\nIn essence, the problem is about finding the optimal selection of players for each team, subject to the constraints, to maximize the overall value of the teams.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4103, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6889ccfc-cc05-409a-8497-ad1a4bfa4b92": {"__data__": {"id_": "6889ccfc-cc05-409a-8497-ad1a4bfa4b92", "embedding": null, "metadata": {"model_name": "template_design"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "template_design_medium", "node_type": "4", "metadata": {"model_name": "template_design"}, "hash": "996da4f9196344357fae08148955a2779e1bb42ca4c0030b92b0b6106c067962", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % Template design\ninclude \"globals.mzn\";\n\nint: S;   \t\t% Number of slots per template.\nint: t;   \t\t% Number of templates.\nint: n;   \t\t% Number of variations.\narray[1..n] of int: d; \t% How much of each variation we must print?\n\n% Lower and upper bounds for the total production.\n%\nint: llower = ceil(sum(i in 1..n)(int2float(d[i]))/int2float(S));\nint: lupper = 2*llower; % If t>1, this should be the optimal Production_{t-1}-1.\n\n% # Slots allocated to variation i in template j\narray[1..n,1..t] of var 0..S: p;\n\n% # Pressings of template j.\narray[1..t] of var 1..lupper: R;\n\n% Sum of all Rj.\nvar llower..lupper: Production;\n\n% Production x S - sum(d[i])\nvar 0..lupper-llower: Surplus;\n\n% First, set up Production to be the sum of the Rj\nconstraint\n\tProduction = sum(i in 1..t)(R[i]);\n\n% the limits on production\nconstraint\n\tProduction >= llower /\\ Production <= lupper;\n\n% The number of slots occupied in each template is S.\nconstraint\n\tforall(j in 1..t)\n\t\t (sum(i in 1..n)(p[i,j]) = S);\n\n% Enough of each variation is printed.\nconstraint\n\tforall(i in 1..n)\n\t\t (sum(j in 1..t)(p[i,j]*R[j]) >= d[i]);\n\n% Symmetry constraints.\n% Variations with the same demand are symmetric.\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] == d[i+1] then\n\t\t\tlex_lesseq([p[i,  j] | j in 1..t],\n\t\t\t\t[p[i+1,j] | j in 1..t])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% pseudo symmetry\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] < d[i+1] then\n\t\t       sum (j in 1..t) (p[i,j]*R[j])\n\t\t     <= sum (j in 1..t) (p[i+1,j]*R[j])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% implied constraints on the surplus\n\n% These are presented in the paper as necessary to get good\n% performance for this model, but I think bounds consistency on the\n% sum(R[i]) constraint would produce the same amount of propagation\n\n% Set up surplus, which is bounded as production is bounded.\nconstraint\n\tSurplus = Production*S - sum(i in 1..n)(d[i]);\n\n% The surplus of each variation is also limited by the surplus.\nconstraint\n\tforall(k in 1..n)\n\t\t (sum(j in 1..t)(p[k,j]*R[j]-d[k]) <= Surplus);\n\n% The surplus of the first k variations is limited by the surplus.\nconstraint\n\tforall(k in 2..n-1)\n\t\t (sum(j in 1..t, m in 1..k)( p[m,j]*R[j]-d[m] ) <= Surplus);\n\n% Implied constraints on the run length.\nconstraint\n\tif t=2 then (\n\t\tR[1] <= Production div 2\n\t/\\\tR[2] >= Production div 2\n\t) else true endif;\n\nconstraint\n\tif t=3 then (\n\t\tR[1] <= Production div 3\n\t/\\\tR[2] <= Production div 2\n\t/\\\tR[3] >= Production div 3\n\t) else true endif;\n\n% Minimize the production.\nsolve :: int_search(array1d(1..n*t,p) ++ R, input_order, indomain_min, complete)\n    minimize Production;\n\noutput [\n    if v = 1 then \"template #\" ++ show(i) ++ \": [\" else \"\" endif ++\n    show(p[v, i]) ++\n    if v = n then \"], pressings: \" ++ show(R[i]) ++ \"\\n\" else \", \" endif\n\t| i in 1..t, v in 1..n]\n    ++ [\"Total pressings: \", show(Production), \"\\n%\\n\"];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%\n\n                    ======\n                    Description:\n                    ---------\n                    **Template Design Problem**\n\nThe Template Design Problem is a classic constraint programming problem that involves allocating slots on templates to produce different variations of a product.\n\n**Decision Variables:**\n\n* `p[i, j]`: The number of slots allocated to variation `i` on template `j`.\n* `R[j]`: The number of pressings (or copies) of template `j`.\n* `Production`: The total number of pressings across all templates.\n* `Surplus`: The total surplus of production, which is the difference between the total production and the total demand.\n\n**Key Constraints:**\n\n* Each template has a fixed number of slots (`S`), and the total number of slots allocated to all variations on each template must equal `S`.\n* The total production of each variation must meet or exceed the demand for that variation.\n* The total surplus of production is limited by the total demand and the production capacity.\n* Symmetry constraints are used to reduce the search space by ensuring that variations with the same demand are treated equally.\n\n**Objective:**\n\nThe objective is to minimize the total production (`Production`) while meeting the demand for each variation and satisfying the constraints.\n\nIn summary, the Template Design Problem involves allocating slots on templates to produce different variations of a product, while minimizing the total production and meeting the demand for each variation.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4559, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8705a544-fa8b-432b-9e6d-033b0898c878": {"__data__": {"id_": "8705a544-fa8b-432b-9e6d-033b0898c878", "embedding": null, "metadata": {"model_name": "toomany"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "toomany_medium", "node_type": "4", "metadata": {"model_name": "toomany"}, "hash": "c160b1044b80e3302ae3161777c9e1fe65b7ee96da2c9216dc64f54f897c55ad", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    %% TooMany.mzn (too many solutions)\nint: n; % number of machines\nset of int: MACHINE = 1..n;\nint: k; % production per day\nint: red = 1; int: white = 2; int: black = 3; int: blue = 4;\nset of int: COLOR = 1..4;\narray[COLOR] of int: l; % lower bound on production\narray[COLOR] of int: u; % upper bound on production\n\narray[MACHINE,COLOR] of var 0..k div 2: produce;\n\nconstraint forall(m in MACHINE)\n                 (sum(c in COLOR)(produce[m,c]) <= k);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) >= l[c]);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) <= u[c]);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] > 0 /\\ produce[m,black] > 0 -> produce[m,blue] = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,blue] <= produce[m,red]);\nconstraint forall(m in MACHINE)\n                 (produce[m,red] mod 4 = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] mod 3 = 0);\n\n\nsolve maximize sum(m in MACHINE, c in COLOR)(produce[m,c]);\n\noutput [ show_int(3,produce[m,c]) ++\n         if c = 4 then \"\\n\" else \" \" endif\n       | m in MACHINE, c in COLOR ];\n\nn = 4;\nk = 11;\nl = [8,7,10,6];\nu = [14,16,12,20];\n\n\n                    ======\n                    Description:\n                    ---------\n                    **Problem Name:** Production Planning Problem\n\n**Description:** This problem involves planning the production of different colored items on multiple machines, subject to various constraints and limitations. The goal is to maximize the total production while meeting the requirements and restrictions.\n\n**Decision Variables:** The main decision variables are `produce[m,c]`, which represent the quantity of items of color `c` produced on machine `m`.\n\n**Key Constraints:**\n\n* Each machine can produce at most `k` items per day.\n* The total production of each color must be within the specified lower and upper bounds (`l[c]` and `u[c]`).\n* If a machine produces white and black items, it cannot produce blue items.\n* The production of blue items on a machine cannot exceed the production of red items.\n* The production of red items on a machine must be a multiple of 4.\n* The production of white items on a machine must be a multiple of 3.\n\n**Objective:** The objective is to maximize the total production of all colors on all machines.\n\nIn essence, this problem involves allocating production capacities to different machines and colors while respecting various constraints and limitations, with the goal of maximizing overall production.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2634, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dc4f424b-ef96-4a7d-ba3d-3740874bc1ee": {"__data__": {"id_": "dc4f424b-ef96-4a7d-ba3d-3740874bc1ee", "embedding": null, "metadata": {"model_name": "traffic_lights_table"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "traffic_lights_table_medium", "node_type": "4", "metadata": {"model_name": "traffic_lights_table"}, "hash": "d2919f51a8f2ffabd657560ff499091cbeb00edc3ccbf75cb97ac2d023101d62", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n%Traffic lights problem in MiniZinc.\n% Specification:\n% Consider a four way traffic junction with eight traffic lights. Four of\n% the traffic lights are for the vehicles and can be represented by the\n% variables V1 to V4 with domains\n% {r,ry,g,y} (for red, red-yellow, green and yellow).\n%  The other four traffic lights are for the pedestrians and can be\n%  represented by the variables P1 to P4 with domains {r,g}.\n%\n% The constraints on these variables can be modelled by quaternary\n% constraints on\n% (Vi, Pi, Vj, Pj ) for 1<=i<=4, j=(1+i)mod 4 which allow just the tuples\n% {(r,r,g,g), (ry,r,y,r), (g,g,r,r), (y,r,ry,r)}.\n%\n% It would be interesting to consider other types of junction (e.g. five roads\n% intersecting) as well as modelling the evolution over time of the\n% traffic light sequence.\n\ninclude \"globals.mzn\";\n\nint: n = 4;\nint: r  = 1; % red\nint: ry = 2; % red-yellow\nint: g  = 3; % green\nint: y  = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V;\narray[1..n] of var Pedestrians: P;\n\n\nsolve satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   table([V[i], P[i], V[j], P[j]], allowed)\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\n% output [\n%  \"V: \", show(V), \"\\nP: \", show(P), \"\\n\"\n% ];\noutput [\n show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: n = 4;\nint: r = 1; % red\nint: ry = 2; % red-yellow\nint: g = 3; % green\nint: y = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V; % ;\narray[1..n] of var Pedestrians: P; %;\n\npredicate cp1d(array[int] of var int: x, array[int] of var int: y) =\n  assert(index_set(x) = index_set(y),\n           \"cp1d: x and y have different sizes\",\n     forall(i in index_set(x)) ( x[i] = y[i] ))\n; \n\n% solve satisfy;\nsolve :: int_search(V ++ P, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   exists(a in 1..4) (\n      cp1d([V[i], P[i], V[j], P[j]], [allowed[a,k] | k in 1..4])\n   )\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\noutput [\n  show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the Traffic Lights Problem.\n\nThis problem is about scheduling the traffic lights at a four-way junction to ensure safe and efficient traffic flow. The junction has eight traffic lights: four for vehicles and four for pedestrians. Each traffic light can be in one of four states: red, red-yellow, green, or yellow.\n\nThe main decision variables are:\n\n* V1 to V4, which represent the states of the traffic lights for vehicles\n* P1 to P4, which represent the states of the traffic lights for pedestrians\n\nThe key constraints are:\n\n* At any given time, the traffic lights for vehicles and pedestrians at adjacent roads must be in a safe and compatible state. For example, if the traffic light for vehicles on one road is green, the traffic light for pedestrians on the adjacent road must be red.\n* The traffic lights must follow a specific sequence to ensure smooth traffic flow.\n\nThe objective of the problem is to find a feasible schedule for the traffic lights that satisfies all the constraints.\n\nIn this model, the constraints are represented using quaternary constraints, which specify the allowed combinations of states for the traffic lights at adjacent roads. The model uses a table constraint to enforce these quaternary constraints. The objective is to find a solution that satisfies all the constraints, and the model uses the \"satisfy\" objective to achieve this.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3933, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "811e8b37-84b5-4762-a9b6-f95e0a372796": {"__data__": {"id_": "811e8b37-84b5-4762-a9b6-f95e0a372796", "embedding": null, "metadata": {"model_name": "TTPPV"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "TTPPV_medium", "node_type": "4", "metadata": {"model_name": "TTPPV"}, "hash": "d1b95f4bccb13b841fb14f6aa3f6032240c61f069ad453f83eaf8eaa8ec96f03", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % Traveling Tournament Problem with Predefined Venues\n%\n% Compact single round robin schedule minimizing total travel distance\n% The venue of each game has already been decided\n% Specialized for CIRC instances (circular distances)\n\ninclude \"globals.mzn\";\n\nint: nbTeams;\nint: nbRounds = nbTeams-1;\n\nset of int: Teams = 1..nbTeams;\nset of int: Rounds = 1..nbRounds;\nset of int: Travels = 1..nbRounds+1;\n\n% predefined venue: pv[i][j] = 1 iff i is playing at home against j\narray[Teams,Teams] of 1..2: pv; \n\n% circular distances: for i>=j, distance[i][j]=min{i-j,j-i+nbTeams}\narray[Teams,Teams] of int: distance = \n  array2d(Teams,Teams,[ if i>=j then (if i-j < j-i+nbTeams then i-j else j-i+nbTeams endif) \n                                else (if j-i < i-j+nbTeams then j-i else i-j+nbTeams endif) \n                                endif | i,j in Teams]);\n\n% output related\nint: digs = ceil(log(10.0,int2float(nbTeams)));\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% decision variables: in round k, team i plays against team opponent[i,k]\narray[Teams,Rounds] of var Teams: opponent;\n\n% auxiliary variables: venue[i,k] = 1 iff team i plays at home in round k\narray[Teams,Rounds] of var 1..2: venue;\nconstraint forall (i in Teams, k in Rounds) (venue[i,k] = pv[i,opponent[i,k]]);\n\n% auxiliary variables: travel[i,k] is the distance travelled by team i to go play in round k (includes travelling back home after last round)\narray[Teams,Travels] of var 0..(nbTeams div 2): travel;\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n% a team cannot play against itself\nconstraint forall (i in Teams, k in Rounds) (opponent[i,k] != i);\n\n% in round k, i plays j means j plays i\nconstraint forall (i in Teams, k in Rounds) (opponent[opponent[i,k],k] = i);\n\n% for each team i, all opponents are different\nconstraint forall (i in Teams) (alldifferent([opponent[i,k] | k in Rounds]));\n\n% for each round k, all opponents are different (implied constraint)\nconstraint forall (k in Rounds) (alldifferent([opponent[i,k] | i in Teams]));\n\n% for each team i, there can be at most 3 consecutive home games and at most 3 consecutive away games\nint: nbStates = 7;\nset of int: States = 1..nbStates;\narray[States,1..2] of int: delta = \n  [| 2, 5\n   | 3, 5\n   | 4, 5\n   | 0, 5\n   | 2, 6\n   | 2, 7\n   | 2, 0 |];\nconstraint forall (i in Teams) (regular( [venue[i,k] | k in Rounds], nbStates, 2, delta, 1, States));\n\n% symmetry breaking: distances are symmetric so reversing the rounds yields a schedule of same cost\nconstraint (opponent[1,1] < opponent[1,nbRounds]);\n\n% define travel variables wrt venues of current- and next-round games\nconstraint forall (i in Teams) (\n\t(venue[i,1]=1 -> travel[i,1] = 0) /\\\n\t(venue[i,1]=2 -> travel[i,1] = distance[i,opponent[i,1]]) );\nconstraint forall (i in Teams, k in 1..nbRounds-1) (\n\t((venue[i,k]=1 /\\ venue[i,k+1]=1) -> travel[i,k+1] = 0) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=1) -> travel[i,k+1] = distance[opponent[i,k],i]) /\\\n\t((venue[i,k]=1 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[i,opponent[i,k+1]]) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[opponent[i,k],opponent[i,k+1]]) );\nconstraint forall (i in Teams) (\n\t(venue[i,nbRounds]=1 -> travel[i,nbRounds+1] = 0) /\\\n\t(venue[i,nbRounds]=2 -> travel[i,nbRounds+1] = distance[opponent[i,nbRounds],i]) );\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nvar int: totalTravel;\nconstraint totalTravel = sum (i in Teams, k in Travels) (travel[i,k]);\nsolve minimize totalTravel;\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\noutput [\"SCHEDULE\\n\"] ++ \n       [ if fix(venue[i,k]) == 1 then \" \" else \"@\" endif ++\n\t show_int(digs,opponent[i,k]) ++ \" \" ++ \n         if k == nbRounds /\\ i != nbTeams then \"\\n\" else \"\" endif\n         | i in Teams, k in Rounds ] ++ [\"\\n\"] ++\n       [\"total travel = \"] ++ [show(totalTravel)] ++ [\"\\n\"];\n\n                    ======\n                    Description:\n                    ---------\n                    The Traveling Tournament Problem with Predefined Venues.\n\nThis problem is about scheduling a round-robin tournament where each team plays every other team exactly once, with the added constraint that the venue of each game has already been decided. The goal is to find a schedule that minimizes the total travel distance of all teams.\n\nThe main decision variables are:\n\n* `opponent[i,k]`: the team that team `i` plays against in round `k`\n* `venue[i,k]`: whether team `i` plays at home (1) or away (2) in round `k`\n* `travel[i,k]`: the distance team `i` travels to play in round `k` (including the return journey after the last round)\n\nThe key constraints are:\n\n* Each team plays every other team exactly once\n* A team cannot play against itself\n* The venue of each game is already decided and must be respected\n* Each team has a different opponent in each round\n* Each round has a different set of opponents\n* No team can have more than three consecutive home games or away games\n* The schedule is symmetric, so reversing the rounds would result in the same total travel distance\n\nThe objective is to minimize the total travel distance of all teams, which is calculated as the sum of the distances traveled by each team in each round.\n\nIn essence, this problem is about finding the most efficient schedule for a tournament, taking into account the pre-defined venues and the need to minimize travel distances.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 5354, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7625bff0-00f7-44d4-9edb-f91ba6f42633": {"__data__": {"id_": "7625bff0-00f7-44d4-9edb-f91ba6f42633", "embedding": null, "metadata": {"model_name": "vessel-loading"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "vessel-loading_medium", "node_type": "4", "metadata": {"model_name": "vessel-loading"}, "hash": "aed297c4a380753ea06480da5644bd9d8962c5d527d3299b3d3541c3cc6668dc", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % Vessel Loading\n\nint: deck_width; % width of deck\nint: deck_length; % height of deck\nint: n_containers; % number of containers\nint: n_classes; % number of container classes\n\narray[int] of int: width;\n% width[c] = width of container c\narray[int] of int: length;\n% length[c] = length of container c\narray[int] of int: class;\n% class[c] = class of container c\narray[int, int] of int: separation;\n% separation[a, b] = the minimum allowed separation between\n%                    containers of classes a and b\n\nset of int: Containers = 1..n_containers;\n\narray[Containers] of var 0..deck_width: Left;\n% Left[c] = leftmost point of container c\narray[Containers] of var 0..deck_width: Right;\n% Right[c] = rightmost point of container c\narray[Containers] of var 0..deck_length: Bottom;\n% Bottom[c] = bottommost point of container c\narray[Containers] of var 0..deck_length: Top;\n% Top[c] = topmost point of container c\n\narray[Containers] of var 1..2: orientation;\n% orientation[c] = 2 if container c is turned 90 degrees, else 1.\n\nconstraint\n  forall (c in Containers) (\n    let {\n      array[1..2] of int: ElemWidth = [width[c], length[c]];\n      array[1..2] of int: ElemLength = [length[c], width[c]]\n    }\n    in \n      Right[c] = Left[c] + ElemWidth[orientation[c]] /\\\n      Top[c] = Bottom[c] + ElemLength[orientation[c]]\n  )\n;\n\nconstraint\n  forall(c, k in Containers where c < k) (\n    Left[c] >= Right[k] + separation[class[c], class[k]] \\/\n    Right[c] + separation[class[c], class[k]] <= Left[k] \\/\n    Bottom[c] >= Top[k] + separation[class[c], class[k]] \\/\n    Top[c] + separation[class[c], class[k]] <= Bottom[k]\n  )\n;\n\n% Excessive (pretty) output\noutput [\"\u250c\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2510\\n\"] ++\n       [if x == 0 then \"\u2502\" else \"\" endif ++\n        let {\n          bool: l = exists([fix(Left[c])   = x | c in Containers]);\n          bool: r = exists([fix(Right[c])  = x | c in Containers]);\n          bool: b = exists([fix(Bottom[c]) = y | c in Containers]);\n          bool: t = exists([fix(Top[c])    = y | c in Containers])\n        } in\n          if     l /\\ r /\\ b /\\ t then \"\u253c\"\n          elseif l /\\ r /\\ b      then \"\u252c\"\n          elseif l /\\ r /\\      t then \"\u2534\"\n          elseif l /\\      b /\\ t then \"\u251c\"\n          elseif      r /\\ b /\\ t then \"\u2524\"\n          elseif l /\\      b      then \"\u250c\"\n          elseif l /\\           t then \"\u2514\"\n          elseif      r /\\ b      then \"\u2510\"\n          elseif      r /\\      t then \"\u2518\"\n          elseif l \\/ r           then \"\u2502\"\n          elseif           b \\/ t then \"\u2500\" \n          else \" \" endif ++\n        if x == deck_width then \"\u2502\\n\" else \"\" endif\n        | y in 0..deck_length, x in 0..deck_width] ++\n        [\"\u2514\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2518\"];\n\n                    ======\n                    Description:\n                    ---------\n                    Vessel Loading Problem.\n\nThe Vessel Loading Problem is a classic constraint programming problem that involves loading containers of different sizes and classes onto a vessel with a fixed deck width and length, while ensuring that certain constraints are satisfied.\n\nThe main decision variables in this problem are:\n\n* `Left[c]` and `Right[c]`: the leftmost and rightmost points of container `c` on the deck, respectively.\n* `Bottom[c]` and `Top[c]`: the bottommost and topmost points of container `c` on the deck, respectively.\n* `orientation[c]`: a binary variable indicating whether container `c` is turned 90 degrees (orientation = 2) or not (orientation = 1).\n\nThe key constraints in this problem are:\n\n* Each container must be placed within the deck boundaries.\n* Containers of different classes must be separated by a minimum allowed distance, specified by the `separation` array.\n* Containers cannot overlap with each other.\n\nThe objective of this problem is to find a feasible arrangement of containers on the deck that satisfies all the constraints.\n\nNote that the provided model does not specify an objective function to be minimized or maximized, which is unusual for a constraint programming problem. Typically, the objective would be to minimize the unused space on the deck or to maximize the number of containers loaded. However, the model focuses on finding a feasible solution that satisfies all the constraints, which is a common approach in constraint programming.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4365, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0dfad1fb-865f-41a8-9e64-eb08e0746fbf": {"__data__": {"id_": "0dfad1fb-865f-41a8-9e64-eb08e0746fbf", "embedding": null, "metadata": {"model_name": "warehouses"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "warehouses_medium", "node_type": "4", "metadata": {"model_name": "warehouses"}, "hash": "0082f00ad83fce8bd5acfc99dd12e9a6901fe8fceda9d3e4fddf412a9f028056", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    % Warehouse allocation\n\n% vim: ft=zinc ts=2 sw=2 et tw=0\n\n% A company needs to construct warehouses to supply stores with goods.  Each\n% warehouse possibly to be constructed has a certain capacity defining how many\n% stores it can supply.  Constructing a warehouse incurs a fixed cost.  Costs\n% for transportation from warehouses to stores depend on the locations of\n% warehouses and stores.\n%\n% Determine which warehouses should be constructed and which warehouse should\n% supply which store such that overall cost (transportation cost plus\n% construction cost) is smallest.\n%-----------------------------------------------------------------------------\n\ninclude \"globals.mzn\";\n\n%-----------------------------------------------------------------------------\n% Instance\n\nn_suppliers = 5;\nn_stores = 10;\nbuilding_cost = 30;\n\ncapacity = [1,4,2,1,3];\n\ncost_matrix =\n [|20, 24, 11, 25, 30\n  |28, 27, 82, 83, 74\n  |74, 97, 71, 96, 70\n  | 2, 55, 73, 69, 61\n  |46, 96, 59, 83,  4\n  |42, 22, 29, 67, 59\n  | 1,  5, 73, 59, 56\n  |10, 73, 13, 43, 96\n  |93, 35, 63, 85, 46\n  |47, 65, 55, 71, 95|]; \n\n%-----------------------------------------------------------------------------\n% Model\n\nint: n_suppliers;\nint: n_stores;\nint: building_cost;\narray[1..n_suppliers] of int: capacity;\narray[1..n_stores,1..n_suppliers] of int: cost_matrix;\n\nint: MaxCost = max(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]);\nint: MaxTotal =   (n_suppliers * building_cost) \n                + sum(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]); \n\narray[1..n_stores] of var 1..n_suppliers: supplier;\narray[1..n_suppliers] of var bool: open;\narray[1..n_stores] of var 1..MaxCost: cost;\nvar 1..MaxTotal: tot;\n\nconstraint\n  sum (i in 1..n_suppliers) (building_cost * bool2int(open[i])) +\n  sum (i in 1..n_stores) (cost[i])\n  = tot;\n\nconstraint\n  forall (i in 1..n_stores) (\n    cost_matrix[i,supplier[i]] = cost[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    let {\n      var int: use\n     } in\n    count(supplier,i,use) /\\ use <= capacity[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    (exists (j in 1..n_stores) (supplier[j] == i)) == open[i]\n  );\n\nsolve\n  :: int_search(\n    supplier ++ cost ++ [bool2int(open[i]) | i in 1..n_suppliers],\n    first_fail,\n    indomain_split,\n    complete\n  )\n  minimize tot;\n\noutput\n  [ \"warehouses:\" ]\n  ++\n  [ \"\\ntot = \", show(tot) ]\n  ++\n  [ \"\\nsupplier = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(supplier[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\ncost = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(cost[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\nopen = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(open[i]) ++\n    if i = n_suppliers then \"\\n]\\n\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_suppliers\n  ]\n\n%-----------------------------------------------------------------------------\n%-----------------------------------------------------------------------------\n\n                    ======\n                    Description:\n                    ---------\n                    **Warehouse Allocation Problem**\n\nThe Warehouse Allocation Problem is a classic constraint programming problem that involves determining the optimal allocation of warehouses to supply stores with goods.\n\n**Decision Variables:**\n\n* `supplier`: an array of variables that represents which warehouse supplies each store.\n* `open`: an array of boolean variables that indicates whether each warehouse is constructed or not.\n* `cost`: an array of variables that represents the transportation cost from each warehouse to each store.\n* `tot`: a variable that represents the total cost (construction cost plus transportation cost).\n\n**Key Constraints:**\n\n* Each store must be supplied by exactly one warehouse.\n* The total capacity of the open warehouses must be sufficient to supply all stores.\n* The transportation cost from each warehouse to each store is determined by the cost matrix.\n* The construction cost of each warehouse is fixed and must be paid if the warehouse is open.\n\n**Objective:**\n\nThe objective is to minimize the total cost, which is the sum of the construction costs of the open warehouses and the transportation costs from the warehouses to the stores.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4403, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "419875f9-94c0-4277-bb92-1883305ec7b4": {"__data__": {"id_": "419875f9-94c0-4277-bb92-1883305ec7b4", "embedding": null, "metadata": {"model_name": "water_buckets1"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "water_buckets1_medium", "node_type": "4", "metadata": {"model_name": "water_buckets1"}, "hash": "e3212fe2a8e34cca83016a04f0b2c7469bee1031268775a366cc1508991f4a9d", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n                    ------\n                    Model 1 :\n\n% Water buckets problem in Minizinc\n% \"\"\"\n% Problem description\n% This is a generalization of the CSPLib specification, which is as follows: Given an 8 pint bucket of water, and two empty buckets which can contain 5 and 3 pints respectively, the problem requires to divide the water into two by pouring water between buckets (that is, to end up with 4 pints in the 8 pint bucket, and 4 pints in the 5 pint bucket) in the smallest number of transfers.\n%\n% The generalization consists in making the specification parametric with respect to the start and goal configurations, which are now inputs to the problem.\n%\n% Problem input\n%\n% * Function start, assigning an initial amount of water to each bucket\n% * Function goal, assigning the goal amount of water to each bucket \n%\n% Search space\n% The set of all possibile sequences of configurations (states), where a configuration is a triple encoding the amount of water in each bucket at a given time-step\n%\n% Constraints\n%\n% * C1: At beginning, buckets contain the amount of water specified by function start\n% * C2: At the end, buckets contain the amount of water specified by function goal\n% * C3: The configuration at each step differs from that of the next one in that the amount of water of exactly 2 buckets changes (that in the others remain the same)\n% * C4: The overall amount of water is the same at each time step\n% * C5: After each transition (involving buckets b1 and b2), either the source bucket becomes empty, or the target becomes full\n% \"\"\"\n\n\nint: nb_buckets = 3;\nint: max_step = 10; % 8 for satisfy\nset of int: buckets = 1..nb_buckets;\nset of int: steps = 1..max_step;\narray[buckets] of int: capacity = [8,5,3];\narray[buckets] of int: start = [8,0,0];\narray[buckets] of int: goal = [4,4,0];\n\n% Search space: The set of all possibile sequences of configurations (states), \n% where a configuration is a triple encoding the amount of water in each \n% bucket at a given time-step\narray[steps, buckets] of var int: state;\nvar 1..max_step: goal_step;\n\n% Objective function\nsolve minimize goal_step;\n% solve :: int_search( [ state[i,j] | i in steps, j in buckets ] , \"first_fail\", \"indomain\", \"complete\")  minimize goal_step;\n\nconstraint\n%   goal_step <= 8 % for solve satisfy\n%   /\\\n   % assertions\n   forall(b in buckets) (\n      (start[b] <= capacity[b]) /\\ (goal[b] <= capacity[b])\n   )\n   /\\\n   sum(b in buckets)(start[b]) = sum(b in buckets)(goal[b])\n   /\\\n   forall(s in steps, b in buckets) (\n      state[s,b] >= 0 /\\\n      state[s,b] <= capacity[b]\n   )\n   /\\\n   forall(b in buckets) (\n      % C1: At beginning, buckets contain the amount of water specified by function start\n      state[1,b]=start[b]\n      /\\\n      % C2: At the end, buckets contain the amount of water specified by function goal\n      state[goal_step,b] = goal[b]\n   )\n   /\\\n   forall(step in 1..max_step-1) (\n      % C3: The configuration at each step differs from that of the next one in that the amount of\n      % water of exactly 2 buckets changes (that in the others remain the same)\n      sum(b in buckets)( bool2int(state[step,b] != state[step+1, b])) = 2\n      /\\\n      % C4: The overall amount of water is the same at each time step\n      sum(b in buckets)(state[step,b]) = sum(b in buckets)(state[step+1,b])\n      /\\\n\n      % C5: After each transition (involving buckets b1 and b2), either the source\n      % bucket becomes empty, or the target becomes full\n      forall(b1, b2 in buckets where b1 != b2) (\n         ((state[step, b1] != state[step+1, b1]) /\\ (state[step, b2] != state[step+1, b2])) ->\n            (state[step+1,b1] = 0 \\/ state[step+1,b1] = capacity[b1] \\/\n             state[step+1,b2] = 0 \\/ state[step+1,b2] = capacity[b2])\n     )\n   )\n;\n\n\noutput [\n  if s = 1 /\\ b = 1 then \n    \"goal_step: \" ++ show(goal_step)\n  else \"\" endif ++\n  if b = 1 then \"\\n\" else \" \" endif ++\n  show(state[s, b])\n  | s in steps, b in buckets\n\n] \n++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\n\ninclude \"globals.mzn\";\n\nint: n_states = 15;\nint: input_max = 15;\nint: initial_state = 1;\nset of int: accepting_states = {15};\n\n\n% distance\narray[1..n_states, 1..n_states] of 0..input_max: transition_fn =\narray2d(1..n_states, 1..n_states,\n[%1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n  0, 2, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 1\n  0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 2 \n  0, 0, 0, 4, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 3\n  0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 4\n  0, 0, 0, 0, 0, 6, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 5\n  0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, % 6\n  0, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 0, 0, 0, 0, % 7\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, % 8 \n  0, 0, 0, 0, 0, 0, 0, 0, 0,10, 0, 0, 0, 0, 0, % 9\n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0,11, 0, 0, 0, 0, %10\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,12, 0, 0, 0, %11 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,13, 0, 0, %12\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,14, 0, %13 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %14\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %15\n]);\n\n\narray[1..n_states] of string:  nodes = [\n        \"8,0,0\", % 1 start\n        \"5,0,3\", % 2\n        \"5,3,0\", % 3 \n        \"2,3,3\", % 4 \n        \"2,5,1\", % 5\n        \"7,0,1\", % 6\n        \"7,1,0\", % 7\n        \"4,1,3\", % 8\n        \"3,5,0\", % 9\n        \"3,2,3\", % 10\n        \"6,2,0\", % 11\n        \"6,0,2\", % 12\n        \"1,5,2\", % 13\n        \"1,4,3\", % 14\n        \"4,4,0\"  % 15 goal\n        ];\n\n\narray[1..input_max] of var 0..input_max: x;\nvar 0..input_max: cost;\n\n% solve satisfy;\nsolve minimize cost;\n\nconstraint\nregular(x, n_states, input_max, transition_fn,\n        initial_state, accepting_states)\n;\n\nconstraint\n   cost = 2+sum([bool2int(x[i-1] != x[i] ) | i in 2..input_max])\n;\n\noutput \n[\"cost: \" ++ show(cost) ++ \"\\n\"] ++\n[show(initial_state) ++ \" \"] ++\n[\n  if fix(x[i]) < input_max then show(x[i]) ++ \" \" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(input_max) ++ \"\\n\"] ++ \n[\"\\n\\n\"] ++\n\n[show(nodes[initial_state]) ++ \"\\n\"] ++\n[\n  if fix(x[i]) < input_max then show(nodes[fix(x[i])]) ++ \"\\n\" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(nodes[input_max]) ++ \"\\n\"] ++ \n[\"\\n\"];\n                    ======\n                    Description:\n                    ---------\n                    The problem is known as the Water Buckets Problem.\n\nThis problem is about dividing a certain amount of water into two buckets of specific capacities using a series of pouring operations. The goal is to find the minimum number of transfers required to achieve a desired distribution of water in the buckets.\n\nThe main decision variables in this problem are the states of the buckets at each time step, represented by the `state` array in the model. Each element of the array represents the amount of water in a particular bucket at a particular time step.\n\nThe key constraints in this problem are:\n\n* The initial state of the buckets is specified by the `start` array.\n* The goal state of the buckets is specified by the `goal` array.\n* At each time step, the amount of water in each bucket must be within its capacity.\n* The total amount of water remains constant throughout the process.\n* At each step, exactly two buckets change their water levels.\n* After each transfer, either the source bucket becomes empty or the target bucket becomes full.\n\nThe objective of the problem is to minimize the number of transfers required to reach the goal state from the initial state.\n\nIn the second model, the problem is represented as a finite state machine, where the states are the possible configurations of the buckets, and the transitions between states are the pouring operations. The goal is to find the shortest path from the initial state to the goal state.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 7756, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"all_interval_medium": {"node_ids": ["a72b4934-9cf8-469a-a3a7-9539883b39bc"], "metadata": {"model_name": "all_interval"}}, "assign_medium": {"node_ids": ["cc78401b-3da2-4142-8254-8e14a7141665"], "metadata": {"model_name": "assign"}}, "aust_color_medium": {"node_ids": ["222e4ed0-395e-45c3-929c-71d810329edf"], "metadata": {"model_name": "aust_color"}}, "bibd_medium": {"node_ids": ["06ce707c-e4a9-4683-841d-2e24832d3c82"], "metadata": {"model_name": "bibd"}}, "bus_scheduling_csplib_medium": {"node_ids": ["13b22c23-05d1-4ce8-95c5-768e78551724"], "metadata": {"model_name": "bus_scheduling_csplib"}}, "car_medium": {"node_ids": ["95b1973f-37a4-4a4a-bc30-339306938e44"], "metadata": {"model_name": "car"}}, "carpet_cutting_medium": {"node_ids": ["e4e15d83-baf1-4de5-92c0-28ba91c370a9"], "metadata": {"model_name": "carpet_cutting"}}, "cell_block_medium": {"node_ids": ["0afdbb52-009b-43fe-b472-cd0415773b83"], "metadata": {"model_name": "cell_block"}}, "clique_medium": {"node_ids": ["d1c37052-b7ac-4468-baff-d6affba82235"], "metadata": {"model_name": "clique"}}, "cluster_medium": {"node_ids": ["114c1571-5c1b-4895-917a-8343db2888ff"], "metadata": {"model_name": "cluster"}}, "compatible_assignment_medium": {"node_ids": ["3a132428-04d7-4535-9d12-395164ce7983"], "metadata": {"model_name": "compatible_assignment"}}, "constrained_connected_medium": {"node_ids": ["98942ef1-1e48-46e8-b6e2-67c76b4dee52"], "metadata": {"model_name": "constrained_connected"}}, "crazy_sets_medium": {"node_ids": ["fea02433-bf7b-48f3-b8b2-83490a9181c0"], "metadata": {"model_name": "crazy_sets"}}, "crossfigure_medium": {"node_ids": ["2ecae988-03e5-4962-a35d-5caa3d3b976a"], "metadata": {"model_name": "crossfigure"}}, "curriculum_medium": {"node_ids": ["07947d3f-064b-4460-acd2-2a3ba8b66406"], "metadata": {"model_name": "curriculum"}}, "diamond_free_degree_sequence_medium": {"node_ids": ["9883aa5f-a9e9-4813-bb49-4fa54f27093d"], "metadata": {"model_name": "diamond_free_degree_sequence"}}, "doublechannel_medium": {"node_ids": ["dce3168c-6c0e-41e3-9a07-4ca75eea2e46"], "metadata": {"model_name": "doublechannel"}}, "fractions_medium": {"node_ids": ["1f5fa0a6-7402-4e15-9c57-3678cd2adfe2"], "metadata": {"model_name": "fractions"}}, "golfers_medium": {"node_ids": ["f2e9acf2-2385-4fcf-96ef-f8b686d5b134"], "metadata": {"model_name": "golfers"}}, "golomb_medium": {"node_ids": ["0bfdcc06-3681-4f03-90db-185ec73ef379"], "metadata": {"model_name": "golomb"}}, "graph_medium": {"node_ids": ["1e804c9f-6691-439a-a60c-fa57e7352b0e"], "metadata": {"model_name": "graph"}}, "itemset_mining_medium": {"node_ids": ["665b3538-25ff-4224-a32e-49c4bf2d4751"], "metadata": {"model_name": "itemset_mining"}}, "jobshop_medium": {"node_ids": ["e5132c48-019e-48fa-ad12-c3621a767a65"], "metadata": {"model_name": "jobshop"}}, "K4xP2Graceful_medium": {"node_ids": ["b297af9e-e77e-4388-9020-19cd8c68158f"], "metadata": {"model_name": "K4xP2Graceful"}}, "killer_sudoku_medium": {"node_ids": ["9c5ac543-196b-44de-aeb6-e3bd7b74ebdf"], "metadata": {"model_name": "killer_sudoku"}}, "knapsack_medium": {"node_ids": ["79a76e35-3375-403d-b124-efd3d225b0cf"], "metadata": {"model_name": "knapsack"}}, "langford_medium": {"node_ids": ["2e652a58-feb7-47c7-968c-4fb9c2fa760d"], "metadata": {"model_name": "langford"}}, "loan_medium": {"node_ids": ["20ad5802-aad7-4f58-be33-4cdccdc4ff64"], "metadata": {"model_name": "loan"}}, "ltsp_medium": {"node_ids": ["a23399d9-df60-4fda-95a9-216063cdbb68"], "metadata": {"model_name": "ltsp"}}, "magic_hexagon_medium": {"node_ids": ["f322f351-2471-4a69-8de0-c3cc211c7348"], "metadata": {"model_name": "magic_hexagon"}}, "magic_sequence_medium": {"node_ids": ["f5fce463-340d-4bb3-a4a8-3d9850d3f0ea"], "metadata": {"model_name": "magic_sequence"}}, "maximum_density_still_life_medium": {"node_ids": ["3498e6d5-39c2-4d27-826b-135eb1d9c675"], "metadata": {"model_name": "maximum_density_still_life"}}, "mip_medium": {"node_ids": ["ebee6287-9ad5-4905-9de2-72b3ac45e0a3"], "metadata": {"model_name": "mip"}}, "missing_solution_medium": {"node_ids": ["7725bcc1-a254-493d-adad-3fb35071b461"], "metadata": {"model_name": "missing_solution"}}, "nonogram_create_automaton2_medium": {"node_ids": ["1e425c9e-9938-4587-8c9d-ad1840abecaa"], "metadata": {"model_name": "nonogram_create_automaton2"}}, "nurses_medium": {"node_ids": ["734342bc-864f-4eca-83e6-ae23ca1c845a"], "metadata": {"model_name": "nurses"}}, "opd_medium": {"node_ids": ["431c391f-5e56-4a7d-b6d8-4f6a1c2a597e"], "metadata": {"model_name": "opd"}}, "partition_medium": {"node_ids": ["f5b53da2-946f-47af-aec7-62d51bf2cf0f"], "metadata": {"model_name": "partition"}}, "photo_medium": {"node_ids": ["c61099b8-0c95-4b0f-9ec0-c70318a5a483"], "metadata": {"model_name": "photo"}}, "project_scheduling_medium": {"node_ids": ["92170cef-c48d-4b0f-b77c-70b0f217fec6"], "metadata": {"model_name": "project_scheduling"}}, "QuasigroupCompletion_medium": {"node_ids": ["e5657726-7cac-48ef-add0-74b048554e58"], "metadata": {"model_name": "QuasigroupCompletion"}}, "QuasiGroupExistence_medium": {"node_ids": ["1ed6abe4-0c61-4c7c-9895-8448198d4552"], "metadata": {"model_name": "QuasiGroupExistence"}}, "queens_medium": {"node_ids": ["7c45ec2b-dbc4-4a32-aeb8-9ca7fb2b7fa2"], "metadata": {"model_name": "queens"}}, "rcpsp_medium": {"node_ids": ["1f8ca28d-8abc-431a-b176-62d717e7b559"], "metadata": {"model_name": "rcpsp"}}, "rehearsal_medium": {"node_ids": ["a97ff742-622d-470f-8ed9-5e0b619abbaa"], "metadata": {"model_name": "rehearsal"}}, "restart_medium": {"node_ids": ["807bd6c6-e1e4-421e-ba08-bf9ff126b086"], "metadata": {"model_name": "restart"}}, "RosteringProblem_medium": {"node_ids": ["dbfbc2c8-52a8-4e71-b71e-e75f2cf2fc66"], "metadata": {"model_name": "RosteringProblem"}}, "sb_medium": {"node_ids": ["0503c332-73a3-48b2-934c-19e9e5e4dce5"], "metadata": {"model_name": "sb"}}, "schur_medium": {"node_ids": ["5da2a39a-e81d-4e64-8946-a31b2e1d6277"], "metadata": {"model_name": "schur"}}, "setselect_medium": {"node_ids": ["02ab9b15-6c33-4ba7-8fad-e4c4acc3afef"], "metadata": {"model_name": "setselect"}}, "shipping_medium": {"node_ids": ["8e62d1f8-da2a-4e70-870d-c6fb52e1a2ac"], "metadata": {"model_name": "shipping"}}, "simple-prod-planning_medium": {"node_ids": ["1e6cd72e-cdc2-4215-bf8a-c7ede3a1032a"], "metadata": {"model_name": "simple-prod-planning"}}, "sonet_problem_medium": {"node_ids": ["b910294d-0bff-49cb-8f9b-8e103aaba2e1"], "metadata": {"model_name": "sonet_problem"}}, "square_pack_medium": {"node_ids": ["db4e21b9-6eef-48a6-b01b-80ce7b513304"], "metadata": {"model_name": "square_pack"}}, "stableroommates_medium": {"node_ids": ["471b24e4-1b83-4bcf-9ce9-154edc2f925f"], "metadata": {"model_name": "stableroommates"}}, "steiner_medium": {"node_ids": ["166928f7-8fcc-4ed6-865d-42433243481b"], "metadata": {"model_name": "steiner"}}, "stoch_fjsp_medium": {"node_ids": ["7a875155-596d-418c-9ca5-caf9e5fa7be1"], "metadata": {"model_name": "stoch_fjsp"}}, "submultisetsum_medium": {"node_ids": ["9e54b495-0011-4112-95ce-003b97f227da"], "metadata": {"model_name": "submultisetsum"}}, "table_seating_medium": {"node_ids": ["f9e738d4-2e94-4dcc-acf0-7f305bff42ad"], "metadata": {"model_name": "table_seating"}}, "teamselect_medium": {"node_ids": ["378d7795-20d1-455f-988f-6f1ae9a42b7f"], "metadata": {"model_name": "teamselect"}}, "template_design_medium": {"node_ids": ["6889ccfc-cc05-409a-8497-ad1a4bfa4b92"], "metadata": {"model_name": "template_design"}}, "toomany_medium": {"node_ids": ["8705a544-fa8b-432b-9e6d-033b0898c878"], "metadata": {"model_name": "toomany"}}, "traffic_lights_table_medium": {"node_ids": ["dc4f424b-ef96-4a7d-ba3d-3740874bc1ee"], "metadata": {"model_name": "traffic_lights_table"}}, "TTPPV_medium": {"node_ids": ["811e8b37-84b5-4762-a9b6-f95e0a372796"], "metadata": {"model_name": "TTPPV"}}, "vessel-loading_medium": {"node_ids": ["7625bff0-00f7-44d4-9edb-f91ba6f42633"], "metadata": {"model_name": "vessel-loading"}}, "warehouses_medium": {"node_ids": ["0dfad1fb-865f-41a8-9e64-eb08e0746fbf"], "metadata": {"model_name": "warehouses"}}, "water_buckets1_medium": {"node_ids": ["419875f9-94c0-4277-bb92-1883305ec7b4"], "metadata": {"model_name": "water_buckets1"}}}}