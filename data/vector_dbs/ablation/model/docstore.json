{"docstore/metadata": {"all_interval": {"doc_hash": "c174d443cc8194f248f9caa934cc85b6baa525b4011b2512fe4193b00eb28fad"}, "bibd": {"doc_hash": "c54f5a4b6f396268a74bcd2773aab833cecb6ef80e86f53c63dcb1f99056543b"}, "bus_scheduling_csplib": {"doc_hash": "16b56f8a373f70a72716c86591c6aeda37db9a6b05edc16ae12149a259d31f88"}, "car": {"doc_hash": "5b1c339236009d986d2b29e4f23b4f4659bf1a12bef64d7d95bf3df5827cb6ee"}, "clique": {"doc_hash": "768be550f32091c0e12d3ddf566d5f64b1f8b64da7e817f19d4681598f30b4bd"}, "crossfigure": {"doc_hash": "f1e54bff699848253107278fa42ee37f69fc71d82e25a787e3ef8b6eddfe41db"}, "curriculum": {"doc_hash": "b815ea9c0cc90c8d3477085bb3711c8e4bbcbfb83d6864f655b95f3e4eec2184"}, "diamond_free_degree_sequence": {"doc_hash": "5aed6785fb38b20e0ba4a3ea224d72a80602ea0d4f36196bc0f8a038a25d6d73"}, "fractions": {"doc_hash": "9ee067a53b941e6046074f703b7705248353a5ab9e82a82ba830255d651b15b7"}, "golfers": {"doc_hash": "cb79b47d157344e2cab6b26cbdf008b8d3ddacc075ccf91a0c5c7a834e82ae79"}, "golomb": {"doc_hash": "e164f02c20efdcfa49a91ff147364260f90bde6c42300d031dede842a93e9061"}, "K4xP2Graceful": {"doc_hash": "2cbb1b36bfb3292aa8784de4bbf5798b807a859cdc1add92a1064622f0bb1895"}, "killer_sudoku": {"doc_hash": "846cf47b8f9b05929e05f5800f31c0f01397d2dfc65615372b3fb6ddfb80119d"}, "langford": {"doc_hash": "468937e1a91a28800007aba2a138d9e5ac594dd82bbee22b60f755fed554fb04"}, "magic_hexagon": {"doc_hash": "be2199999e1dd49470c5059433cb11fc77370940a85a3f80afcc85234562fb41"}, "magic_sequence": {"doc_hash": "7f2b60d3151598d681273ea22d678e50223ed105a27fd52386b745f48016ef83"}, "maximum_density_still_life": {"doc_hash": "9f62e2c67a1b5f1c14e87035625f0832cdeea7a149520eabebe950075ca38e14"}, "nonogram_create_automaton2": {"doc_hash": "89e6ecc75405b66e7c67875a5e5d52fc61a9dd72f02156637c944effaa4e4ff5"}, "opd": {"doc_hash": "65c8a2d13c6b6235b84c7e8d23abccc65374bef5364f729343402e0f72a719b9"}, "partition": {"doc_hash": "f7f008866eaea055351f46909affd24db51e3af878e1003d0bcafb536fe42e0e"}, "QuasigroupCompletion": {"doc_hash": "72beee6de8df66b8ac85c50cfe444de20e40f905e6ff4113fb66500273adbcff"}, "QuasiGroupExistence": {"doc_hash": "101c3bb823a07dec85ee458f4b43cc375178fdc1b1ba0227e68fa1cc439f9741"}, "queens": {"doc_hash": "e53219a7814a4285ba072f2b8c70c8c2d637f87e151be48706ebe11b2a091cbb"}, "rehearsal": {"doc_hash": "47878f3c78f63eddda54157e8e78d600ab6a28f6909c8f275eba7724d1879262"}, "RosteringProblem": {"doc_hash": "dcb597d14bf87b64a5c58d5a0ab83d3f8f5910b4f13722e8345326072121f5f6"}, "sb": {"doc_hash": "36df11b2f91d8cbfd388b8ce631b3beb33ba5c5f6b5b8e76a75c1398b55633d2"}, "schur": {"doc_hash": "185a4a98bb47e5f0d28320b8e67e3198373e7fb75fc3c84bcbdcc44f3547afa5"}, "sonet_problem": {"doc_hash": "cb49ba0750ddae3f7df128d5c4f57a2a1b8075d1e8f8ae75911d223c2d4bdfb0"}, "steiner": {"doc_hash": "9dbff475761c6323f42a487023a3f060d92acf41940777eeebdd99b8846469e0"}, "stoch_fjsp": {"doc_hash": "696c8f99457132eaf6cb09a68a9685b4ed5dba7b5cba2e096989284f09bd2686"}, "template_design": {"doc_hash": "9e60ec1ffb6c5ab8391d12e1ef11a9ede96d3368bc41e71280aadac1a4385f20"}, "traffic_lights_table": {"doc_hash": "2645d72e7ac2b26234eea40231d52bedfeb5b326ff0c6daae73f9186213af6d8"}, "TTPPV": {"doc_hash": "5f99608029be4ecc59c3920a0d26d7a51f9d0401c96bc8fd2f7377e6b14c3474"}, "vessel-loading": {"doc_hash": "e69e7be85c1a89f81e968bdff5dae734d1e2aba225c4eb9df2298e63d225b342"}, "warehouses": {"doc_hash": "aee392b846eba43a799d5e093dc710a17033e76a67dd01218ee3bb380d9382cf"}, "water_buckets1": {"doc_hash": "6bb371fdadea2a6dd401f669556cc3c8188b175fdce7925646cebe6437233bd4"}, "9baa24d7-64ec-446d-8250-34dc3cf12345": {"doc_hash": "290dbce603d32c55ee2f6c414eda99f31096026eea643f357bfba65c011bcfbf", "ref_doc_id": "all_interval"}, "27ef8104-4480-45b5-947b-5ae1908f8bfc": {"doc_hash": "92bbf6139ae6d2f12e0a7af1089ac00cea7ecce1f297c6be3ad5c74b44ea502d", "ref_doc_id": "all_interval"}, "5211e029-6e2b-487a-bf98-a39757accdac": {"doc_hash": "c507426b6811473aa2ae6350f9b69c5782909d9f3d25e31d39a3f7861d261a22", "ref_doc_id": "all_interval"}, "0c85778f-c957-4d9d-bee5-6e117a1d81f0": {"doc_hash": "4d53dcca3db40cdb249fc354fba8caaa695bd7972132cbc80821329f934bc89f", "ref_doc_id": "bibd"}, "d2e19595-0892-4beb-b665-aa6f798d1231": {"doc_hash": "98481fb50b969d08c1b7e43131cb74c38f9fd0b38930126a9dd5f27caa21302b", "ref_doc_id": "bus_scheduling_csplib"}, "457ec603-e982-41b2-9813-cefcf06031af": {"doc_hash": "362ed1b103d9deb907e8323cc3206374f8bfee7ba853c2f86bd40b3727f056a7", "ref_doc_id": "car"}, "57dbe89b-0f50-4ebb-9ae5-fee4f9a9d92c": {"doc_hash": "452456335ebd12af4a3a255f49f55e07324c381d09eb6619551e525513b34632", "ref_doc_id": "clique"}, "ce5b5f35-1a8f-4c1b-abab-38de98a6cf68": {"doc_hash": "b75b2c72e0384b2087f16ccaa9e9bf5becbfe44a4c1b672cfb13bd875ff3ede3", "ref_doc_id": "crossfigure"}, "819439df-1da9-463d-b9fc-4e37250610eb": {"doc_hash": "a84375287bf9529854952f2130eba92ead61e9fa6d45e13a0ad51b1eb1c2504b", "ref_doc_id": "crossfigure"}, "f79d82ec-48f0-4182-88ac-508aae45fb64": {"doc_hash": "74faba9f7fa2c345245fbcdc2981f015eaa9b5025eb18025822b64ff4c3173d8", "ref_doc_id": "crossfigure"}, "6781354b-32d3-4437-abe4-344a644df63d": {"doc_hash": "4c148b153ac17232b3ac4a8be4d340bead765f14ce4963352b00806451bda125", "ref_doc_id": "crossfigure"}, "dcf18f80-383b-45a9-98ab-902162562c42": {"doc_hash": "40bbfc4bb6202d0cbda2777bd0db780bad8cc669144c82d9223a3d37da5032ce", "ref_doc_id": "curriculum"}, "ff84eb52-5167-4fb0-b69f-389a3fa9e2d6": {"doc_hash": "280dbd85ac7e960c68a288d9cebaf5d6677e48ec4f7a93511245b15e5e34a3fc", "ref_doc_id": "diamond_free_degree_sequence"}, "176afb79-57bb-41d9-b6f8-7534a91370ae": {"doc_hash": "9ee067a53b941e6046074f703b7705248353a5ab9e82a82ba830255d651b15b7", "ref_doc_id": "fractions"}, "fc4b0349-a5c0-4735-8407-3a83942db3ef": {"doc_hash": "0de4b95b4c648edaf8f6deae99b662041987daa723f10887743158ce9977384c", "ref_doc_id": "golfers"}, "be27bbed-354b-4957-be62-8357a1a71283": {"doc_hash": "4c827deeff3eb386c8afcef58c40c2bb54158f718ae33ffd36a11b576d2c5bad", "ref_doc_id": "golfers"}, "ae5326b8-5733-40ac-83ac-1a79339c234e": {"doc_hash": "028437c234d1e62289b27243c38401aa27ce07f478cb4e9f7189717b053ff010", "ref_doc_id": "golfers"}, "19ce32c5-ae5c-43f3-9596-427f9228d19b": {"doc_hash": "c7bbd50470ec4ba47b1a2502dc3104d60b68c3a616ec66dcf90421a29e3fd8c1", "ref_doc_id": "golomb"}, "29918f34-c21b-437f-90c7-fb2b74773a33": {"doc_hash": "2cbb1b36bfb3292aa8784de4bbf5798b807a859cdc1add92a1064622f0bb1895", "ref_doc_id": "K4xP2Graceful"}, "e7c4b030-7194-4690-8986-704101cdfc8d": {"doc_hash": "69b90917f5d9037ac5dc0a32594a8b331a5bcc5796869b035a21d93f9a885949", "ref_doc_id": "killer_sudoku"}, "75481c62-5655-4f83-9e12-72652b06aba1": {"doc_hash": "2fb341241474a0eb2918ba6955f5f3d0cb7117cd76a42e01630094346e8b1b11", "ref_doc_id": "killer_sudoku"}, "d0ff85b2-464d-4048-aaee-4d97fcb04ef5": {"doc_hash": "0e5a941f053394711565fad366cd174aa403aedd5ebcf80878b1cb1350f65541", "ref_doc_id": "killer_sudoku"}, "19d2f517-f636-420d-8d7d-2d1cb8f3db50": {"doc_hash": "119bb9dc2ed03ce340d41ec2c04fe6219fa90adde8fd879ed69c5a13e87246a0", "ref_doc_id": "killer_sudoku"}, "ed3d5303-2f28-4fff-94e4-0d39ba4ea60f": {"doc_hash": "62eca26347653a90cc50c7a04cf4604547a9b5f11782dc6e02c7fa46c9378a49", "ref_doc_id": "langford"}, "0ee4cf4e-a7d8-4935-a81d-1e9523557acb": {"doc_hash": "be2199999e1dd49470c5059433cb11fc77370940a85a3f80afcc85234562fb41", "ref_doc_id": "magic_hexagon"}, "4fff1322-f056-4737-8944-f8414ea747ad": {"doc_hash": "d6bc4af96c03730e0653119ba7fa4cc823e553b326cfd31f364e72d126119c28", "ref_doc_id": "magic_sequence"}, "743821a7-ccf6-4eab-85e8-bdf91306e96f": {"doc_hash": "05e9ec8689475f73b04dcc23ca3346ca54590605ff67b1426297ef79be47091b", "ref_doc_id": "magic_sequence"}, "3100b844-a880-4ce4-8ad1-bd9a62477c3c": {"doc_hash": "d0ba56317d2ac187fa7d4b91da06d3a647b72b869f794bfa6dbce8bbdd62bdfb", "ref_doc_id": "magic_sequence"}, "902b1497-65bc-4777-9c0c-f616eb1b3b30": {"doc_hash": "0702d320c8e80cea07002d638a3d7d2d5a96424cd7857b9e2e5521fdef554b4f", "ref_doc_id": "maximum_density_still_life"}, "dd60bb82-b292-43e3-a2c6-592d3047ebaa": {"doc_hash": "e1fd67832b01d4ff3a4b3c62eab4f68d4df1217c56033f41d64a2b3ec39f48a5", "ref_doc_id": "nonogram_create_automaton2"}, "237b8603-00f1-459c-b665-dada38345f79": {"doc_hash": "4f50c4f8d3872f9ca3ffc36c13bc2377fc44dad311546a4521c9b4d45fd50ff9", "ref_doc_id": "nonogram_create_automaton2"}, "c295f0f1-7c87-4150-a2d6-40acc2f5e579": {"doc_hash": "65c8a2d13c6b6235b84c7e8d23abccc65374bef5364f729343402e0f72a719b9", "ref_doc_id": "opd"}, "dceda50c-a8d2-4cdc-9556-1d32e753da3d": {"doc_hash": "4f57108a7bb8579be05d0da0c574061e8be563e0f03d598775725364b4894452", "ref_doc_id": "partition"}, "df1176d1-de7a-4c86-95d7-8e6d7a58c1ae": {"doc_hash": "ef47135aadf761d4bc0c38f8494ab1c71d1cd95daf1664a4aef31cf67a258f34", "ref_doc_id": "partition"}, "8602b091-2d1b-470a-bf5e-5522ac62fec3": {"doc_hash": "72beee6de8df66b8ac85c50cfe444de20e40f905e6ff4113fb66500273adbcff", "ref_doc_id": "QuasigroupCompletion"}, "d92d971d-e456-4c41-b96d-eeed942424d8": {"doc_hash": "bdd0fd72340928ed985541e720694f9650a3895fbdfd214cee1aec313d20b48f", "ref_doc_id": "QuasiGroupExistence"}, "382c0a9e-fdfb-445d-995c-ad92cfc8aa0d": {"doc_hash": "663c50fd2ba9f605cd6c4a4d3891d2e837e5f3cc30bc0c4634b09818245e7417", "ref_doc_id": "QuasiGroupExistence"}, "af21919a-71e2-4849-822b-52b728ecec1c": {"doc_hash": "f21830c3fd44a0f0d4cbe024d68535c7a3ecaa0c1f8b7a6a3b507d50cfb29f82", "ref_doc_id": "QuasiGroupExistence"}, "d0b850c8-b5a3-49a0-8b66-b9f3dae1f588": {"doc_hash": "c235e470bf736bceb3c6e980824d2fe4641213030bebb16294670534a9d0142c", "ref_doc_id": "QuasiGroupExistence"}, "55fcb77f-2129-44ab-b643-85e00197d24d": {"doc_hash": "0cba1aab2bc54592b82091b5c5413ea35aea2f0fd6f59ba72184874b1ab92dc0", "ref_doc_id": "QuasiGroupExistence"}, "680e2f88-27bf-4314-b412-18d0c3719c42": {"doc_hash": "e53219a7814a4285ba072f2b8c70c8c2d637f87e151be48706ebe11b2a091cbb", "ref_doc_id": "queens"}, "88a0d16b-a89e-4035-9043-adcf855f19b9": {"doc_hash": "7199d12ce35e1cd0ff940a51d76e1de8ce3a67faa02daeb01207ed3fd76cf60d", "ref_doc_id": "rehearsal"}, "aaa35a6c-cbf2-480e-be7c-10c6b2a523fc": {"doc_hash": "203b88ef93d1bada30e3369c35b5163a3daf360447487168b9442e89f9dcbcc3", "ref_doc_id": "rehearsal"}, "b870b772-c8ce-46d8-a3fe-bbe15972b29b": {"doc_hash": "e4cc6359b50988396db7ba6cd6e5b1cd13df0f8a983fc6abbf513b9637a314b8", "ref_doc_id": "rehearsal"}, "f8f5da7f-477a-4f69-abb8-579035d6b52e": {"doc_hash": "986b059e01a9f1c8d6585bdbe194fd5cf0ed2d6a43cd3bf790e6e87a49b60496", "ref_doc_id": "RosteringProblem"}, "bc34364b-6cf9-4c94-bc01-486f18e9898e": {"doc_hash": "cc13ddf1b250fd13a79426cbada0692161c91fcb37f5ab41f5fc8f745f5b2d0b", "ref_doc_id": "RosteringProblem"}, "918df488-03af-4c8a-9aeb-c8292c4a885a": {"doc_hash": "16346bd036eecdeb31af92c063954c4d3e0aaa09f809ce516075e5e4531a01a9", "ref_doc_id": "sb"}, "35462174-f9ae-4110-811e-9639e0169f86": {"doc_hash": "0c944609b070afe33ab439e9586f343fdaa045a0575465369d7e41fba8be6225", "ref_doc_id": "sb"}, "46c3d8a4-29ce-4350-9224-8eef9e70bb72": {"doc_hash": "e1a5876442951c488d1ebd6643ccab3501d7e0b962c5dc73ec4b327c1a4fd25a", "ref_doc_id": "sb"}, "c805fa24-5f97-4da1-aafd-ce6b47f2b988": {"doc_hash": "586eae4760d7905eefc239e32f5891a39247a58b1d7f3ec732eba91d37067529", "ref_doc_id": "schur"}, "a6addad5-b9af-4ebb-ab11-5cc0e7bf9fc0": {"doc_hash": "873167af9d9265ba5565b0095f88e954d667220348831d498a5df762f3685042", "ref_doc_id": "sonet_problem"}, "52139d6b-be60-4dd2-aee9-ab7075906ce5": {"doc_hash": "50206dd3e415408d4783294c241056dd0f70dab520c9ed2f5ff94049bff59e49", "ref_doc_id": "steiner"}, "b6c12a8e-e234-4235-9249-b454ed8bdc9d": {"doc_hash": "f3a2cb8694814ce00e52952671c478bc6adac5e24736c2c9156508c3d4ab3a36", "ref_doc_id": "stoch_fjsp"}, "50d06e8f-5183-46b1-a0ff-eb3567c625cb": {"doc_hash": "b9ac11657721c4bd6e3d1bcbe1f8c6197931f83ba70de6d38e50672ebeba73d7", "ref_doc_id": "stoch_fjsp"}, "59ca7377-8a99-4678-896a-52d84c60fd04": {"doc_hash": "97f3302b198c87dd8d574db6e1d28d3aae794313902e9af45297581993273e4f", "ref_doc_id": "template_design"}, "83dadf5e-3a2d-467d-a532-dfe7c94af3b1": {"doc_hash": "8c12a9d33b616e2360f2d36fcac6dd82fedbc1bddf9c3a5c7068af6162286b64", "ref_doc_id": "traffic_lights_table"}, "ea5fe9c8-d3bd-4cac-b518-f30eb284456f": {"doc_hash": "797806a137bfdaeded8ebbcc722b489f6c760117fba3f7637dcff7045e610366", "ref_doc_id": "TTPPV"}, "8de5e16a-6b19-4c71-9f55-78bd9ef36d37": {"doc_hash": "c44f2f87a66130f1316fec19f3bd281f4af1677f4f22a58bee6d1e9903cfd127", "ref_doc_id": "TTPPV"}, "412dc12d-0dff-4ab2-8741-4161dac425f7": {"doc_hash": "8bca0462903e3539c5b0382349a3d40dee027c687ac2857a91e162ec84739aa3", "ref_doc_id": "vessel-loading"}, "32f19a75-4a42-4478-bcaa-56ca975298a9": {"doc_hash": "19a0574f82a3094ba026a5266bb8117240b14f9d66b597a71770e65668e7bbde", "ref_doc_id": "warehouses"}, "f1931183-2430-4ade-b730-ead1a231d0e5": {"doc_hash": "e7d2c7d3f9b12b511ae8ca2b3fbcad9d36a929c4317cdec5c93e6bd58f46359c", "ref_doc_id": "water_buckets1"}, "5a6ab93e-791b-44a3-9b34-dd50bdb65cc5": {"doc_hash": "7e2b2e7f483d467668d7ea64112659066ee713fa75f6d4f609cdda16f07b977b", "ref_doc_id": "water_buckets1"}, "1c4a588d-d1c7-4c3b-a946-d7c95c3e31bb": {"doc_hash": "ce6b11b08db6b22417aeb3b4bb1fdd196d624356347400088ce672daed58d4df", "ref_doc_id": "water_buckets1"}}, "docstore/data": {"9baa24d7-64ec-446d-8250-34dc3cf12345": {"__data__": {"id_": "9baa24d7-64ec-446d-8250-34dc3cf12345", "embedding": null, "metadata": {"problem_family": "All-Interval_Series"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "all_interval", "node_type": "4", "metadata": {"problem_family": "All-Interval_Series"}, "hash": "c174d443cc8194f248f9caa934cc85b6baa525b4011b2512fe4193b00eb28fad", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "27ef8104-4480-45b5-947b-5ae1908f8bfc", "node_type": "1", "metadata": {}, "hash": "9c7d852cd19acaa25237292d5cbbab0466f9e80e179e7c756ef71809af1bc0eb", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 : \n\n\n%\n% All interval problem in MiniZinc\n%\n% \"\"\"\n% Given the twelve standard pitch-classes (c, c%, d, ...), represented by\n% numbers 0,1,...,11, find a series in which each pitch-class occurs exactly\n% once and in which the musical intervals between neighbouring notes cover\n% the full set of intervals from the minor second (1 semitone) to the major\n% seventh (11 semitones). That is, for each of the intervals, there is a\n% pair of neigbhouring pitch-classes in the series, between which this\n% interval appears. The problem of finding such a series can be easily\n% formulated as an instance of a more general arithmetic problem on Z_n,\n% the set of integer residues modulo n. Given n in N, find a vector\n% s = (s_1, ..., s_n), such that (i) s is a permutation of\n% Z_n = {0,1,...,n-1}; and (ii) the interval vector\n% v = (|s_2-s_1|, |s_3-s_2|, ... |s_n-s_{n-1}|) is a permutation of\n% Z_n-{0} = {1,2,...,n-1}. A vector v satisfying these conditions is\n% called an all-interval series of size n; the problem of finding such\n% a series is the all-interval series problem of size n. We may also be\n% interested in finding all possible series of a given size.\n\ninclude \"globals.mzn\";\n\nint: n = 12;\n% array[1..n] of var 1..n: x;\narray[1..n] of var 1..n: x;\narray[1..n-1] of var 1..n-1: diffs;\nint: sum_distinct = ((n+1)*n) div 2;\n\n% max_regret seems to be quite good....\nsolve :: int_search(x, max_regret, indomain_split, complete) satisfy;\n\nconstraint      \n  all_different(diffs) :: domain\n  /\\  \n  all_different(x) :: domain\n  /\\ \n  forall(k in 1..n-1) (\n      diffs[k] = abs(x[k+1] - x[k])\n  )\n  /\\ % symmetry breaking\n  x[1] < x[n-1]\n  /\\\n  diffs[1] < diffs[2]\n;\n\n\noutput [\n       show(x) ++ \",\" % , \" \", show(sum_distinct), \" diffs: \", show(diffs)\n]\n\n\nModel 2 : \n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n%    all_different(series) /\\\n\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i != j)  (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n;\n\noutput\n[  show(series)\n];\n\n\nModel 3 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   %  C1: Each pitch class occurs exactly once\n   forall(i, j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i!=j) (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput\n[ show(series)\n];\n\n\nModel 4 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3237, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "27ef8104-4480-45b5-947b-5ae1908f8bfc": {"__data__": {"id_": "27ef8104-4480-45b5-947b-5ae1908f8bfc", "embedding": null, "metadata": {"problem_family": "All-Interval_Series"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "all_interval", "node_type": "4", "metadata": {"problem_family": "All-Interval_Series"}, "hash": "c174d443cc8194f248f9caa934cc85b6baa525b4011b2512fe4193b00eb28fad", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9baa24d7-64ec-446d-8250-34dc3cf12345", "node_type": "1", "metadata": {"problem_family": "All-Interval_Series"}, "hash": "290dbce603d32c55ee2f6c414eda99f31096026eea643f357bfba65c011bcfbf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5211e029-6e2b-487a-bf98-a39757accdac", "node_type": "1", "metadata": {}, "hash": "14560133949c70b9b24393f8f6ef3cfbdb16e23017349c349bd7846068cb9468", "class_name": "RelatedNodeInfo"}}, "text": "output\n[ show(series)\n];\n\n\nModel 4 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[differ] of var differ: differences;\n\nsolve satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 1..n-2) (\n       differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in differ where i != j) (\n       differences[i] != differences[j]\n   )\n;\n\noutput [\n  show(series)\n];\n\n\nModel 5 : \n\n\ninclude \"globals.mzn\";\n\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_median, complete) satisfy;\n\nconstraint\n  % C1: Each pitch class occurs exactly once\n  % GCAD: Exploitation of alldifferent() global constraint\n  all_different(series)\n  /\\\n\n  % C2: Differences between neighbouring notes are all different\n  % GCAD: Exploitation of alldifferent() global constraint\n  % alldifferent(all (i in classes: i <> n-1) abs(series[i+1] - series[i]));\n  all_different( \n         [ abs(series[i+1] - series[i]) | i in classes where i != n-1]\n  )\n  \n;\n\noutput [\n  show(series)\n];\n\n\nModel 6 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\n% solve satisfy;\nsolve :: int_search(series, occurrence, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n      differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in 0..n-2 where i != j) (\n      differences[i] != differences[j]\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\noutput [\n  show(series)\n];\n\n\nModel 7 : \n\n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\nsolve ::int_search(series, first_fail, indomain_max, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(series)\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n          differences[i] = abs(series[i+1] - series[i])\n   )\n   /\\\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(differences)\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;", "mimetype": "text/plain", "start_char_idx": 3127, "end_char_idx": 6630, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5211e029-6e2b-487a-bf98-a39757accdac": {"__data__": {"id_": "5211e029-6e2b-487a-bf98-a39757accdac", "embedding": null, "metadata": {"problem_family": "All-Interval_Series"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "all_interval", "node_type": "4", "metadata": {"problem_family": "All-Interval_Series"}, "hash": "c174d443cc8194f248f9caa934cc85b6baa525b4011b2512fe4193b00eb28fad", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "27ef8104-4480-45b5-947b-5ae1908f8bfc", "node_type": "1", "metadata": {"problem_family": "All-Interval_Series"}, "hash": "92bbf6139ae6d2f12e0a7af1089ac00cea7ecce1f297c6be3ad5c74b44ea502d", "class_name": "RelatedNodeInfo"}}, "text": "output [\n   \"series: \" ++ show(series) ++ \"\\n\" ++\n   \"differences: \" ++ show(differences) \n];", "mimetype": "text/plain", "start_char_idx": 6633, "end_char_idx": 6726, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0c85778f-c957-4d9d-bee5-6e117a1d81f0": {"__data__": {"id_": "0c85778f-c957-4d9d-bee5-6e117a1d81f0", "embedding": null, "metadata": {"problem_family": "Balanced_Incomplete_Block_Designs"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bibd", "node_type": "4", "metadata": {"problem_family": "Balanced_Incomplete_Block_Designs"}, "hash": "c54f5a4b6f396268a74bcd2773aab833cecb6ef80e86f53c63dcb1f99056543b", "class_name": "RelatedNodeInfo"}}, "text": "% bibd.mzn\n% vim: ft=zinc ts=4 sw=4 et tw=0\n% Ralph Becket <rafe@csse.unimelb.edu.au>\n% Tue Oct 23 11:28:06 EST 2007\n%\n% Balanced incomplete block designs.  See the following:\n% http://mathworld.wolfram.com/BlockDesign.html\n% http://www.dcs.st-and.ac.uk/~ianm/CSPLib/prob/prob028/spec.html\n%\n%\n%\n% A BIBD (v, b, r, k, lambda) problem is to find a binary matrix of v rows\n% of b columns such that each row sums to r, each column sums to k, and\n% the dot product beween any pair of distinct rows is lambda.\n\ninclude \"lex_lesseq.mzn\";\n\nint: v;\nint: k;\nint: lambda;\n\nint: b = (lambda * v * (v - 1)) div (k * (k - 1));\nint: r = (lambda * (v - 1)) div (k - 1);\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\narray [rows, cols] of var bool: m;\n\n    % Every row must sum to r.\n    %\nconstraint forall (i in rows) (sum (j in cols) (bool2int(m[i, j])) = r);\n\n    % Every column must sum to k.\n    %\nconstraint forall (j in cols) (sum (i in rows) (bool2int(m[i, j])) = k);\n\n    % The dot product of every pair of distinct rows must be lambda.\n    %\nconstraint\n    forall (i_a, i_b in rows where i_a < i_b) (\n        sum (j in cols) (bool2int(m[i_a, j] /\\ m[i_b, j])) = lambda\n    );\n\n    % Break row symmetry in the incidence matrix.\n    %\nconstraint forall(i in rows diff {max(rows)})(\n        lex_lesseq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    );\n\n    % Break column symmetry in the incidence matrix.\n    %\nconstraint forall(j in cols diff {max(cols)})(\n        lex_lesseq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    );\n\nsolve :: bool_search([m[i, j] | i in rows, j in cols],\n    input_order, indomain_min, complete)\n    satisfy;\n\noutput  [\"bibd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r),\n        \", k = \", show(k), \", lambda = \", show(lambda), \")\\n\\n\"] ++\n        [ ( if j > b then \"\\n\" else show(bool2int(m[i, j])) endif )\n        | i in rows, j in 1..(b + 1)\n        ];\n\n%----------------------------------------------------------------------------%\n%----------------------------------------------------------------------------%", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2060, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d2e19595-0892-4beb-b665-aa6f798d1231": {"__data__": {"id_": "d2e19595-0892-4beb-b665-aa6f798d1231", "embedding": null, "metadata": {"problem_family": "Bus_Driver_Scheduling"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bus_scheduling_csplib", "node_type": "4", "metadata": {"problem_family": "Bus_Driver_Scheduling"}, "hash": "16b56f8a373f70a72716c86591c6aeda37db9a6b05edc16ae12149a259d31f88", "class_name": "RelatedNodeInfo"}}, "text": "%\n% Bus driver scheduling problem (prob022 in CSPLib) in MiniZinc.\n%\n% Specification\n% Bus driver scheduling can be formulated as a set paritioning problem.\n% We propose 12 set partitioning problems derived from small bus driver\n% scheduling problems. These consist of a given set of tasks (pieces of\n% work) to cover and a large set of possible shifts, where each shift\n% covers a subset of the tasks and has an associated cost. We must select\n% a subset of possible shifts that covers each piece of work once and\n% only once: this is called a partition. Further,\n%\n% In the driver scheduling (unlike air crew scheduling) the main aim is\n% to reduce the number of shifts used in the solution partition and the\n% total cost of the partition is secondary. To simplify the problem we have\n% made the cost of each shift the same. This means that the goal is to\n% minimise the number of shifts.\n%\n% The problems come from four different bus companies:\n% Reading (r1 to r5a),\n% CentreWest Ealing area (c1, c1a, c2),\n% the former London Transport (t1 and t2).\n%\n% The problems have differing regulations and features (e.g. urban and\n% short distance rural bus schedules can have very different features). Note\n% that r1 and r1a are the same problem, but have different numbers of\n% generated shifts. Similarly with the problems: c1, c1a and r5, r5a.\n%\n% Problems are presented in the same format as the set partitioning\n% examples in ORLIB. The first line gives the number of rows (pieces of work),\n% columns (shifts) and the minimum number of columns need for a partition.\n% Then each line after that corresponds to one column. It starts with\n% the cost (which is always 1 in our case) then the number of rows it\n% covers, followed by the rows it covers.\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \nint: num_work;\nint: num_shifts;\nint: min_num_shifts;\narray[1..num_shifts] of set of int: shifts;\n\narray[1..num_shifts] of var 0..1: x;\nvar 0..num_shifts: tot_shifts;\n\n% solve minimize tot_shifts;\nsolve :: int_search(\n        x ++ [tot_shifts], \n        first_fail, \n        indomain_min, \n        complete) \n    minimize tot_shifts;\n    % satisfy;\n\nconstraint\n   tot_shifts = sum(x)\n   /\\\n   forall(j in 0..num_work-1) (\n       sum(i in 1..num_shifts) (x[i]*bool2int(j in shifts[i])) = 1\n   )\n   /\\\n   tot_shifts >= min_num_shifts\n\n   % /\\ % for solve satisfy (t1)\n   % tot_shifts = 7\n;\n\n\noutput [\n  \"tot_shifts: \" ++ show(tot_shifts) ++ \"\\n\" ++ \n  \"x: \" ++ show(x) ++ \"\\n\"\n] ++ \n[\n  if fix(x[i]) = 1 then show(shifts[i]) else \"\" endif\n  | i in 1..num_shifts\n] ++ \n[\"\\n\"] ++\n[\n  if fix(x[i]) = 1 then show(i) ++ \" \" else \"\" endif\n  | i in 1..num_shifts\n] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2647, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "457ec603-e982-41b2-9813-cefcf06031af": {"__data__": {"id_": "457ec603-e982-41b2-9813-cefcf06031af", "embedding": null, "metadata": {"problem_family": "Car_Sequencing"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "car", "node_type": "4", "metadata": {"problem_family": "Car_Sequencing"}, "hash": "5b1c339236009d986d2b29e4f23b4f4659bf1a12bef64d7d95bf3df5827cb6ee", "class_name": "RelatedNodeInfo"}}, "text": "%\n% Car sequencing in MiniZinc.\n% include \"globals.mzn\";\n\nint: numclasses;\nint: numoptions;\nint: numcars;\nset of int: Classes = 1..numclasses;\nset of int: Options = 1..numoptions;\nset of int: Slots = 1..numcars;\n\narray[Classes] of int: numberPerClass;\n\narray[Classes,Options] of int: optionsRequired;\narray[Options] of int: windowSize;\narray[Options] of int: optMax;\n\narray[Options] of int: optionNumberPerClass = [sum(j in Classes) (numberPerClass[j] * optionsRequired[j,i]) | i in Options];\n\n% decision variables\n\narray[Slots] of var Classes: slot;\narray[Options, Slots] of var 0..1: setup;\n\n\nvar int: z = sum(s in Classes) (s*slot[s]);\n\n% solve minimize z;\nsolve :: int_search(slot, input_order, indomain_min, complete)\n  satisfy;\n\nconstraint\n  forall(c in Classes ) (\n    sum(s in Slots ) (bool2int(slot[s] = c)) = numberPerClass[c]\n  )\n  /\\\n  forall(o in Options, s in 1..numcars - windowSize[o] + 1) (\n    sum(j in s..s + windowSize[o]- 1) (setup[o,j]) <= optMax[o]\n  )\n  /\\\n  forall(o in Options, s in Slots ) (\n    setup[o,s] = optionsRequired[slot[s],o]\n  )\n  /\\\n  forall(o in Options, i in 1..optionNumberPerClass[o]) (\n    sum(s in 1..(numcars - i * windowSize[o])) (setup[o,s]) >=\n           (optionNumberPerClass[o] - i * optMax[o])\n  )\n;\n\n% for solve satisfy\n% constraint z = 82;\n\n\noutput [\n \"z: \" ++ show(z) ++ \"\\n\" ++\n \"slot: \" ++ show(slot) ++ \"\\n\"\n] ++\n[\n  if j = 1 then \"\\n\" else \" \" endif ++ \n    show(setup[i,j])\n  | i in Options, j in Slots\n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1465, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "57dbe89b-0f50-4ebb-9ae5-fee4f9a9d92c": {"__data__": {"id_": "57dbe89b-0f50-4ebb-9ae5-fee4f9a9d92c", "embedding": null, "metadata": {"problem_family": "Maximum_Clique"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "clique", "node_type": "4", "metadata": {"problem_family": "Maximum_Clique"}, "hash": "768be550f32091c0e12d3ddf566d5f64b1f8b64da7e817f19d4681598f30b4bd", "class_name": "RelatedNodeInfo"}}, "text": "% Maximum Clique Problem\n\nint: n = 5;\narray[1..n, 1..n] of int: adj =\n    [| 0, 1, 0, 1, 0\n     | 1, 0, 1, 0, 0\n     | 0, 1, 0, 1, 1\n     | 1, 0, 1, 0, 1\n     | 0, 0, 1, 1, 0 |];\n\n% --- naive model ---\n\n% decision variables: which vertices are in the clique?\narray[1..n] of var bool: c;\nvar int: size;\n\n% how many vertices have we selected?\nconstraint size = sum(c);\n\n% we can only pick one of any non-adjacent pair of vertices\nconstraint forall (i, j in 1..n where i < j /\\ 0 == adj[i,j]) (bool2int(c[i]) + bool2int(c[j]) <= 1);\n\nsolve maximize size;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 551, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ce5b5f35-1a8f-4c1b-abab-38de98a6cf68": {"__data__": {"id_": "ce5b5f35-1a8f-4c1b-abab-38de98a6cf68", "embedding": null, "metadata": {"problem_family": "Crossfigures"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crossfigure", "node_type": "4", "metadata": {"problem_family": "Crossfigures"}, "hash": "f1e54bff699848253107278fa42ee37f69fc71d82e25a787e3ef8b6eddfe41db", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "819439df-1da9-463d-b9fc-4e37250610eb", "node_type": "1", "metadata": {}, "hash": "a1cc5a99c5e96381d019a6cd5b64f09ab257dc7496b578a6191a8a461d3eb0ef", "class_name": "RelatedNodeInfo"}}, "text": "% Crossfigure problem in MiniZinc.\n% \"\"\"\n% Crossfigures are the numerical equivalent of crosswords. You have a grid and some\n% clues with numerical answers to place on this grid. Clues come in several different\n% forms (for example: Across 1. 25 across times two, 2. five dozen, 5. a square number,\n% 10. prime, 14. 29 across times 21 down ...).\n% \"\"\"\n\n\nint: n = 9;\narray[1..n, 1..n] of var 0..9: M;\n\nset of int: D = 0..9999; % the max length of the numbers in this problem is 4\nvar D: A1;\nvar D: A4;\nvar D: A7;\nvar D: A8;\nvar D: A9;\nvar D: A10;\nvar D: A11;\nvar D: A13;\nvar D: A15;\nvar D: A17;\nvar D: A20;\nvar D: A23;\nvar D: A24;\nvar D: A25;\nvar D: A27;\nvar D: A28;\nvar D: A29;\nvar D: A30;\n\nvar D: D1;\nvar D: D2;\nvar D: D3;\nvar D: D4;\nvar D: D5;\nvar D: D6;\nvar D: D10;\nvar D: D12;\nvar D: D14;\nvar D: D16;\nvar D: D17;\nvar D: D18;\nvar D: D19;\nvar D: D20;\nvar D: D21;\nvar D: D22;\nvar D: D26;\nvar D: D28;\n\n\n%\n% across(Matrix, Across, Len, Row, Col)\n%\tConstrains 'Across' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding across.\n%\npredicate across(array[int, int] of var D: Matrix, var D: Across, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Across)\n   /\\\n   forall(i in 0..Len-1) (\n\n       Matrix[Row,Col+i] = tmp[i+1]\n   )\n;\n\n%\n% down(Matrix, Down, Len, Row, Col):\n%\tConstrains 'Down' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding down.\n%\npredicate down(array[int,int] of var D: Matrix, var D: Down, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Down)\n   /\\\n   forall(i in 0..Len-1) (\n      Matrix[Row+i,Col] = tmp[i+1]\n   )\n;\n\n\n%\n% converts a number <-> array\n%\npredicate toNum10(array[int] of var D: a, var D: n) =\n          let { int: len = length(a) }\n          in\n          n = sum(i in 1..len) (\n            ceil(pow(10.0, int2float(len-i))) * a[i]\n          )\n          /\\ forall(i in 1..len) (a[i] >= 0)\n;\n\n\n%\n% x is a square\n% \npredicate square(var D: x) =\n   exists(y in D) (\n      y*y = x\n   )\n;\n\n\n%\n% very simple primality test\n%\npredicate is_prime(var int: x) =\n   forall(i in 2..ceil(sqrt(9999.0))) ( \n        (i < x) -> (x mod i > 0)\n   )\n;\n\n\nsolve :: int_search(\n         [M[i,j] | i,j in 1..n] ++\n         [A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n         D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28],\n         occurrence,\n         indomain_min,\n         complete\n         ) \n     satisfy;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2631, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "819439df-1da9-463d-b9fc-4e37250610eb": {"__data__": {"id_": "819439df-1da9-463d-b9fc-4e37250610eb", "embedding": null, "metadata": {"problem_family": "Crossfigures"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crossfigure", "node_type": "4", "metadata": {"problem_family": "Crossfigures"}, "hash": "f1e54bff699848253107278fa42ee37f69fc71d82e25a787e3ef8b6eddfe41db", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ce5b5f35-1a8f-4c1b-abab-38de98a6cf68", "node_type": "1", "metadata": {"problem_family": "Crossfigures"}, "hash": "b75b2c72e0384b2087f16ccaa9e9bf5becbfe44a4c1b672cfb13bd875ff3ede3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f79d82ec-48f0-4182-88ac-508aae45fb64", "node_type": "1", "metadata": {}, "hash": "f2f74f9d50042d876e5cbbc3085d505325e51ab895cd8d8cf195f1df7faa1e74", "class_name": "RelatedNodeInfo"}}, "text": "%\n% very simple primality test\n%\npredicate is_prime(var int: x) =\n   forall(i in 2..ceil(sqrt(9999.0))) ( \n        (i < x) -> (x mod i > 0)\n   )\n;\n\n\nsolve :: int_search(\n         [M[i,j] | i,j in 1..n] ++\n         [A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n         D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28],\n         occurrence,\n         indomain_min,\n         complete\n         ) \n     satisfy;\n\n\nconstraint\n\n   % Set up the constraints between the matrix elements and the\n   % clue numbers.\n   across(M, A1, 4, 1, 1)  /\\ \n   across(M, A4, 4, 1, 6)  /\\ \n   across(M, A7, 2, 2, 1)  /\\ \n   across(M, A8, 3, 2, 4)  /\\ \n   across(M, A9, 2, 2, 8)  /\\ \n   across(M, A10, 2, 3, 3) /\\ \n   across(M, A11, 2, 3, 6) /\\ \n   across(M, A13, 4, 4, 1) /\\ \n   across(M, A15, 4, 4, 6) /\\ \n   across(M, A17, 4, 6, 1) /\\ \n   across(M, A20, 4, 6, 6) /\\ \n   across(M, A23, 2, 7, 3) /\\ \n   across(M, A24, 2, 7, 6) /\\ \n   across(M, A25, 2, 8, 1) /\\ \n   across(M, A27, 3, 8, 4) /\\ \n   across(M, A28, 2, 8, 8) /\\ \n   across(M, A29, 4, 9, 1) /\\ \n   across(M, A30, 4, 9, 6) /\\ \n\n   down(M, D1, 4, 1, 1)  /\\ \n   down(M, D2, 2, 1, 2)  /\\ \n   down(M, D3, 4, 1, 4)  /\\ \n   down(M, D4, 4, 1, 6)  /\\ \n   down(M, D5, 2, 1, 8)  /\\ \n   down(M, D6, 4, 1, 9)  /\\ \n   down(M, D10, 2, 3, 3) /\\ \n   down(M, D12, 2, 3, 7) /\\ \n   down(M, D14, 3, 4, 2) /\\ \n   down(M, D16, 3, 4, 8) /\\ \n   down(M, D17, 4, 6, 1) /\\ \n   down(M, D18, 2, 6, 3) /\\ \n   down(M, D19, 4, 6, 4) /\\ \n   down(M, D20, 4, 6, 6) /\\ \n   down(M, D21, 2, 6, 7) /\\ \n   down(M, D22, 4, 6, 9) /\\ \n   down(M, D26, 2, 8, 2) /\\ \n   down(M, D28, 2, 8, 8) /\\", "mimetype": "text/plain", "start_char_idx": 2184, "end_char_idx": 3808, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f79d82ec-48f0-4182-88ac-508aae45fb64": {"__data__": {"id_": "f79d82ec-48f0-4182-88ac-508aae45fb64", "embedding": null, "metadata": {"problem_family": "Crossfigures"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crossfigure", "node_type": "4", "metadata": {"problem_family": "Crossfigures"}, "hash": "f1e54bff699848253107278fa42ee37f69fc71d82e25a787e3ef8b6eddfe41db", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "819439df-1da9-463d-b9fc-4e37250610eb", "node_type": "1", "metadata": {"problem_family": "Crossfigures"}, "hash": "a84375287bf9529854952f2130eba92ead61e9fa6d45e13a0ad51b1eb1c2504b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6781354b-32d3-4437-abe4-344a644df63d", "node_type": "1", "metadata": {}, "hash": "d330b90e77e8bedeb2234ec9120c8965f84fe9150b653393fed1e753d609a714", "class_name": "RelatedNodeInfo"}}, "text": "% Set up the clue constraints.\n%  Across\n%  1 27 across times two\n%  4 4 down plus seventy-one\n%  7 18 down plus four\n%  8 6 down divided by sixteen\n%  9 2 down minus eighteen\n% 10 Dozen in six gross\n% 11 5 down minus seventy\n% 13 26 down times 23 across\n% 15 6 down minus 350\n% 17 25 across times 23 across\n% 20 A square number\n% 23 A prime number\n% 24 A square number\n% 25 20 across divided by seventeen\n% 27 6 down divided by four\n% 28 Four dozen\n% 29 Seven gross\n% 30 22 down plus 450 \n\n   A1 = 2 * A27         /\\ \n   A4 = D4 + 71         /\\ \n   A7 = D18 + 4         /\\ \n   A8 = D6 div 16       /\\ \n   A9 = D2 - 18         /\\ \n   A10 = 6 * 144 div 12 /\\ \n   A11 = D5 - 70        /\\ \n   A13 = D26 * A23      /\\ \n   A15 = D6 - 350       /\\ \n   A17 = A25 * A23      /\\ \n   square(A20)          /\\ \n   is_prime(A23)        /\\\n   square(A24)          /\\ \n   A25 = A20 div 17     /\\ \n   A27 = D6 div 4       /\\ \n   A28 = 4 * 12         /\\ \n   A29 = 7 * 144        /\\ \n   A30 = D22 + 450      /\\ \n\n   % Down\n   %\n   %  1 1 across plus twenty-seven\n   %  2 Five dozen\n   %  3 30 across plus 888\n   %  4 Two times 17 across\n   %  5 29 across divided by twelve\n   %  6 28 across times 23 across\n   % 10 10 across plus four\n   % 12 Three times 24 across\n   % 14 13 across divided by sixteen\n   % 16 28 down times fifteen\n   % 17 13 across minus 399\n   % 18 29 across divided by eighteen\n   % 19 22 down minus ninety-four\n   % 20 20 across minus nine\n   % 21 25 across minus fifty-two\n   % 22 20 down times six\n   % 26 Five times 24 across\n   % 28 21 down plus twenty-seven \n\n   D1 = A1 + 27     /\\ \n   D2 = 5 * 12      /\\ \n   D3 = A30 + 888   /\\ \n   D4 = 2 * A17     /\\ \n   D5 = A29 div 12  /\\ \n   D6 = A28 * A23   /\\ \n   D10 = A10 + 4    /\\ \n   D12 = A24 * 3    /\\ \n   D14 = A13 div 16 /\\ \n   D16 = 15 * D28   /\\ \n   D17 = A13 - 399  /\\ \n   D18 = A29 div 18 /\\ \n   D19 = D22 - 94   /\\ \n   D20 = A20 - 9    /\\ \n   D21 = A25 - 52   /\\ \n   D22 = 6 * D20    /\\ \n   D26 = 5 * A24    /\\ \n   D28 = D21 + 27", "mimetype": "text/plain", "start_char_idx": 3815, "end_char_idx": 5808, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6781354b-32d3-4437-abe4-344a644df63d": {"__data__": {"id_": "6781354b-32d3-4437-abe4-344a644df63d", "embedding": null, "metadata": {"problem_family": "Crossfigures"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crossfigure", "node_type": "4", "metadata": {"problem_family": "Crossfigures"}, "hash": "f1e54bff699848253107278fa42ee37f69fc71d82e25a787e3ef8b6eddfe41db", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f79d82ec-48f0-4182-88ac-508aae45fb64", "node_type": "1", "metadata": {"problem_family": "Crossfigures"}, "hash": "74faba9f7fa2c345245fbcdc2981f015eaa9b5025eb18025822b64ff4c3173d8", "class_name": "RelatedNodeInfo"}}, "text": "% Fix the blackboxes\n   /\\\n   M[1,5] = 0 /\\\n   M[2,3] = 0 /\\\n   M[2,7] = 0 /\\\n   M[3,2] = 0 /\\\n   M[3,5] = 0 /\\\n   M[3,8] = 0 /\\\n   M[4,5] = 0 /\\\n   M[5,1] = 0 /\\\n   M[5,3] = 0 /\\\n   M[5,4] = 0 /\\\n   M[5,5] = 0 /\\\n   M[5,6] = 0 /\\\n   M[5,7] = 0 /\\\n   M[5,9] = 0 /\\\n   M[6,5] = 0 /\\\n   M[7,2] = 0 /\\\n   M[7,5] = 0 /\\\n   M[7,8] = 0 /\\\n   M[8,3] = 0 /\\\n   M[8,7] = 0 /\\\n   M[9,5] = 0\n;\n\n\noutput [\n show([A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n       D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28]), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(M[i,j])\n  | i,j  in 1..n\n] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 5814, "end_char_idx": 6458, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dcf18f80-383b-45a9-98ab-902162562c42": {"__data__": {"id_": "dcf18f80-383b-45a9-98ab-902162562c42", "embedding": null, "metadata": {"problem_family": "Balanced_Academic_Curriculum_Problem__BACP_"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "curriculum", "node_type": "4", "metadata": {"problem_family": "Balanced_Academic_Curriculum_Problem__BACP_"}, "hash": "b815ea9c0cc90c8d3477085bb3711c8e4bbcbfb83d6864f655b95f3e4eec2184", "class_name": "RelatedNodeInfo"}}, "text": "% The balanced academic curriculum problem:\n%\n% A curriculum is a set of courses with prerequisites.\n% Each course must be assigned within a set number of periods.\n% A course cannot be scheduled before its prerequisites.\n% Each course confers a number of academic credits (it's \"load\").\n% Students have lower and upper bounds on the number of credits they can study for in a given period.\n% Students have lower and upper bounds on the number of courses they can study for in a given period.\n% The goal is to assign a period to every course satisfying these criteria, minimising the load for all periods.\n\ninclude \"globals.mzn\";\n\nint: n_courses;\nint: n_periods;\nint: load_per_period_lb;\nint: load_per_period_ub;\nint: courses_per_period_lb;\nint: courses_per_period_ub;\narray [1..n_courses] of int: course_load;\nint: max_course_load = sum(c in courses)(course_load[c]);\n\nset of int: courses = 1..n_courses;\nset of int: periods = 1..n_periods;\n\n% period course is assigned to\narray [courses] of var periods: course_period;\n% whether period i has course j assigned\narray [periods, courses] of var 0..1: x;\n% total load for each period\narray [periods] of var load_per_period_lb..load_per_period_ub: load;\n% optimisation target\nvar load_per_period_lb..load_per_period_ub: objective;\n\nconstraint forall(p in periods) (\n    forall(c in courses) (x[p,c] = bool2int(course_period[c] = p)) /\\\n    sum(i in courses) (x[p,i]) >= courses_per_period_lb /\\\n    sum(i in courses) (x[p,i]) <= courses_per_period_ub /\\\n    load[p] = sum(c in courses) (x[p,c] * course_load[c]) /\\\n    load[p] >= load_per_period_lb /\\\n    load[p] <= objective\n);\n\n% prerequisite(a, b) means \"course a has prerequisite course b\".\n\npredicate prerequisite(courses: a, courses: b) =\n    course_period[b] < course_period[a];\n\n% add some redundant linear constraints\n\nconstraint forall(p in 0..n_periods-1) (\n    let {\n\t\tvar 0..max_course_load: l = sum(c in courses) (bool2int(course_period[c] > p) * course_load[c])\n\t} in \n        l >= (n_periods-p) * load_per_period_lb /\\\n        l <= (n_periods-p) * objective\n    );\n\nsolve :: seq_search([\n      int_search([x[i,j] | i in periods, j in courses], input_order, indomain_max, complete),\n      int_search([objective], input_order, indomain_min, complete)\n    ]) minimize objective;\n\noutput \n    [show(c) ++ \"-\" ++ show(course_period[c]) ++ \"\\t\" | c in courses ] ++ [\"\\n\"] ++\n    [\"objective = \", show(objective)];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2419, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ff84eb52-5167-4fb0-b69f-389a3fa9e2d6": {"__data__": {"id_": "ff84eb52-5167-4fb0-b69f-389a3fa9e2d6", "embedding": null, "metadata": {"problem_family": "Diamond-free_Degree_Sequences"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "diamond_free_degree_sequence", "node_type": "4", "metadata": {"problem_family": "Diamond-free_Degree_Sequences"}, "hash": "5aed6785fb38b20e0ba4a3ea224d72a80602ea0d4f36196bc0f8a038a25d6d73", "class_name": "RelatedNodeInfo"}}, "text": "%\n% Diamond-free Degree Sequence (CSPLib #50) in MiniZinc.\n%\n% Given a simple undirected graph G=(V,E), where V is the set of vertices and E the set of\n% undirected edges, the edge {u,v} is in E if and only if vertex u is adjacent to vertex v\u2208G.\n% The graph is simple in that there are no loop edges, i.e. we have no edges of the form {v,v}.\n% Each vertex v\u2208V has a degree dv i.e. the number of edges incident on that vertex. Consequently\n% a graph has a degree sequence d1,\u2026,dn, where di>=di+1. A diamond is a set of four vertices\n% in V such that there are at least five edges between those vertices. Conversely, a graph is\n% diamond-free if it has no diamond as an induced subgraph, i.e. for every set of four vertices\n% the number of edges between those vertices is at most four.\n%\n% In our problem we have additional properties required of the degree sequences of the graphs,\n% in particular that the degree of each vertex is greater than zero (i.e. isolated vertices\n% are disallowed), the degree of each vertex is modulo 3, and the sum of the degrees is\n% modulo 12 (i.e. |E| is modulo 6).\n%\n% The problem is then for a given value of n, produce all unique degree sequences d1,\u2026,dn such\n% that\n%\n%  * di\u2265di+1\n%  * each degree di>0 and di is modulo 3\n%  * the sum of the degrees is modulo 12\n%  * there exists a simple diamond-free graph with that degree sequence\n\n\ninclude \"globals.mzn\"; \n\nint: n = 11;\n\n% decision variables\narray[1..n,1..n] of var 0..1: x;\narray[1..n] of var 1..n: degrees;\n\n\n% solve satisfy;\nsolve :: int_search(degrees, first_fail, indomain_split, complete) satisfy;\n\nconstraint\n  forall(i,j,k,l in 1..n where i < j /\\ j < k /\\ k < l) (\n     x[i,j] + x[i,k] + x[i,l] + x[j,k] + x[j,l] + x[k,l] <= 4\n  )\n  /\\\n  forall(i in 1..n) (\n     degrees[i] = sum([x[i,j] | j in 1..n])\n     /\\ degrees[i] mod 3 = 0\n     % no loops\n     /\\ x[i,i] = 0\n  ) \n  /\\ % undirected graph\n  forall(i,j in 1..n) (\n    x[i,j] = x[j,i]\n  )\n  /\\ sum(degrees) mod 12 = 0\n\n  % symmetry breaking\n  /\\ decreasing(degrees)\n  /\\ lex2(x)\n;\n\noutput \n[ \"degrees: \", show(degrees), \"\\n\"]\n% ++\n% [\n%   if j = 1 then \"\\n\" else \" \" endif ++\n%     show(x[i,j])\n%   | i,j in 1..n\n% ]\n;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2171, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "176afb79-57bb-41d9-b6f8-7534a91370ae": {"__data__": {"id_": "176afb79-57bb-41d9-b6f8-7534a91370ae", "embedding": null, "metadata": {"problem_family": "The_n-Fractions_Puzzle"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fractions", "node_type": "4", "metadata": {"problem_family": "The_n-Fractions_Puzzle"}, "hash": "9ee067a53b941e6046074f703b7705248353a5ab9e82a82ba830255d651b15b7", "class_name": "RelatedNodeInfo"}}, "text": "%\n% Fractions problem in MiniZinc.\n%\n% Prolog benchmark problem (BProlog)\n% \"\"\"\n% Find distinct non-zero digits such that the following equation holds:\n%        A        D        G\n%     ------  + ----- + ------  = 1\n%       B*C      E*F      H*I\n\ninclude \"globals.mzn\"; \n\nvar 1..9: A;\nvar 1..9: B;\nvar 1..9: C;\nvar 1..9: D;\nvar 1..9: E;\nvar 1..9: F;\nvar 1..9: G;\nvar 1..9: H;\nvar 1..9: I;\narray[1..9] of var 1..9: Vars=[A,B,C,D,E,F,G,H,I];\n\nvar 1..81: D1;\nvar 1..81: D2;\nvar 1..81: D3;\n\n\n\n% solve satisfy;\nsolve :: int_search(Vars ++ [D1,D2,D3], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   all_different(Vars) /\\\n   D1 = 10*B+C /\\\n   D2 = 10*E+F /\\\n   D3 = 10*H+I /\\\n   A*D2*D3 + D*D1*D3 + G*D1*D2 = D1*D2*D3 /\\\n   % break the symmetry\n   A*D2 >= D*D1 /\\\n   D*D3 >= G*D2 /\\\n   %redundant constraints\n   3*A >= D1 /\\\n   3*G <= D2\n\n;\n\noutput [\n  show(Vars), \"\\n\"\n]\n;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 881, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fc4b0349-a5c0-4735-8407-3a83942db3ef": {"__data__": {"id_": "fc4b0349-a5c0-4735-8407-3a83942db3ef", "embedding": null, "metadata": {"problem_family": "Social_Golfers_Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golfers", "node_type": "4", "metadata": {"problem_family": "Social_Golfers_Problem"}, "hash": "cb79b47d157344e2cab6b26cbdf008b8d3ddacc075ccf91a0c5c7a834e82ae79", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "be27bbed-354b-4957-be62-8357a1a71283", "node_type": "1", "metadata": {}, "hash": "9ce0013aec78c85b5423518c8e683fcb83f813ec5fb7c1804e0898ddbe891e99", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n\n% The social golfers problem\n% A club has a number of golfers that play rounds in groups (the number of\n% golfers is a multiple of the number of groups).  Each round, a golfer\n% plays with a group of different people, such that the same pair of golfers\n% never play together twice.\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\nset of int: places = 1..n_golfers;\n\narray [rounds, places] of var golfers: round_place_golfer;\narray [golfers, golfers] of var 0..n_rounds: golfer_golfer_round;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (p in places) (round_place_golfer[r, p])\n    );\n\n    % Break some symmetry by strictly ordering each group in each round.\n    %\nconstraint\n    forall (r in rounds, p in places) (\n        if p mod n_per_group != 0\n        then round_place_golfer[r, p] < round_place_golfer[r, p + 1]\n        else true\n        endif\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (r in rounds, g in 0..(n_groups - 1), i, j in 1..n_per_group\n            where i < j) (\n        golfer_golfer_round[\n            round_place_golfer[r, n_per_group * g + i],\n            round_place_golfer[r, n_per_group * g + j]\n        ] = r\n    );\n\nsolve\n    :: int_search([round_place_golfer[r, p] | r in rounds, p in places],\n        first_fail, indomain_min, complete)\n    satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if p = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif ) ++\n    ( if p mod n_per_group = 1 then \"   \" else \" \" endif ) ++\n    show_int(2, round_place_golfer[r, p]) | r in rounds, p in places\n];\n\n\nModel 2 :", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2086, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "be27bbed-354b-4957-be62-8357a1a71283": {"__data__": {"id_": "be27bbed-354b-4957-be62-8357a1a71283", "embedding": null, "metadata": {"problem_family": "Social_Golfers_Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golfers", "node_type": "4", "metadata": {"problem_family": "Social_Golfers_Problem"}, "hash": "cb79b47d157344e2cab6b26cbdf008b8d3ddacc075ccf91a0c5c7a834e82ae79", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fc4b0349-a5c0-4735-8407-3a83942db3ef", "node_type": "1", "metadata": {"problem_family": "Social_Golfers_Problem"}, "hash": "0de4b95b4c648edaf8f6deae99b662041987daa723f10887743158ce9977384c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ae5326b8-5733-40ac-83ac-1a79339c234e", "node_type": "1", "metadata": {}, "hash": "e92b3d85be42002bd6d0d67d7fb636724355c430774aae379300a6c18730b66e", "class_name": "RelatedNodeInfo"}}, "text": "Model 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups, group] of var golfers: round_group_i_golfer;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (g in groups, i in group) (round_group_i_golfer[r, g, i])\n    );\n\n    % We also break some symmetry\n    % here by strictly ordering each group.\n    %\nconstraint\n    forall (r in rounds, g in groups, i in group where i < n_per_group) (\n        round_group_i_golfer[r, g, i] < round_group_i_golfer[r, g, i + 1]\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups, i, j in group where i < j) (\n            bool2int(\n                round_group_i_golfer[r, g, i] = a\n            /\\  round_group_i_golfer[r, g, j] = b\n            )\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if g = 1 /\\ i = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif) ++\n    ( if i = 1 then \"   \" else \" \" endif) ++\n    show_int(2, round_group_i_golfer[r, g, i]) \n    |  r in rounds, g in groups, i in group\n];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups] of var set of golfers: round_group_golfers;\n\n    % Each group has to have the right size.\n    %\nconstraint\n    forall (r in rounds, g in groups) (\n        card(round_group_golfers[r, g]) = n_per_group\n    );\n\n    % Each group in each round has to be disjoint.\n    %\nconstraint\n    forall (r in rounds) (\n        all_disjoint (g in groups) (round_group_golfers[r, g])\n    );\n\n    % Symmetry breaking.\n    %\n% constraint\n%     forall (r in rounds, g in groups where g < n_groups) (\n%         round_group_golfers[r, g] < round_group_golfers[r, g + 1]\n%     );\n\n    % Each pair may play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups) (\n            bool2int({a, b} subset round_group_golfers[r, g])\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [    ( if   g = 1\n              then \"\\nround \" ++ show(r) ++ \":   \"\n              else \"   \"\n              endif\n            ) ++\n            show(round_group_golfers[r, g])\n       |    r in rounds, g in groups\n       ];\n\n\nModel 4 :", "mimetype": "text/plain", "start_char_idx": 2077, "end_char_idx": 5257, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ae5326b8-5733-40ac-83ac-1a79339c234e": {"__data__": {"id_": "ae5326b8-5733-40ac-83ac-1a79339c234e", "embedding": null, "metadata": {"problem_family": "Social_Golfers_Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golfers", "node_type": "4", "metadata": {"problem_family": "Social_Golfers_Problem"}, "hash": "cb79b47d157344e2cab6b26cbdf008b8d3ddacc075ccf91a0c5c7a834e82ae79", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "be27bbed-354b-4957-be62-8357a1a71283", "node_type": "1", "metadata": {"problem_family": "Social_Golfers_Problem"}, "hash": "4c827deeff3eb386c8afcef58c40c2bb54158f718ae33ffd36a11b576d2c5bad", "class_name": "RelatedNodeInfo"}}, "text": "Model 4 :\n\n\nint: weeks = 4;\nint: groups = 3;\nint: groupSize = 3;\nint: golfers = groups * groupSize;\n\nset of int: Golfer = 1..golfers;\nset of int: Week = 1..weeks;\nset of int: Group = 1..groups;\n\n% Search space: The set of all possible group assignments to all \n% players in each of the weeks\narray[Golfer, Week] of var Group: assign;\n\n% solve satisfy;\n% solve :: int_search([assign[i,j] | i in Golfer, j in Week ], \"first_fail\", \"indomain\", \"complete\") satisfy;\nsolve :: int_search([assign[i,j] | i in Golfer, j in Week ], \n        first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each group has exactly groupSize players\n   forall (gr in Group, w in Week)( % c1\n     sum (g in Golfer) (bool2int(assign[g,w] = gr)) = groupSize\n   )\n   /\\\n   % C2: Each pair of players only meets at most once\n   forall (g1, g2 in Golfer, w1, w2 in Week  where g1 != g2 /\\ w1 != w2) (\n     (bool2int(assign[g1,w1] = assign[g2,w1]) + bool2int(assign[g1,w2] = assign[g2,w2])) <= 1\n   )\n  /\\\n  % SBSA: Symmetry-breaking by selective assignment\n  % On the first week, the first groupSize golfers play in group 1, the \n  % second groupSize golfers play in group 2, etc. On the second week, \n  % golfer 1 plays in group 1, golfer 2 plays in group 2, etc.\n  forall(g in Golfer) (\n    assign[g,1]=((g-1) div groupSize) + 1 % \n  )\n  /\\\n  forall(g in Golfer where g <= groupSize)(\n    assign[g,2]=g\n  )\n\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n  show(assign[i,j])\n  | i in Golfer, j in Week\n] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 5248, "end_char_idx": 6751, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "19ce32c5-ae5c-43f3-9596-427f9228d19b": {"__data__": {"id_": "19ce32c5-ae5c-43f3-9596-427f9228d19b", "embedding": null, "metadata": {"problem_family": "Golomb_rulers"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golomb", "node_type": "4", "metadata": {"problem_family": "Golomb_rulers"}, "hash": "e164f02c20efdcfa49a91ff147364260f90bde6c42300d031dede842a93e9061", "class_name": "RelatedNodeInfo"}}, "text": "% Golomb rulers\n% From csplib:\n% A Golomb ruler may be defined as a set of m integers 0 = a_1 < a_2 <\n% ... < a_m such that the m(m-1)/2 differences a_j - a_i, 1 <= i < j\n% <= m are distinct. Such a ruler is said to contain m marks and is of\n% length a_m. The objective is to find optimal (minimum length) or\n% near optimal rulers.\n%\n% This is the \"ternary constraints and an alldifferent\" model\n\ninclude \"globals.mzn\";\n\nint: m;\nint: n = m*m;\n\narray[1..m] of var 0..n: mark;\n\narray[1..(m*(m-1)) div 2] of var 0..n: differences =\n    [ mark[j] - mark[i] | i in 1..m, j in i+1..m];\n\nconstraint mark[1] = 0;\n\nconstraint forall ( i in 1..m-1 ) ( mark[i] < mark[i+1] );\n\nconstraint alldifferent(differences);\n\n    % Symmetry breaking\nconstraint differences[1] < differences[(m*(m-1)) div 2];\n\nsolve :: int_search(mark, input_order, indomain, complete)\n    minimize mark[m];\n\noutput [show(mark)];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1051, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "29918f34-c21b-437f-90c7-fb2b74773a33": {"__data__": {"id_": "29918f34-c21b-437f-90c7-fb2b74773a33", "embedding": null, "metadata": {"problem_family": "Graceful_Graphs"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "K4xP2Graceful", "node_type": "4", "metadata": {"problem_family": "Graceful_Graphs"}, "hash": "2cbb1b36bfb3292aa8784de4bbf5798b807a859cdc1add92a1064622f0bb1895", "class_name": "RelatedNodeInfo"}}, "text": "% K4P2 Graceful Graph in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: m = 16;\nint: n = 8;\narray[1..n] of var 0..m: nodes;\narray[1..m, 1..2] of var 1..n: graph;\narray[1..m] of var 1..m: edges;\n\n\n\nsolve :: int_search(nodes, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..m) (\n    abs(nodes[graph[i,1]] - nodes[graph[i,2]]) = edges[i]  \n  )\n  /\\\n  all_different(edges) \n  /\\ \n  all_different(nodes)\n;\n\ngraph =\narray2d(1..m, 1..2,\n[1, 2,\n1, 3,\n1, 4,\n2, 3,\n2, 4,\n3, 4,\n\n5, 6,\n5, 7,\n5, 8,\n6, 7,\n6, 8,\n7, 8,\n\n1, 5,\n2, 6,\n3, 7,\n4, 8]);\n\noutput\n[\n  \"nodes: \" ++ show(nodes) ++ \"\\n\" ++\n  \"edges: \" ++ show(edges) ++ \"\\n\"\n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 636, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e7c4b030-7194-4690-8986-704101cdfc8d": {"__data__": {"id_": "e7c4b030-7194-4690-8986-704101cdfc8d", "embedding": null, "metadata": {"problem_family": "Killer_Sudoku"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "killer_sudoku", "node_type": "4", "metadata": {"problem_family": "Killer_Sudoku"}, "hash": "846cf47b8f9b05929e05f5800f31c0f01397d2dfc65615372b3fb6ddfb80119d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "75481c62-5655-4f83-9e12-72652b06aba1", "node_type": "1", "metadata": {}, "hash": "5ece27f22c2a325f4f0732c25f9e14b2f7cc602e887cc41c2b4d06906bf623a9", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n%\n% Killer Sudoku in MiniZinc.\n\n%   Killer sudoku (also killer su doku, sumdoku, sum doku, addoku, or\n%   samunamupure) is a puzzle that combines elements of sudoku and kakuro.\n%   Despite the name, the simpler killer sudokus can be easier to solve\n%   than regular sudokus, depending on the solver's skill at mental arithmetic;\n%   the hardest ones, however, can take hours to crack.\n \n%   The objective is to fill the grid with numbers from 1 to 9 in a way that\n%   the following conditions are met:\n \n%     * Each row, column, and nonet contains each number exactly once.\n%     * The sum of all numbers in a cage must match the small number printed\n%       in its corner.\n%     * No number appears more than once in a cage. (This is the standard rule\n%       for killer sudokus, and implies that no cage can include more\n%       than 9 cells.)\n \n%   In 'Killer X', an additional rule is that each of the long diagonals\n%   contains each number once.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 963, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "75481c62-5655-4f83-9e12-72652b06aba1": {"__data__": {"id_": "75481c62-5655-4f83-9e12-72652b06aba1", "embedding": null, "metadata": {"problem_family": "Killer_Sudoku"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "killer_sudoku", "node_type": "4", "metadata": {"problem_family": "Killer_Sudoku"}, "hash": "846cf47b8f9b05929e05f5800f31c0f01397d2dfc65615372b3fb6ddfb80119d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e7c4b030-7194-4690-8986-704101cdfc8d", "node_type": "1", "metadata": {"problem_family": "Killer_Sudoku"}, "hash": "69b90917f5d9037ac5dc0a32594a8b331a5bcc5796869b035a21d93f9a885949", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d0ff85b2-464d-4048-aaee-4d97fcb04ef5", "node_type": "1", "metadata": {}, "hash": "fc6087444ace75ab9d6b9105c4c71520d3cdd692c12c641a2d7a07a2b6d774b9", "class_name": "RelatedNodeInfo"}}, "text": "%   Despite the name, the simpler killer sudokus can be easier to solve\n%   than regular sudokus, depending on the solver's skill at mental arithmetic;\n%   the hardest ones, however, can take hours to crack.\n \n%   The objective is to fill the grid with numbers from 1 to 9 in a way that\n%   the following conditions are met:\n \n%     * Each row, column, and nonet contains each number exactly once.\n%     * The sum of all numbers in a cage must match the small number printed\n%       in its corner.\n%     * No number appears more than once in a cage. (This is the standard rule\n%       for killer sudokus, and implies that no cage can include more\n%       than 9 cells.)\n \n%   In 'Killer X', an additional rule is that each of the long diagonals\n%   contains each number once.\n%   \"\"\"\n \n\nint: num_p = 29; % number of segments\nint: num_hints = 4;  % number of hints per segments (that's max number of hints)\nint: max_val = 100;\narray[1..num_p, 1..2*num_hints+1] of 0..max_val: P =\n  array2d(1..num_p, 1..2*num_hints+1, [\n    1,1,  1,2, 0,0, 0,0,   3,\n    1,3,  1,4, 1,5, 0,0,  15,\n    1,6,  2,5, 2,6, 3,5,  22,\n    1,7,  2,7, 0,0, 0,0,   4,\n    1,8,  2,8, 0,0, 0,0,  16,\n    1,9,  2,9, 3,9, 4,9,  15,\n    2,1,  2,2, 3,1, 3,2,  25,\n    2,3,  2,4, 0,0, 0,0,  17,\n    3,3,  3,4, 4,4, 0,0,   9,\n    3,6,  4,6, 5,6, 0,0,   8,\n    3,7,  3,8, 4,7, 0,0,  20,\n    4,1,  5,1, 0,0, 0,0,   6,\n    4,2,  4,3, 0,0, 0,0,  14,\n    4,5,  5,5, 6,5, 0,0,  17,\n    4,8,  5,7, 5,8, 0,0,  17,\n    5,2,  5,3, 6,2, 0,0,  13,\n    5,4,  6,4, 7,4, 0,0,  20,\n    5,9,  6,9, 0,0, 0,0,  12,\n    6,1,  7,1, 8,1, 9,1,  27,\n    6,3,  7,2, 7,3, 0,0,   6,\n    6,6,  7,6, 7,7, 0,0,  20,\n    6,7,  6,8, 0,0, 0,0,   6,\n    7,5,  8,4, 8,5, 9,4,  10,\n    7,8,  7,9, 8,8, 8,9,  14,\n    8,2,  9,2, 0,0, 0,0,   8,\n    8,3,  9,3, 0,0, 0,0,  16,\n    8,6,  8,7, 0,0, 0,0,  15,\n    9,5,  9,6, 9,7, 0,0,  13,\n    9,8,  9,9, 0,0, 0,0,  17\n   ]);", "mimetype": "text/plain", "start_char_idx": 188, "end_char_idx": 2082, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d0ff85b2-464d-4048-aaee-4d97fcb04ef5": {"__data__": {"id_": "d0ff85b2-464d-4048-aaee-4d97fcb04ef5", "embedding": null, "metadata": {"problem_family": "Killer_Sudoku"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "killer_sudoku", "node_type": "4", "metadata": {"problem_family": "Killer_Sudoku"}, "hash": "846cf47b8f9b05929e05f5800f31c0f01397d2dfc65615372b3fb6ddfb80119d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "75481c62-5655-4f83-9e12-72652b06aba1", "node_type": "1", "metadata": {"problem_family": "Killer_Sudoku"}, "hash": "2fb341241474a0eb2918ba6955f5f3d0cb7117cd76a42e01630094346e8b1b11", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "19d2f517-f636-420d-8d7d-2d1cb8f3db50", "node_type": "1", "metadata": {}, "hash": "4af3abeb40dd5e6c1367cc55c0bcbd3493ac5e7166f13adc22a0418c1ea07f53", "class_name": "RelatedNodeInfo"}}, "text": "% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n \n  forall(i in 1..n) (\n        all_different([x[i,j] | j in 1..n]) /\\\n        all_different([x[j,i] | j in 1..n])\n  )\n  /\\\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n  /\\ % calculate the hints\n  forall(p in 1..num_p) (\n     sum(i in 1..num_hints where P[p,2*(i-1)+1] > 0) (x[  P[p, 2*(i-1)+1], P[p,2*(i-1)+2]  ]) = P[p, 2*num_hints+1]\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];\n\n\nModel 2 :", "mimetype": "text/plain", "start_char_idx": 2085, "end_char_idx": 2702, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "19d2f517-f636-420d-8d7d-2d1cb8f3db50": {"__data__": {"id_": "19d2f517-f636-420d-8d7d-2d1cb8f3db50", "embedding": null, "metadata": {"problem_family": "Killer_Sudoku"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "killer_sudoku", "node_type": "4", "metadata": {"problem_family": "Killer_Sudoku"}, "hash": "846cf47b8f9b05929e05f5800f31c0f01397d2dfc65615372b3fb6ddfb80119d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d0ff85b2-464d-4048-aaee-4d97fcb04ef5", "node_type": "1", "metadata": {"problem_family": "Killer_Sudoku"}, "hash": "0e5a941f053394711565fad366cd174aa403aedd5ebcf80878b1cb1350f65541", "class_name": "RelatedNodeInfo"}}, "text": "Model 2 :\n\n\ninclude \"globals.mzn\"; \nint: n = 9;\narray[1..n, 1..n] of var 1..9: x;\n\nint: num_segments = 29; % number of segments\n\narray[1..n, 1..n] of int: segments =\narray2d(1..n, 1..n,\n[\n  1, 1, 2, 2, 2, 3, 4, 5, 6, % 1\n  7, 7, 8, 8, 3, 3, 4, 5, 6, % 2\n  7, 7, 9, 9, 3,10,11,11, 6, % 3\n 13,14,14, 9,15,10,11,12, 6, % 4\n 13,16,16,17,15,10,12,12,18, % 5\n 19,16,20,17,15,21,22,22,18, % 6\n 19,20,20,17,23,21,21,24,24, % 7\n 19,25,26,23,23,27,27,24,24, % 8\n 19,25,26,23,28,28,28,29,29, % 9\n]);\n\narray[1..num_segments] of int: segment_sums =\n[\n   3, % 1\n  15, % 2\n  22, % 3\n   4, % 4\n  16, % 5\n  15, % 6\n  25, % 7\n  17, % 8\n   9, % 9\n   8, % 10\n  20, % 11\n  17, % 12\n   6, % 13\n  14, % 14\n  17, % 15\n  13, % 16\n  20, % 17\n  12, % 18\n  27, % 19\n   6, % 20\n  20, % 21\n   6, % 22\n  10, % 23\n  14, % 24\n   8, % 25\n  16, % 26\n  15, % 27\n  13, % 28\n  17  % 29\n];\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\n% Standard Sudoku constraints\nconstraint\n  % rows and columns\n  forall(i in 1..n) (\n     all_different([x[i,j] | j in 1..n]) /\\\n     all_different([x[j,i] | j in 1..n])\n  )\n  /\\ % blocks\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n;\n\n% Handle the segments\nconstraint\n  forall(p in 1..num_segments) (\n    segment_sums[p] = sum([x[i,j] | i,j in 1..n where segments[i,j] = p])\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];", "mimetype": "text/plain", "start_char_idx": 2693, "end_char_idx": 4176, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ed3d5303-2f28-4fff-94e4-0d39ba4ea60f": {"__data__": {"id_": "ed3d5303-2f28-4fff-94e4-0d39ba4ea60f", "embedding": null, "metadata": {"problem_family": "Langford_s_number_problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "langford", "node_type": "4", "metadata": {"problem_family": "Langford_s_number_problem"}, "hash": "468937e1a91a28800007aba2a138d9e5ac594dd82bbee22b60f755fed554fb04", "class_name": "RelatedNodeInfo"}}, "text": "% Langford's number problem in MiniZinc.\n%\n% Arrange 2 sets of positive integers 1..k to a sequence,\n% such that, following the first occurence of an integer i,\n% each subsequent occurrence of i, appears i+1 indices later\n% than the last.\n% For example, for k=4, a solution would be 41312432\n\ninclude \"globals.mzn\";\n\nint: k;\nset of int: positionDomain = 1..2*k;\n\narray[positionDomain] of var positionDomain: position;\n% better presentation:\narray[positionDomain] of var 1..k: solution;\n\nsolve :: int_search(position, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..k) (\n     position[i+k] = position[i] + i+1 /\\\n     % hakank: added this\n     solution[position[i]] = i /\\ \n     solution[position[k+i]] = i\n  )\n  /\\   \n  all_different(position)\n  /\\ % symmetry breaking\n  solution[1] < solution[2*k]\n;\n\n\noutput [\n  show(solution), \"\\n\"\n\n];\n\n%\n% data\n%\nk = 4;\n% k = 7;\n% k = 8;\n% k = 10;\n% k = 20;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 921, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0ee4cf4e-a7d8-4935-a81d-1e9523557acb": {"__data__": {"id_": "0ee4cf4e-a7d8-4935-a81d-1e9523557acb", "embedding": null, "metadata": {"problem_family": "Magic_Hexagon"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_hexagon", "node_type": "4", "metadata": {"problem_family": "Magic_Hexagon"}, "hash": "be2199999e1dd49470c5059433cb11fc77370940a85a3f80afcc85234562fb41", "class_name": "RelatedNodeInfo"}}, "text": "% Magic Hexagon in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nset of int: N = 1..19;\nvar N: a;\nvar N: b;\nvar N: c;\nvar N: d;\nvar N: e;\nvar N: f;\nvar N: g;\nvar N: h;\nvar N: i;\nvar N: j;\nvar N: k;\nvar N: l;\nvar N: m;\nvar N: n;\nvar N: o;\nvar N: p;\nvar N: q;\nvar N: r;\nvar N: s;\n\narray[N] of var N: LD = [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s];\n\nsolve satisfy;\n\nconstraint\n  all_different(LD) /\\\n\n  a + b + c =  38 /\\\n  d + e + f + g =  38 /\\\n  h + i + j + k + l =  38 /\\ \n  m + n + o + p =  38 /\\ \n  q + r + s =  38 /\\ \n  a + d + h =  38 /\\ \n  b + e + i + m =  38 /\\ \n  c + f + j + n + q =  38 /\\ \n  g + k + o + r =  38 /\\ \n  l + p + s =  38 /\\ \n  c + g + l =  38 /\\ \n  b + f + k + p =  38 /\\ \n  a + e + j + o + s =  38 /\\ \n  d + i + n + r =  38 /\\ \n  h + m + q =  38 /\\ \n\n  a < c /\\\n  a < h /\\\n  a < l /\\\n  a < q /\\\n  a < s /\\\n  c < h\n;\n\noutput\n[\n  show(LD)\n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 869, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4fff1322-f056-4737-8944-f8414ea747ad": {"__data__": {"id_": "4fff1322-f056-4737-8944-f8414ea747ad", "embedding": null, "metadata": {"problem_family": "Magic_Squares_and_Sequences"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_sequence", "node_type": "4", "metadata": {"problem_family": "Magic_Squares_and_Sequences"}, "hash": "7f2b60d3151598d681273ea22d678e50223ed105a27fd52386b745f48016ef83", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "743821a7-ccf6-4eab-85e8-bdf91306e96f", "node_type": "1", "metadata": {}, "hash": "3a0b4d584e9fbb1f37a3cb9c222f5c87e9f8e19a3a42ddce1e31b2221b026e3e", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n% Magic sequence in MiniZinc.\n% A magic sequence of length n is a sequence of integers x0 . . xn-1 between 0 and n-1, such that for all i in 0 to n-1, the number i occurs exactly xi times in the sequence. For instance, 6,2,1,0,0,0,1,0,0,0 is a magic sequence since 0 occurs 6 times in it, 1 occurs twice, ...\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n  forall(i in 0..n-1) (\n    s[i] = sum(j in 0..n-1) (bool2int(s[j] = i))\n  )\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 2 : \n\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n        forall(i in 0..n-1) (\n                s[i] = sum(j in 0..n-1) (bool2int(s[j]=i))\n        )\n        /\\ \n        sum(i in 0..n-1) (s[i])=n \n        /\\\n        sum(i in 0..n-1) (s[i]*i) =n\n;\n\n\noutput [\n       show(s), \"\\n\",\n];\n\n\n\nModel 3 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  10;\narray[0..n-1] of var 0..n-1: s;\narray[0..n-1] of int: value = array1d(0..n-1, [i | i in 0..n-1]); % helper for distribute\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   distribute(s, value, s)         /\\ \n   sum(i in 0..n-1) (s[i])   = n   /\\\n   sum(i in 0..n-1) (s[i]*i) = n\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 4 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  100;\narray[0..n-1] of var 0..n-1: s;\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   global_cardinality(s,array1d(0..n-1, set2array(index_set(s))), s) :: domain\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\nModel 5 : \n\n\n% Magic squares in MiniZinc\n\ninclude \"globals.mzn\";\n\nint: n = 3;\n\nint: total = ( n * (n*n + 1)) div 2;\narray[1..n,1..n] of var 1..n*n: magic;\n\n\n% solve satisfy;\nsolve :: int_search(\n        [magic[i,j] | i in 1..n, j in 1..n], \n        first_fail,\n        indomain_min,\n        complete) \n    satisfy;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1867, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "743821a7-ccf6-4eab-85e8-bdf91306e96f": {"__data__": {"id_": "743821a7-ccf6-4eab-85e8-bdf91306e96f", "embedding": null, "metadata": {"problem_family": "Magic_Squares_and_Sequences"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_sequence", "node_type": "4", "metadata": {"problem_family": "Magic_Squares_and_Sequences"}, "hash": "7f2b60d3151598d681273ea22d678e50223ed105a27fd52386b745f48016ef83", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4fff1322-f056-4737-8944-f8414ea747ad", "node_type": "1", "metadata": {"problem_family": "Magic_Squares_and_Sequences"}, "hash": "d6bc4af96c03730e0653119ba7fa4cc823e553b326cfd31f364e72d126119c28", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3100b844-a880-4ce4-8ad1-bd9a62477c3c", "node_type": "1", "metadata": {}, "hash": "ded41d4683ac3cbd46f4813b32a003a198d771e55b5cb857b1c20d6611316044", "class_name": "RelatedNodeInfo"}}, "text": "output [\n       show(s), \"\\n\"\n];\n\n\nModel 5 : \n\n\n% Magic squares in MiniZinc\n\ninclude \"globals.mzn\";\n\nint: n = 3;\n\nint: total = ( n * (n*n + 1)) div 2;\narray[1..n,1..n] of var 1..n*n: magic;\n\n\n% solve satisfy;\nsolve :: int_search(\n        [magic[i,j] | i in 1..n, j in 1..n], \n        first_fail,\n        indomain_min,\n        complete) \n    satisfy;\n\n\nconstraint\n\n        all_different([magic[i,j] | i in 1..n, j in 1..n]) :: domain\n        /\\\n        forall(k in 1..n) (\n           sum(i in 1..n) (magic[k,i]) = total % :: domain\n           /\\\n           sum(i in 1..n) (magic[i,k]) = total %:: domain\n        )\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,i]) = total  %:: domain\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,n-i+1]) = total %:: domain\n;\n\n% symmetry breaking\n% Activating all these constraints we get the\n% \"standard\" way of counting the number of solutions:\n%    1, 0, 1, 880, 275305224\n% i.e. this sequence: http://oeis.org/A006052\n%\n% Without the constraints the number of solutions are:\n%  N  #solutions\n%  -------------\n%  1     1\n%  2     0\n%  3     8\n%  4  7040\n%  5  many... \n%\n% constraint\n%    magic[1,1] < magic[1,n]\n%    /\\ magic[1,n] < magic[n,1]\n%    /\\ magic[1,1] < magic[n,n]\n% ;\n\n\noutput [\n  \"Total: \" ++ show(total) ++ \"\\n\"\n] ++\n[\n    %   show(magic)\n  if j = 1 then \"\\n\" else \"\" endif ++\n    if fix(magic[i,j]) < 10 then \" \" else \"\" endif ++\n    show(magic[i,j]) ++ \" \"\n  | i,j in 1..n\n] \n++ \n[\"\\n\"];\n\n\nModel 6 : \n\n\n% Magic square integer programming version in MiniZinc.\n% In recreational mathematics, a magic square of order n is an\n% arrangement of n^2 numbers, usually distinct integers, in a square,\n% such that n numbers in all rows, all columns, and both diagonals sum\n% to the same constant. A normal magic square contains the integers\n% from 1 to n^2.", "mimetype": "text/plain", "start_char_idx": 1518, "end_char_idx": 3329, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3100b844-a880-4ce4-8ad1-bd9a62477c3c": {"__data__": {"id_": "3100b844-a880-4ce4-8ad1-bd9a62477c3c", "embedding": null, "metadata": {"problem_family": "Magic_Squares_and_Sequences"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_sequence", "node_type": "4", "metadata": {"problem_family": "Magic_Squares_and_Sequences"}, "hash": "7f2b60d3151598d681273ea22d678e50223ed105a27fd52386b745f48016ef83", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "743821a7-ccf6-4eab-85e8-bdf91306e96f", "node_type": "1", "metadata": {"problem_family": "Magic_Squares_and_Sequences"}, "hash": "05e9ec8689475f73b04dcc23ca3346ca54590605ff67b1426297ef79be47091b", "class_name": "RelatedNodeInfo"}}, "text": "output [\n  \"Total: \" ++ show(total) ++ \"\\n\"\n] ++\n[\n    %   show(magic)\n  if j = 1 then \"\\n\" else \"\" endif ++\n    if fix(magic[i,j]) < 10 then \" \" else \"\" endif ++\n    show(magic[i,j]) ++ \" \"\n  | i,j in 1..n\n] \n++ \n[\"\\n\"];\n\n\nModel 6 : \n\n\n% Magic square integer programming version in MiniZinc.\n% In recreational mathematics, a magic square of order n is an\n% arrangement of n^2 numbers, usually distinct integers, in a square,\n% such that n numbers in all rows, all columns, and both diagonals sum\n% to the same constant. A normal magic square contains the integers\n% from 1 to n^2.\n\n\n% square order\nint: n = 3; \n\n% integers to be placed\nset of 1..n*n: N = 1..n*n;\n\n% x[i,j,k] = 1 means that cell (i,j) contains integer k\narray[1..n, 1..n, N] of var 0..1: x;\n\narray[1..n, 1..n] of var 1..n*n: square;\n\nvar int: s; % the magic sum\n\nsolve :: int_search(\n        [x[i,j,k] | i,j in 1..n, k in N] ++ \n        [square[i,j] | i,j in 1..n] ++\n        [s],\n        first_fail,\n        indomain_min, \n        complete % \"credit(640, bbs(5))\" % \"complete\"\n      ) \n    satisfy;\n\nconstraint \n  s >= 0 \n  /\\\n  s <= n*n*n\n  /\\\n  % each cell must be assigned exactly one integer\n  forall(i in 1..n, j in 1..n) (\n     sum(k in N) (x[i,j,k]) = 1\n  )\n  /\\\n  % each integer must be assigned exactly to one cell\n  forall(k in N) (\n     sum(i in 1..n, j in 1..n) (x[i,j,k]) = 1\n  )\n\n  /\\\n  % the sum in each row must be the magic sum \n  forall(i in 1..n) (\n     sum(j in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in each column must be the magic sum\n  forall(j in 1..n) (\n     sum(i in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in the diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,i,k]) = s\n\n  /\\\n  % the sum in the co-diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,n-i+1,k]) = s\n\n  /\\\n  % for output\n  forall(i,j in 1..n) ( square[i,j] = sum(k in N) (k * x[i,j,k]))\n;\n\n\noutput [ \n   \"\\ns: \", show(s)\n] ++\n[\n  if  j = 1 then \"\\n\" else \" \" endif ++\n    show(square[i,j]) \n  | i,j in 1..n\n\n] ++ [\"\\n\"];\n\n% printf \"\\n\";\n% printf \"Magic sum is %d\\n\", s;\n% printf \"\\n\";\n% for{i in 1..n}\n% {  printf{j in 1..n} \"%3d\", sum{k in N} k * x[i,j,k];\n%    printf \"\\n\";\n% }\n% printf \"\\n\";", "mimetype": "text/plain", "start_char_idx": 2748, "end_char_idx": 4964, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "902b1497-65bc-4777-9c0c-f616eb1b3b30": {"__data__": {"id_": "902b1497-65bc-4777-9c0c-f616eb1b3b30", "embedding": null, "metadata": {"problem_family": "Maximum_density_still_life"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "maximum_density_still_life", "node_type": "4", "metadata": {"problem_family": "Maximum_density_still_life"}, "hash": "9f62e2c67a1b5f1c14e87035625f0832cdeea7a149520eabebe950075ca38e14", "class_name": "RelatedNodeInfo"}}, "text": "% Maximum density still life in MiniZinc.\n\n% include \"globals.mzn\"; \nint: size = 7; % to change\n\nset of int: objFunctionBoardCoord      = 2..size+1;\nset of int: checkConstraintsBoardCoord = 1..size+2;\nset of int: augmentedBoardCoord        = 0..size+3;\n\n% Search space: The set of all possible assignments of 0s (dead) and 1s (live) \n% to the cells of the board section. However, to be able to easily express \n% constraints on \"boundary\" cells, we take as search space the set of 0/1 \n% boards of size n+4 by n+4: the actual stable pattern appears in the sub-board \n% defined by ignoring the first/last two rows/columns.\narray[augmentedBoardCoord,augmentedBoardCoord] of var 0..1: grid;\n\nvar int: z = sum(r in objFunctionBoardCoord, c in objFunctionBoardCoord) (grid[r,c]);\n\n% Objective function: Maximize the number of live cells in the sub-board defined \n% by ignoring the first/last two/ rows/columns.\n\n\n% solve maximize z;\nsolve :: int_search(\n        [grid[i,j] | i,j in augmentedBoardCoord], \n        smallest, \n        indomain_max, \n        complete) \n    maximize z;\n\nconstraint\n\n  % C1: Cells in the first/last two rows/columns are all 0 (dead)\n  forall(x in augmentedBoardCoord) (\n    grid[0,x] = 0 /\\\n    grid[1,x] = 0 /\\\n    grid[size+2,x] = 0 /\\  \n    grid[size+3,x] = 0 /\\\n    grid[x,0] == 0 /\\       \n    grid[x,1] == 0 /\\\n    grid[x,size+2] = 0 /\\  \n    grid[x,size+3] = 0 \n  )\n  /\\\n  forall(r in checkConstraintsBoardCoord,c in checkConstraintsBoardCoord) (\n    % C2: Each cell of the board (except those of the first/last row/column) \n    %     that has exactly three live neighbors is alive. \n    %     Together with constraint C1, this implies that cells in the\n    %     second/last-but-one row/column cannot have three live neighbors.\n    (\n      ( ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] + \n          grid[r,c-1] + grid[r,c+1] + \n          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1]\n          ) = 3 \n       ) -> (grid[r,c] = 1)\n    )\n    /\\    \n\n    % C3: Each live cell must have 2 or 3 live neighbors (cells of the first/last \n    % row/column may be ignored by this constraint)\n    (\n       (grid[r,c] = 1) -> \n                      (\n                        2 <= \n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          )\n                        /\\\n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          ) <= 3\n                      )\n    )\n  )\n  \n  /\\\n  % SBSO: Symmetry-breaking by selective ordering\n  % The assignment is forced to respect an ordering on the values that occur in corner entries\n  % of the board. In particular:  \n  % - if the NW-corner cell is dead, the SE-corner cell\n  % must be dead too \n  % - if the NE-corner cell is dead, the SW-corner cell must be dead too\n  % \n  grid[2,2] >= grid[size+1,size+1] /\\\n  grid[2,size+1] >= grid[size+1,2]\n;\n\n\noutput [\n  if j = 0 then \"\\n\" else \" \" endif ++\n    show(grid[i,j])\n  | i,j in augmentedBoardCoord\n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3237, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dd60bb82-b292-43e3-a2c6-592d3047ebaa": {"__data__": {"id_": "dd60bb82-b292-43e3-a2c6-592d3047ebaa", "embedding": null, "metadata": {"problem_family": "Nonogram"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "nonogram_create_automaton2", "node_type": "4", "metadata": {"problem_family": "Nonogram"}, "hash": "89e6ecc75405b66e7c67875a5e5d52fc61a9dd72f02156637c944effaa4e4ff5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "237b8603-00f1-459c-b665-dada38345f79", "node_type": "1", "metadata": {}, "hash": "f9019d987c4ec0ff9b290cecb8618de4bbd280ee1e3d31ea0263e33e79229c76", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n% Nonoram solver using regular and is written in all-MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: rows;\nint: row_rule_len;\narray[1..rows, 1..row_rule_len] of int: row_rules;\nint: cols;\nint: col_rule_len;\narray[1..cols, 1..col_rule_len] of int: col_rules;\n\n\narray[1..rows, 1..cols] of var 1..2: x;\n\nsolve :: int_search(\n     [x[i,j] | j in 1..cols, i in 1..rows], \n     first_fail, \n     indomain_min, \n     complete) \nsatisfy;\n\n%\n% The approach is rather simple:\n%  - zero_positions is a set of the positions in the state table where the \n%    state 0 should be, which also correspond to the state of the pattern \"0\"\n%  - when this have been identified everything else comes to rest\n%\n% On the other hand, the calculation of the states is hairy, very hairy.\n%\npredicate make_automaton(array[int] of var int: x, array[int] of int: pattern) =\n    let {\n        int: n = length(pattern),\n        % fix for \"zero clues\"\n        int: len = max(length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern),1),\n        int: leading_zeros = sum(i in 1..n) (bool2int(pattern[i] = 0)),\n        set of int: zero_positions = {sum(j in 1..i) (pattern[j]+1) -leading_zeros | i in 1..n where pattern[i] > 0},\n       array[1..2*len] of 0..len*2: states = \n     if (length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern)) = 0 then \n       [1,1]  % fix for \"zero clues\"\n     else \n    [1, 2] ++\n    [\n       if i div 2 in zero_positions then\n           if i mod 2 = 0 then\n            0\n           else\n            (i div 2) + 1\n           endif\n       elseif (i-1) div 2 in zero_positions then\n           if i mod 2 = 0 then\n            (i div 2)+1\n           else\n            (i div 2)+2\n           endif\n       else\n         if not( (((i-1) div 2) - 1) in zero_positions) then\n            if i mod 2 = 0 then\n               (i div 2) + 1\n            else \n              if (i div 2) + 1 in zero_positions then\n                  (i div 2) + 2\n              else \n                  0\n              endif\n            endif\n          else\n             if i mod 2 = 0 then\n                 (i div 2) + 1\n             else \n                if not((i div 2) + 1 in zero_positions) then\n                   0\n                else \n                   (i div 2) + 2 \n                endif\n             endif\n          endif\n       endif\n    | i in 3..2*(len-1)]\n    ++\n    [len, 0]\n    endif\n    } \n    in\n    regular(\n       x,\n       len, \n       2, \n       array2d(1..len, 1..2, states),\n       1, \n       {len}) % :: domain\n;\n\nconstraint\n\n      forall(j in 1..cols) (\n        make_automaton([x[i,j] | i in 1..rows], [col_rules[j,k] | k in 1..col_rule_len])\n      )\n      /\\\n      forall(i in 1..rows) (\n        make_automaton([x[i,j] | j in 1..cols], [row_rules[i,k] | k in 1..row_rule_len])\n      )\n\n;\n\noutput \n[\n  if j = 1 then \"\\n\" else \"\" endif ++\n     if fix(x[i,j]) = 1 then \" \" else \"#\" endif\n    \n  | i in 1..rows, j in 1..cols\n] \n++ \n[\n  \"\\n\"\n];\n\n\n\nModel 2 :", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2974, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "237b8603-00f1-459c-b665-dada38345f79": {"__data__": {"id_": "237b8603-00f1-459c-b665-dada38345f79", "embedding": null, "metadata": {"problem_family": "Nonogram"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "nonogram_create_automaton2", "node_type": "4", "metadata": {"problem_family": "Nonogram"}, "hash": "89e6ecc75405b66e7c67875a5e5d52fc61a9dd72f02156637c944effaa4e4ff5", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dd60bb82-b292-43e3-a2c6-592d3047ebaa", "node_type": "1", "metadata": {"problem_family": "Nonogram"}, "hash": "e1fd67832b01d4ff3a4b3c62eab4f68d4df1217c56033f41d64a2b3ec39f48a5", "class_name": "RelatedNodeInfo"}}, "text": "Model 2 : \n\n\ninclude \"globals.mzn\";\nint: X;\nint: Y;\n\nint: maxlen;\n\narray [1..Y,1..maxlen] of int: rows;\n\narray [1..X,1..maxlen] of int: cols;\n\narray[1..2, 1..2, 1..2] of 0..1: nonmul = \n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 1, 1,\n         1, 0, 0, 1]\n    );\n\narray[1..2, 1..2, 1..2] of 0..1: nonadd =\n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 0, 1,\n         1, 0, 0, 1]\n    );\n\n% variables\n%\narray[1..Y, 1..X] of var 1..2: A;\n\n% All variables in a region must be different\n% Ordering to ensure each variable is handled exactly once\npredicate nonogram_row(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: row) =\n    nonogram([A[row, v] | v in 1..X], cons);\n\npredicate nonogram_col(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: col) = \n    nonogram([A[v,col] | v in 1..Y], cons);\n\npredicate nonogram(array[int] of var 1..2: A, array [int] of int: cons) = \n    let {\n          int: n = if cons[1] = 0 then 0 else max(index_set(cons)) endif,\n          array [1..n + 1, 1..2] of int: consarr =\n              if cons[1] = 0 then [|1, 0|] \n              else array2d(1..n + 1, 1..2,\n                [1, 2] ++\n                [    i * nonmul[cons[i - 1] + 1, cons[i] + 1, s] + \n                     nonadd[cons[i - 1] + 1, cons[i] + 1, s] \n                     | i in 2..n, s in 1..2 \n                ] ++ \n                [n+1,0]\n              )\n              endif\n     } in (\n         regular(A, n + 1, 2, consarr, 1, {n + 1})\n     );\n\nconstraint forall(i in 1..Y) (\n    nonogram_row(A, [rows[i, j] | j in 1..maxlen where rows[i, j] >= 0], i)\n);\n\nconstraint forall(i in 1..X) (\n    nonogram_col(A, [cols[i, j] | j in 1..maxlen where cols[i, j] >= 0], i)\n);\n\nsolve :: int_search(array1d(1..X*Y,A),input_order,indomain_max,complete) satisfy;\n\noutput [\n    if fix(A[r, c]) = 1 then \" \" else \".\" endif ++ \n    if c = Y then \"\\n\" else \" \" endif\n    | r in 1..X, c in 1..Y\n];", "mimetype": "text/plain", "start_char_idx": 2965, "end_char_idx": 4924, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c295f0f1-7c87-4150-a2d6-40acc2f5e579": {"__data__": {"id_": "c295f0f1-7c87-4150-a2d6-40acc2f5e579", "embedding": null, "metadata": {"problem_family": "Optimal_Financial_Portfolio_Design"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "opd", "node_type": "4", "metadata": {"problem_family": "Optimal_Financial_Portfolio_Design"}, "hash": "65c8a2d13c6b6235b84c7e8d23abccc65374bef5364f729343402e0f72a719b9", "class_name": "RelatedNodeInfo"}}, "text": "%% Design of Collateralised Debt Obligations Squared (CDO^2) Transactions\n% An OPD (v, b, r) problem is to find a binary matrix of v rows\n% and b columns such that each row sums to r, and\n% the dot product beween any pair of distinct rows is minimal.\n\n%Requires MiniZinc >= 2.0.2 for the symmetry_breaking_constraint predicate\n\ninclude \"lex_greatereq.mzn\";\n\n%instance data\nint: v;\nint: b;\nint: r;\n\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\n\n%computing a lower bound for lambda\nint: rv = r*v;\nint: rvmodb = rv mod b;\nint: floorrv = rv div b;\nint: ceilrv = rv div b + bool2int(rv mod b != 0);\nint: num = (ceilrv*ceilrv*rvmodb+floorrv*floorrv*(b-rvmodb)-rv);\nint: denom = v*(v-1);\nint: lb_lambda = num div denom + bool2int( num mod denom !=0);\n\n% This line is there for debugging purposes, it can be safely removed\nint: tmp = trace(\"Computed lower bound for lambda: \"++show(lb_lambda)++\"\\n\",lb_lambda);\n\n\n% lambda is called objective for the MiniZinc Challenge\nvar lb_lambda..b: objective;\n\n\narray [rows, cols] of var 0..1: m;\n\n\n% Every row must sum to r.\nconstraint forall (i in rows) (sum (j in cols) (m[i, j]) = r);\n\n% The dot product of every pair of distinct rows must be at most lambda for an OPD and a PD, and equal to lambda for a BIBD\nconstraint forall (i_a, i_b in rows where i_a < i_b) (\n    sum (j in cols) (m[i_a, j] * m[i_b, j]) <= objective\n);\n\n\n% Break row symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(i in rows diff {max(rows)})(\n        lex_greatereq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    )\n);\n% Break column symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(j in cols diff {max(cols)})(\n        lex_greatereq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    )\n);\n\n\nsolve \n    :: seq_search([int_search([m[i, j] | i in rows, j in cols], input_order, indomain_max, complete),\n       \t\t   int_search([objective], input_order,indomain_min,complete)])\n    minimize objective; \n\n\n% Disabled the full solution. Printing only the objective value, lower bound, and parameters.\noutput  [\"opd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r), \"). Found lambda = \", show(objective),\"\\tlb: \", show(lb_lambda)]\n%       ++[\"\\n\\n\"] ++ \n%\t[ ( if j > b then \"\\n\" else \n%\t        if fix(m[i,j])=1 then \"*\" else \" \" endif\n%\t    endif )\n%       | i in rows, j in 1..(b + 1) ]\n;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2382, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dceda50c-a8d2-4cdc-9556-1d32e753da3d": {"__data__": {"id_": "dceda50c-a8d2-4cdc-9556-1d32e753da3d", "embedding": null, "metadata": {"problem_family": "Number_Partitioning"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "partition", "node_type": "4", "metadata": {"problem_family": "Number_Partitioning"}, "hash": "f7f008866eaea055351f46909affd24db51e3af878e1003d0bcafb536fe42e0e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "df1176d1-de7a-4c86-95d7-8e6d7a58c1ae", "node_type": "1", "metadata": {}, "hash": "3b3e1011c4b24b5d963a22d0d1ac0412d3e0462584d7d088c0acce983972d8b8", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 : \n\n% Partitioning problem\n% Partition 2*n numbers into two groups, each of size n, such that\n% their sums are equal and the sums of their squares are equal.\n\ninclude \"globals.mzn\";\n\n% Instance\n\nn = 32;\n\n% Model\n\nint: n;\n\narray[1..n] of var 1..2*n: x;\narray[1..n] of var 1..2*n: y;\n\nconstraint true\n    %   Break symmetries by ordering numbers in each group\n    /\\  forall (i in 2..n) (x[i-1] < x[i] /\\ y[i-1] < y[i])\n    %   Break symmetries by ordering the groups\n    /\\  x[1] < y[1]\n    \n    %   Partition the numbers\n    /\\  (alldifferent(x++y)) :: bounds\n    \n    %   The sums are equal\n    /\\  sum (x) = 2*n*(2*n+1) div 4\n    /\\  sum (y) = 2*n*(2*n+1) div 4\n    \n    %   The sums of the squares are equal\n    /\\  let {\n            array[1..n] of var 1..4*n*n: sx,\n            array[1..n] of var 1..4*n*n: sy\n        } in\n        forall (i in 1..n) (sx[i]=x[i]*x[i] /\\ sy[i] = y[i]*y[i])\n    /\\  sum (sx) = 2*n*(2*n+1)*(4*n+1) div 12\n    /\\  sum (sy) = 2*n*(2*n+1)*(4*n+1) div 12\n;\n\nsolve ::int_search(x++y,first_fail,indomain_min,complete) satisfy;\n\noutput\n    [\"x = \",show(x),\"\\n\",\"y = \",show(y),\"\\n\",\n     \"sum = \",show(2*n*(2*n+1) div 4),\"\\n\",\n     \"sum of squares = \", show(2*n*(2*n+1)*(4*n+1) div 12), \"\\n\"\n     ];\n\n\n\nModel 2 :", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1246, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "df1176d1-de7a-4c86-95d7-8e6d7a58c1ae": {"__data__": {"id_": "df1176d1-de7a-4c86-95d7-8e6d7a58c1ae", "embedding": null, "metadata": {"problem_family": "Number_Partitioning"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "partition", "node_type": "4", "metadata": {"problem_family": "Number_Partitioning"}, "hash": "f7f008866eaea055351f46909affd24db51e3af878e1003d0bcafb536fe42e0e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dceda50c-a8d2-4cdc-9556-1d32e753da3d", "node_type": "1", "metadata": {"problem_family": "Number_Partitioning"}, "hash": "4f57108a7bb8579be05d0da0c574061e8be563e0f03d598775725364b4894452", "class_name": "RelatedNodeInfo"}}, "text": "Model 2 :\n\n\n\n%\n% Set partition problem in Minizinc.\n%\n%  This is a partition problem.\n%  Given the set S = {1, 2, ..., n},\n%  it consists in finding two sets A and B such that:\n%  <ul>\n%  <li>A U B = S,</li>\n%  <li>|A| = |B|,</li>\n%  <li>sum(A) = sum(B),</li>\n%  <li>sum_squares(A) = sum_squares(B).</li>\n%  </ul>\n \n%\ninclude \"globals.mzn\";\n \nint: n = 16;\nset of 1..n: S = 1..n;\nint: num_sets = 2;\narray[1..num_sets] of var set of S: a;\narray[1..num_sets] of var 0..n*n: sums;\narray[1..num_sets] of var 0..n*n*n*n: sum_squared;\n \n \n%\n% set_sum\n% sums the elements in the set s\n%\npredicate set_sum(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i)\n;\n \npredicate set_sum_squared(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i*i)\n;\n \n \nsolve :: set_search(a, first_fail, indomain_min, complete) satisfy;\n% solve maximize sums[1];\n \nconstraint\n  assert(n mod 4 == 0, \"n must be a multiple of 4\")\n;\n \nconstraint\n   % use all the elements in S and it should be disjoint sets\n   partition_set(a, S)\n   /\\\n   forall(i in 1..num_sets) (  \n     a[i] `set_sum` sums[i]\n     /\\ a[i] `set_sum_squared` sum_squared[i]\n   )\n   /\\\n   forall(i in 2..num_sets) (\n     card(a[i]) > 0 /\\ % this is needed by eclipse\n     card(a[i]) = card(a[i-1]) /\\\n     sums[i] = sums[i-1]\n     /\\ sum_squared[i] = sum_squared[i-1]\n   )\n \n  % symmetry breaking\n  /\\ 1 in a[1]\n \n;\n \noutput [\n   \"a: \" ++ show(a) ++ \"\\n\" ++\n   \"sums: \" ++ show(sums) ++ \"\\n\" ++\n   \"sum_squared: \" ++ show(sum_squared) ++ \"\\n\"\n];\n \n% For model seeker\n% output [\n%    show(set2array(fix(a[i]))) ++ \",\"\n%   | i in 1..num_sets\n% ];", "mimetype": "text/plain", "start_char_idx": 1237, "end_char_idx": 2890, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8602b091-2d1b-470a-bf5e-5522ac62fec3": {"__data__": {"id_": "8602b091-2d1b-470a-bf5e-5522ac62fec3", "embedding": null, "metadata": {"problem_family": "Quasigroup_Completion"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasigroupCompletion", "node_type": "4", "metadata": {"problem_family": "Quasigroup_Completion"}, "hash": "72beee6de8df66b8ac85c50cfe444de20e40f905e6ff4113fb66500273adbcff", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n% Quasigroup with Holes (aka Latin Square Completion)\n\ninclude \"alldifferent.mzn\";\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n\narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N] of var PuzzleRange: puzzle;\n\n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j] = start[i,j] else true endif );\n\n% All different in rows\nconstraint forall (i in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | j in PuzzleRange ] ) );\n\n% All different in columns.\nconstraint forall (j in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | i in PuzzleRange ] ) );\n\nsolve satisfy;\n\noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n \narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N, 1..N] of var 0..1: puzzle;\n \n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j, start[i,j]] = 1 else true endif );\n \n% All different in rows\nconstraint forall (i,k in PuzzleRange) (\n        sum(j in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% All different in columns\nconstraint forall (j,k in PuzzleRange) (\n        sum(i in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% Each cell must have a number assigned\nconstraint forall (i,j in PuzzleRange) (\n        sum(k in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\nsolve satisfy;\n \noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1760, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d92d971d-e456-4c41-b96d-eeed942424d8": {"__data__": {"id_": "d92d971d-e456-4c41-b96d-eeed942424d8", "embedding": null, "metadata": {"problem_family": "Quasigroup_Existence"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasiGroupExistence", "node_type": "4", "metadata": {"problem_family": "Quasigroup_Existence"}, "hash": "101c3bb823a07dec85ee458f4b43cc375178fdc1b1ba0227e68fa1cc439f9741", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "382c0a9e-fdfb-445d-995c-ad92cfc8aa0d", "node_type": "1", "metadata": {}, "hash": "c08c3877b8c4d2d96781760c2c2ce0c9219fcfbf29eaec502fe561d33d1841e0", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n\n% Quasigroup problem in MiniZinc.\n% The quasiGroup existence problem\n% An m order quasigroup  is an mxm multiplication table of integers 1..m,\n% where each element occurrs exactly once in each row and column and certain\n% multiplication axioms hold (in this case, we want axiom 7 to hold).\n%\n% QG7.m problems are order m quasigroups for which (b*a)*b = a*(b*a).\n\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n% solve satisfy;\n \nconstraint\n      \n     % assign the \"reflected\" quasigroup to qGColumns to access its columns\n     %  forall row,col : nDomain .\n     %    quasiGroupColumns[col,row] = quasiGroup[row,col],\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % all values in the diagonals\n     forall( i in nDomain ) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n \n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row, col] | row in nDomain])\n     )\n     /\\\n \n     % this strange constraint\n     % corresponds to:\n     % quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i], j] \n     forall(i,j in nDomain) (\n              quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i],j]\n     )\n     /\\\n     % some implied? constraint\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n%\n% data\n%\nn = 5;\n\n\n\nModel 2 :", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1750, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "382c0a9e-fdfb-445d-995c-ad92cfc8aa0d": {"__data__": {"id_": "382c0a9e-fdfb-445d-995c-ad92cfc8aa0d", "embedding": null, "metadata": {"problem_family": "Quasigroup_Existence"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasiGroupExistence", "node_type": "4", "metadata": {"problem_family": "Quasigroup_Existence"}, "hash": "101c3bb823a07dec85ee458f4b43cc375178fdc1b1ba0227e68fa1cc439f9741", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d92d971d-e456-4c41-b96d-eeed942424d8", "node_type": "1", "metadata": {"problem_family": "Quasigroup_Existence"}, "hash": "bdd0fd72340928ed985541e720694f9650a3895fbdfd214cee1aec313d20b48f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "af21919a-71e2-4849-822b-52b728ecec1c", "node_type": "1", "metadata": {}, "hash": "b3f8d6f46167624961afc1172d99a50d596f474b0fddd0320a1aa28bf0b25ddf", "class_name": "RelatedNodeInfo"}}, "text": "Model 2 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 9; % solutions for n=5, n=9...\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 3 :", "mimetype": "text/plain", "start_char_idx": 1741, "end_char_idx": 3468, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "af21919a-71e2-4849-822b-52b728ecec1c": {"__data__": {"id_": "af21919a-71e2-4849-822b-52b728ecec1c", "embedding": null, "metadata": {"problem_family": "Quasigroup_Existence"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasiGroupExistence", "node_type": "4", "metadata": {"problem_family": "Quasigroup_Existence"}, "hash": "101c3bb823a07dec85ee458f4b43cc375178fdc1b1ba0227e68fa1cc439f9741", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "382c0a9e-fdfb-445d-995c-ad92cfc8aa0d", "node_type": "1", "metadata": {"problem_family": "Quasigroup_Existence"}, "hash": "663c50fd2ba9f605cd6c4a4d3891d2e837e5f3cc30bc0c4634b09818245e7417", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d0b850c8-b5a3-49a0-8b66-b9f3dae1f588", "node_type": "1", "metadata": {}, "hash": "249ec1fd572383af10d4ba58a23d4443969beeac9dccf222a3ca8efb438614e5", "class_name": "RelatedNodeInfo"}}, "text": "Model 3 : \n\n\ninclude \"globals.mzn\";\n \nint: n = 4;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n \n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (i != j) ->\n         (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n \n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n \n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 3459, "end_char_idx": 5186, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d0b850c8-b5a3-49a0-8b66-b9f3dae1f588": {"__data__": {"id_": "d0b850c8-b5a3-49a0-8b66-b9f3dae1f588", "embedding": null, "metadata": {"problem_family": "Quasigroup_Existence"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasiGroupExistence", "node_type": "4", "metadata": {"problem_family": "Quasigroup_Existence"}, "hash": "101c3bb823a07dec85ee458f4b43cc375178fdc1b1ba0227e68fa1cc439f9741", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "af21919a-71e2-4849-822b-52b728ecec1c", "node_type": "1", "metadata": {"problem_family": "Quasigroup_Existence"}, "hash": "f21830c3fd44a0f0d4cbe024d68535c7a3ecaa0c1f8b7a6a3b507d50cfb29f82", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "55fcb77f-2129-44ab-b643-85e00197d24d", "node_type": "1", "metadata": {}, "hash": "7d81d2ee3b945095ffc7da6caaeb66f3b17c19f1a49bcad617301169783854c1", "class_name": "RelatedNodeInfo"}}, "text": "Model 4 :\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n \n     % Idempotency\n     % forall i : nDomain .\n     %     (quasiGroup[i,i] = i),\n \n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     % allDifferent(qgDiagonal) %,\n \n     % anti-Abelian\n     % forall i : nDomain .\n     %   forall j : nDomain .\n     %     (i != j) =>\n     %     (quasiGroup[i,j] != quasiGroup[j,i]),\n \n     % if (i*i)=j then (j*j) = i\n     % forall i : nDomain .\n     %  forall j : nDomain .\n     %    (quasiGroup[i,i]=j) => (quasiGroup[j,j]=i),\n \n \n     % Symmetry-breaking constraints   \n     % forall i : nDomain .\n     %      quasiGroup[i,n-1] + 2 >= i\n \n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n \n \n%\n% data\n%\nn = 4; % 4 works\n\n\nModel 5 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 6 :", "mimetype": "text/plain", "start_char_idx": 5190, "end_char_idx": 8140, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "55fcb77f-2129-44ab-b643-85e00197d24d": {"__data__": {"id_": "55fcb77f-2129-44ab-b643-85e00197d24d", "embedding": null, "metadata": {"problem_family": "Quasigroup_Existence"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasiGroupExistence", "node_type": "4", "metadata": {"problem_family": "Quasigroup_Existence"}, "hash": "101c3bb823a07dec85ee458f4b43cc375178fdc1b1ba0227e68fa1cc439f9741", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d0b850c8-b5a3-49a0-8b66-b9f3dae1f588", "node_type": "1", "metadata": {"problem_family": "Quasigroup_Existence"}, "hash": "c235e470bf736bceb3c6e980824d2fe4641213030bebb16294670534a9d0142c", "class_name": "RelatedNodeInfo"}}, "text": "Model 6 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 5;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 7 :\n\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 8131, "end_char_idx": 10965, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "680e2f88-27bf-4314-b412-18d0c3719c42": {"__data__": {"id_": "680e2f88-27bf-4314-b412-18d0c3719c42", "embedding": null, "metadata": {"problem_family": "N-Queens"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "queens", "node_type": "4", "metadata": {"problem_family": "N-Queens"}, "hash": "e53219a7814a4285ba072f2b8c70c8c2d637f87e151be48706ebe11b2a091cbb", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n% n queens problem in MiniZinc.\n\ninclude \"globals.mzn\";\n\nint: n;\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail, \n        indomain_min, \n        complete) \n    satisfy;\n\n% solve satisfy;\n\nconstraint all_different(queens);\n\nconstraint\n    forall(i, j in 1..n where i < j) (\n         queens[i] != queens[j] /\\\n         queens[i] + i != queens[j] + j /\\\n         queens[i] - i != queens[j] - j\n    ) \n ;\n\noutput [\n  show(queens) ++ \"\\n\"\n\n];\n\n% data\nn = 8;\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n;\n\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail,\n        indomain_median,\n        complete\n       )\n     satisfy;\n\n% solve satisfy;\nconstraint all_different(queens); %  :: domain;\nconstraint all_different([queens[i]+i | i in 1..n]) :: domain;\nconstraint all_different([queens[i]-i | i in 1..n]) :: domain;\n\noutput \n[\n  \"queens: \" ++ show(queens)\n] ++ \n% [\n%   if j = 1 then \"\\n\" else \"\" endif ++\n%      if fix(queens[i]) = j then          \n%         show_int(2,j)\n%      else\n%         \"__\"\n%      endif\n%   | i in 1..n, j in 1..n\n% ] ++\n[\"\\n\"]\n;\n\n% data\nn = 8;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1161, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "88a0d16b-a89e-4035-9043-adcf855f19b9": {"__data__": {"id_": "88a0d16b-a89e-4035-9043-adcf855f19b9", "embedding": null, "metadata": {"problem_family": "The_Rehearsal_Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rehearsal", "node_type": "4", "metadata": {"problem_family": "The_Rehearsal_Problem"}, "hash": "47878f3c78f63eddda54157e8e78d600ab6a28f6909c8f275eba7724d1879262", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "aaa35a6c-cbf2-480e-be7c-10c6b2a523fc", "node_type": "1", "metadata": {}, "hash": "0ed4c603dde9349bb284aa2322364176ed78338c6006ab5699cb3f4718a25768", "class_name": "RelatedNodeInfo"}}, "text": "%\n% Scheduling a Rehearsal in MiniZinc.\n% A concert is to consist of nine pieces of music of different durations\n% each involving a different combination of the five members of the orchestra.\n% Players can arrive at rehearsals immediately before the first piece in which\n% they are involved and depart immediately after the last piece in which\n% they are involved. The problem is to devise an order in which the pieces\n% can be rehearsed so as to minimize the total time that players are waiting\n% to play, i.e. the total time when players are present but not currently\n% playing. In the table below, 1 means that the player is required for\n% the corresponding piece, 0 otherwise. The duration (i.e. rehearsal time)\n% is in some unspecified time units.\n%\n%    Piece       1    2   3    4    5  6    7   8    9\n%    Player 1    1    1   0    1    0  1    1   0    1\n%    Player 2    1    1   0    1    1  1    0   1    0\n%    Player 3    1    1   0    0    0  0    1   1    0\n%    Player 4    1    0   0    0    1  1    0   0    1\n%    Player 5    0    0   1    0    1  1    1   1    0\n%    Duration    2    4   1    3    3  2    5   7    6\n%\n% For example, if the nine pieces were rehearsed in numerical order as\n% given above, then the total waiting time would be:\n%       Player 1: 1+3+7=11\n%       Player 2: 1+5=6\n%       Player 3: 1+3+3+2=9\n%       Player 4: 4+1+3+5+7=20\n%       Player 5: 3\n% giving a total of 49 units. The optimal sequence, as we shall see,\n% is much better than this.\n%\n% ...\n%\n% The minimum waiting time for the rehearsal problem is 17 time units, and\n% an optimal sequence is 3, 8, 2, 7, 1, 6, 5, 4, 9.\n%\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \n\n\nint: num_pieces;\nint: num_players;\narray[1..num_pieces] of int: duration;\narray[1..num_players, 1..num_pieces] of 0..1: rehearsal;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1796, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aaa35a6c-cbf2-480e-be7c-10c6b2a523fc": {"__data__": {"id_": "aaa35a6c-cbf2-480e-be7c-10c6b2a523fc", "embedding": null, "metadata": {"problem_family": "The_Rehearsal_Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rehearsal", "node_type": "4", "metadata": {"problem_family": "The_Rehearsal_Problem"}, "hash": "47878f3c78f63eddda54157e8e78d600ab6a28f6909c8f275eba7724d1879262", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "88a0d16b-a89e-4035-9043-adcf855f19b9", "node_type": "1", "metadata": {"problem_family": "The_Rehearsal_Problem"}, "hash": "7199d12ce35e1cd0ff940a51d76e1de8ce3a67faa02daeb01207ed3fd76cf60d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b870b772-c8ce-46d8-a3fe-bbe15972b29b", "node_type": "1", "metadata": {}, "hash": "fb0ea0b32e0a742ebbc0029d7744b7ecf2db2e9483426a61c8f3c598663b9cd6", "class_name": "RelatedNodeInfo"}}, "text": "include \"globals.mzn\"; \n\n\nint: num_pieces;\nint: num_players;\narray[1..num_pieces] of int: duration;\narray[1..num_players, 1..num_pieces] of 0..1: rehearsal;\n\n\n%\n% Decision variables\n%\narray[1..num_pieces] of var 1..num_pieces: rehearsal_order;\narray[1..num_players] of var 0..sum(duration): waiting_time; % waiting time for players\narray[1..num_players] of var 1..num_pieces: p_from; % first rehearsal\narray[1..num_players] of var 1..num_pieces: p_to;   % last rehearsal\nvar 0..sum(duration): total_waiting_time = sum(waiting_time); % objective\n\nsolve :: int_search(\n         rehearsal_order % ++ waiting_time% ++ p_from ++ p_to ++ [total_waiting_time]\n         , \n         first_fail, % occurrence, % max_regret, % first_fail, \n         indomain_max, % indomain_max, \n         complete) \n     minimize total_waiting_time;\n     % satisfy;\n\n% solve :: labelling_ff minimize total_waiting_time;\n\nconstraint\n  all_different(rehearsal_order) :: domain\n  /\\\n\n  % This solution is my own without glancing at Smith's models...\n  forall(p in 1..num_players) (\n     % This versions is much faster than using exists (see below)\n     % fix the range from..to, i.e. don't count all that start with 0 \n     % or ends with 0.\n     % This means that we collect the rehearsals with many 0 at the ends\n     %\n     p_from[p] < p_to[p]\n     /\\\n     % skipping rehearsal at start (don't come yet)\n     forall(i in 1..num_pieces) (\n        i < p_from[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\\n     % skipping rehearsal at end (go home after last rehearsal)\n     forall(i in 1..num_pieces) (\n        i > p_to[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\ % and now: count the waiting time for from..to\n     waiting_time[p] = \n         sum(i in 1..num_pieces) (\n              duration[rehearsal_order[i]] * bool2int(\n                                             i >= p_from[p] /\\ i <= p_to[p] \n                                             /\\\n                                             rehearsal[p,rehearsal_order[i]] = 0\n                                )\n     ) \n\n%      % alternative solution with exists. \n%      %  More elegant (= declarative) in my book but slower.\n%      exists(from, to in 1..num_pieces) ( \n%         % skipping rehearsal at start (don't come yet)\n%         forall(i in 1..from-1) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\\n%         % skipping rehearsal at end (go home after last rehearsal)\n%         forall(i in to+1..num_pieces) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\ % and now: count the waiting time for from..to\n%         waiting_time[p] = \n%             sum(i in from..to) (\n%                  duration[rehearsal_order[i]]*\n%                                  bool2int(\n%                                       rehearsal[p,rehearsal_order[i]] = 0\n%                                   )\n%          ) \n%      )\n\n\n  )\n\n  /\\ % symmetry breaking\n  rehearsal_order[1] < rehearsal_order[num_pieces]\n\n  % for all solutions\n  % /\\ total_waiting_time = 17\n;", "mimetype": "text/plain", "start_char_idx": 1640, "end_char_idx": 4698, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b870b772-c8ce-46d8-a3fe-bbe15972b29b": {"__data__": {"id_": "b870b772-c8ce-46d8-a3fe-bbe15972b29b", "embedding": null, "metadata": {"problem_family": "The_Rehearsal_Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rehearsal", "node_type": "4", "metadata": {"problem_family": "The_Rehearsal_Problem"}, "hash": "47878f3c78f63eddda54157e8e78d600ab6a28f6909c8f275eba7724d1879262", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "aaa35a6c-cbf2-480e-be7c-10c6b2a523fc", "node_type": "1", "metadata": {"problem_family": "The_Rehearsal_Problem"}, "hash": "203b88ef93d1bada30e3369c35b5163a3daf360447487168b9442e89f9dcbcc3", "class_name": "RelatedNodeInfo"}}, "text": ")\n\n  /\\ % symmetry breaking\n  rehearsal_order[1] < rehearsal_order[num_pieces]\n\n  % for all solutions\n  % /\\ total_waiting_time = 17\n;\n\n\n%\n% data\n%\n%\n% num_pieces = 9;\n% num_players = 5;\n% duration = [2, 4, 1, 3, 3, 2, 5, 7, 6];\n% rehearsal = array2d(1..num_players, 1..num_pieces, \n%     [\n%      1,1,0,1,0,1,1,0,1,\n%      1,1,0,1,1,1,0,1,0,\n%      1,1,0,0,0,0,1,1,0,\n%      1,0,0,0,1,1,0,0,1,\n%      0,0,1,0,1,1,1,1,0\n%   ]);\n\n%\n% This is the problem from the Choco v 2.1 example \n% num_pieces = 5;\n% num_players = 3;\n% duration = [4,6,3,5,7];\n% rehearsal =  array2d(1..num_players, 1..num_pieces, \n%         [\n%         1,1,0,1,0,\n%         0,1,1,0,1,\n%         1,1,0,1,1   \n%   ]);\n\n\noutput[\n  \"order: \" , show(rehearsal_order), \"\\n\",\n  \"waiting_time: \", show(waiting_time), \"\\n\",\n  \"total_waiting_time: \" , show(total_waiting_time), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(rehearsal[p, rehearsal_order[j]]) ++ \" \"\n  | p in 1..num_players, j in 1..num_pieces, \n] ++ \n[\"\\n\"]\n;", "mimetype": "text/plain", "start_char_idx": 4564, "end_char_idx": 5565, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f8f5da7f-477a-4f69-abb8-579035d6b52e": {"__data__": {"id_": "f8f5da7f-477a-4f69-abb8-579035d6b52e", "embedding": null, "metadata": {"problem_family": "Rotating_Rostering_Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "RosteringProblem", "node_type": "4", "metadata": {"problem_family": "Rotating_Rostering_Problem"}, "hash": "dcb597d14bf87b64a5c58d5a0ab83d3f8f5910b4f13722e8345326072121f5f6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bc34364b-6cf9-4c94-bc01-486f18e9898e", "node_type": "1", "metadata": {}, "hash": "1a2ff45773c396a2be12031e5e12541141f0e6e6752c644bfc9733f15868b020", "class_name": "RelatedNodeInfo"}}, "text": "include \"all_equal.mzn\";\ninclude \"global_cardinality.mzn\";\n\n% load parameters\ninclude \"parameters.dzn\";\n\nint: daysPerWeek = 7;\n\n% the number of weeks\nint: numberOfWeeks;\n\nint: numberOfDays = numberOfWeeks * daysPerWeek;\n\n% the minimum number of days in a row with the same shift\nint: s_min;\n\n% the maximum number of days in a row with the same shift\nint: s_max; \n\n% 3 shifts: early = 1, late = 2 and night shift = 3 + day off (rest day) = 0\nint: numberOfShifts = 3;\n\n% the shift requirement matrix, including at M_{i,j} the needed employees for day i and shift j\narray[1..daysPerWeek, 1..numberOfShifts+1] of int: shiftRequirements;\n\n\n% the variables X \narray[1..numberOfWeeks * daysPerWeek] of var 0..numberOfShifts: plan1d;\narray[1..numberOfWeeks,1..daysPerWeek] of var 0..numberOfShifts: plan2d;\narray[1..daysPerWeek,1..numberOfWeeks] of var 0..numberOfShifts: plan2dT;\n\n% helper arrays\narray[1..s_min,1..s_min] of var 0..numberOfShifts: s_min_arrays;\narray[1..s_max,1..s_max] of var 0..numberOfShifts: s_max_arrays;\n\n% convert the 2D plan into 1D\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan1d[(week-1) * daysPerWeek + day]\n           );  \n\n% transpose the 2D plan\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan2dT[day, week]\n           );\n\n% C_equalDays: constrains that weekend days (Saturday and Sunday) always have the same shift\nconstraint forall(week in 1..numberOfWeeks) (\n               plan2d[week, daysPerWeek - 1] == plan2d[week, daysPerWeek]\n           );                        \n\n                                                                                                                                \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_min, j in 1..s_min) (\n                 s_min_arrays[i, j] == plan1d[((numberOfDays - s_min - 1 + i + j) mod numberOfDays) + 1]\n           );                                            \n                                            \n% C_shiftRepetitions:for every shift type a minimum number of consecutive assignments to this shift is given\nconstraint forall(day in 1..numberOfDays - s_min) (\n               plan1d[day] != plan1d[day+1] -> all_equal(plan1d[day+1..day+s_min])\n           );     \n% the constraints over the array bounds           \nconstraint forall(d in 1..s_min) (\n               plan1d[d + numberOfDays - s_min] != plan1d[((d + numberOfDays - s_min) mod numberOfDays) +1] -> all_equal(s_min_arrays[d,1..s_min])\n           );                     \n\n           \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_max, j in 1..s_max) (\n                 s_max_arrays[i, j] == plan1d[((numberOfDays - s_max - 2 + i + j) mod numberOfDays) + 1]\n           );                      \n                                            \n% C_shiftRepetitions:for every shift type a maximum number of consecutive assignments to this shift is given           \nconstraint forall(day in 1..numberOfWeeks * daysPerWeek - s_max) (\n               (all_equal(plan1d[day..day+s_max])) -> (plan1d[day] != plan1d[day + s_max])\n           );               \n% the constraints over the array bounds             \nconstraint forall(d in 1..s_max) (\n               (all_equal(s_max_arrays[d, 1..s_max])) -> (plan1d[d + numberOfDays - s_max] != plan1d[d])\n           );                     \n\n                               \n                                                                                                   \n% C_restDays: at least 2 days must be rest days every 2 weeks.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3620, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bc34364b-6cf9-4c94-bc01-486f18e9898e": {"__data__": {"id_": "bc34364b-6cf9-4c94-bc01-486f18e9898e", "embedding": null, "metadata": {"problem_family": "Rotating_Rostering_Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "RosteringProblem", "node_type": "4", "metadata": {"problem_family": "Rotating_Rostering_Problem"}, "hash": "dcb597d14bf87b64a5c58d5a0ab83d3f8f5910b4f13722e8345326072121f5f6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f8f5da7f-477a-4f69-abb8-579035d6b52e", "node_type": "1", "metadata": {"problem_family": "Rotating_Rostering_Problem"}, "hash": "986b059e01a9f1c8d6585bdbe194fd5cf0ed2d6a43cd3bf790e6e87a49b60496", "class_name": "RelatedNodeInfo"}}, "text": "constraint forall(day in 1..(numberOfWeeks - 2) * daysPerWeek) (\n               count(j in plan1d[day..day + daysPerWeek * 2])(j=0) >= 2                   \n           );            \nconstraint forall(i in 1..2 * daysPerWeek-1) (\n               count(j in plan1d[numberOfWeeks * daysPerWeek-i .. numberOfWeeks * daysPerWeek] ++ plan1d[1..2*daysPerWeek-i])(j=0) >= 2    \n           );         \n                                            \n% C_shiftOrder: restricts the order of shifts. There is a forward rotating principle. This means, that after an early shift there can only follow a shift with the same or a higher value, or a rest shift.\nconstraint forall(day in 2..numberOfWeeks * daysPerWeek - 1) (\n               plan1d[day] <= plan1d[day + 1] \\/ plan1d[day+1] == 0\n           );         \nconstraint plan1d[1] >= plan1d[numberOfDays] \\/ plan1d[1] == 0;\n                      \n% C_shiftRequirements: for every weekday for each shift the number of required staff is provided (e.g. usually less staff is required on the weekend) \nconstraint forall(day in 1..daysPerWeek) (\n              (global_cardinality(row(plan2dT,day),[0,1,2,3],row(shiftRequirements,day)))   \n           );    \n           \n% solve the problem           \nsolve :: int_search(plan1d, input_order, indomain_min, complete)\n      satisfy;           \n      \n% print the problem      \noutput [ show(row(plan2d,j)) ++ \"\\n\" | j in 1..numberOfWeeks ] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 3621, "end_char_idx": 5048, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "918df488-03af-4c8a-9aeb-c8292c4a885a": {"__data__": {"id_": "918df488-03af-4c8a-9aeb-c8292c4a885a", "embedding": null, "metadata": {"problem_family": "Solitaire_Battleships"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sb", "node_type": "4", "metadata": {"problem_family": "Solitaire_Battleships"}, "hash": "36df11b2f91d8cbfd388b8ce631b3beb33ba5c5f6b5b8e76a75c1398b55633d2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "35462174-f9ae-4110-811e-9639e0169f86", "node_type": "1", "metadata": {}, "hash": "0ebf8a1cb461e17b750863cf4775a61736198c3b97cb145f1b9d0fbd23796922", "class_name": "RelatedNodeInfo"}}, "text": "% Solitaire Battleships is a puzzle where\n% we are given a partially filled in board and the number\n% of ships in each row and column and have to fill it with ships\n \n% \"Improved\" version does not introduce reified set_in\n\nint: width;   % height of board (usually 10)\nint: height;  % width of board (usually 10)\nint: maxship; % maximal length of ship (usually 4)\n\n\nset of int: ROWS = 1..width;\nset of int: COLS = 1..height;\nset of int: XROWS = 0..width+1;    % extended rows\nset of int: XCOLS = 0..height+1;   % extended cols\n\n%% ship types enumerated type\nset of int: SHIPS = 1..maxship;  % different ship types\nint: submarine = 1;\nint: destroyer = 2;\nint: cruiser = 3;\nint: battleship = 4;\n\n\n%% the PIECES enumerated type!\nset of int: PIECES = 1..7;\nint: w = 1; % water\nint: c = 2; % circle (submarine)\nint: l = 3; % left end of ship\nint: r = 4; % right end of ship\nint: t = 5; % top of ship\nint: b = 6; % bottom of ship\nint: m = 7; % middle of ship\narray[PIECES] of string: code = [\".\",\"c\",\"l\",\"r\",\"t\",\"b\",\"m\"];\n\narray[ROWS,COLS] of 0..7: hint; % the initial board configuration\narray[ROWS] of int: rowsum;     % sums for each row\narray[COLS] of int: colsum;     % sums for each col\narray[SHIPS] of int: ship; % the number of each type of ship (usually [4,3,2,1]).\n\n\n\n% variables \narray[XROWS,XCOLS] of var PIECES: board;  % the board\n \narray[XROWS,XCOLS] of var 0..1: fill;     % which pieces are ships\n\narray[PIECES] of var 0..width*height: npiece; % number of pieces of each type", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1485, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "35462174-f9ae-4110-811e-9639e0169f86": {"__data__": {"id_": "35462174-f9ae-4110-811e-9639e0169f86", "embedding": null, "metadata": {"problem_family": "Solitaire_Battleships"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sb", "node_type": "4", "metadata": {"problem_family": "Solitaire_Battleships"}, "hash": "36df11b2f91d8cbfd388b8ce631b3beb33ba5c5f6b5b8e76a75c1398b55633d2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "918df488-03af-4c8a-9aeb-c8292c4a885a", "node_type": "1", "metadata": {"problem_family": "Solitaire_Battleships"}, "hash": "16346bd036eecdeb31af92c063954c4d3e0aaa09f809ce516075e5e4531a01a9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "46c3d8a4-29ce-4350-9224-8eef9e70bb72", "node_type": "1", "metadata": {}, "hash": "c7b7dc75f538ee19468972c666edde85debb6d082a1c334fe54f6a3b924411ac", "class_name": "RelatedNodeInfo"}}, "text": "% variables \narray[XROWS,XCOLS] of var PIECES: board;  % the board\n \narray[XROWS,XCOLS] of var 0..1: fill;     % which pieces are ships\n\narray[PIECES] of var 0..width*height: npiece; % number of pieces of each type\n\n\n% model\n\n% ensure hints are respected\nconstraint forall(i in ROWS, j in COLS)(\n\t\t\t   if hint[i,j] != 0 then\n\t\t\t   \t\tboard[i,j] == hint[i,j]\n\t\t\t   else true endif\n\t       ); \n\n% make extended rows and cols empty\nconstraint forall(i in XROWS)(board[i,0] == w /\\ board[i,width+1] == w);\nconstraint forall(j in COLS)(board[0,j] == w /\\ board[height+1,j] == w);\n\n% ensure that the fill array matches the board\nconstraint forall(i in XROWS, j in XCOLS)(\n\t\t\t   fill[i,j] = bool2int(board[i,j] != w)\n\t       ); \n\n% spacing constraints: gaps betwen ships\nconstraint forall(i in ROWS, j in COLS)(\n\t   (board[i,j] == w \\/ board[i+1,j+1] == w)\n\t/\\ (board[i,j] == w \\/ board[i+1,j-1] == w)   % diagonal constraints\n            /\\ (board[i,j] in {c,l,r,t} -> board[i-1,j] == w)\n            /\\ (board[i,j] in {c,l,r,b} -> board[i+1,j] == w)\n            /\\ (board[i,j] in {c,l,t,b} -> board[i,j-1] == w)\n            /\\ (board[i,j] in {c,r,t,b} -> board[i,j+1] == w)\n           );\n               \t\t\t                       \n% ship shape constraints\nconstraint forall(i in ROWS, j in COLS)(\n               %% a left piece needs a right piece or middle to the right\n\t\t\t   (board[i,j] == l -> (board[i,j+1] == r \\/ board[i,j+1] == m))\n\t\t\t/\\ (board[i,j] == r -> (board[i,j-1] == l \\/ board[i,j-1] == m))\n\t\t\t/\\ (board[i,j] == t -> (board[i+1,j] == b \\/ board[i+1,j] == m))\n\t\t\t/\\ (board[i,j] == b -> (board[i-1,j] == t \\/ board[i-1,j] == m))\n\t\t\t   %% a middle piece has to have two opposite sides filled\n\t\t\t/\\ (board[i,j] == m -> (   fill[i-1,j] == fill[i+1,j]\n\t\t\t                        /\\ fill[i,j-1] == fill[i,j+1]\n\t\t\t                        /\\ fill[i-1,j] + fill[i,j-1] == 1))\n\t\t   );\n\t\t   \n% sum up pieces\nconstraint forall(p in PIECES)(\n\t\t\t   sum(i in ROWS, j in COLS)(bool2int(board[i,j] == p)) == npiece[p]\n\t\t   );\n\n% piece sum constraints\nconstraint npiece[c] == ship[submarine]; % submarines\nconstraint npiece[l] == npiece[r]; % left right (probably redundant)\nconstraint npiece[t] == npiece[b]; % top bottom\nconstraint npiece[l] + npiece[t] == sum(s in destroyer..maxship)(ship[s]); \n                                   % no of ends\nconstraint npiece[m] == sum(s in cruiser..maxship)(ship[s] * (s - 2)); \n                                   % no of middles \t\t   \n\t\t    \n% count number of bigger ships\n% at least for standard battleships you can probably simply\n% enforce this constraint for s in destroyer..destroyer\t\t\n% and still be guaranteed a correct solution    \nconstraint forall(s in destroyer..maxship)(\n\t           sum(i in ROWS,j in COLS)(bool2int(\n\t\t\t       if j + s - 1 <= width then\n\t\t\t          board[i,j] == l /\\ board[i,j+s-1] == r     % ship length s lr\n\t\t\t       /\\ forall(k in j+1..j+s-2)(board[i,k] == m)\n\t\t\t       else false endif\n\t\t\t    \\/\n\t\t\t       if i + s - 1 <= height then\n\t\t\t          board[i,j] == t /\\ board[i+s-1,j] == b     % ship length s tb\n\t\t\t       /\\ forall(k in i+1..i+s-2)(board[k,j] == m)\n\t\t\t       else false endif\n\t\t       )) = ship[s]\n\t\t   );\t\t    \n\t\t    \t\t    \n\n% row sums respected\nconstraint forall(i in ROWS)(\n               sum(j in COLS)(fill[i,j]) == rowsum[i]\n           );\n           \n% column sums respected           \nconstraint forall(j in COLS)(\n               sum(i in ROWS)(fill[i,j]) == colsum[j]\n           );", "mimetype": "text/plain", "start_char_idx": 1271, "end_char_idx": 4742, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "46c3d8a4-29ce-4350-9224-8eef9e70bb72": {"__data__": {"id_": "46c3d8a4-29ce-4350-9224-8eef9e70bb72", "embedding": null, "metadata": {"problem_family": "Solitaire_Battleships"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sb", "node_type": "4", "metadata": {"problem_family": "Solitaire_Battleships"}, "hash": "36df11b2f91d8cbfd388b8ce631b3beb33ba5c5f6b5b8e76a75c1398b55633d2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "35462174-f9ae-4110-811e-9639e0169f86", "node_type": "1", "metadata": {"problem_family": "Solitaire_Battleships"}, "hash": "0c944609b070afe33ab439e9586f343fdaa045a0575465369d7e41fba8be6225", "class_name": "RelatedNodeInfo"}}, "text": "solve :: int_search([ fill[i,j] | i in ROWS, j in COLS], \n      \t\t  input_order, indomain_min, complete)\n      satisfy;\n\noutput [ code[fix(board[i,j])] ++ \n\t\t if j == width then \" \" ++ show(rowsum[i]) ++ \"\\n\"\n\t\t else \"\" endif\n\t   | i in ROWS, j in COLS ]  ++\n\t   [ show(colsum[j]) | j in COLS ] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 4756, "end_char_idx": 5061, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c805fa24-5f97-4da1-aafd-ce6b47f2b988": {"__data__": {"id_": "c805fa24-5f97-4da1-aafd-ce6b47f2b988", "embedding": null, "metadata": {"problem_family": "Schur_s_Lemma"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "schur", "node_type": "4", "metadata": {"problem_family": "Schur_s_Lemma"}, "hash": "185a4a98bb47e5f0d28320b8e67e3198373e7fb75fc3c84bcbdcc44f3547afa5", "class_name": "RelatedNodeInfo"}}, "text": "%% schurs numbers\n%%\n%% determine if n balls labelled 1..n\n%% can be placed in c boxes with no box containing a triple {x,y,z} where x+y=z\n \n\nint: n; %% number of balls\nint: c; %% number of boxes\n\narray[1..n] of var 1..c: box;\n\nconstraint forall(i in 1..n-1, j in i+1 .. n - i)(\n\t   \t    box[i] != box[j] \\/ \n\t\t    box[i] != box[i+j] \\/ \n\t\t    box[j] != box[i+j]);\n\nsolve satisfy;\n\noutput [\"n = \", show(n), \";\\nc = \", show(c), \";\\nbox = \",show(box),\";\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 456, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a6addad5-b9af-4ebb-ab11-5cc0e7bf9fc0": {"__data__": {"id_": "a6addad5-b9af-4ebb-ab11-5cc0e7bf9fc0", "embedding": null, "metadata": {"problem_family": "Synchronous_Optical_Networking__SONET__Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sonet_problem", "node_type": "4", "metadata": {"problem_family": "Synchronous_Optical_Networking__SONET__Problem"}, "hash": "cb49ba0750ddae3f7df128d5c4f57a2a1b8075d1e8f8ae75911d223c2d4bdfb0", "class_name": "RelatedNodeInfo"}}, "text": "% The SONET problem is a network design problem: set up a network between\n% n nodes, where only certain nodes require a connection.\n% Nodes are connected by putting them on a ring, where all nodes\n% on a ring can communicate. Putting a node on a ring requires a so-called\n% ADM, and each ring has a capacity of nodes, i.e. ADMs. There is a certain\n% amount of rings, r, that is available. The objective is to set up a network\n% by using a minimal amount of ADMs.\n%\n%\n% About the problem model\n%\n% The problem model has the amount of rings ('r'), amount of nodes('n'),\n% the 'demand' (which nodes require communication) and node-capacity of each\n% ring ('capacity_nodes') as parameters.\n% The assignement of nodes to rings is modelled by a 2-dimensional matrix 'rings',\n% indexed by the amnount of rings and nodes. The matrix-domain is boolean:\n% If the node in column j is assigned to the ring in row i, then rings[i,j] = 1\n% and 0 otherwise. So all the '1's in the matrix 'rings' stand for an ADM.\n% Hence the objective is to minimise the sum over all columns and rows of matrix\n% 'rings'.\n% \"\"\"\n\nint: r;  % upper bound for amount of rings\nint: n;  % amount of clients\n\n\n% original comment: \n% we have double entries here because of the symmetric structure!\narray[1..n, 1..n] of 0..1: demand;\narray[1..r] of 1..n: capacity_nodes;\n\narray[1..r, 1..n] of var 0..1: rings;\nvar int: z =  sum(ring in 1..r, client in 1..n) (rings[ring, client]);\n\nsolve minimize z;\n% solve satisfy;\n\n\nconstraint\n%   z <= 7 % for solve satisfy\n%   /\\\n\n   % original comment:\n   % if there is a demand between 2 nodes, then there has to exist \n   % a ring, on which they are both installed\n   forall(client1,client2 in 1..n where client1 < client2) (\n      (demand[client1,client2] = 1) ->\n           exists(ring in 1..r) (\n                 rings[ring,client1] + rings[ring, client2] >= 2\n           )\n   )   \n   /\\\n   % original comment:\n   % capacity of each ring must not be exceeded     \n   forall(ring in 1..r) (\n        sum(client in 1..n) (\n              rings[ring, client]\n              ) <= capacity_nodes[ring] \n   )\n;\n\n\n%\n% data\n% (sonet_problem1nu.param)\n%\nr = 4;\nn = 5;\n\ndemand =\narray2d(1..n, 1..n,\n        [0,1,0,1,0,\n         1,0,1,0,0,\n         0,1,0,0,1,\n         1,0,0,0,0,\n         0,0,1,0,0])\n;\n\ncapacity_nodes = [3,2,2,1];\n\n\noutput \n[\n  \"z: \", show(z)\n] ++\n[\n  if client = 1 then \"\\n\" else \" \" endif ++\n    show(rings[ring, client])\n  | ring in 1..r, client in 1..n\n] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2477, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "52139d6b-be60-4dd2-aee9-ab7075906ce5": {"__data__": {"id_": "52139d6b-be60-4dd2-aee9-ab7075906ce5", "embedding": null, "metadata": {"problem_family": "Steiner_triple_systems"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "steiner", "node_type": "4", "metadata": {"problem_family": "Steiner_triple_systems"}, "hash": "9dbff475761c6323f42a487023a3f060d92acf41940777eeebdd99b8846469e0", "class_name": "RelatedNodeInfo"}}, "text": "% The ternary Steiner problem of order n is to find n(n-1)/6 sets of elements in {1,2,...,n}\n% such that each set contains three elements and any two sets have at most one element in common.\n% For example, the following shows a solution for size n=7:\n%\n%      {1,2,3}, {1,4,5}, {1,6,7}, {2,4,6}, {2,5,7}, {3,4,7}, {3,5,6}\n\ninclude \"globals.mzn\";\n\nint: N = 7; \nint: NB = N *(N-1) div 6;\narray[1..NB] of var set of 1..N: Sets;\n\n% solve satisfy;\nsolve::set_search(Sets, first_fail, indomain_min, complete) satisfy;\n\n\n\nconstraint\n   forall(i in index_set(Sets)) (\n      card(Sets[i]) = 3\n   )\n   /\\ \n   forall(i,j in index_set(Sets) where i < j) (\n      card( Sets[i] intersect Sets[j]) <= 1\n   )\n   /\\ % symmetry breaking\n   decreasing(Sets)\n\n;\n\noutput [\n       \"N: \", show(N), \" NB: \", show(NB), \"\\n\",\n       \"Sets: \", show(Sets)\n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 830, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b6c12a8e-e234-4235-9249-b454ed8bdc9d": {"__data__": {"id_": "b6c12a8e-e234-4235-9249-b454ed8bdc9d", "embedding": null, "metadata": {"problem_family": "Stochastic_Assignment_and_Scheduling_Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "stoch_fjsp", "node_type": "4", "metadata": {"problem_family": "Stochastic_Assignment_and_Scheduling_Problem"}, "hash": "696c8f99457132eaf6cb09a68a9685b4ed5dba7b5cba2e096989284f09bd2686", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "50d06e8f-5183-46b1-a0ff-eb3567c625cb", "node_type": "1", "metadata": {}, "hash": "b2868895262cbee3008db9721ab70f27a404b7995a2e54ebe9aff44e39578e32", "class_name": "RelatedNodeInfo"}}, "text": "% Stochastic General Assignment Problem \n% First stage:\n%    assign task to machines \n% Second stage:\n%    based on observed processign times, schedule taks on respective machines\n% Objective:\n%    minimise expected makespan\n\ninclude \"globals.mzn\";\n\n% Parameters\n\nint: no_mach;   % Number of machines\nint: no_jobs;   % Number of jobs\nint: no_task;   % Number of total tasks\nint: no_optt;   % Number of total optional tasks\n\nset of int: Mach  = 1..no_mach;\nset of int: Jobs  = 1..no_jobs;\nset of int: Tasks = 1..no_task;\nset of int: OptTs = 1..no_optt;\n\narray [Jobs] of set of int: tasks;\narray [Tasks] of set of int: optts;\n\narray [OptTs] of int: optt_mach;\narray [SCENARIOS1,OptTs] of int: optt_dur;\n\n\narray [Jobs] of int: last_task = [ max(tasks[j]) | j in Jobs ];\n%---------implications for multi scenarion solving ---------------\nint: nbScenarios;\nset of int: SCENARIOS1 = 1.nbScenarios;\nint: first_scen;\nint: last_scen;\nset of int: SCENARIOS = first_scen.last_scen;\narray[SCENARIOS1] of int: weights;\n\n%-------end of multi scenario addons ----------------\narray [Tasks] of int: task_job = \n    [ min(j in Jobs where t in tasks[j])(j) | t in Tasks ];\narray [SCENARIOS,Tasks] of int: task_mins =\n    array2d(SCENARIOS,Tasks,[ sum(k in tasks[task_job[t]])(if k < t then task_mind[s,k] else 0 endif)\n    |   s in SCENARIOS, t in Tasks ]);\narray [SCENARIOS,Tasks] of int: task_maxs =\n    array2d(SCENARIOS,Tasks,[ t_max[s] -\n        sum(k in tasks[task_job[t]])(if k < t then 0 else task_mind[s,k] endif)\n    |   s in SCENARIOS,  t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_mind =\n    array2d(SCENARIOS,Tasks,[ min(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS,t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_maxd = \n    array2d(SCENARIOS,Tasks,[ max(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS, t in Tasks ]);\n\n    % Additional deirved parameters for optional tasks\n    %\narray [OptTs] of int: optt_task =\n    [ min(t in Tasks where o in optts[t])(t) | o in OptTs ];\n\narray[SCENARIOS1] of int: min_dur = [ min([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\narray[SCENARIOS1] of int: max_dur = [ max([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\nset of int: Durs = min(min_dur).max(max_dur);\n\n    % Parameters related to the planning horizon\n    %\narray[SCENARIOS1] of int: t_max = [sum(t in Tasks)(max(o in optts[t])(optt_dur[s,o])) | s in SCENARIOS1];\n\nset of int: Times = 0.max(t_max);\n\n%-----------------------------------------------------------------------------%\n% Variables\n\n    % Start time variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Times: start =\n    array2d(SCENARIOS,Tasks,[ let { var task_mins[s,t].task_maxs[s,t]: k } in k | s in SCENARIOS, t in Tasks ]);\n\n    % Duration variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Durs: dur =\n    array2d(SCENARIOS,Tasks,[ if task_mind[s,t] = task_maxd[s,t] then task_mind[s,t] else\n        let { var task_mind[s,t].task_maxd[s,t]: d } in d endif\n    |   s in SCENARIOS,t in Tasks ]);", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "50d06e8f-5183-46b1-a0ff-eb3567c625cb": {"__data__": {"id_": "50d06e8f-5183-46b1-a0ff-eb3567c625cb", "embedding": null, "metadata": {"problem_family": "Stochastic_Assignment_and_Scheduling_Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "stoch_fjsp", "node_type": "4", "metadata": {"problem_family": "Stochastic_Assignment_and_Scheduling_Problem"}, "hash": "696c8f99457132eaf6cb09a68a9685b4ed5dba7b5cba2e096989284f09bd2686", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b6c12a8e-e234-4235-9249-b454ed8bdc9d", "node_type": "1", "metadata": {"problem_family": "Stochastic_Assignment_and_Scheduling_Problem"}, "hash": "f3a2cb8694814ce00e52952671c478bc6adac5e24736c2c9156508c3d4ab3a36", "class_name": "RelatedNodeInfo"}}, "text": "set of int: Times = 0.max(t_max);\n\n%-----------------------------------------------------------------------------%\n% Variables\n\n    % Start time variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Times: start =\n    array2d(SCENARIOS,Tasks,[ let { var task_mins[s,t].task_maxs[s,t]: k } in k | s in SCENARIOS, t in Tasks ]);\n\n    % Duration variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Durs: dur =\n    array2d(SCENARIOS,Tasks,[ if task_mind[s,t] = task_maxd[s,t] then task_mind[s,t] else\n        let { var task_mind[s,t].task_maxd[s,t]: d } in d endif\n    |   s in SCENARIOS,t in Tasks ]);\n\n    % Variables whether an optional task is executed\n    %\narray [OptTs] of var bool: b;\n\narray[SCENARIOS] of var Times: de_objective;\n\nset of int: StochTimes = 0.sum(t_max);\nvar StochTimes: objective;\n%-----------------------------------------------------------------------------%\n% Constraints\n\n    % Precedence relations\n    %\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs, i in tasks[j] where i < last_task[j])(\n            start[s,i] + dur[s,i] <= start[s,i + 1]\n        )    \n    );\n\n    % Duration constraints\n    %\nconstraint\n    forall(o in OptTs,s in SCENARIOS)(\n        let { int: t = optt_task[o] } in (\n            if card(optts[t]) = 1 then\n                b[o] = true\n            else\n                b[o] -> dur[s,t] = optt_dur[s,o]\n            endif\n        )\n    );\n\n    % Optional tasks' constraints\n    %\nconstraint\n    forall(t in Tasks where card(optts[t]) > 1)(\n        ( sum(o in optts[t])(bool2int(b[o])) <= 1     )\n    /\\  ( exists(o in optts[t])(b[o])                 )\n    );\n\nconstraint\n    forall(t in Tasks where card(optts[t]) = 2)(\n        let {\n            int: o1 = min(optts[t]),\n            int: o2 = max(optts[t])\n        } in ( b[o1] <-> not(b[o2]) )\n    );\n\n    % Resource constraints\n    %\nconstraint\n    forall(m in Mach,s in SCENARIOS)(\n        let {\n            set of int: MTasks = { o | o in OptTs where optt_mach[o] = m }\n        } in (\n            cumulative(\n                [ start[s,optt_task[o]] | o in MTasks ],\n                [ optt_dur[s,o]         | o in MTasks ],\n                [ bool2int(b[o])      | o in MTasks ],\n                1\n            )\n        )\n    );\n\n% Objective constraint\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs)(start[s,last_task[j]] + dur[s,last_task[j]] <= de_objective[s])\n    );\nconstraint \n        objective = sum(s in SCENARIOS)(weights[s]*de_objective[s]);\n%-----------------------------------------------------------------------------%\n% Solve item\n\nsolve \n    :: search\n    minimize objective;\n\n%------------------------------------------------------------------------------%\n% Searches\n\nann: s_mindur   = int_search([dur[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_minstart = int_search([start[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_bool     = bool_search(b, input_order, indomain_max, complete);\nann: s_obj      = int_search(de_objective, input_order, indomain_min, complete);\n\nann: search = seq_search([s_mindur, s_bool, s_minstart, s_obj]);\n\n%-----------------------------------------------------------------------------%\n% Output\n\noutput \n[   \"objective = \", show(de_objective), \";\\n\",\n    \"stoch obj = \", show(objective), \";\\n\",\n    \"start = \", show(start), \";\\n\",\n    \"dur = \", show(dur), \";\\n\",\n    \"b = \", show(b), \";\\n\",\n];", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "59ca7377-8a99-4678-896a-52d84c60fd04": {"__data__": {"id_": "59ca7377-8a99-4678-896a-52d84c60fd04", "embedding": null, "metadata": {"problem_family": "Template_Design"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "template_design", "node_type": "4", "metadata": {"problem_family": "Template_Design"}, "hash": "9e60ec1ffb6c5ab8391d12e1ef11a9ede96d3368bc41e71280aadac1a4385f20", "class_name": "RelatedNodeInfo"}}, "text": "% Template design\ninclude \"globals.mzn\";\n\nint: S;   \t\t% Number of slots per template.\nint: t;   \t\t% Number of templates.\nint: n;   \t\t% Number of variations.\narray[1..n] of int: d; \t% How much of each variation we must print?\n\n% Lower and upper bounds for the total production.\n%\nint: llower = ceil(sum(i in 1..n)(int2float(d[i]))/int2float(S));\nint: lupper = 2*llower; % If t>1, this should be the optimal Production_{t-1}-1.\n\n% # Slots allocated to variation i in template j\narray[1..n,1..t] of var 0..S: p;\n\n% # Pressings of template j.\narray[1..t] of var 1..lupper: R;\n\n% Sum of all Rj.\nvar llower..lupper: Production;\n\n% Production x S - sum(d[i])\nvar 0..lupper-llower: Surplus;\n\n% First, set up Production to be the sum of the Rj\nconstraint\n\tProduction = sum(i in 1..t)(R[i]);\n\n% the limits on production\nconstraint\n\tProduction >= llower /\\ Production <= lupper;\n\n% The number of slots occupied in each template is S.\nconstraint\n\tforall(j in 1..t)\n\t\t (sum(i in 1..n)(p[i,j]) = S);\n\n% Enough of each variation is printed.\nconstraint\n\tforall(i in 1..n)\n\t\t (sum(j in 1..t)(p[i,j]*R[j]) >= d[i]);\n\n% Symmetry constraints.\n% Variations with the same demand are symmetric.\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] == d[i+1] then\n\t\t\tlex_lesseq([p[i,  j] | j in 1..t],\n\t\t\t\t[p[i+1,j] | j in 1..t])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% pseudo symmetry\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] < d[i+1] then\n\t\t       sum (j in 1..t) (p[i,j]*R[j])\n\t\t     <= sum (j in 1..t) (p[i+1,j]*R[j])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% implied constraints on the surplus\n\n% These are presented in the paper as necessary to get good\n% performance for this model, but I think bounds consistency on the\n% sum(R[i]) constraint would produce the same amount of propagation\n\n% Set up surplus, which is bounded as production is bounded.\nconstraint\n\tSurplus = Production*S - sum(i in 1..n)(d[i]);\n\n% The surplus of each variation is also limited by the surplus.\nconstraint\n\tforall(k in 1..n)\n\t\t (sum(j in 1..t)(p[k,j]*R[j]-d[k]) <= Surplus);\n\n% The surplus of the first k variations is limited by the surplus.\nconstraint\n\tforall(k in 2..n-1)\n\t\t (sum(j in 1..t, m in 1..k)( p[m,j]*R[j]-d[m] ) <= Surplus);\n\n% Implied constraints on the run length.\nconstraint\n\tif t=2 then (\n\t\tR[1] <= Production div 2\n\t/\\\tR[2] >= Production div 2\n\t) else true endif;\n\nconstraint\n\tif t=3 then (\n\t\tR[1] <= Production div 3\n\t/\\\tR[2] <= Production div 2\n\t/\\\tR[3] >= Production div 3\n\t) else true endif;\n\n% Minimize the production.\nsolve :: int_search(array1d(1..n*t,p) ++ R, input_order, indomain_min, complete)\n    minimize Production;\n\noutput [\n    if v = 1 then \"template #\" ++ show(i) ++ \": [\" else \"\" endif ++\n    show(p[v, i]) ++\n    if v = n then \"], pressings: \" ++ show(R[i]) ++ \"\\n\" else \", \" endif\n\t| i in 1..t, v in 1..n]\n    ++ [\"Total pressings: \", show(Production), \"\\n%\\n\"];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2997, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "83dadf5e-3a2d-467d-a532-dfe7c94af3b1": {"__data__": {"id_": "83dadf5e-3a2d-467d-a532-dfe7c94af3b1", "embedding": null, "metadata": {"problem_family": "Traffic_Lights"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "traffic_lights_table", "node_type": "4", "metadata": {"problem_family": "Traffic_Lights"}, "hash": "2645d72e7ac2b26234eea40231d52bedfeb5b326ff0c6daae73f9186213af6d8", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n%Traffic lights problem in MiniZinc.\n% Specification:\n% Consider a four way traffic junction with eight traffic lights. Four of\n% the traffic lights are for the vehicles and can be represented by the\n% variables V1 to V4 with domains\n% {r,ry,g,y} (for red, red-yellow, green and yellow).\n%  The other four traffic lights are for the pedestrians and can be\n%  represented by the variables P1 to P4 with domains {r,g}.\n%\n% The constraints on these variables can be modelled by quaternary\n% constraints on\n% (Vi, Pi, Vj, Pj ) for 1<=i<=4, j=(1+i)mod 4 which allow just the tuples\n% {(r,r,g,g), (ry,r,y,r), (g,g,r,r), (y,r,ry,r)}.\n%\n% It would be interesting to consider other types of junction (e.g. five roads\n% intersecting) as well as modelling the evolution over time of the\n% traffic light sequence.\n\ninclude \"globals.mzn\";\n\nint: n = 4;\nint: r  = 1; % red\nint: ry = 2; % red-yellow\nint: g  = 3; % green\nint: y  = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V;\narray[1..n] of var Pedestrians: P;\n\n\nsolve satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   table([V[i], P[i], V[j], P[j]], allowed)\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\n% output [\n%  \"V: \", show(V), \"\\nP: \", show(P), \"\\n\"\n% ];\noutput [\n show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: n = 4;\nint: r = 1; % red\nint: ry = 2; % red-yellow\nint: g = 3; % green\nint: y = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V; % ;\narray[1..n] of var Pedestrians: P; %;\n\npredicate cp1d(array[int] of var int: x, array[int] of var int: y) =\n  assert(index_set(x) = index_set(y),\n           \"cp1d: x and y have different sizes\",\n     forall(i in index_set(x)) ( x[i] = y[i] ))\n; \n\n% solve satisfy;\nsolve :: int_search(V ++ P, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   exists(a in 1..4) (\n      cp1d([V[i], P[i], V[j], P[j]], [allowed[a,k] | k in 1..4])\n   )\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\noutput [\n  show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2367, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ea5fe9c8-d3bd-4cac-b518-f30eb284456f": {"__data__": {"id_": "ea5fe9c8-d3bd-4cac-b518-f30eb284456f", "embedding": null, "metadata": {"problem_family": "Traveling_Tournament_Problem_with_Predefined_Venues__TTPPV_"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "TTPPV", "node_type": "4", "metadata": {"problem_family": "Traveling_Tournament_Problem_with_Predefined_Venues__TTPPV_"}, "hash": "5f99608029be4ecc59c3920a0d26d7a51f9d0401c96bc8fd2f7377e6b14c3474", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8de5e16a-6b19-4c71-9f55-78bd9ef36d37", "node_type": "1", "metadata": {}, "hash": "4b1625c329daa913b7c04fdd5b8a60503ebfec09ba467577cc2c7cce9b089ce5", "class_name": "RelatedNodeInfo"}}, "text": "% Traveling Tournament Problem with Predefined Venues\n%\n% Compact single round robin schedule minimizing total travel distance\n% The venue of each game has already been decided\n% Specialized for CIRC instances (circular distances)\n\ninclude \"globals.mzn\";\n\nint: nbTeams;\nint: nbRounds = nbTeams-1;\n\nset of int: Teams = 1..nbTeams;\nset of int: Rounds = 1..nbRounds;\nset of int: Travels = 1..nbRounds+1;\n\n% predefined venue: pv[i][j] = 1 iff i is playing at home against j\narray[Teams,Teams] of 1..2: pv; \n\n% circular distances: for i>=j, distance[i][j]=min{i-j,j-i+nbTeams}\narray[Teams,Teams] of int: distance = \n  array2d(Teams,Teams,[ if i>=j then (if i-j < j-i+nbTeams then i-j else j-i+nbTeams endif) \n                                else (if j-i < i-j+nbTeams then j-i else i-j+nbTeams endif) \n                                endif | i,j in Teams]);\n\n% output related\nint: digs = ceil(log(10.0,int2float(nbTeams)));\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% decision variables: in round k, team i plays against team opponent[i,k]\narray[Teams,Rounds] of var Teams: opponent;\n\n% auxiliary variables: venue[i,k] = 1 iff team i plays at home in round k\narray[Teams,Rounds] of var 1..2: venue;\nconstraint forall (i in Teams, k in Rounds) (venue[i,k] = pv[i,opponent[i,k]]);\n\n% auxiliary variables: travel[i,k] is the distance travelled by team i to go play in round k (includes travelling back home after last round)\narray[Teams,Travels] of var 0..(nbTeams div 2): travel;\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1501, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8de5e16a-6b19-4c71-9f55-78bd9ef36d37": {"__data__": {"id_": "8de5e16a-6b19-4c71-9f55-78bd9ef36d37", "embedding": null, "metadata": {"problem_family": "Traveling_Tournament_Problem_with_Predefined_Venues__TTPPV_"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "TTPPV", "node_type": "4", "metadata": {"problem_family": "Traveling_Tournament_Problem_with_Predefined_Venues__TTPPV_"}, "hash": "5f99608029be4ecc59c3920a0d26d7a51f9d0401c96bc8fd2f7377e6b14c3474", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ea5fe9c8-d3bd-4cac-b518-f30eb284456f", "node_type": "1", "metadata": {"problem_family": "Traveling_Tournament_Problem_with_Predefined_Venues__TTPPV_"}, "hash": "797806a137bfdaeded8ebbcc722b489f6c760117fba3f7637dcff7045e610366", "class_name": "RelatedNodeInfo"}}, "text": "% a team cannot play against itself\nconstraint forall (i in Teams, k in Rounds) (opponent[i,k] != i);\n\n% in round k, i plays j means j plays i\nconstraint forall (i in Teams, k in Rounds) (opponent[opponent[i,k],k] = i);\n\n% for each team i, all opponents are different\nconstraint forall (i in Teams) (alldifferent([opponent[i,k] | k in Rounds]));\n\n% for each round k, all opponents are different (implied constraint)\nconstraint forall (k in Rounds) (alldifferent([opponent[i,k] | i in Teams]));\n\n% for each team i, there can be at most 3 consecutive home games and at most 3 consecutive away games\nint: nbStates = 7;\nset of int: States = 1..nbStates;\narray[States,1..2] of int: delta = \n  [| 2, 5\n   | 3, 5\n   | 4, 5\n   | 0, 5\n   | 2, 6\n   | 2, 7\n   | 2, 0 |];\nconstraint forall (i in Teams) (regular( [venue[i,k] | k in Rounds], nbStates, 2, delta, 1, States));\n\n% symmetry breaking: distances are symmetric so reversing the rounds yields a schedule of same cost\nconstraint (opponent[1,1] < opponent[1,nbRounds]);\n\n% define travel variables wrt venues of current- and next-round games\nconstraint forall (i in Teams) (\n\t(venue[i,1]=1 -> travel[i,1] = 0) /\\\n\t(venue[i,1]=2 -> travel[i,1] = distance[i,opponent[i,1]]) );\nconstraint forall (i in Teams, k in 1..nbRounds-1) (\n\t((venue[i,k]=1 /\\ venue[i,k+1]=1) -> travel[i,k+1] = 0) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=1) -> travel[i,k+1] = distance[opponent[i,k],i]) /\\\n\t((venue[i,k]=1 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[i,opponent[i,k+1]]) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[opponent[i,k],opponent[i,k+1]]) );\nconstraint forall (i in Teams) (\n\t(venue[i,nbRounds]=1 -> travel[i,nbRounds+1] = 0) /\\\n\t(venue[i,nbRounds]=2 -> travel[i,nbRounds+1] = distance[opponent[i,nbRounds],i]) );\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nvar int: totalTravel;\nconstraint totalTravel = sum (i in Teams, k in Travels) (travel[i,k]);\nsolve minimize totalTravel;\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\noutput [\"SCHEDULE\\n\"] ++ \n       [ if fix(venue[i,k]) == 1 then \" \" else \"@\" endif ++\n\t show_int(digs,opponent[i,k]) ++ \" \" ++ \n         if k == nbRounds /\\ i != nbTeams then \"\\n\" else \"\" endif\n         | i in Teams, k in Rounds ] ++ [\"\\n\"] ++\n       [\"total travel = \"] ++ [show(totalTravel)] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 1504, "end_char_idx": 3772, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "412dc12d-0dff-4ab2-8741-4161dac425f7": {"__data__": {"id_": "412dc12d-0dff-4ab2-8741-4161dac425f7", "embedding": null, "metadata": {"problem_family": "Vessel_Loading"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "vessel-loading", "node_type": "4", "metadata": {"problem_family": "Vessel_Loading"}, "hash": "e69e7be85c1a89f81e968bdff5dae734d1e2aba225c4eb9df2298e63d225b342", "class_name": "RelatedNodeInfo"}}, "text": "% Vessel Loading\n\nint: deck_width; % width of deck\nint: deck_length; % height of deck\nint: n_containers; % number of containers\nint: n_classes; % number of container classes\n\narray[int] of int: width;\n% width[c] = width of container c\narray[int] of int: length;\n% length[c] = length of container c\narray[int] of int: class;\n% class[c] = class of container c\narray[int, int] of int: separation;\n% separation[a, b] = the minimum allowed separation between\n%                    containers of classes a and b\n\nset of int: Containers = 1..n_containers;\n\narray[Containers] of var 0..deck_width: Left;\n% Left[c] = leftmost point of container c\narray[Containers] of var 0..deck_width: Right;\n% Right[c] = rightmost point of container c\narray[Containers] of var 0..deck_length: Bottom;\n% Bottom[c] = bottommost point of container c\narray[Containers] of var 0..deck_length: Top;\n% Top[c] = topmost point of container c\n\narray[Containers] of var 1..2: orientation;\n% orientation[c] = 2 if container c is turned 90 degrees, else 1.\n\nconstraint\n  forall (c in Containers) (\n    let {\n      array[1..2] of int: ElemWidth = [width[c], length[c]];\n      array[1..2] of int: ElemLength = [length[c], width[c]]\n    }\n    in \n      Right[c] = Left[c] + ElemWidth[orientation[c]] /\\\n      Top[c] = Bottom[c] + ElemLength[orientation[c]]\n  )\n;\n\nconstraint\n  forall(c, k in Containers where c < k) (\n    Left[c] >= Right[k] + separation[class[c], class[k]] \\/\n    Right[c] + separation[class[c], class[k]] <= Left[k] \\/\n    Bottom[c] >= Top[k] + separation[class[c], class[k]] \\/\n    Top[c] + separation[class[c], class[k]] <= Bottom[k]\n  )\n;\n\n% Excessive (pretty) output\noutput [\"\u250c\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2510\\n\"] ++\n       [if x == 0 then \"\u2502\" else \"\" endif ++\n        let {\n          bool: l = exists([fix(Left[c])   = x | c in Containers]);\n          bool: r = exists([fix(Right[c])  = x | c in Containers]);\n          bool: b = exists([fix(Bottom[c]) = y | c in Containers]);\n          bool: t = exists([fix(Top[c])    = y | c in Containers])\n        } in\n          if     l /\\ r /\\ b /\\ t then \"\u253c\"\n          elseif l /\\ r /\\ b      then \"\u252c\"\n          elseif l /\\ r /\\      t then \"\u2534\"\n          elseif l /\\      b /\\ t then \"\u251c\"\n          elseif      r /\\ b /\\ t then \"\u2524\"\n          elseif l /\\      b      then \"\u250c\"\n          elseif l /\\           t then \"\u2514\"\n          elseif      r /\\ b      then \"\u2510\"\n          elseif      r /\\      t then \"\u2518\"\n          elseif l \\/ r           then \"\u2502\"\n          elseif           b \\/ t then \"\u2500\" \n          else \" \" endif ++\n        if x == deck_width then \"\u2502\\n\" else \"\" endif\n        | y in 0..deck_length, x in 0..deck_width] ++\n        [\"\u2514\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2518\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2710, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "32f19a75-4a42-4478-bcaa-56ca975298a9": {"__data__": {"id_": "32f19a75-4a42-4478-bcaa-56ca975298a9", "embedding": null, "metadata": {"problem_family": "Warehouse_Location_Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "warehouses", "node_type": "4", "metadata": {"problem_family": "Warehouse_Location_Problem"}, "hash": "aee392b846eba43a799d5e093dc710a17033e76a67dd01218ee3bb380d9382cf", "class_name": "RelatedNodeInfo"}}, "text": "% Warehouse allocation\n\n% vim: ft=zinc ts=2 sw=2 et tw=0\n\n% A company needs to construct warehouses to supply stores with goods.  Each\n% warehouse possibly to be constructed has a certain capacity defining how many\n% stores it can supply.  Constructing a warehouse incurs a fixed cost.  Costs\n% for transportation from warehouses to stores depend on the locations of\n% warehouses and stores.\n%\n% Determine which warehouses should be constructed and which warehouse should\n% supply which store such that overall cost (transportation cost plus\n% construction cost) is smallest.\n%-----------------------------------------------------------------------------\n\ninclude \"globals.mzn\";\n\n%-----------------------------------------------------------------------------\n% Instance\n\nn_suppliers = 5;\nn_stores = 10;\nbuilding_cost = 30;\n\ncapacity = [1,4,2,1,3];\n\ncost_matrix =\n [|20, 24, 11, 25, 30\n  |28, 27, 82, 83, 74\n  |74, 97, 71, 96, 70\n  | 2, 55, 73, 69, 61\n  |46, 96, 59, 83,  4\n  |42, 22, 29, 67, 59\n  | 1,  5, 73, 59, 56\n  |10, 73, 13, 43, 96\n  |93, 35, 63, 85, 46\n  |47, 65, 55, 71, 95|]; \n\n%-----------------------------------------------------------------------------\n% Model\n\nint: n_suppliers;\nint: n_stores;\nint: building_cost;\narray[1..n_suppliers] of int: capacity;\narray[1..n_stores,1..n_suppliers] of int: cost_matrix;\n\nint: MaxCost = max(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]);\nint: MaxTotal =   (n_suppliers * building_cost) \n                + sum(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]); \n\narray[1..n_stores] of var 1..n_suppliers: supplier;\narray[1..n_suppliers] of var bool: open;\narray[1..n_stores] of var 1..MaxCost: cost;\nvar 1..MaxTotal: tot;\n\nconstraint\n  sum (i in 1..n_suppliers) (building_cost * bool2int(open[i])) +\n  sum (i in 1..n_stores) (cost[i])\n  = tot;\n\nconstraint\n  forall (i in 1..n_stores) (\n    cost_matrix[i,supplier[i]] = cost[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    let {\n      var int: use\n     } in\n    count(supplier,i,use) /\\ use <= capacity[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    (exists (j in 1..n_stores) (supplier[j] == i)) == open[i]\n  );\n\nsolve\n  :: int_search(\n    supplier ++ cost ++ [bool2int(open[i]) | i in 1..n_suppliers],\n    first_fail,\n    indomain_split,\n    complete\n  )\n  minimize tot;\n\noutput\n  [ \"warehouses:\" ]\n  ++\n  [ \"\\ntot = \", show(tot) ]\n  ++\n  [ \"\\nsupplier = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(supplier[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\ncost = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(cost[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\nopen = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(open[i]) ++\n    if i = n_suppliers then \"\\n]\\n\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_suppliers\n  ]\n\n%-----------------------------------------------------------------------------\n%-----------------------------------------------------------------------------", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3065, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f1931183-2430-4ade-b730-ead1a231d0e5": {"__data__": {"id_": "f1931183-2430-4ade-b730-ead1a231d0e5", "embedding": null, "metadata": {"problem_family": "Water_Bucket_Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "water_buckets1", "node_type": "4", "metadata": {"problem_family": "Water_Bucket_Problem"}, "hash": "6bb371fdadea2a6dd401f669556cc3c8188b175fdce7925646cebe6437233bd4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5a6ab93e-791b-44a3-9b34-dd50bdb65cc5", "node_type": "1", "metadata": {}, "hash": "6e25024c8fe4654824d500250472be5c7cc1ae2b19f0dc59fd93623023311169", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n% Water buckets problem in Minizinc\n% \"\"\"\n% Problem description\n% This is a generalization of the CSPLib specification, which is as follows: Given an 8 pint bucket of water, and two empty buckets which can contain 5 and 3 pints respectively, the problem requires to divide the water into two by pouring water between buckets (that is, to end up with 4 pints in the 8 pint bucket, and 4 pints in the 5 pint bucket) in the smallest number of transfers.\n%\n% The generalization consists in making the specification parametric with respect to the start and goal configurations, which are now inputs to the problem.\n%\n% Problem input\n%\n% * Function start, assigning an initial amount of water to each bucket\n% * Function goal, assigning the goal amount of water to each bucket \n%\n% Search space\n% The set of all possibile sequences of configurations (states), where a configuration is a triple encoding the amount of water in each bucket at a given time-step\n%\n% Constraints\n%\n% * C1: At beginning, buckets contain the amount of water specified by function start\n% * C2: At the end, buckets contain the amount of water specified by function goal\n% * C3: The configuration at each step differs from that of the next one in that the amount of water of exactly 2 buckets changes (that in the others remain the same)\n% * C4: The overall amount of water is the same at each time step\n% * C5: After each transition (involving buckets b1 and b2), either the source bucket becomes empty, or the target becomes full\n% \"\"\"\n\n\nint: nb_buckets = 3;\nint: max_step = 10; % 8 for satisfy\nset of int: buckets = 1..nb_buckets;\nset of int: steps = 1..max_step;\narray[buckets] of int: capacity = [8,5,3];\narray[buckets] of int: start = [8,0,0];\narray[buckets] of int: goal = [4,4,0];\n\n% Search space: The set of all possibile sequences of configurations (states), \n% where a configuration is a triple encoding the amount of water in each \n% bucket at a given time-step\narray[steps, buckets] of var int: state;\nvar 1..max_step: goal_step;\n\n% Objective function\nsolve minimize goal_step;\n% solve :: int_search( [ state[i,j] | i in steps, j in buckets ] , \"first_fail\", \"indomain\", \"complete\")  minimize goal_step;\n\nconstraint\n%   goal_step <= 8 % for solve satisfy\n%   /\\\n   % assertions\n   forall(b in buckets) (\n      (start[b] <= capacity[b]) /\\ (goal[b] <= capacity[b])\n   )\n   /\\\n   sum(b in buckets)(start[b]) = sum(b in buckets)(goal[b])\n   /\\\n   forall(s in steps, b in buckets) (\n      state[s,b] >= 0 /\\\n      state[s,b] <= capacity[b]\n   )\n   /\\\n   forall(b in buckets) (\n      % C1: At beginning, buckets contain the amount of water specified by function start\n      state[1,b]=start[b]\n      /\\\n      % C2: At the end, buckets contain the amount of water specified by function goal\n      state[goal_step,b] = goal[b]\n   )\n   /\\\n   forall(step in 1..max_step-1) (\n      % C3: The configuration at each step differs from that of the next one in that the amount of\n      % water of exactly 2 buckets changes (that in the others remain the same)\n      sum(b in buckets)( bool2int(state[step,b] != state[step+1, b])) = 2\n      /\\\n      % C4: The overall amount of water is the same at each time step\n      sum(b in buckets)(state[step,b]) = sum(b in buckets)(state[step+1,b])\n      /\\\n\n      % C5: After each transition (involving buckets b1 and b2), either the source\n      % bucket becomes empty, or the target becomes full\n      forall(b1, b2 in buckets where b1 != b2) (\n         ((state[step, b1] != state[step+1, b1]) /\\ (state[step, b2] != state[step+1, b2])) ->\n            (state[step+1,b1] = 0 \\/ state[step+1,b1] = capacity[b1] \\/\n             state[step+1,b2] = 0 \\/ state[step+1,b2] = capacity[b2])\n     )\n   )\n;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3716, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5a6ab93e-791b-44a3-9b34-dd50bdb65cc5": {"__data__": {"id_": "5a6ab93e-791b-44a3-9b34-dd50bdb65cc5", "embedding": null, "metadata": {"problem_family": "Water_Bucket_Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "water_buckets1", "node_type": "4", "metadata": {"problem_family": "Water_Bucket_Problem"}, "hash": "6bb371fdadea2a6dd401f669556cc3c8188b175fdce7925646cebe6437233bd4", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f1931183-2430-4ade-b730-ead1a231d0e5", "node_type": "1", "metadata": {"problem_family": "Water_Bucket_Problem"}, "hash": "e7d2c7d3f9b12b511ae8ca2b3fbcad9d36a929c4317cdec5c93e6bd58f46359c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1c4a588d-d1c7-4c3b-a946-d7c95c3e31bb", "node_type": "1", "metadata": {}, "hash": "25322ac2d4bf7070782d7a9d3fc6e67d92007f8f16751535a7d7545940926994", "class_name": "RelatedNodeInfo"}}, "text": "output [\n  if s = 1 /\\ b = 1 then \n    \"goal_step: \" ++ show(goal_step)\n  else \"\" endif ++\n  if b = 1 then \"\\n\" else \" \" endif ++\n  show(state[s, b])\n  | s in steps, b in buckets\n\n] \n++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\n\ninclude \"globals.mzn\";\n\nint: n_states = 15;\nint: input_max = 15;\nint: initial_state = 1;\nset of int: accepting_states = {15};\n\n\n% distance\narray[1..n_states, 1..n_states] of 0..input_max: transition_fn =\narray2d(1..n_states, 1..n_states,\n[%1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n  0, 2, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 1\n  0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 2 \n  0, 0, 0, 4, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 3\n  0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 4\n  0, 0, 0, 0, 0, 6, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 5\n  0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, % 6\n  0, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 0, 0, 0, 0, % 7\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, % 8 \n  0, 0, 0, 0, 0, 0, 0, 0, 0,10, 0, 0, 0, 0, 0, % 9\n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0,11, 0, 0, 0, 0, %10\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,12, 0, 0, 0, %11 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,13, 0, 0, %12\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,14, 0, %13 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %14\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %15\n]);", "mimetype": "text/plain", "start_char_idx": 3719, "end_char_idx": 4986, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1c4a588d-d1c7-4c3b-a946-d7c95c3e31bb": {"__data__": {"id_": "1c4a588d-d1c7-4c3b-a946-d7c95c3e31bb", "embedding": null, "metadata": {"problem_family": "Water_Bucket_Problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "water_buckets1", "node_type": "4", "metadata": {"problem_family": "Water_Bucket_Problem"}, "hash": "6bb371fdadea2a6dd401f669556cc3c8188b175fdce7925646cebe6437233bd4", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5a6ab93e-791b-44a3-9b34-dd50bdb65cc5", "node_type": "1", "metadata": {"problem_family": "Water_Bucket_Problem"}, "hash": "7e2b2e7f483d467668d7ea64112659066ee713fa75f6d4f609cdda16f07b977b", "class_name": "RelatedNodeInfo"}}, "text": "array[1..n_states] of string:  nodes = [\n        \"8,0,0\", % 1 start\n        \"5,0,3\", % 2\n        \"5,3,0\", % 3 \n        \"2,3,3\", % 4 \n        \"2,5,1\", % 5\n        \"7,0,1\", % 6\n        \"7,1,0\", % 7\n        \"4,1,3\", % 8\n        \"3,5,0\", % 9\n        \"3,2,3\", % 10\n        \"6,2,0\", % 11\n        \"6,0,2\", % 12\n        \"1,5,2\", % 13\n        \"1,4,3\", % 14\n        \"4,4,0\"  % 15 goal\n        ];\n\n\narray[1..input_max] of var 0..input_max: x;\nvar 0..input_max: cost;\n\n% solve satisfy;\nsolve minimize cost;\n\nconstraint\nregular(x, n_states, input_max, transition_fn,\n        initial_state, accepting_states)\n;\n\nconstraint\n   cost = 2+sum([bool2int(x[i-1] != x[i] ) | i in 2..input_max])\n;\n\noutput \n[\"cost: \" ++ show(cost) ++ \"\\n\"] ++\n[show(initial_state) ++ \" \"] ++\n[\n  if fix(x[i]) < input_max then show(x[i]) ++ \" \" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(input_max) ++ \"\\n\"] ++ \n[\"\\n\\n\"] ++\n\n[show(nodes[initial_state]) ++ \"\\n\"] ++\n[\n  if fix(x[i]) < input_max then show(nodes[fix(x[i])]) ++ \"\\n\" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(nodes[input_max]) ++ \"\\n\"] ++ \n[\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 4989, "end_char_idx": 6128, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"all_interval": {"node_ids": ["9baa24d7-64ec-446d-8250-34dc3cf12345", "27ef8104-4480-45b5-947b-5ae1908f8bfc", "5211e029-6e2b-487a-bf98-a39757accdac"], "metadata": {"problem_family": "All-Interval_Series"}}, "bibd": {"node_ids": ["0c85778f-c957-4d9d-bee5-6e117a1d81f0"], "metadata": {"problem_family": "Balanced_Incomplete_Block_Designs"}}, "bus_scheduling_csplib": {"node_ids": ["d2e19595-0892-4beb-b665-aa6f798d1231"], "metadata": {"problem_family": "Bus_Driver_Scheduling"}}, "car": {"node_ids": ["457ec603-e982-41b2-9813-cefcf06031af"], "metadata": {"problem_family": "Car_Sequencing"}}, "clique": {"node_ids": ["57dbe89b-0f50-4ebb-9ae5-fee4f9a9d92c"], "metadata": {"problem_family": "Maximum_Clique"}}, "crossfigure": {"node_ids": ["ce5b5f35-1a8f-4c1b-abab-38de98a6cf68", "819439df-1da9-463d-b9fc-4e37250610eb", "f79d82ec-48f0-4182-88ac-508aae45fb64", "6781354b-32d3-4437-abe4-344a644df63d"], "metadata": {"problem_family": "Crossfigures"}}, "curriculum": {"node_ids": ["dcf18f80-383b-45a9-98ab-902162562c42"], "metadata": {"problem_family": "Balanced_Academic_Curriculum_Problem__BACP_"}}, "diamond_free_degree_sequence": {"node_ids": ["ff84eb52-5167-4fb0-b69f-389a3fa9e2d6"], "metadata": {"problem_family": "Diamond-free_Degree_Sequences"}}, "fractions": {"node_ids": ["176afb79-57bb-41d9-b6f8-7534a91370ae"], "metadata": {"problem_family": "The_n-Fractions_Puzzle"}}, "golfers": {"node_ids": ["fc4b0349-a5c0-4735-8407-3a83942db3ef", "be27bbed-354b-4957-be62-8357a1a71283", "ae5326b8-5733-40ac-83ac-1a79339c234e"], "metadata": {"problem_family": "Social_Golfers_Problem"}}, "golomb": {"node_ids": ["19ce32c5-ae5c-43f3-9596-427f9228d19b"], "metadata": {"problem_family": "Golomb_rulers"}}, "K4xP2Graceful": {"node_ids": ["29918f34-c21b-437f-90c7-fb2b74773a33"], "metadata": {"problem_family": "Graceful_Graphs"}}, "killer_sudoku": {"node_ids": ["e7c4b030-7194-4690-8986-704101cdfc8d", "75481c62-5655-4f83-9e12-72652b06aba1", "d0ff85b2-464d-4048-aaee-4d97fcb04ef5", "19d2f517-f636-420d-8d7d-2d1cb8f3db50"], "metadata": {"problem_family": "Killer_Sudoku"}}, "langford": {"node_ids": ["ed3d5303-2f28-4fff-94e4-0d39ba4ea60f"], "metadata": {"problem_family": "Langford_s_number_problem"}}, "magic_hexagon": {"node_ids": ["0ee4cf4e-a7d8-4935-a81d-1e9523557acb"], "metadata": {"problem_family": "Magic_Hexagon"}}, "magic_sequence": {"node_ids": ["4fff1322-f056-4737-8944-f8414ea747ad", "743821a7-ccf6-4eab-85e8-bdf91306e96f", "3100b844-a880-4ce4-8ad1-bd9a62477c3c"], "metadata": {"problem_family": "Magic_Squares_and_Sequences"}}, "maximum_density_still_life": {"node_ids": ["902b1497-65bc-4777-9c0c-f616eb1b3b30"], "metadata": {"problem_family": "Maximum_density_still_life"}}, "nonogram_create_automaton2": {"node_ids": ["dd60bb82-b292-43e3-a2c6-592d3047ebaa", "237b8603-00f1-459c-b665-dada38345f79"], "metadata": {"problem_family": "Nonogram"}}, "opd": {"node_ids": ["c295f0f1-7c87-4150-a2d6-40acc2f5e579"], "metadata": {"problem_family": "Optimal_Financial_Portfolio_Design"}}, "partition": {"node_ids": ["dceda50c-a8d2-4cdc-9556-1d32e753da3d", "df1176d1-de7a-4c86-95d7-8e6d7a58c1ae"], "metadata": {"problem_family": "Number_Partitioning"}}, "QuasigroupCompletion": {"node_ids": ["8602b091-2d1b-470a-bf5e-5522ac62fec3"], "metadata": {"problem_family": "Quasigroup_Completion"}}, "QuasiGroupExistence": {"node_ids": ["d92d971d-e456-4c41-b96d-eeed942424d8", "382c0a9e-fdfb-445d-995c-ad92cfc8aa0d", "af21919a-71e2-4849-822b-52b728ecec1c", "d0b850c8-b5a3-49a0-8b66-b9f3dae1f588", "55fcb77f-2129-44ab-b643-85e00197d24d"], "metadata": {"problem_family": "Quasigroup_Existence"}}, "queens": {"node_ids": ["680e2f88-27bf-4314-b412-18d0c3719c42"], "metadata": {"problem_family": "N-Queens"}}, "rehearsal": {"node_ids": ["88a0d16b-a89e-4035-9043-adcf855f19b9", "aaa35a6c-cbf2-480e-be7c-10c6b2a523fc", "b870b772-c8ce-46d8-a3fe-bbe15972b29b"], "metadata": {"problem_family": "The_Rehearsal_Problem"}}, "RosteringProblem": {"node_ids": ["f8f5da7f-477a-4f69-abb8-579035d6b52e", "bc34364b-6cf9-4c94-bc01-486f18e9898e"], "metadata": {"problem_family": "Rotating_Rostering_Problem"}}, "sb": {"node_ids": ["918df488-03af-4c8a-9aeb-c8292c4a885a", "35462174-f9ae-4110-811e-9639e0169f86", "46c3d8a4-29ce-4350-9224-8eef9e70bb72"], "metadata": {"problem_family": "Solitaire_Battleships"}}, "schur": {"node_ids": ["c805fa24-5f97-4da1-aafd-ce6b47f2b988"], "metadata": {"problem_family": "Schur_s_Lemma"}}, "sonet_problem": {"node_ids": ["a6addad5-b9af-4ebb-ab11-5cc0e7bf9fc0"], "metadata": {"problem_family": "Synchronous_Optical_Networking__SONET__Problem"}}, "steiner": {"node_ids": ["52139d6b-be60-4dd2-aee9-ab7075906ce5"], "metadata": {"problem_family": "Steiner_triple_systems"}}, "stoch_fjsp": {"node_ids": ["b6c12a8e-e234-4235-9249-b454ed8bdc9d", "50d06e8f-5183-46b1-a0ff-eb3567c625cb"], "metadata": {"problem_family": "Stochastic_Assignment_and_Scheduling_Problem"}}, "template_design": {"node_ids": ["59ca7377-8a99-4678-896a-52d84c60fd04"], "metadata": {"problem_family": "Template_Design"}}, "traffic_lights_table": {"node_ids": ["83dadf5e-3a2d-467d-a532-dfe7c94af3b1"], "metadata": {"problem_family": "Traffic_Lights"}}, "TTPPV": {"node_ids": ["ea5fe9c8-d3bd-4cac-b518-f30eb284456f", "8de5e16a-6b19-4c71-9f55-78bd9ef36d37"], "metadata": {"problem_family": "Traveling_Tournament_Problem_with_Predefined_Venues__TTPPV_"}}, "vessel-loading": {"node_ids": ["412dc12d-0dff-4ab2-8741-4161dac425f7"], "metadata": {"problem_family": "Vessel_Loading"}}, "warehouses": {"node_ids": ["32f19a75-4a42-4478-bcaa-56ca975298a9"], "metadata": {"problem_family": "Warehouse_Location_Problem"}}, "water_buckets1": {"node_ids": ["f1931183-2430-4ade-b730-ead1a231d0e5", "5a6ab93e-791b-44a3-9b34-dd50bdb65cc5", "1c4a588d-d1c7-4c3b-a946-d7c95c3e31bb"], "metadata": {"problem_family": "Water_Bucket_Problem"}}}}