{"docstore/metadata": {"all_interval_expert": {"doc_hash": "3773605a029a54987244f8221617c309d18471cd4a57a8f520b8d5c2524e10c4"}, "assign_expert": {"doc_hash": "7f861c34941b8b9eb4ec5c96592c6950e2b5f3a617e193569dabc559f0c8f15b"}, "aust_color_expert": {"doc_hash": "e310824312251198365bbe75193c5aca0257421815dfbc9ea7141b75dd94f296"}, "bibd_expert": {"doc_hash": "ade85b961eaae89a6311c8b52406e58f6fd2e7f710dcac020f5fa949abd9af36"}, "bus_scheduling_csplib_expert": {"doc_hash": "c8742ad12c16c77f8f5985da49f18b794d12bf409926b7f0521a5033e69e6031"}, "car_expert": {"doc_hash": "e8abee4103cfb42fd1c8d30ef75d043a75fb8e80061bd867d967ea0d26230c9f"}, "carpet_cutting_expert": {"doc_hash": "6131aa7151c9baaa56c2eed19c920d49aaad3af6f36cd9fa6e32edc1ffea1106"}, "cell_block_expert": {"doc_hash": "6eebc641d9cb5a40e1bd5fe4321cca143a443f127807dfa14d5445738a53ff0c"}, "clique_expert": {"doc_hash": "eac82b4cf40f0009ee71763d4f9bf832d09b308488c3bc1201746226e5e3ead4"}, "cluster_expert": {"doc_hash": "58132042875b8ac5184c4a69a4387fa2a774863ad3dbc0cc5cc5a39ee5a080fc"}, "compatible_assignment_expert": {"doc_hash": "a2a76e86790af8516abcf987354e7612216ca36b533ebc550f43ac4914220e5f"}, "constrained_connected_expert": {"doc_hash": "48dfbafd40fd9951725110d05cdf74262ada9f7a2de45f3dec3672dfed14a377"}, "crazy_sets_expert": {"doc_hash": "3b1868c9d818028ce82f35475a06185856ece6a8fb6fb45f13f1734080232f3e"}, "crossfigure_expert": {"doc_hash": "b30921bab914c1f9c661e419e48dac6803b8e7a1860d5206cbe7e6c51620e23a"}, "curriculum_expert": {"doc_hash": "e0a326f98ff30cdb92b3a155fca3ea06f010fe59159cf515acb1497af00a15f7"}, "diamond_free_degree_sequence_expert": {"doc_hash": "e94886e26ef28e959e2820a39fc86cab1d1af794156ca911a80d55a7c3e7b4e2"}, "doublechannel_expert": {"doc_hash": "65a740da58c85206b099ac5627f5dc1c58db2774b2489414d90e149f7883e3c3"}, "fractions_expert": {"doc_hash": "cbb853ead0f153a92167f69fc105737d79593918ad700879a1205e7cdc9a4890"}, "golfers_expert": {"doc_hash": "d11c085748364424722a0c50ae8d57426e2609d28ac63f4f6f1c253a42a23246"}, "golomb_expert": {"doc_hash": "f67dae1464c9114fbb260aae88aab0e127c8fb6590952f1be9156260cec0707b"}, "graph_expert": {"doc_hash": "a8204a631d47c813e9ca6a333415afa892e4a1eed6443064d1e8899795c76a5c"}, "itemset_mining_expert": {"doc_hash": "9fba2d738f4e44a992bf240638ff26e1f5cac796b287b518a51188feb737f3c9"}, "jobshop_expert": {"doc_hash": "5e4711476b9e268123585e8ab3bf52748780090d624c78edce02eecfdd1f87ee"}, "K4xP2Graceful_expert": {"doc_hash": "d19931b0279805436aa907a4a7be411dc2ecc168567cd86f259c896e7d6b60b0"}, "killer_sudoku_expert": {"doc_hash": "baadad4aa4c73cb141ec2d0b03e69a6d3bb838d573ef6d99f3a632ff945cdb94"}, "knapsack_expert": {"doc_hash": "93033d72327a07da61a7f2de6f67a9e4bdd73e9fe7b0f1dddd9bb1428321335d"}, "langford_expert": {"doc_hash": "a29ca633b5d7125a9ae527dc8b7c2b5ba58939fac9bdb367cfee55ef73a515a6"}, "loan_expert": {"doc_hash": "8732ccd88f9aed0cf287c767b3ecc20b22fa851e9bc18f8c70d013d82e003bf0"}, "ltsp_expert": {"doc_hash": "2a09859bfa2142e8751ff32ee19daf60151eee8f9826c2033e72c78fda634012"}, "magic_hexagon_expert": {"doc_hash": "e72099230cc68d972c2d6761bf2d68acde338b3128379de7681f95d8d64bb6c3"}, "magic_sequence_expert": {"doc_hash": "2dc921137fe2d0d223ffde2ea0a3e7465f9bd45e4e0ee26a1befcc393bcd93c3"}, "maximum_density_still_life_expert": {"doc_hash": "e8252b5257e5495a900bce805a9b6067fa233e230233090181ace3f8be5d48b6"}, "mip_expert": {"doc_hash": "1a2401fe73151efc79e09566eb804fe077f4d957d0399e161c047b4a7cee0324"}, "missing_solution_expert": {"doc_hash": "eb1e32b492504ac3a0638c51b0df8ec5c5800d984f94f0a5144eae5696e46116"}, "nonogram_create_automaton2_expert": {"doc_hash": "86fab21b6b801b438f931cf77b8d9c7099634fe2de611c24f69e02414f6085b6"}, "nurses_expert": {"doc_hash": "26fa94a1732228cdb1e129d54eab554d18fab1bb662bb48a68f35ff7ba196712"}, "opd_expert": {"doc_hash": "4dcffcf9d354159dc1db5182bd9a4a4a8416f28c602dc687d3e30cea9d4b3fa5"}, "partition_expert": {"doc_hash": "7383607ba8f923f1cee542ae2f703203ed010e19e4bb955d0cfcc1d5e3cd14bb"}, "photo_expert": {"doc_hash": "7e93c5093794c8f32323616a1b7dd8fb59275833f3fafe3eb6e2d53732072f13"}, "project_scheduling_expert": {"doc_hash": "92f7199873452802c2413620d2075be6d542c41664511e00b87498d41cc88ddb"}, "QuasigroupCompletion_expert": {"doc_hash": "94bbfc62345a97ff77da7d489be1ea651bdfda2c7316d5a53daa65d1c6cb0ce5"}, "QuasiGroupExistence_expert": {"doc_hash": "04955f752128fb9304668221e29295dd0c498ab27135bc232af9eb9028cdd06b"}, "queens_expert": {"doc_hash": "97b473f5055bb71507c9fa3f70e53114eedfe22b2253c076ef9307f26359c09d"}, "rcpsp_expert": {"doc_hash": "a9d18695dbc085fdfaf9052240358a69907ea0fb1584b7b8f793d69589ef05b5"}, "rehearsal_expert": {"doc_hash": "3ff56b6cd55b869f42dded9154eeab6437289cb3e9c76331e9c847cfb21c5704"}, "restart_expert": {"doc_hash": "84f4609be2c6f4ae58e4ed738bad03740516181659af93d70a4b264e361bccfc"}, "RosteringProblem_expert": {"doc_hash": "ad025b0b65da2df91d6d64e8dd61f2d98e1d42c2012934b5e4e11ef91682868a"}, "sb_expert": {"doc_hash": "3281914b6ae40e43263647d24ca5eb7a375bc59dffdbd21d6565a76c239f355e"}, "schur_expert": {"doc_hash": "52db4ee6fd0877e170114eccac4d2ec290de54ecb40b28d3736dc6dfa3472c6b"}, "setselect_expert": {"doc_hash": "ff725dd7f41c157d93be82d60b300866baab74889989152c3ce456685c09699a"}, "shipping_expert": {"doc_hash": "8d51525a8b43bdeecd2549b294d146f6600aa5a538a556df69be068dc15c7b83"}, "simple-prod-planning_expert": {"doc_hash": "1b9839717b681c903c0aded1abb17f8e6f4d4b029973e07da84ee71b1e7b5da0"}, "sonet_problem_expert": {"doc_hash": "dd7873a3b9f3e2cb49983fc94cf30d285282f65a39a9ddd3d253d2626a98d794"}, "square_pack_expert": {"doc_hash": "0fec7097c61033c5b81c1501c78a72d40940c9c7ae3b2587b3f12aa3511ed5dc"}, "stableroommates_expert": {"doc_hash": "1aa9f7738dd799beaf060fd10144ba1d4687c5151966f8805af5ec1a5f4ec0b2"}, "steiner_expert": {"doc_hash": "4b645fb666d5a5eaa0e137b768741948e07ec061280fb6ee16f8e2f722a747d2"}, "stoch_fjsp_expert": {"doc_hash": "55dc7adf31d90b7ba7a026eac41cb636d11635938ce67d83dfee0bc0e7c5b268"}, "submultisetsum_expert": {"doc_hash": "d811b6a7d4b0ceaf37182d324cddc75ddd686e29825394803015beb9fea90b6b"}, "table_seating_expert": {"doc_hash": "16fee3cbac315570c551f7ebd5e6c31d99bcb4a474d343b576d2bce77cdd2410"}, "teamselect_expert": {"doc_hash": "eef6ecae2e55d2553b03fe54b946b624d678e621c5bbef9385d2fd3eb0e13e8a"}, "template_design_expert": {"doc_hash": "a9b0950cbcd91b6be9b52a4ce1b8a5d16f9def0b0f8a9ebb0dc6afbdd9eb6724"}, "toomany_expert": {"doc_hash": "5bc8ea7ea0175334621dd9fdd3af4509bc0a7433aad97c362474daf49d4b905c"}, "traffic_lights_table_expert": {"doc_hash": "23d9bcc31ada08179f8aaf01c49aa31eb5a6042ffe5d6672ede18513783ebd32"}, "TTPPV_expert": {"doc_hash": "e0d6a1982dd4a4a2280a177af0eb729872db6a51d49b58ec1bf19682f7cba9c0"}, "vessel-loading_expert": {"doc_hash": "d3d5bfdcc9922a64f5c5ff64440cff69e56cb3728de767b1a4bb2a7049972c0a"}, "warehouses_expert": {"doc_hash": "432011d20a3c553170a07aaab0dbe6bb7f6cb10c500f8594b8322f2b1ec55a4c"}, "water_buckets1_expert": {"doc_hash": "27a3247ebf0d977bb8c9560d6db24018b29f42ad77cd769688c8ac73a313fdad"}, "3c48f97a-16cf-46fb-9778-777c1713b1c8": {"doc_hash": "3773605a029a54987244f8221617c309d18471cd4a57a8f520b8d5c2524e10c4", "ref_doc_id": "all_interval_expert"}, "e3490413-2df2-4bea-ae16-9c49a0955d39": {"doc_hash": "7f861c34941b8b9eb4ec5c96592c6950e2b5f3a617e193569dabc559f0c8f15b", "ref_doc_id": "assign_expert"}, "ff70edfc-d9dc-47d0-acf7-03831450871f": {"doc_hash": "e310824312251198365bbe75193c5aca0257421815dfbc9ea7141b75dd94f296", "ref_doc_id": "aust_color_expert"}, "b85d2124-b231-4b75-b593-2a2aa834a0d6": {"doc_hash": "ade85b961eaae89a6311c8b52406e58f6fd2e7f710dcac020f5fa949abd9af36", "ref_doc_id": "bibd_expert"}, "c44065c7-ef5d-479e-9438-7123e75ca229": {"doc_hash": "c8742ad12c16c77f8f5985da49f18b794d12bf409926b7f0521a5033e69e6031", "ref_doc_id": "bus_scheduling_csplib_expert"}, "bd94337e-fefc-46a9-9a33-7f05a37f2ae3": {"doc_hash": "e8abee4103cfb42fd1c8d30ef75d043a75fb8e80061bd867d967ea0d26230c9f", "ref_doc_id": "car_expert"}, "252f0455-165a-45da-a421-027460f998a0": {"doc_hash": "6131aa7151c9baaa56c2eed19c920d49aaad3af6f36cd9fa6e32edc1ffea1106", "ref_doc_id": "carpet_cutting_expert"}, "c42a6330-50e8-4df1-9f48-fcb20fc536a0": {"doc_hash": "6eebc641d9cb5a40e1bd5fe4321cca143a443f127807dfa14d5445738a53ff0c", "ref_doc_id": "cell_block_expert"}, "6758bed3-eefd-4c94-a8af-b1dde5398644": {"doc_hash": "eac82b4cf40f0009ee71763d4f9bf832d09b308488c3bc1201746226e5e3ead4", "ref_doc_id": "clique_expert"}, "0db0e6a7-89b3-47f6-8deb-848745bf9e4c": {"doc_hash": "58132042875b8ac5184c4a69a4387fa2a774863ad3dbc0cc5cc5a39ee5a080fc", "ref_doc_id": "cluster_expert"}, "53a3c95f-b618-4174-8956-8ed6c14ea2f9": {"doc_hash": "a2a76e86790af8516abcf987354e7612216ca36b533ebc550f43ac4914220e5f", "ref_doc_id": "compatible_assignment_expert"}, "2c173bcc-99e8-4b1e-9bc5-c13286194d4f": {"doc_hash": "48dfbafd40fd9951725110d05cdf74262ada9f7a2de45f3dec3672dfed14a377", "ref_doc_id": "constrained_connected_expert"}, "199261a2-7322-4010-80d0-1eb08304cc79": {"doc_hash": "3b1868c9d818028ce82f35475a06185856ece6a8fb6fb45f13f1734080232f3e", "ref_doc_id": "crazy_sets_expert"}, "b767ffc8-a765-4afe-9cd9-dff54c5ff537": {"doc_hash": "b30921bab914c1f9c661e419e48dac6803b8e7a1860d5206cbe7e6c51620e23a", "ref_doc_id": "crossfigure_expert"}, "d6583452-c1ae-47bb-8007-d69624a5ac5a": {"doc_hash": "e0a326f98ff30cdb92b3a155fca3ea06f010fe59159cf515acb1497af00a15f7", "ref_doc_id": "curriculum_expert"}, "91c10eba-9129-40a8-90c9-95bc4caac302": {"doc_hash": "e94886e26ef28e959e2820a39fc86cab1d1af794156ca911a80d55a7c3e7b4e2", "ref_doc_id": "diamond_free_degree_sequence_expert"}, "5a0eac48-ae3d-494a-aa6e-3546b0d28efb": {"doc_hash": "65a740da58c85206b099ac5627f5dc1c58db2774b2489414d90e149f7883e3c3", "ref_doc_id": "doublechannel_expert"}, "e3a11130-2fb0-4c2b-9192-dfd82610836d": {"doc_hash": "cbb853ead0f153a92167f69fc105737d79593918ad700879a1205e7cdc9a4890", "ref_doc_id": "fractions_expert"}, "e36a1efe-5300-48ee-a349-1ab315dabc84": {"doc_hash": "d11c085748364424722a0c50ae8d57426e2609d28ac63f4f6f1c253a42a23246", "ref_doc_id": "golfers_expert"}, "f6e8897f-a6b7-40ca-9909-97535722dca2": {"doc_hash": "f67dae1464c9114fbb260aae88aab0e127c8fb6590952f1be9156260cec0707b", "ref_doc_id": "golomb_expert"}, "4f159be2-2435-43e0-90fb-8190f18bd7aa": {"doc_hash": "a8204a631d47c813e9ca6a333415afa892e4a1eed6443064d1e8899795c76a5c", "ref_doc_id": "graph_expert"}, "d1788cff-6ef4-446d-bba4-b3f6e2362c0f": {"doc_hash": "9fba2d738f4e44a992bf240638ff26e1f5cac796b287b518a51188feb737f3c9", "ref_doc_id": "itemset_mining_expert"}, "c2b61012-ee95-4395-a6d3-1262408c37b4": {"doc_hash": "5e4711476b9e268123585e8ab3bf52748780090d624c78edce02eecfdd1f87ee", "ref_doc_id": "jobshop_expert"}, "1921d207-e716-4416-a015-c6fed6bdc1eb": {"doc_hash": "d19931b0279805436aa907a4a7be411dc2ecc168567cd86f259c896e7d6b60b0", "ref_doc_id": "K4xP2Graceful_expert"}, "03b74dd0-8753-4a79-b2b3-559f498dd170": {"doc_hash": "baadad4aa4c73cb141ec2d0b03e69a6d3bb838d573ef6d99f3a632ff945cdb94", "ref_doc_id": "killer_sudoku_expert"}, "f934f715-c515-4fbc-a9ee-1553a1c72c33": {"doc_hash": "93033d72327a07da61a7f2de6f67a9e4bdd73e9fe7b0f1dddd9bb1428321335d", "ref_doc_id": "knapsack_expert"}, "329e278e-151f-4e7e-ac24-184bf0e910aa": {"doc_hash": "a29ca633b5d7125a9ae527dc8b7c2b5ba58939fac9bdb367cfee55ef73a515a6", "ref_doc_id": "langford_expert"}, "4583cc66-6dfc-44c1-adc5-8003f6bdfbde": {"doc_hash": "8732ccd88f9aed0cf287c767b3ecc20b22fa851e9bc18f8c70d013d82e003bf0", "ref_doc_id": "loan_expert"}, "ef15b295-f1f1-4741-a03a-c0d15c614c70": {"doc_hash": "2a09859bfa2142e8751ff32ee19daf60151eee8f9826c2033e72c78fda634012", "ref_doc_id": "ltsp_expert"}, "37f8eaa5-a03e-48fb-96b3-3bb5b3566536": {"doc_hash": "e72099230cc68d972c2d6761bf2d68acde338b3128379de7681f95d8d64bb6c3", "ref_doc_id": "magic_hexagon_expert"}, "a693c877-aa1a-483c-a2a5-42a0b9e4ffef": {"doc_hash": "2dc921137fe2d0d223ffde2ea0a3e7465f9bd45e4e0ee26a1befcc393bcd93c3", "ref_doc_id": "magic_sequence_expert"}, "9a04da90-8ea4-4bfa-8d66-f882a4711f77": {"doc_hash": "e8252b5257e5495a900bce805a9b6067fa233e230233090181ace3f8be5d48b6", "ref_doc_id": "maximum_density_still_life_expert"}, "b9fd314b-802c-4389-96aa-e89e6b04066f": {"doc_hash": "1a2401fe73151efc79e09566eb804fe077f4d957d0399e161c047b4a7cee0324", "ref_doc_id": "mip_expert"}, "1a8a84ee-699c-411c-8c78-6001da0bd9ce": {"doc_hash": "eb1e32b492504ac3a0638c51b0df8ec5c5800d984f94f0a5144eae5696e46116", "ref_doc_id": "missing_solution_expert"}, "a701b1cb-c7e6-407a-a6f8-24eea868051c": {"doc_hash": "86fab21b6b801b438f931cf77b8d9c7099634fe2de611c24f69e02414f6085b6", "ref_doc_id": "nonogram_create_automaton2_expert"}, "0c874774-53da-446e-8309-de99c5d1bab3": {"doc_hash": "26fa94a1732228cdb1e129d54eab554d18fab1bb662bb48a68f35ff7ba196712", "ref_doc_id": "nurses_expert"}, "3958f0e1-15cf-4742-b2ff-e9eedc06f4e0": {"doc_hash": "4dcffcf9d354159dc1db5182bd9a4a4a8416f28c602dc687d3e30cea9d4b3fa5", "ref_doc_id": "opd_expert"}, "83c49095-65bd-4a89-8f76-47a1c13e22db": {"doc_hash": "7383607ba8f923f1cee542ae2f703203ed010e19e4bb955d0cfcc1d5e3cd14bb", "ref_doc_id": "partition_expert"}, "e0ebe79c-abb1-4e23-b437-6d449a2c17fc": {"doc_hash": "7e93c5093794c8f32323616a1b7dd8fb59275833f3fafe3eb6e2d53732072f13", "ref_doc_id": "photo_expert"}, "8707b1a8-f48d-47bb-b1a5-d4ecc7942266": {"doc_hash": "92f7199873452802c2413620d2075be6d542c41664511e00b87498d41cc88ddb", "ref_doc_id": "project_scheduling_expert"}, "8fa9da72-3178-496b-a8bb-7b9c2b2baefe": {"doc_hash": "94bbfc62345a97ff77da7d489be1ea651bdfda2c7316d5a53daa65d1c6cb0ce5", "ref_doc_id": "QuasigroupCompletion_expert"}, "e99eace8-e037-4cd6-a5d3-161e93a209b2": {"doc_hash": "04955f752128fb9304668221e29295dd0c498ab27135bc232af9eb9028cdd06b", "ref_doc_id": "QuasiGroupExistence_expert"}, "357c8965-6b86-47fa-b009-3ed3d1921152": {"doc_hash": "97b473f5055bb71507c9fa3f70e53114eedfe22b2253c076ef9307f26359c09d", "ref_doc_id": "queens_expert"}, "08783bbc-03d7-4e3a-b874-86e88f60d62e": {"doc_hash": "a9d18695dbc085fdfaf9052240358a69907ea0fb1584b7b8f793d69589ef05b5", "ref_doc_id": "rcpsp_expert"}, "83c78238-65f7-4137-9f90-89c83d422f97": {"doc_hash": "3ff56b6cd55b869f42dded9154eeab6437289cb3e9c76331e9c847cfb21c5704", "ref_doc_id": "rehearsal_expert"}, "49baeef8-6e28-45cb-99df-864df0eea981": {"doc_hash": "84f4609be2c6f4ae58e4ed738bad03740516181659af93d70a4b264e361bccfc", "ref_doc_id": "restart_expert"}, "a7291c84-11ce-4d56-9ff4-af47346d9bdf": {"doc_hash": "ad025b0b65da2df91d6d64e8dd61f2d98e1d42c2012934b5e4e11ef91682868a", "ref_doc_id": "RosteringProblem_expert"}, "8cf6f982-34cd-43e6-a45a-efe4a0c40dc2": {"doc_hash": "3281914b6ae40e43263647d24ca5eb7a375bc59dffdbd21d6565a76c239f355e", "ref_doc_id": "sb_expert"}, "460f7ffb-e565-4044-89e0-d75f71ae277d": {"doc_hash": "52db4ee6fd0877e170114eccac4d2ec290de54ecb40b28d3736dc6dfa3472c6b", "ref_doc_id": "schur_expert"}, "876feadd-53f7-4f0c-8921-433be12f81b2": {"doc_hash": "ff725dd7f41c157d93be82d60b300866baab74889989152c3ce456685c09699a", "ref_doc_id": "setselect_expert"}, "617ba7f2-d498-436c-b09c-8dd5138ac1fa": {"doc_hash": "8d51525a8b43bdeecd2549b294d146f6600aa5a538a556df69be068dc15c7b83", "ref_doc_id": "shipping_expert"}, "867da411-7ed7-4a06-a382-6f160274173b": {"doc_hash": "1b9839717b681c903c0aded1abb17f8e6f4d4b029973e07da84ee71b1e7b5da0", "ref_doc_id": "simple-prod-planning_expert"}, "31e6c7ce-b4df-43f0-afa9-b61624bd36c3": {"doc_hash": "dd7873a3b9f3e2cb49983fc94cf30d285282f65a39a9ddd3d253d2626a98d794", "ref_doc_id": "sonet_problem_expert"}, "a8b9b47b-08cd-4c22-ab76-cfed35152b91": {"doc_hash": "0fec7097c61033c5b81c1501c78a72d40940c9c7ae3b2587b3f12aa3511ed5dc", "ref_doc_id": "square_pack_expert"}, "c1852542-f99e-4272-b2fc-8592ff768941": {"doc_hash": "1aa9f7738dd799beaf060fd10144ba1d4687c5151966f8805af5ec1a5f4ec0b2", "ref_doc_id": "stableroommates_expert"}, "fbdc559a-d050-4322-8f15-1de559c2d56f": {"doc_hash": "4b645fb666d5a5eaa0e137b768741948e07ec061280fb6ee16f8e2f722a747d2", "ref_doc_id": "steiner_expert"}, "fe19315d-e90b-4f06-b8b4-500c32dd0fa8": {"doc_hash": "55dc7adf31d90b7ba7a026eac41cb636d11635938ce67d83dfee0bc0e7c5b268", "ref_doc_id": "stoch_fjsp_expert"}, "6c154017-4684-4517-834f-7068e5ad220b": {"doc_hash": "d811b6a7d4b0ceaf37182d324cddc75ddd686e29825394803015beb9fea90b6b", "ref_doc_id": "submultisetsum_expert"}, "3b3c979f-d158-4329-923a-fbc8c642b276": {"doc_hash": "16fee3cbac315570c551f7ebd5e6c31d99bcb4a474d343b576d2bce77cdd2410", "ref_doc_id": "table_seating_expert"}, "cf86ef0c-8b0f-41bb-99e9-f503b64a75c0": {"doc_hash": "eef6ecae2e55d2553b03fe54b946b624d678e621c5bbef9385d2fd3eb0e13e8a", "ref_doc_id": "teamselect_expert"}, "117c106b-5043-469c-8a54-a0b261e29310": {"doc_hash": "a9b0950cbcd91b6be9b52a4ce1b8a5d16f9def0b0f8a9ebb0dc6afbdd9eb6724", "ref_doc_id": "template_design_expert"}, "9c59ce8f-ee1f-442f-9a85-64e809abb3a9": {"doc_hash": "5bc8ea7ea0175334621dd9fdd3af4509bc0a7433aad97c362474daf49d4b905c", "ref_doc_id": "toomany_expert"}, "13f2cb95-7177-43ef-bd2e-460a083aca31": {"doc_hash": "23d9bcc31ada08179f8aaf01c49aa31eb5a6042ffe5d6672ede18513783ebd32", "ref_doc_id": "traffic_lights_table_expert"}, "a0f58007-0662-48ff-94fe-189f41e7f1d0": {"doc_hash": "e0d6a1982dd4a4a2280a177af0eb729872db6a51d49b58ec1bf19682f7cba9c0", "ref_doc_id": "TTPPV_expert"}, "b84890a9-e170-4c03-a142-6eff1f9f01ec": {"doc_hash": "d3d5bfdcc9922a64f5c5ff64440cff69e56cb3728de767b1a4bb2a7049972c0a", "ref_doc_id": "vessel-loading_expert"}, "4f9fc22c-c7d1-488f-8a71-15b9b7e6f5c5": {"doc_hash": "432011d20a3c553170a07aaab0dbe6bb7f6cb10c500f8594b8322f2b1ec55a4c", "ref_doc_id": "warehouses_expert"}, "dec65d8f-faba-42ea-b8a7-1bd526517378": {"doc_hash": "27a3247ebf0d977bb8c9560d6db24018b29f42ad77cd769688c8ac73a313fdad", "ref_doc_id": "water_buckets1_expert"}}, "docstore/data": {"3c48f97a-16cf-46fb-9778-777c1713b1c8": {"__data__": {"id_": "3c48f97a-16cf-46fb-9778-777c1713b1c8", "embedding": null, "metadata": {"model_name": "all_interval", "source_code": "Model 1 : \n\n\n%\n% All interval problem in MiniZinc\n%\n% \"\"\"\n% Given the twelve standard pitch-classes (c, c%, d, ...), represented by\n% numbers 0,1,...,11, find a series in which each pitch-class occurs exactly\n% once and in which the musical intervals between neighbouring notes cover\n% the full set of intervals from the minor second (1 semitone) to the major\n% seventh (11 semitones). That is, for each of the intervals, there is a\n% pair of neigbhouring pitch-classes in the series, between which this\n% interval appears. The problem of finding such a series can be easily\n% formulated as an instance of a more general arithmetic problem on Z_n,\n% the set of integer residues modulo n. Given n in N, find a vector\n% s = (s_1, ..., s_n), such that (i) s is a permutation of\n% Z_n = {0,1,...,n-1}; and (ii) the interval vector\n% v = (|s_2-s_1|, |s_3-s_2|, ... |s_n-s_{n-1}|) is a permutation of\n% Z_n-{0} = {1,2,...,n-1}. A vector v satisfying these conditions is\n% called an all-interval series of size n; the problem of finding such\n% a series is the all-interval series problem of size n. We may also be\n% interested in finding all possible series of a given size.\n\ninclude \"globals.mzn\";\n\nint: n = 12;\n% array[1..n] of var 1..n: x;\narray[1..n] of var 1..n: x;\narray[1..n-1] of var 1..n-1: diffs;\nint: sum_distinct = ((n+1)*n) div 2;\n\n% max_regret seems to be quite good....\nsolve :: int_search(x, max_regret, indomain_split, complete) satisfy;\n\nconstraint      \n  all_different(diffs) :: domain\n  /\\  \n  all_different(x) :: domain\n  /\\ \n  forall(k in 1..n-1) (\n      diffs[k] = abs(x[k+1] - x[k])\n  )\n  /\\ % symmetry breaking\n  x[1] < x[n-1]\n  /\\\n  diffs[1] < diffs[2]\n;\n\n\noutput [\n       show(x) ++ \",\" % , \" \", show(sum_distinct), \" diffs: \", show(diffs)\n]\n\n\nModel 2 : \n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n%    all_different(series) /\\\n\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i != j)  (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n;\n\noutput\n[  show(series)\n];\n\n\nModel 3 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   %  C1: Each pitch class occurs exactly once\n   forall(i, j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i!=j) (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput\n[ show(series)\n];\n\n\nModel 4 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[differ] of var differ: differences;\n\nsolve satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 1..n-2) (\n       differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in differ where i != j) (\n       differences[i] != differences[j]\n   )\n;\n\noutput [\n  show(series)\n];\n\n\nModel 5 : \n\n\ninclude \"globals.mzn\";\n\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_median, complete) satisfy;\n\nconstraint\n  % C1: Each pitch class occurs exactly once\n  % GCAD: Exploitation of alldifferent() global constraint\n  all_different(series)\n  /\\\n\n  % C2: Differences between neighbouring notes are all different\n  % GCAD: Exploitation of alldifferent() global constraint\n  % alldifferent(all (i in classes: i <> n-1) abs(series[i+1] - series[i]));\n  all_different( \n         [ abs(series[i+1] - series[i]) | i in classes where i != n-1]\n  )\n  \n;\n\noutput [\n  show(series)\n];\n\n\nModel 6 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\n% solve satisfy;\nsolve :: int_search(series, occurrence, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n      differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in 0..n-2 where i != j) (\n      differences[i] != differences[j]\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\noutput [\n  show(series)\n];\n\n\nModel 7 : \n\n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\nsolve ::int_search(series, first_fail, indomain_max, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(series)\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n          differences[i] = abs(series[i+1] - series[i])\n   )\n   /\\\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(differences)\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput [\n   \"series: \" ++ show(series) ++ \"\\n\" ++\n   \"differences: \" ++ show(differences) \n];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "all_interval_expert", "node_type": "4", "metadata": {"model_name": "all_interval", "source_code": "Model 1 : \n\n\n%\n% All interval problem in MiniZinc\n%\n% \"\"\"\n% Given the twelve standard pitch-classes (c, c%, d, ...), represented by\n% numbers 0,1,...,11, find a series in which each pitch-class occurs exactly\n% once and in which the musical intervals between neighbouring notes cover\n% the full set of intervals from the minor second (1 semitone) to the major\n% seventh (11 semitones). That is, for each of the intervals, there is a\n% pair of neigbhouring pitch-classes in the series, between which this\n% interval appears. The problem of finding such a series can be easily\n% formulated as an instance of a more general arithmetic problem on Z_n,\n% the set of integer residues modulo n. Given n in N, find a vector\n% s = (s_1, ..., s_n), such that (i) s is a permutation of\n% Z_n = {0,1,...,n-1}; and (ii) the interval vector\n% v = (|s_2-s_1|, |s_3-s_2|, ... |s_n-s_{n-1}|) is a permutation of\n% Z_n-{0} = {1,2,...,n-1}. A vector v satisfying these conditions is\n% called an all-interval series of size n; the problem of finding such\n% a series is the all-interval series problem of size n. We may also be\n% interested in finding all possible series of a given size.\n\ninclude \"globals.mzn\";\n\nint: n = 12;\n% array[1..n] of var 1..n: x;\narray[1..n] of var 1..n: x;\narray[1..n-1] of var 1..n-1: diffs;\nint: sum_distinct = ((n+1)*n) div 2;\n\n% max_regret seems to be quite good....\nsolve :: int_search(x, max_regret, indomain_split, complete) satisfy;\n\nconstraint      \n  all_different(diffs) :: domain\n  /\\  \n  all_different(x) :: domain\n  /\\ \n  forall(k in 1..n-1) (\n      diffs[k] = abs(x[k+1] - x[k])\n  )\n  /\\ % symmetry breaking\n  x[1] < x[n-1]\n  /\\\n  diffs[1] < diffs[2]\n;\n\n\noutput [\n       show(x) ++ \",\" % , \" \", show(sum_distinct), \" diffs: \", show(diffs)\n]\n\n\nModel 2 : \n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n%    all_different(series) /\\\n\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i != j)  (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n;\n\noutput\n[  show(series)\n];\n\n\nModel 3 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   %  C1: Each pitch class occurs exactly once\n   forall(i, j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i!=j) (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput\n[ show(series)\n];\n\n\nModel 4 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[differ] of var differ: differences;\n\nsolve satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 1..n-2) (\n       differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in differ where i != j) (\n       differences[i] != differences[j]\n   )\n;\n\noutput [\n  show(series)\n];\n\n\nModel 5 : \n\n\ninclude \"globals.mzn\";\n\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_median, complete) satisfy;\n\nconstraint\n  % C1: Each pitch class occurs exactly once\n  % GCAD: Exploitation of alldifferent() global constraint\n  all_different(series)\n  /\\\n\n  % C2: Differences between neighbouring notes are all different\n  % GCAD: Exploitation of alldifferent() global constraint\n  % alldifferent(all (i in classes: i <> n-1) abs(series[i+1] - series[i]));\n  all_different( \n         [ abs(series[i+1] - series[i]) | i in classes where i != n-1]\n  )\n  \n;\n\noutput [\n  show(series)\n];\n\n\nModel 6 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\n% solve satisfy;\nsolve :: int_search(series, occurrence, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n      differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in 0..n-2 where i != j) (\n      differences[i] != differences[j]\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\noutput [\n  show(series)\n];\n\n\nModel 7 : \n\n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\nsolve ::int_search(series, first_fail, indomain_max, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(series)\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n          differences[i] = abs(series[i+1] - series[i])\n   )\n   /\\\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(differences)\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput [\n   \"series: \" ++ show(series) ++ \"\\n\" ++\n   \"differences: \" ++ show(differences) \n];"}, "hash": "3773605a029a54987244f8221617c309d18471cd4a57a8f520b8d5c2524e10c4", "class_name": "RelatedNodeInfo"}}, "text": "name: All-Interval Series Problem\n\ndescription: The All-Interval Series Problem is a classic problem in constraint programming that involves finding a series of pitch classes such that each pitch class occurs exactly once and the musical intervals between neighboring notes cover the full set of intervals from the minor second (1 semitone) to the major seventh (11 semitones).\n\nvariables: x = (x_1, ..., x_n) where x_i \u2208 {0, ..., n-1} for i = 1, ..., n; diffs = (diffs_1, ..., diffs_{n-1}) where diffs_i \u2208 {1, ..., n-1} for i = 1, ..., n-1\n\nThe variables x represent the pitch classes in the series, and the variables diffs represent the intervals between neighboring notes.\n\nconstraints: \nall_different(x) \u2227 all_different(diffs) \u2227 \n\u2200k \u2208 {1, ..., n-1} (diffs_k = |x_{k+1} - x_k|) \u2227 \nx_1 < x_{n-1} \u2227 diffs_1 < diffs_2\n\nThe constraints ensure that each pitch class occurs exactly once, each interval occurs exactly once, the intervals are calculated correctly, and some symmetry-breaking constraints are added to reduce the search space.\n\nobjective: The problem is a satisfaction problem, meaning that the goal is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1230, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e3490413-2df2-4bea-ae16-9c49a0955d39": {"__data__": {"id_": "e3490413-2df2-4bea-ae16-9c49a0955d39", "embedding": null, "metadata": {"model_name": "assign", "source_code": "Model 1 :\n\nint: n;\nset of int: WORK = 1..n;\nint: m;\nset of int: TASK = 1..m;\narray[WORK,TASK] of int: profit;\narray[WORK] of var TASK: x;\n% new\narray[WORK] of var int: px =\n     [ profit[w,x[w]] | w in WORK ];\nvar int: obj = sum(w in WORK)(px[w]);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\n\nann: varselect;\nann: valselect;\n\nsolve :: int_search(px, varselect, valselect, complete)\n      maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x);\\n\"];\n\n\nvarselect = largest;\nvalselect = indomain_min;\n\n\nModel 2 : \n\n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[DOM] of var COD: task;\narray[COD] of var DOM: worker;\n\ninclude \"inverse.mzn\";\nconstraint inverse(task,worker);\n\n\nsolve maximize sum(w in COD)\n            (profit[w,task[w]]);\n\noutput [show(task)];\n\n\n\nModel 3 : \n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[COD] of var DOM: worker;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(worker);\n\n\nsolve maximize sum(t in COD)\n            (profit[worker[t],t]);\n\noutput [show(worker)];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "assign_expert", "node_type": "4", "metadata": {"model_name": "assign", "source_code": "Model 1 :\n\nint: n;\nset of int: WORK = 1..n;\nint: m;\nset of int: TASK = 1..m;\narray[WORK,TASK] of int: profit;\narray[WORK] of var TASK: x;\n% new\narray[WORK] of var int: px =\n     [ profit[w,x[w]] | w in WORK ];\nvar int: obj = sum(w in WORK)(px[w]);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\n\nann: varselect;\nann: valselect;\n\nsolve :: int_search(px, varselect, valselect, complete)\n      maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x);\\n\"];\n\n\nvarselect = largest;\nvalselect = indomain_min;\n\n\nModel 2 : \n\n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[DOM] of var COD: task;\narray[COD] of var DOM: worker;\n\ninclude \"inverse.mzn\";\nconstraint inverse(task,worker);\n\n\nsolve maximize sum(w in COD)\n            (profit[w,task[w]]);\n\noutput [show(task)];\n\n\n\nModel 3 : \n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[COD] of var DOM: worker;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(worker);\n\n\nsolve maximize sum(t in COD)\n            (profit[worker[t],t]);\n\noutput [show(worker)];\n"}, "hash": "7f861c34941b8b9eb4ec5c96592c6950e2b5f3a617e193569dabc559f0c8f15b", "class_name": "RelatedNodeInfo"}}, "text": "name: Assignment Problem\n\ndescription: The Assignment Problem is a classic problem in combinatorial optimization and operations research. It involves finding the optimal assignment of a set of workers to a set of tasks, where each worker can be assigned to at most one task and each task can be assigned to at most one worker, in order to maximize the total profit or value of the assignments.\n\nvariables: x, px, task, worker\nx: an array of variables, where x[w] represents the task assigned to worker w\npx: an array of variables, where px[w] represents the profit of assigning worker w to task x[w]\ntask: an array of variables, where task[w] represents the worker assigned to task w\nworker: an array of variables, where worker[t] represents the task assigned to worker t\nThese variables represent the assignment of workers to tasks and the corresponding profits.\n\nconstraints: alldifferent(x), inverse(task,worker), alldifferent(worker)\nalldifferent(x): ensures that each worker is assigned to at most one task\ninverse(task,worker): ensures that each task is assigned to at most one worker and each worker is assigned to at most one task\nalldifferent(worker): ensures that each task is assigned to at most one worker\nThese constraints ensure that the assignment is one-to-one, i.e., each worker is assigned to at most one task and each task is assigned to at most one worker.\n\nobjective: maximize obj, where obj = sum(w in WORK)(px[w]) or obj = sum(t in COD)(profit[worker[t],t])\nThe objective is to maximize the total profit of the assignments, which is the sum of the profits of assigning each worker to their assigned task.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1627, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ff70edfc-d9dc-47d0-acf7-03831450871f": {"__data__": {"id_": "ff70edfc-d9dc-47d0-acf7-03831450871f", "embedding": null, "metadata": {"model_name": "aust_color", "source_code": "Model 1 :\n\n% Colouring Australia using 4 colors \nint: nc = 4;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n\n\n Model 2 :\n\n % Colouring Australia using nc colors \nint: nc;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aust_color_expert", "node_type": "4", "metadata": {"model_name": "aust_color", "source_code": "Model 1 :\n\n% Colouring Australia using 4 colors \nint: nc = 4;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n\n\n Model 2 :\n\n % Colouring Australia using nc colors \nint: nc;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n"}, "hash": "e310824312251198365bbe75193c5aca0257421815dfbc9ea7141b75dd94f296", "class_name": "RelatedNodeInfo"}}, "text": "name: Graph Colouring Problem (Australia Map Colouring)\n\ndescription: The Graph Colouring Problem is a classic problem in constraint programming, where we need to assign colours to the regions of a map such that no two adjacent regions have the same colour. In this specific instance, we are colouring the map of Australia, which is divided into six regions: Western Australia (wa), Northern Territory (nt), South Australia (sa), Queensland (q), New South Wales (nsw), and Victoria (v), plus Tasmania (t).\n\nvariables: wa, nt, sa, q, nsw, v, t \u2208 {1, ..., nc} \nThese variables represent the colours assigned to each region of the Australia map, where nc is the total number of colours available.\n\nconstraints: wa \u2260 nt, wa \u2260 sa, nt \u2260 sa, nt \u2260 q, sa \u2260 q, sa \u2260 nsw, sa \u2260 v, q \u2260 nsw, nsw \u2260 v \nThese constraints ensure that no two adjacent regions have the same colour. For example, wa \u2260 nt means that Western Australia and Northern Territory cannot have the same colour.\n\nobjective: satisfy \nThe objective of the problem is to find a feasible solution that satisfies all the constraints, i.e., to find a colouring of the Australia map such that no two adjacent regions have the same colour. There is no objective to minimize or maximize a specific value.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1248, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b85d2124-b231-4b75-b593-2a2aa834a0d6": {"__data__": {"id_": "b85d2124-b231-4b75-b593-2a2aa834a0d6", "embedding": null, "metadata": {"model_name": "bibd", "source_code": "% bibd.mzn\n% vim: ft=zinc ts=4 sw=4 et tw=0\n% Ralph Becket <rafe@csse.unimelb.edu.au>\n% Tue Oct 23 11:28:06 EST 2007\n%\n% Balanced incomplete block designs.  See the following:\n% http://mathworld.wolfram.com/BlockDesign.html\n% http://www.dcs.st-and.ac.uk/~ianm/CSPLib/prob/prob028/spec.html\n%\n%\n%\n% A BIBD (v, b, r, k, lambda) problem is to find a binary matrix of v rows\n% of b columns such that each row sums to r, each column sums to k, and\n% the dot product beween any pair of distinct rows is lambda.\n\ninclude \"lex_lesseq.mzn\";\n\nint: v;\nint: k;\nint: lambda;\n\nint: b = (lambda * v * (v - 1)) div (k * (k - 1));\nint: r = (lambda * (v - 1)) div (k - 1);\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\narray [rows, cols] of var bool: m;\n\n    % Every row must sum to r.\n    %\nconstraint forall (i in rows) (sum (j in cols) (bool2int(m[i, j])) = r);\n\n    % Every column must sum to k.\n    %\nconstraint forall (j in cols) (sum (i in rows) (bool2int(m[i, j])) = k);\n\n    % The dot product of every pair of distinct rows must be lambda.\n    %\nconstraint\n    forall (i_a, i_b in rows where i_a < i_b) (\n        sum (j in cols) (bool2int(m[i_a, j] /\\ m[i_b, j])) = lambda\n    );\n\n    % Break row symmetry in the incidence matrix.\n    %\nconstraint forall(i in rows diff {max(rows)})(\n        lex_lesseq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    );\n\n    % Break column symmetry in the incidence matrix.\n    %\nconstraint forall(j in cols diff {max(cols)})(\n        lex_lesseq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    );\n\nsolve :: bool_search([m[i, j] | i in rows, j in cols],\n    input_order, indomain_min, complete)\n    satisfy;\n\noutput  [\"bibd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r),\n        \", k = \", show(k), \", lambda = \", show(lambda), \")\\n\\n\"] ++\n        [ ( if j > b then \"\\n\" else show(bool2int(m[i, j])) endif )\n        | i in rows, j in 1..(b + 1)\n        ];\n\n%----------------------------------------------------------------------------%\n%----------------------------------------------------------------------------%\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bibd_expert", "node_type": "4", "metadata": {"model_name": "bibd", "source_code": "% bibd.mzn\n% vim: ft=zinc ts=4 sw=4 et tw=0\n% Ralph Becket <rafe@csse.unimelb.edu.au>\n% Tue Oct 23 11:28:06 EST 2007\n%\n% Balanced incomplete block designs.  See the following:\n% http://mathworld.wolfram.com/BlockDesign.html\n% http://www.dcs.st-and.ac.uk/~ianm/CSPLib/prob/prob028/spec.html\n%\n%\n%\n% A BIBD (v, b, r, k, lambda) problem is to find a binary matrix of v rows\n% of b columns such that each row sums to r, each column sums to k, and\n% the dot product beween any pair of distinct rows is lambda.\n\ninclude \"lex_lesseq.mzn\";\n\nint: v;\nint: k;\nint: lambda;\n\nint: b = (lambda * v * (v - 1)) div (k * (k - 1));\nint: r = (lambda * (v - 1)) div (k - 1);\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\narray [rows, cols] of var bool: m;\n\n    % Every row must sum to r.\n    %\nconstraint forall (i in rows) (sum (j in cols) (bool2int(m[i, j])) = r);\n\n    % Every column must sum to k.\n    %\nconstraint forall (j in cols) (sum (i in rows) (bool2int(m[i, j])) = k);\n\n    % The dot product of every pair of distinct rows must be lambda.\n    %\nconstraint\n    forall (i_a, i_b in rows where i_a < i_b) (\n        sum (j in cols) (bool2int(m[i_a, j] /\\ m[i_b, j])) = lambda\n    );\n\n    % Break row symmetry in the incidence matrix.\n    %\nconstraint forall(i in rows diff {max(rows)})(\n        lex_lesseq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    );\n\n    % Break column symmetry in the incidence matrix.\n    %\nconstraint forall(j in cols diff {max(cols)})(\n        lex_lesseq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    );\n\nsolve :: bool_search([m[i, j] | i in rows, j in cols],\n    input_order, indomain_min, complete)\n    satisfy;\n\noutput  [\"bibd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r),\n        \", k = \", show(k), \", lambda = \", show(lambda), \")\\n\\n\"] ++\n        [ ( if j > b then \"\\n\" else show(bool2int(m[i, j])) endif )\n        | i in rows, j in 1..(b + 1)\n        ];\n\n%----------------------------------------------------------------------------%\n%----------------------------------------------------------------------------%\n"}, "hash": "ade85b961eaae89a6311c8b52406e58f6fd2e7f710dcac020f5fa949abd9af36", "class_name": "RelatedNodeInfo"}}, "text": "name: Balanced Incomplete Block Design (BIBD)\n\ndescription: A Balanced Incomplete Block Design (BIBD) is a combinatorial design in which a set of v elements is divided into b blocks, each of size k, such that each element occurs in r blocks, and every pair of elements occurs together in \u03bb blocks. The goal is to find a binary matrix representing the incidence of elements in blocks, satisfying these conditions.\n\nvariables: m[i, j] for i in {1, ..., v}, j in {1, ..., b} - m[i, j] represents whether element i is in block j (true) or not (false).\n\nconstraints: \n1. \u2200i in {1, ..., v} (\u2211(j in {1, ..., b}) bool2int(m[i, j]) = r) - Each element occurs in r blocks.\n2. \u2200j in {1, ..., b} (\u2211(i in {1, ..., v}) bool2int(m[i, j]) = k) - Each block contains k elements.\n3. \u2200i, i' in {1, ..., v} where i < i' (\u2211(j in {1, ..., b}) bool2int(m[i, j] \u2227 m[i', j]) = \u03bb) - Every pair of elements occurs together in \u03bb blocks.\n4. \u2200i in {1, ..., v-1} (lex_lesseq([m[i, j] | j in {1, ..., b}], [m[i+1, j] | j in {1, ..., b}])) - Break row symmetry in the incidence matrix.\n5. \u2200j in {1, ..., b-1} (lex_lesseq([m[i, j] | i in {1, ..., v}], [m[i, j+1] | i in {1, ..., v}])) - Break column symmetry in the incidence matrix.\n\nobjective: The problem is a satisfaction problem, meaning that the goal is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1393, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c44065c7-ef5d-479e-9438-7123e75ca229": {"__data__": {"id_": "c44065c7-ef5d-479e-9438-7123e75ca229", "embedding": null, "metadata": {"model_name": "bus_scheduling_csplib", "source_code": "%\n% Bus driver scheduling problem (prob022 in CSPLib) in MiniZinc.\n%\n% Specification\n% Bus driver scheduling can be formulated as a set paritioning problem.\n% We propose 12 set partitioning problems derived from small bus driver\n% scheduling problems. These consist of a given set of tasks (pieces of\n% work) to cover and a large set of possible shifts, where each shift\n% covers a subset of the tasks and has an associated cost. We must select\n% a subset of possible shifts that covers each piece of work once and\n% only once: this is called a partition. Further,\n%\n% In the driver scheduling (unlike air crew scheduling) the main aim is\n% to reduce the number of shifts used in the solution partition and the\n% total cost of the partition is secondary. To simplify the problem we have\n% made the cost of each shift the same. This means that the goal is to\n% minimise the number of shifts.\n%\n% The problems come from four different bus companies:\n% Reading (r1 to r5a),\n% CentreWest Ealing area (c1, c1a, c2),\n% the former London Transport (t1 and t2).\n%\n% The problems have differing regulations and features (e.g. urban and\n% short distance rural bus schedules can have very different features). Note\n% that r1 and r1a are the same problem, but have different numbers of\n% generated shifts. Similarly with the problems: c1, c1a and r5, r5a.\n%\n% Problems are presented in the same format as the set partitioning\n% examples in ORLIB. The first line gives the number of rows (pieces of work),\n% columns (shifts) and the minimum number of columns need for a partition.\n% Then each line after that corresponds to one column. It starts with\n% the cost (which is always 1 in our case) then the number of rows it\n% covers, followed by the rows it covers.\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \nint: num_work;\nint: num_shifts;\nint: min_num_shifts;\narray[1..num_shifts] of set of int: shifts;\n\narray[1..num_shifts] of var 0..1: x;\nvar 0..num_shifts: tot_shifts;\n\n% solve minimize tot_shifts;\nsolve :: int_search(\n        x ++ [tot_shifts], \n        first_fail, \n        indomain_min, \n        complete) \n    minimize tot_shifts;\n    % satisfy;\n\nconstraint\n   tot_shifts = sum(x)\n   /\\\n   forall(j in 0..num_work-1) (\n       sum(i in 1..num_shifts) (x[i]*bool2int(j in shifts[i])) = 1\n   )\n   /\\\n   tot_shifts >= min_num_shifts\n\n   % /\\ % for solve satisfy (t1)\n   % tot_shifts = 7\n;\n\n\noutput [\n  \"tot_shifts: \" ++ show(tot_shifts) ++ \"\\n\" ++ \n  \"x: \" ++ show(x) ++ \"\\n\"\n] ++ \n[\n  if fix(x[i]) = 1 then show(shifts[i]) else \"\" endif\n  | i in 1..num_shifts\n] ++ \n[\"\\n\"] ++\n[\n  if fix(x[i]) = 1 then show(i) ++ \" \" else \"\" endif\n  | i in 1..num_shifts\n] ++ [\"\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bus_scheduling_csplib_expert", "node_type": "4", "metadata": {"model_name": "bus_scheduling_csplib", "source_code": "%\n% Bus driver scheduling problem (prob022 in CSPLib) in MiniZinc.\n%\n% Specification\n% Bus driver scheduling can be formulated as a set paritioning problem.\n% We propose 12 set partitioning problems derived from small bus driver\n% scheduling problems. These consist of a given set of tasks (pieces of\n% work) to cover and a large set of possible shifts, where each shift\n% covers a subset of the tasks and has an associated cost. We must select\n% a subset of possible shifts that covers each piece of work once and\n% only once: this is called a partition. Further,\n%\n% In the driver scheduling (unlike air crew scheduling) the main aim is\n% to reduce the number of shifts used in the solution partition and the\n% total cost of the partition is secondary. To simplify the problem we have\n% made the cost of each shift the same. This means that the goal is to\n% minimise the number of shifts.\n%\n% The problems come from four different bus companies:\n% Reading (r1 to r5a),\n% CentreWest Ealing area (c1, c1a, c2),\n% the former London Transport (t1 and t2).\n%\n% The problems have differing regulations and features (e.g. urban and\n% short distance rural bus schedules can have very different features). Note\n% that r1 and r1a are the same problem, but have different numbers of\n% generated shifts. Similarly with the problems: c1, c1a and r5, r5a.\n%\n% Problems are presented in the same format as the set partitioning\n% examples in ORLIB. The first line gives the number of rows (pieces of work),\n% columns (shifts) and the minimum number of columns need for a partition.\n% Then each line after that corresponds to one column. It starts with\n% the cost (which is always 1 in our case) then the number of rows it\n% covers, followed by the rows it covers.\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \nint: num_work;\nint: num_shifts;\nint: min_num_shifts;\narray[1..num_shifts] of set of int: shifts;\n\narray[1..num_shifts] of var 0..1: x;\nvar 0..num_shifts: tot_shifts;\n\n% solve minimize tot_shifts;\nsolve :: int_search(\n        x ++ [tot_shifts], \n        first_fail, \n        indomain_min, \n        complete) \n    minimize tot_shifts;\n    % satisfy;\n\nconstraint\n   tot_shifts = sum(x)\n   /\\\n   forall(j in 0..num_work-1) (\n       sum(i in 1..num_shifts) (x[i]*bool2int(j in shifts[i])) = 1\n   )\n   /\\\n   tot_shifts >= min_num_shifts\n\n   % /\\ % for solve satisfy (t1)\n   % tot_shifts = 7\n;\n\n\noutput [\n  \"tot_shifts: \" ++ show(tot_shifts) ++ \"\\n\" ++ \n  \"x: \" ++ show(x) ++ \"\\n\"\n] ++ \n[\n  if fix(x[i]) = 1 then show(shifts[i]) else \"\" endif\n  | i in 1..num_shifts\n] ++ \n[\"\\n\"] ++\n[\n  if fix(x[i]) = 1 then show(i) ++ \" \" else \"\" endif\n  | i in 1..num_shifts\n] ++ [\"\\n\"];\n"}, "hash": "c8742ad12c16c77f8f5985da49f18b794d12bf409926b7f0521a5033e69e6031", "class_name": "RelatedNodeInfo"}}, "text": "name: Bus Driver Scheduling Problem\n\ndescription: The Bus Driver Scheduling Problem is a classic problem in constraint programming that involves assigning bus drivers to shifts to cover a set of tasks (pieces of work) while minimizing the number of shifts used. Each shift has a set of tasks it covers, and the goal is to select a subset of shifts that covers each task exactly once.\n\nvariables: x = (x[1], ..., x[num_shifts]) \u2208 {0, 1}^num_shifts, tot_shifts \u2208 {0, ..., num_shifts}\n\nThe decision variables x[i] represent whether shift i is selected (x[i] = 1) or not (x[i] = 0). The variable tot_shifts represents the total number of shifts used in the solution.\n\nconstraints: \ntot_shifts = \u2211(x)\n\u2200j \u2208 {0, ..., num_work-1}, \u2211(i \u2208 {1, ..., num_shifts}) (x[i] * bool2int(j \u2208 shifts[i])) = 1\ntot_shifts \u2265 min_num_shifts\n\nThe first constraint sets the total number of shifts used to the sum of the x variables. The second constraint ensures that each task is covered exactly once by the selected shifts. The third constraint sets a lower bound on the total number of shifts used.\n\nobjective: Minimize tot_shifts", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1106, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bd94337e-fefc-46a9-9a33-7f05a37f2ae3": {"__data__": {"id_": "bd94337e-fefc-46a9-9a33-7f05a37f2ae3", "embedding": null, "metadata": {"model_name": "car", "source_code": "%\n% Car sequencing in MiniZinc.\n% include \"globals.mzn\";\n\nint: numclasses;\nint: numoptions;\nint: numcars;\nset of int: Classes = 1..numclasses;\nset of int: Options = 1..numoptions;\nset of int: Slots = 1..numcars;\n\narray[Classes] of int: numberPerClass;\n\narray[Classes,Options] of int: optionsRequired;\narray[Options] of int: windowSize;\narray[Options] of int: optMax;\n\narray[Options] of int: optionNumberPerClass = [sum(j in Classes) (numberPerClass[j] * optionsRequired[j,i]) | i in Options];\n\n% decision variables\n\narray[Slots] of var Classes: slot;\narray[Options, Slots] of var 0..1: setup;\n\n\nvar int: z = sum(s in Classes) (s*slot[s]);\n\n% solve minimize z;\nsolve :: int_search(slot, input_order, indomain_min, complete)\n  satisfy;\n\nconstraint\n  forall(c in Classes ) (\n    sum(s in Slots ) (bool2int(slot[s] = c)) = numberPerClass[c]\n  )\n  /\\\n  forall(o in Options, s in 1..numcars - windowSize[o] + 1) (\n    sum(j in s..s + windowSize[o]- 1) (setup[o,j]) <= optMax[o]\n  )\n  /\\\n  forall(o in Options, s in Slots ) (\n    setup[o,s] = optionsRequired[slot[s],o]\n  )\n  /\\\n  forall(o in Options, i in 1..optionNumberPerClass[o]) (\n    sum(s in 1..(numcars - i * windowSize[o])) (setup[o,s]) >=\n           (optionNumberPerClass[o] - i * optMax[o])\n  )\n;\n\n% for solve satisfy\n% constraint z = 82;\n\n\noutput [\n \"z: \" ++ show(z) ++ \"\\n\" ++\n \"slot: \" ++ show(slot) ++ \"\\n\"\n] ++\n[\n  if j = 1 then \"\\n\" else \" \" endif ++ \n    show(setup[i,j])\n  | i in Options, j in Slots\n];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "car_expert", "node_type": "4", "metadata": {"model_name": "car", "source_code": "%\n% Car sequencing in MiniZinc.\n% include \"globals.mzn\";\n\nint: numclasses;\nint: numoptions;\nint: numcars;\nset of int: Classes = 1..numclasses;\nset of int: Options = 1..numoptions;\nset of int: Slots = 1..numcars;\n\narray[Classes] of int: numberPerClass;\n\narray[Classes,Options] of int: optionsRequired;\narray[Options] of int: windowSize;\narray[Options] of int: optMax;\n\narray[Options] of int: optionNumberPerClass = [sum(j in Classes) (numberPerClass[j] * optionsRequired[j,i]) | i in Options];\n\n% decision variables\n\narray[Slots] of var Classes: slot;\narray[Options, Slots] of var 0..1: setup;\n\n\nvar int: z = sum(s in Classes) (s*slot[s]);\n\n% solve minimize z;\nsolve :: int_search(slot, input_order, indomain_min, complete)\n  satisfy;\n\nconstraint\n  forall(c in Classes ) (\n    sum(s in Slots ) (bool2int(slot[s] = c)) = numberPerClass[c]\n  )\n  /\\\n  forall(o in Options, s in 1..numcars - windowSize[o] + 1) (\n    sum(j in s..s + windowSize[o]- 1) (setup[o,j]) <= optMax[o]\n  )\n  /\\\n  forall(o in Options, s in Slots ) (\n    setup[o,s] = optionsRequired[slot[s],o]\n  )\n  /\\\n  forall(o in Options, i in 1..optionNumberPerClass[o]) (\n    sum(s in 1..(numcars - i * windowSize[o])) (setup[o,s]) >=\n           (optionNumberPerClass[o] - i * optMax[o])\n  )\n;\n\n% for solve satisfy\n% constraint z = 82;\n\n\noutput [\n \"z: \" ++ show(z) ++ \"\\n\" ++\n \"slot: \" ++ show(slot) ++ \"\\n\"\n] ++\n[\n  if j = 1 then \"\\n\" else \" \" endif ++ \n    show(setup[i,j])\n  | i in Options, j in Slots\n];\n"}, "hash": "e8abee4103cfb42fd1c8d30ef75d043a75fb8e80061bd867d967ea0d26230c9f", "class_name": "RelatedNodeInfo"}}, "text": "name: Car Sequencing Problem\n\ndescription: The Car Sequencing Problem is a classic problem in constraint programming that involves scheduling the production of cars with different options and classes. The goal is to find an optimal sequence of cars to produce, taking into account the availability of options and the constraints on the production process.\n\nvariables: \n`slot[s] \u2208 Classes, s \u2208 Slots` \n`setup[o, s] \u2208 {0, 1}, o \u2208 Options, s \u2208 Slots`\n\nThe decision variables are `slot` and `setup`. `slot[s]` represents the class of the car produced in slot `s`, and `setup[o, s]` represents whether option `o` is installed in the car produced in slot `s`.\n\nconstraints: \n`\u2200c \u2208 Classes, \u2211(s \u2208 Slots) (bool2int(slot[s] = c)) = numberPerClass[c]`\n`\u2200o \u2208 Options, s \u2208 1..numcars - windowSize[o] + 1, \u2211(j \u2208 s..s + windowSize[o]- 1) (setup[o, j]) \u2264 optMax[o]`\n`\u2200o \u2208 Options, s \u2208 Slots, setup[o, s] = optionsRequired[slot[s], o]`\n`\u2200o \u2208 Options, i \u2208 1..optionNumberPerClass[o], \u2211(s \u2208 1..(numcars - i * windowSize[o])) (setup[o, s]) \u2265 (optionNumberPerClass[o] - i * optMax[o])`\n\nThe constraints ensure that: \n- each class of cars is produced the required number of times, \n- the number of consecutive cars with a particular option does not exceed the maximum allowed, \n- each car is produced with the required options, \n- and the total number of cars with a particular option is at least the minimum required.\n\nobjective: \n`minimize z = \u2211(s \u2208 Classes) (s * slot[s])`\n\nThe objective is to minimize the total \"cost\" of the production sequence, where the cost of each car is proportional to its class.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1586, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "252f0455-165a-45da-a421-027460f998a0": {"__data__": {"id_": "252f0455-165a-45da-a421-027460f998a0", "embedding": null, "metadata": {"model_name": "carpet_cutting", "source_code": "Model 1 :\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\narray[ROOM] of var ROT: rot;\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)(shape[i,rot[i]] != {});\n\nconstraint forall(i in ROOM)(forall(r in ROFF)\n  (r in shape[i,rot[i]] -> \n  (x[i] + d[r,1] + d[r,3] <= l /\\\n   y[i] + d[r,2] + d[r,4] <= h)));\n\nconstraint forall(i,j in ROOM where i < j)\n  (forall(r1,r2 in ROFF)\n (r1 in shape[i,rot[i]] /\\ \n  r2 in shape[j,rot[j]] -> \n(x[i] + d[r1,1] + d[r1,3] <= x[j] + d[r2,1]\n                   \\/\n x[j] + d[r2,1] + d[r2,3] <= x[i] + d[r1,1]\n                   \\/\n y[i] + d[r1,2] + d[r1,4] <= y[j] + d[r2,2]\n                   \\/\ny[j] + d[r2,2] + d[r2,4] <= y[i] + d[r1,2])\n   ));\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nrot = \\(rot);\\n\"];\n\n\n\nModel 2 :\n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: DIM = 1..2;\narray[ROFF,DIM] of int: rect_size = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 3..4]);\narray[ROFF,DIM] of int: rect_offset = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 1..2]);\narray[int] of set of ROFF: shapes = [ {1,3,4}, {2,5,6}, {1}, {7} ];\nset of int: SHAPE = index_set(shapes);\n%array[int] of set of RECT: s = sort([shapes[i,j] | i in 1..n, j in 1..4]);\n\narray[ROOM] of var SHAPE: kind;\narray[ROOM,DIM] of var int: coords =\n      array2d(ROOM,DIM, [ if j = 1 then x[i] else y[i] endif\n                         | i in ROOM, j in 1..2 ]);\n\n\n\ninclude \"geost.mzn\";\n\nconstraint geost_bb(2,\n                    rect_size,\n                    rect_offset,\n                    shapes,\n                    coords,\n                    kind,\n                    [0,0],\n                    [l,h]);\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)\n                 (exists(r in ROT where shape[i,r] != {})\n                        (shapes[kind[i]] = shape[i,r]));\n\n\noutput [\"rect_size = \\(rect_size);\\nrect_offset = \\(rect_offset);\\n\"] ++\n       [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];\n\n\n\nModel 3 : \n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: SHAPE = 1..4;\narray[ROOM] of var SHAPE: kind;\n\nconstraint geost_bb(2,\n       [| 3,4 | 4,3 | 1,1 | 1,2 | 1,1 | 2,1 | 4,3 |],\n       [| 0,0 | 0,1 | 1,4 | 3,1 | 4,2 | 1,0 | 0,0 |],\n       [ {1,3,4}, {2,5,6}, {1}, {7} ],\n       [| x[1], y[1] | x[2],y[2] | x[3],y[3] |],\n       kind,\n       [ 0,0 ],\n       [ l, h]);\n\nconstraint kind[1] in {1,2};\nconstraint kind[2] in {1,2};\nconstraint kind[3] in {3,4}; \ninclude \"geost.mzn\";\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "carpet_cutting_expert", "node_type": "4", "metadata": {"model_name": "carpet_cutting", "source_code": "Model 1 :\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\narray[ROOM] of var ROT: rot;\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)(shape[i,rot[i]] != {});\n\nconstraint forall(i in ROOM)(forall(r in ROFF)\n  (r in shape[i,rot[i]] -> \n  (x[i] + d[r,1] + d[r,3] <= l /\\\n   y[i] + d[r,2] + d[r,4] <= h)));\n\nconstraint forall(i,j in ROOM where i < j)\n  (forall(r1,r2 in ROFF)\n (r1 in shape[i,rot[i]] /\\ \n  r2 in shape[j,rot[j]] -> \n(x[i] + d[r1,1] + d[r1,3] <= x[j] + d[r2,1]\n                   \\/\n x[j] + d[r2,1] + d[r2,3] <= x[i] + d[r1,1]\n                   \\/\n y[i] + d[r1,2] + d[r1,4] <= y[j] + d[r2,2]\n                   \\/\ny[j] + d[r2,2] + d[r2,4] <= y[i] + d[r1,2])\n   ));\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nrot = \\(rot);\\n\"];\n\n\n\nModel 2 :\n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: DIM = 1..2;\narray[ROFF,DIM] of int: rect_size = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 3..4]);\narray[ROFF,DIM] of int: rect_offset = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 1..2]);\narray[int] of set of ROFF: shapes = [ {1,3,4}, {2,5,6}, {1}, {7} ];\nset of int: SHAPE = index_set(shapes);\n%array[int] of set of RECT: s = sort([shapes[i,j] | i in 1..n, j in 1..4]);\n\narray[ROOM] of var SHAPE: kind;\narray[ROOM,DIM] of var int: coords =\n      array2d(ROOM,DIM, [ if j = 1 then x[i] else y[i] endif\n                         | i in ROOM, j in 1..2 ]);\n\n\n\ninclude \"geost.mzn\";\n\nconstraint geost_bb(2,\n                    rect_size,\n                    rect_offset,\n                    shapes,\n                    coords,\n                    kind,\n                    [0,0],\n                    [l,h]);\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)\n                 (exists(r in ROT where shape[i,r] != {})\n                        (shapes[kind[i]] = shape[i,r]));\n\n\noutput [\"rect_size = \\(rect_size);\\nrect_offset = \\(rect_offset);\\n\"] ++\n       [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];\n\n\n\nModel 3 : \n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: SHAPE = 1..4;\narray[ROOM] of var SHAPE: kind;\n\nconstraint geost_bb(2,\n       [| 3,4 | 4,3 | 1,1 | 1,2 | 1,1 | 2,1 | 4,3 |],\n       [| 0,0 | 0,1 | 1,4 | 3,1 | 4,2 | 1,0 | 0,0 |],\n       [ {1,3,4}, {2,5,6}, {1}, {7} ],\n       [| x[1], y[1] | x[2],y[2] | x[3],y[3] |],\n       kind,\n       [ 0,0 ],\n       [ l, h]);\n\nconstraint kind[1] in {1,2};\nconstraint kind[2] in {1,2};\nconstraint kind[3] in {3,4}; \ninclude \"geost.mzn\";\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];"}, "hash": "6131aa7151c9baaa56c2eed19c920d49aaad3af6f36cd9fa6e32edc1ffea1106", "class_name": "RelatedNodeInfo"}}, "text": "name: 2D Rectangular Cutting Stock Problem\n\ndescription: The 2D Rectangular Cutting Stock Problem is a classic problem in operations research and computer science. It involves cutting a set of rectangles from a larger rectangular roll of material, such as wood or metal, to minimize waste. Each rectangle has a specific size and offset, and can be rotated by 90 degrees. The goal is to find the optimal placement of the rectangles on the roll to minimize the total length of the roll used.\n\nvariables: x[i], y[i], rot[i], l, kind[i]\n\n* x[i] and y[i] are the coordinates of the top-left corner of room i on the roll.\n* rot[i] is the rotation of room i (0, 90, 180, or 270 degrees).\n* l is the total length of the roll used.\n* kind[i] is the shape of room i (1, 2, 3, or 4).\n\nconstraints: \nforall(i in ROOM)(shape[i,rot[i]] != {}),\nforall(i in ROOM)(forall(r in ROFF)(r in shape[i,rot[i]] -> x[i] + d[r,1] + d[r,3] <= l /\\ y[i] + d[r,2] + d[r,4] <= h)),\nforall(i,j in ROOM where i < j)(forall(r1,r2 in ROFF)(r1 in shape[i,rot[i]] /\\ r2 in shape[j,rot[j]] -> x[i] + d[r1,1] + d[r1,3] <= x[j] + d[r2,1] \\/ x[j] + d[r2,1] + d[r2,3] <= x[i] + d[r1,1] \\/ y[i] + d[r1,2] + d[r1,4] <= y[j] + d[r2,2] \\/ y[j] + d[r2,2] + d[r2,4] <= y[i] + d[r1,2])),\ngeost_bb(2, rect_size, rect_offset, shapes, coords, kind, [0,0], [l,h]),\nkind[i] in {1,2,3,4}\n\n* The first constraint ensures that each room has a non-empty shape.\n* The second constraint ensures that each rectangle in a room does not exceed the roll's length and height.\n* The third constraint ensures that no two rooms overlap.\n* The fourth constraint is a geometric constraint that ensures the rectangles are placed correctly on the roll.\n* The fifth constraint ensures that each room has a valid shape.\n\nobjective: minimize l", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1769, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c42a6330-50e8-4df1-9f48-fcb20fc536a0": {"__data__": {"id_": "c42a6330-50e8-4df1-9f48-fcb20fc536a0", "embedding": null, "metadata": {"model_name": "cell_block", "source_code": "Model 1 :\n\n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\n%constraint forall(p1, p2 in PRISONER where p1 < p2)\n%                 (abs(r[p1] - r[p2]) + abs(c[p1] - c[p2]) > 0); \ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nconstraint forall(p in PRISONER, d in danger where p != d)\n                 ( abs(r[p] - r[d]) + abs(c[p] - c[d]) > 1 );\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n\n\n\nModel 2 : \n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nfunction var int: \n     manhattan(var int:x1, var int:y1,\n               var int:x2, var int:y2) =\n     abs(x2 - x1) + abs(y2 - y1);\n\nconstraint forall(p in PRISONER, d in danger where p != d) \n                 (manhattan(r[p],c[p],r[d],c[d]) > 1);\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cell_block_expert", "node_type": "4", "metadata": {"model_name": "cell_block", "source_code": "Model 1 :\n\n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\n%constraint forall(p1, p2 in PRISONER where p1 < p2)\n%                 (abs(r[p1] - r[p2]) + abs(c[p1] - c[p2]) > 0); \ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nconstraint forall(p in PRISONER, d in danger where p != d)\n                 ( abs(r[p] - r[d]) + abs(c[p] - c[d]) > 1 );\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n\n\n\nModel 2 : \n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nfunction var int: \n     manhattan(var int:x1, var int:y1,\n               var int:x2, var int:y2) =\n     abs(x2 - x1) + abs(y2 - y1);\n\nconstraint forall(p in PRISONER, d in danger where p != d) \n                 (manhattan(r[p],c[p],r[d],c[d]) > 1);\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n"}, "hash": "6eebc641d9cb5a40e1bd5fe4321cca143a443f127807dfa14d5445738a53ff0c", "class_name": "RelatedNodeInfo"}}, "text": "name: Prisoner Allocation Problem\n\ndescription: The Prisoner Allocation Problem is a classic constraint satisfaction problem that involves allocating prisoners to cells in a prison. The prison has a certain number of rows and columns, and each prisoner has a specific cost associated with being placed in a particular cell. The goal is to allocate the prisoners to cells in such a way that the total cost is minimized, while also satisfying certain constraints. These constraints include ensuring that prisoners who are deemed \"dangerous\" are not placed in adjacent cells, and that female prisoners are placed in cells in the top half of the prison, while male prisoners are placed in cells in the bottom half.\n\nvariables: r, c (arrays of variables, where r[p] and c[p] represent the row and column of prisoner p, respectively)\n\nThese variables represent the decision of which cell to allocate each prisoner to.\n\nconstraints: \nalldifferent([r[p] * m + c[p] | p in PRISONER]) (each prisoner must be allocated to a unique cell)\nforall(p in PRISONER, d in danger where p != d) (manhattan(r[p],c[p],r[d],c[d]) > 1) (dangerous prisoners must not be placed in adjacent cells)\nforall(p in female)(r[p] <= (n + 1) div 2) (female prisoners must be placed in cells in the top half of the prison)\nforall(p in male)(r[p] >= n div 2 + 1) (male prisoners must be placed in cells in the bottom half of the prison)\n\nThese constraints ensure that the allocation of prisoners to cells is valid and satisfies the rules of the prison.\n\nobjective: minimize totalcost (the total cost of allocating prisoners to cells)", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1595, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6758bed3-eefd-4c94-a8af-b1dde5398644": {"__data__": {"id_": "6758bed3-eefd-4c94-a8af-b1dde5398644", "embedding": null, "metadata": {"model_name": "clique", "source_code": "% Maximum Clique Problem\n\nint: n = 5;\narray[1..n, 1..n] of int: adj =\n    [| 0, 1, 0, 1, 0\n     | 1, 0, 1, 0, 0\n     | 0, 1, 0, 1, 1\n     | 1, 0, 1, 0, 1\n     | 0, 0, 1, 1, 0 |];\n\n% --- naive model ---\n\n% decision variables: which vertices are in the clique?\narray[1..n] of var bool: c;\nvar int: size;\n\n% how many vertices have we selected?\nconstraint size = sum(c);\n\n% we can only pick one of any non-adjacent pair of vertices\nconstraint forall (i, j in 1..n where i < j /\\ 0 == adj[i,j]) (bool2int(c[i]) + bool2int(c[j]) <= 1);\n\nsolve maximize size;\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "clique_expert", "node_type": "4", "metadata": {"model_name": "clique", "source_code": "% Maximum Clique Problem\n\nint: n = 5;\narray[1..n, 1..n] of int: adj =\n    [| 0, 1, 0, 1, 0\n     | 1, 0, 1, 0, 0\n     | 0, 1, 0, 1, 1\n     | 1, 0, 1, 0, 1\n     | 0, 0, 1, 1, 0 |];\n\n% --- naive model ---\n\n% decision variables: which vertices are in the clique?\narray[1..n] of var bool: c;\nvar int: size;\n\n% how many vertices have we selected?\nconstraint size = sum(c);\n\n% we can only pick one of any non-adjacent pair of vertices\nconstraint forall (i, j in 1..n where i < j /\\ 0 == adj[i,j]) (bool2int(c[i]) + bool2int(c[j]) <= 1);\n\nsolve maximize size;\n\n"}, "hash": "eac82b4cf40f0009ee71763d4f9bf832d09b308488c3bc1201746226e5e3ead4", "class_name": "RelatedNodeInfo"}}, "text": "name: Maximum Clique Problem\n\ndescription: The Maximum Clique Problem is a classic problem in graph theory and computer science. Given a graph, the goal is to find the largest subset of vertices such that every pair of vertices in the subset is connected by an edge. This problem has applications in social network analysis, data mining, and computer vision, among others.\n\nvariables: c = (c_1, ..., c_n), size\n\nThe decision variables c_i (i = 1, ..., n) are boolean variables indicating whether vertex i is included in the clique or not. The variable size is an integer representing the total number of vertices in the clique.\n\nconstraints: size = \u2211_{i=1}^n c_i, \u2200i, j \u2208 {1, ..., n} where i < j and adj[i, j] = 0, c_i + c_j \u2264 1\n\nThe first constraint ensures that the size of the clique is equal to the sum of the boolean variables c_i. The second constraint ensures that for any pair of non-adjacent vertices i and j, at most one of them can be included in the clique.\n\nobjective: Maximize size", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 995, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0db0e6a7-89b3-47f6-8deb-848745bf9e4c": {"__data__": {"id_": "0db0e6a7-89b3-47f6-8deb-848745bf9e4c", "embedding": null, "metadata": {"model_name": "cluster", "source_code": "int: n; % points to be clustered\nset of int: POINT = 1..n;\narray[POINT,POINT] of int: dist; % distance between two points\nint: maxdist = max([ dist[i,j] | i,j in POINT]);\n\n\nint: k; % number of clusters\nset of int: CLUSTER = 1..k;\n\nint: maxdiam;\n\narray[POINT] of var CLUSTER: x;\n\nconstraint forall(i,j in POINT where i < j /\\ x[i] = x[j])\n                 (dist[i,j] <= maxdiam);\n\nconstraint forall(i in 1..k-1)\n                 (  min([ j | j in POINT where x[j] = i])\n                  < min([ j | j in POINT where x[j] = i+1]));\n\nvar 0..maxdist: obj = min( i,j in POINT where i < j )\n                         ( dist[i,j] + maxdist * (x[i] != x[j]) );\n\ninclude \"value_precede_chain.mzn\";\nconstraint value_precede_chain([ i | i in 1..k ],x);\n\nsolve maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x)\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cluster_expert", "node_type": "4", "metadata": {"model_name": "cluster", "source_code": "int: n; % points to be clustered\nset of int: POINT = 1..n;\narray[POINT,POINT] of int: dist; % distance between two points\nint: maxdist = max([ dist[i,j] | i,j in POINT]);\n\n\nint: k; % number of clusters\nset of int: CLUSTER = 1..k;\n\nint: maxdiam;\n\narray[POINT] of var CLUSTER: x;\n\nconstraint forall(i,j in POINT where i < j /\\ x[i] = x[j])\n                 (dist[i,j] <= maxdiam);\n\nconstraint forall(i in 1..k-1)\n                 (  min([ j | j in POINT where x[j] = i])\n                  < min([ j | j in POINT where x[j] = i+1]));\n\nvar 0..maxdist: obj = min( i,j in POINT where i < j )\n                         ( dist[i,j] + maxdist * (x[i] != x[j]) );\n\ninclude \"value_precede_chain.mzn\";\nconstraint value_precede_chain([ i | i in 1..k ],x);\n\nsolve maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x)\\n\"];\n"}, "hash": "58132042875b8ac5184c4a69a4387fa2a774863ad3dbc0cc5cc5a39ee5a080fc", "class_name": "RelatedNodeInfo"}}, "text": "name: Capacitated Clustering Problem\n\ndescription: The Capacitated Clustering Problem is a classic problem in constraint programming that involves dividing a set of points into a fixed number of clusters, such that the maximum distance between any two points in the same cluster does not exceed a certain limit, and the clusters are ordered in a way that the points in each cluster are contiguous.\n\nvariables: x (array of variables, where x[i] represents the cluster assignment of point i)\n\nThe decision variables x represent the assignment of each point to a cluster.\n\nconstraints: \n\u2200i,j in POINT where i < j /\\ x[i] = x[j], dist[i,j] \u2264 maxdiam \n\u2200i in 1..k-1, min([ j | j in POINT where x[j] = i]) < min([ j | j in POINT where x[j] = i+1])\nvalue_precede_chain([ i | i in 1..k ],x)\n\nThe first constraint ensures that the distance between any two points in the same cluster does not exceed the maximum diameter. The second constraint ensures that the points in each cluster are contiguous, i.e., the points in cluster i are all less than the points in cluster i+1. The third constraint is a global constraint that ensures the same contiguity property.\n\nobjective: maximize obj = min( i,j in POINT where i < j ) ( dist[i,j] + maxdist * (x[i] != x[j]) )\n\nThe objective is to maximize the minimum distance between any two points in different clusters, while also penalizing the assignment of points to different clusters.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1417, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "53a3c95f-b618-4174-8956-8ed6c14ea2f9": {"__data__": {"id_": "53a3c95f-b618-4174-8956-8ed6c14ea2f9", "embedding": null, "metadata": {"model_name": "compatible_assignment", "source_code": "Model 1 :\n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(task);\nconstraint forall(w1, w2 in W)\n                 (task[w1] != m /\\ task[w2] = task[w1] + 1 ->\n                   compatible[w1,w2]);\n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ \"task = \\(task)\\n\" ] ;\n\n\nModel 2 : \n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\narray[T] of var opt W: worker;\n\nconstraint inverse(task,worker);\nconstraint forall(t in T where t mod m != 0)\n                 (compatible[worker[t],worker[t+1]]);\n           \n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ if fix(occurs(worker[t])) then show(worker[t]) else \" \" endif ++ \" \"\n       | t in T ] \n       ++ [ show(task), \"\\n\" ]\n       ;\n\npredicate inverse(array[int] of var opt int: f, array[int] of var opt int: g) = \n          forall(i in index_set(f), j in index_set(g))\n                (occurs(f[i]) /\\ occurs(g[j]) ->\n                 (deopt(f[i]) = j <-> deopt(g[j]) = i)); \n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "compatible_assignment_expert", "node_type": "4", "metadata": {"model_name": "compatible_assignment", "source_code": "Model 1 :\n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(task);\nconstraint forall(w1, w2 in W)\n                 (task[w1] != m /\\ task[w2] = task[w1] + 1 ->\n                   compatible[w1,w2]);\n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ \"task = \\(task)\\n\" ] ;\n\n\nModel 2 : \n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\narray[T] of var opt W: worker;\n\nconstraint inverse(task,worker);\nconstraint forall(t in T where t mod m != 0)\n                 (compatible[worker[t],worker[t+1]]);\n           \n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ if fix(occurs(worker[t])) then show(worker[t]) else \" \" endif ++ \" \"\n       | t in T ] \n       ++ [ show(task), \"\\n\" ]\n       ;\n\npredicate inverse(array[int] of var opt int: f, array[int] of var opt int: g) = \n          forall(i in index_set(f), j in index_set(g))\n                (occurs(f[i]) /\\ occurs(g[j]) ->\n                 (deopt(f[i]) = j <-> deopt(g[j]) = i)); \n"}, "hash": "a2a76e86790af8516abcf987354e7612216ca36b533ebc550f43ac4914220e5f", "class_name": "RelatedNodeInfo"}}, "text": "name: Task Scheduling Problem\n\ndescription: The Task Scheduling Problem is a classic problem in constraint programming where we have a set of tasks and a set of workers. Each task has a profit associated with it, and each worker can perform a subset of tasks. The problem is to assign tasks to workers such that the total profit is maximized, subject to certain constraints.\n\nvariables: task[w] (w \u2208 W), worker[t] (t \u2208 T)\nThe decision variables are task[w] which represents the task assigned to worker w, and worker[t] which represents the worker assigned to task t.\n\nconstraints: \nalldifferent(task), \n\u2200w1, w2 \u2208 W (task[w1] \u2260 m \u2227 task[w2] = task[w1] + 1 \u2192 compatible[w1, w2]), \ninverse(task, worker), \n\u2200t \u2208 T (t mod m \u2260 0 \u2192 compatible[worker[t], worker[t+1]])\n\nThe constraints are: \n- Each worker is assigned a unique task (alldifferent(task)).\n- If two tasks are assigned to two consecutive workers, then the tasks must be compatible (compatible[w1, w2]).\n- The inverse constraint ensures that each task is assigned to a unique worker and each worker is assigned a unique task (inverse(task, worker)).\n- If two tasks are consecutive, then the workers assigned to these tasks must be compatible (compatible[worker[t], worker[t+1]]).\n\nobjective: Maximize \u2211(w \u2208 W) profit[w, task[w]]\nThe objective is to maximize the total profit by assigning tasks to workers such that the profit of each task is maximized.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1406, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2c173bcc-99e8-4b1e-9bc5-c13286194d4f": {"__data__": {"id_": "2c173bcc-99e8-4b1e-9bc5-c13286194d4f", "embedding": null, "metadata": {"model_name": "constrained_connected", "source_code": "% constrained clustering \n% Pick a maximal subset of edges so that no two nodes\n% given by the pairs (first[i],second[i]) \n% are connected.\n\nint: n;\nset of int: NODE = 1..n;\nint: m;\nset of int: EDGE = 1..m;\narray[EDGE] of NODE: pre;\narray[EDGE] of NODE: suc;\nint: d;\nset of int: DPAIR = 1..d;\narray[DPAIR] of NODE: first;\narray[DPAIR] of NODE: second;\n\nvar set of EDGE: selected;\n% a representative for each cluster\narray[NODE] of var NODE: rep;\n\n%constraint forall(e in selected)\n%                 (rep[pre[e]] = rep[suc[e]]);\nconstraint forall(e in EDGE)\n                 (e in selected -> rep[pre[e]] = rep[suc[e]]);\n\nconstraint forall(d in DPAIR)\n                 (rep[first[d]] != rep[second[d]]);\n\nsolve maximize card(selected);\n\noutput [ \"(\" ++ show(pre[e]) ++ \",\" ++ show(suc[e]) ++ \")\\n\"\n       | e in fix(selected) ]\n       ++ [show(rep),\"\\n\"]\n       ;\n\n\n\n                 \n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "constrained_connected_expert", "node_type": "4", "metadata": {"model_name": "constrained_connected", "source_code": "% constrained clustering \n% Pick a maximal subset of edges so that no two nodes\n% given by the pairs (first[i],second[i]) \n% are connected.\n\nint: n;\nset of int: NODE = 1..n;\nint: m;\nset of int: EDGE = 1..m;\narray[EDGE] of NODE: pre;\narray[EDGE] of NODE: suc;\nint: d;\nset of int: DPAIR = 1..d;\narray[DPAIR] of NODE: first;\narray[DPAIR] of NODE: second;\n\nvar set of EDGE: selected;\n% a representative for each cluster\narray[NODE] of var NODE: rep;\n\n%constraint forall(e in selected)\n%                 (rep[pre[e]] = rep[suc[e]]);\nconstraint forall(e in EDGE)\n                 (e in selected -> rep[pre[e]] = rep[suc[e]]);\n\nconstraint forall(d in DPAIR)\n                 (rep[first[d]] != rep[second[d]]);\n\nsolve maximize card(selected);\n\noutput [ \"(\" ++ show(pre[e]) ++ \",\" ++ show(suc[e]) ++ \")\\n\"\n       | e in fix(selected) ]\n       ++ [show(rep),\"\\n\"]\n       ;\n\n\n\n                 \n"}, "hash": "48dfbafd40fd9951725110d05cdf74262ada9f7a2de45f3dec3672dfed14a377", "class_name": "RelatedNodeInfo"}}, "text": "name: Constrained Clustering\n\ndescription: The Constrained Clustering problem is a variant of the traditional clustering problem, where we want to group nodes into clusters such that no two nodes in the same cluster are connected by a forbidden edge. The goal is to find the maximum number of edges that can be included in the clustering while satisfying the constraints.\n\nvariables: selected \u2286 EDGE, rep: NODE \u2192 NODE\nThe decision variables are `selected`, a subset of edges that will be included in the clustering, and `rep`, a function that assigns a representative node to each node in the graph.\n\nconstraints: \u2200e \u2208 EDGE: e \u2208 selected \u2192 rep[pre[e]] = rep[suc[e]], \u2200d \u2208 DPAIR: rep[first[d]] \u2260 rep[second[d]]\nThe constraints ensure that if an edge is selected, its endpoints must have the same representative node, and that the representative nodes of nodes connected by a forbidden edge must be different.\n\nobjective: maximize |selected|\nThe objective is to maximize the number of edges included in the clustering.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1016, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "199261a2-7322-4010-80d0-1eb08304cc79": {"__data__": {"id_": "199261a2-7322-4010-80d0-1eb08304cc79", "embedding": null, "metadata": {"model_name": "crazy_sets", "source_code": "Model 1 :\n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m] of var set of NUMBER: s;\n\nconstraint forall(i,j,k in 1..m where i < j /\\ j < k)\n     ( s[i] intersect s[j] intersect s[k] = {} );\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\nconstraint forall(i in 1..m, o in NUMBER)\n      (o in s[i] \n       -> exists(j in 1..c)(x[i,j] = o));\nconstraint forall(i in 1..m, j in 1..c)(x[i,j] in s[i]);\n\nsolve satisfy;\n\noutput [show(s)];\n\nn = 10;\nc = 4;\nm = 4;\n\n\n\nModel 2 : \n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint global_cardinality_low_up( [ x[i,j] | i in 1..m, j in 1..c ],\n                              [ i | i in 1..n ],\n                              [ 0 | i in 1..n ],\n                              [ 2 | i in 1..n ]);\n\n\nsolve satisfy;\n\n   output [ if j = 1 then \"{\" else \"\" endif ++\n   show(x[i,j])\n   ++ if j = c then \"}\" else \", \" endif\n   ++ if j = c /\\ i < m then \", \" else \"\" endif\n   | i in 1..m, j in 1..c ];\n   \n\nn = 10;\nc = 4;\nm = 4;\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crazy_sets_expert", "node_type": "4", "metadata": {"model_name": "crazy_sets", "source_code": "Model 1 :\n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m] of var set of NUMBER: s;\n\nconstraint forall(i,j,k in 1..m where i < j /\\ j < k)\n     ( s[i] intersect s[j] intersect s[k] = {} );\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\nconstraint forall(i in 1..m, o in NUMBER)\n      (o in s[i] \n       -> exists(j in 1..c)(x[i,j] = o));\nconstraint forall(i in 1..m, j in 1..c)(x[i,j] in s[i]);\n\nsolve satisfy;\n\noutput [show(s)];\n\nn = 10;\nc = 4;\nm = 4;\n\n\n\nModel 2 : \n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint global_cardinality_low_up( [ x[i,j] | i in 1..m, j in 1..c ],\n                              [ i | i in 1..n ],\n                              [ 0 | i in 1..n ],\n                              [ 2 | i in 1..n ]);\n\n\nsolve satisfy;\n\n   output [ if j = 1 then \"{\" else \"\" endif ++\n   show(x[i,j])\n   ++ if j = c then \"}\" else \", \" endif\n   ++ if j = c /\\ i < m then \", \" else \"\" endif\n   | i in 1..m, j in 1..c ];\n   \n\nn = 10;\nc = 4;\nm = 4;\n"}, "hash": "3b1868c9d818028ce82f35475a06185856ece6a8fb6fb45f13f1734080232f3e", "class_name": "RelatedNodeInfo"}}, "text": "name: Error-Correcting Code Design\n\ndescription: The problem of Error-Correcting Code Design involves designing a set of codes such that any three codes have no element in common. This problem is a classic problem in constraint programming and is used in various applications such as coding theory and data storage.\n\nvariables: s[i], x[i,j]\n\nThe decision variables are s[i] which represents the i-th set of codes, and x[i,j] which represents the j-th element of the i-th set.\n\nconstraints: \ns[i] intersect s[j] intersect s[k] = {}, \nx[i,j] < x[i,j+1], \nx[i,j] < x[i+1,j], \no in s[i] -> exists(j in 1..c)(x[i,j] = o), \nx[i,j] in s[i]\n\nThe constraints ensure that any three sets have no element in common, the elements in each set are in increasing order, and the elements in each set are distinct. The last two constraints ensure that the x[i,j] variables are correctly assigned to the sets s[i].\n\nobjective: satisfy\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, i.e., to design a set of codes such that any three codes have no element in common.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1096, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b767ffc8-a765-4afe-9cd9-dff54c5ff537": {"__data__": {"id_": "b767ffc8-a765-4afe-9cd9-dff54c5ff537", "embedding": null, "metadata": {"model_name": "crossfigure", "source_code": "% Crossfigure problem in MiniZinc.\n% \"\"\"\n% Crossfigures are the numerical equivalent of crosswords. You have a grid and some\n% clues with numerical answers to place on this grid. Clues come in several different\n% forms (for example: Across 1. 25 across times two, 2. five dozen, 5. a square number,\n% 10. prime, 14. 29 across times 21 down ...).\n% \"\"\"\n\n\nint: n = 9;\narray[1..n, 1..n] of var 0..9: M;\n\nset of int: D = 0..9999; % the max length of the numbers in this problem is 4\nvar D: A1;\nvar D: A4;\nvar D: A7;\nvar D: A8;\nvar D: A9;\nvar D: A10;\nvar D: A11;\nvar D: A13;\nvar D: A15;\nvar D: A17;\nvar D: A20;\nvar D: A23;\nvar D: A24;\nvar D: A25;\nvar D: A27;\nvar D: A28;\nvar D: A29;\nvar D: A30;\n\nvar D: D1;\nvar D: D2;\nvar D: D3;\nvar D: D4;\nvar D: D5;\nvar D: D6;\nvar D: D10;\nvar D: D12;\nvar D: D14;\nvar D: D16;\nvar D: D17;\nvar D: D18;\nvar D: D19;\nvar D: D20;\nvar D: D21;\nvar D: D22;\nvar D: D26;\nvar D: D28;\n\n\n%\n% across(Matrix, Across, Len, Row, Col)\n%\tConstrains 'Across' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding across.\n%\npredicate across(array[int, int] of var D: Matrix, var D: Across, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Across)\n   /\\\n   forall(i in 0..Len-1) (\n\n       Matrix[Row,Col+i] = tmp[i+1]\n   )\n;\n\n%\n% down(Matrix, Down, Len, Row, Col):\n%\tConstrains 'Down' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding down.\n%\npredicate down(array[int,int] of var D: Matrix, var D: Down, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Down)\n   /\\\n   forall(i in 0..Len-1) (\n      Matrix[Row+i,Col] = tmp[i+1]\n   )\n;\n\n\n%\n% converts a number <-> array\n%\npredicate toNum10(array[int] of var D: a, var D: n) =\n          let { int: len = length(a) }\n          in\n          n = sum(i in 1..len) (\n            ceil(pow(10.0, int2float(len-i))) * a[i]\n          )\n          /\\ forall(i in 1..len) (a[i] >= 0)\n;\n\n\n%\n% x is a square\n% \npredicate square(var D: x) =\n   exists(y in D) (\n      y*y = x\n   )\n;\n\n\n%\n% very simple primality test\n%\npredicate is_prime(var int: x) =\n   forall(i in 2..ceil(sqrt(9999.0))) ( \n        (i < x) -> (x mod i > 0)\n   )\n;\n\n\nsolve :: int_search(\n         [M[i,j] | i,j in 1..n] ++\n         [A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n         D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28],\n         occurrence,\n         indomain_min,\n         complete\n         ) \n     satisfy;\n\n\nconstraint\n\n   % Set up the constraints between the matrix elements and the\n   % clue numbers.\n   across(M, A1, 4, 1, 1)  /\\ \n   across(M, A4, 4, 1, 6)  /\\ \n   across(M, A7, 2, 2, 1)  /\\ \n   across(M, A8, 3, 2, 4)  /\\ \n   across(M, A9, 2, 2, 8)  /\\ \n   across(M, A10, 2, 3, 3) /\\ \n   across(M, A11, 2, 3, 6) /\\ \n   across(M, A13, 4, 4, 1) /\\ \n   across(M, A15, 4, 4, 6) /\\ \n   across(M, A17, 4, 6, 1) /\\ \n   across(M, A20, 4, 6, 6) /\\ \n   across(M, A23, 2, 7, 3) /\\ \n   across(M, A24, 2, 7, 6) /\\ \n   across(M, A25, 2, 8, 1) /\\ \n   across(M, A27, 3, 8, 4) /\\ \n   across(M, A28, 2, 8, 8) /\\ \n   across(M, A29, 4, 9, 1) /\\ \n   across(M, A30, 4, 9, 6) /\\ \n\n   down(M, D1, 4, 1, 1)  /\\ \n   down(M, D2, 2, 1, 2)  /\\ \n   down(M, D3, 4, 1, 4)  /\\ \n   down(M, D4, 4, 1, 6)  /\\ \n   down(M, D5, 2, 1, 8)  /\\ \n   down(M, D6, 4, 1, 9)  /\\ \n   down(M, D10, 2, 3, 3) /\\ \n   down(M, D12, 2, 3, 7) /\\ \n   down(M, D14, 3, 4, 2) /\\ \n   down(M, D16, 3, 4, 8) /\\ \n   down(M, D17, 4, 6, 1) /\\ \n   down(M, D18, 2, 6, 3) /\\ \n   down(M, D19, 4, 6, 4) /\\ \n   down(M, D20, 4, 6, 6) /\\ \n   down(M, D21, 2, 6, 7) /\\ \n   down(M, D22, 4, 6, 9) /\\ \n   down(M, D26, 2, 8, 2) /\\ \n   down(M, D28, 2, 8, 8) /\\ \n\n\n   % Set up the clue constraints.\n%  Across\n%  1 27 across times two\n%  4 4 down plus seventy-one\n%  7 18 down plus four\n%  8 6 down divided by sixteen\n%  9 2 down minus eighteen\n% 10 Dozen in six gross\n% 11 5 down minus seventy\n% 13 26 down times 23 across\n% 15 6 down minus 350\n% 17 25 across times 23 across\n% 20 A square number\n% 23 A prime number\n% 24 A square number\n% 25 20 across divided by seventeen\n% 27 6 down divided by four\n% 28 Four dozen\n% 29 Seven gross\n% 30 22 down plus 450 \n\n   A1 = 2 * A27         /\\ \n   A4 = D4 + 71         /\\ \n   A7 = D18 + 4         /\\ \n   A8 = D6 div 16       /\\ \n   A9 = D2 - 18         /\\ \n   A10 = 6 * 144 div 12 /\\ \n   A11 = D5 - 70        /\\ \n   A13 = D26 * A23      /\\ \n   A15 = D6 - 350       /\\ \n   A17 = A25 * A23      /\\ \n   square(A20)          /\\ \n   is_prime(A23)        /\\\n   square(A24)          /\\ \n   A25 = A20 div 17     /\\ \n   A27 = D6 div 4       /\\ \n   A28 = 4 * 12         /\\ \n   A29 = 7 * 144        /\\ \n   A30 = D22 + 450      /\\ \n\n   % Down\n   %\n   %  1 1 across plus twenty-seven\n   %  2 Five dozen\n   %  3 30 across plus 888\n   %  4 Two times 17 across\n   %  5 29 across divided by twelve\n   %  6 28 across times 23 across\n   % 10 10 across plus four\n   % 12 Three times 24 across\n   % 14 13 across divided by sixteen\n   % 16 28 down times fifteen\n   % 17 13 across minus 399\n   % 18 29 across divided by eighteen\n   % 19 22 down minus ninety-four\n   % 20 20 across minus nine\n   % 21 25 across minus fifty-two\n   % 22 20 down times six\n   % 26 Five times 24 across\n   % 28 21 down plus twenty-seven \n\n   D1 = A1 + 27     /\\ \n   D2 = 5 * 12      /\\ \n   D3 = A30 + 888   /\\ \n   D4 = 2 * A17     /\\ \n   D5 = A29 div 12  /\\ \n   D6 = A28 * A23   /\\ \n   D10 = A10 + 4    /\\ \n   D12 = A24 * 3    /\\ \n   D14 = A13 div 16 /\\ \n   D16 = 15 * D28   /\\ \n   D17 = A13 - 399  /\\ \n   D18 = A29 div 18 /\\ \n   D19 = D22 - 94   /\\ \n   D20 = A20 - 9    /\\ \n   D21 = A25 - 52   /\\ \n   D22 = 6 * D20    /\\ \n   D26 = 5 * A24    /\\ \n   D28 = D21 + 27\n\n\n   % Fix the blackboxes\n   /\\\n   M[1,5] = 0 /\\\n   M[2,3] = 0 /\\\n   M[2,7] = 0 /\\\n   M[3,2] = 0 /\\\n   M[3,5] = 0 /\\\n   M[3,8] = 0 /\\\n   M[4,5] = 0 /\\\n   M[5,1] = 0 /\\\n   M[5,3] = 0 /\\\n   M[5,4] = 0 /\\\n   M[5,5] = 0 /\\\n   M[5,6] = 0 /\\\n   M[5,7] = 0 /\\\n   M[5,9] = 0 /\\\n   M[6,5] = 0 /\\\n   M[7,2] = 0 /\\\n   M[7,5] = 0 /\\\n   M[7,8] = 0 /\\\n   M[8,3] = 0 /\\\n   M[8,7] = 0 /\\\n   M[9,5] = 0\n;\n\n\noutput [\n show([A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n       D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28]), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(M[i,j])\n  | i,j  in 1..n\n] ++ [\"\\n\"];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crossfigure_expert", "node_type": "4", "metadata": {"model_name": "crossfigure", "source_code": "% Crossfigure problem in MiniZinc.\n% \"\"\"\n% Crossfigures are the numerical equivalent of crosswords. You have a grid and some\n% clues with numerical answers to place on this grid. Clues come in several different\n% forms (for example: Across 1. 25 across times two, 2. five dozen, 5. a square number,\n% 10. prime, 14. 29 across times 21 down ...).\n% \"\"\"\n\n\nint: n = 9;\narray[1..n, 1..n] of var 0..9: M;\n\nset of int: D = 0..9999; % the max length of the numbers in this problem is 4\nvar D: A1;\nvar D: A4;\nvar D: A7;\nvar D: A8;\nvar D: A9;\nvar D: A10;\nvar D: A11;\nvar D: A13;\nvar D: A15;\nvar D: A17;\nvar D: A20;\nvar D: A23;\nvar D: A24;\nvar D: A25;\nvar D: A27;\nvar D: A28;\nvar D: A29;\nvar D: A30;\n\nvar D: D1;\nvar D: D2;\nvar D: D3;\nvar D: D4;\nvar D: D5;\nvar D: D6;\nvar D: D10;\nvar D: D12;\nvar D: D14;\nvar D: D16;\nvar D: D17;\nvar D: D18;\nvar D: D19;\nvar D: D20;\nvar D: D21;\nvar D: D22;\nvar D: D26;\nvar D: D28;\n\n\n%\n% across(Matrix, Across, Len, Row, Col)\n%\tConstrains 'Across' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding across.\n%\npredicate across(array[int, int] of var D: Matrix, var D: Across, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Across)\n   /\\\n   forall(i in 0..Len-1) (\n\n       Matrix[Row,Col+i] = tmp[i+1]\n   )\n;\n\n%\n% down(Matrix, Down, Len, Row, Col):\n%\tConstrains 'Down' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding down.\n%\npredicate down(array[int,int] of var D: Matrix, var D: Down, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Down)\n   /\\\n   forall(i in 0..Len-1) (\n      Matrix[Row+i,Col] = tmp[i+1]\n   )\n;\n\n\n%\n% converts a number <-> array\n%\npredicate toNum10(array[int] of var D: a, var D: n) =\n          let { int: len = length(a) }\n          in\n          n = sum(i in 1..len) (\n            ceil(pow(10.0, int2float(len-i))) * a[i]\n          )\n          /\\ forall(i in 1..len) (a[i] >= 0)\n;\n\n\n%\n% x is a square\n% \npredicate square(var D: x) =\n   exists(y in D) (\n      y*y = x\n   )\n;\n\n\n%\n% very simple primality test\n%\npredicate is_prime(var int: x) =\n   forall(i in 2..ceil(sqrt(9999.0))) ( \n        (i < x) -> (x mod i > 0)\n   )\n;\n\n\nsolve :: int_search(\n         [M[i,j] | i,j in 1..n] ++\n         [A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n         D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28],\n         occurrence,\n         indomain_min,\n         complete\n         ) \n     satisfy;\n\n\nconstraint\n\n   % Set up the constraints between the matrix elements and the\n   % clue numbers.\n   across(M, A1, 4, 1, 1)  /\\ \n   across(M, A4, 4, 1, 6)  /\\ \n   across(M, A7, 2, 2, 1)  /\\ \n   across(M, A8, 3, 2, 4)  /\\ \n   across(M, A9, 2, 2, 8)  /\\ \n   across(M, A10, 2, 3, 3) /\\ \n   across(M, A11, 2, 3, 6) /\\ \n   across(M, A13, 4, 4, 1) /\\ \n   across(M, A15, 4, 4, 6) /\\ \n   across(M, A17, 4, 6, 1) /\\ \n   across(M, A20, 4, 6, 6) /\\ \n   across(M, A23, 2, 7, 3) /\\ \n   across(M, A24, 2, 7, 6) /\\ \n   across(M, A25, 2, 8, 1) /\\ \n   across(M, A27, 3, 8, 4) /\\ \n   across(M, A28, 2, 8, 8) /\\ \n   across(M, A29, 4, 9, 1) /\\ \n   across(M, A30, 4, 9, 6) /\\ \n\n   down(M, D1, 4, 1, 1)  /\\ \n   down(M, D2, 2, 1, 2)  /\\ \n   down(M, D3, 4, 1, 4)  /\\ \n   down(M, D4, 4, 1, 6)  /\\ \n   down(M, D5, 2, 1, 8)  /\\ \n   down(M, D6, 4, 1, 9)  /\\ \n   down(M, D10, 2, 3, 3) /\\ \n   down(M, D12, 2, 3, 7) /\\ \n   down(M, D14, 3, 4, 2) /\\ \n   down(M, D16, 3, 4, 8) /\\ \n   down(M, D17, 4, 6, 1) /\\ \n   down(M, D18, 2, 6, 3) /\\ \n   down(M, D19, 4, 6, 4) /\\ \n   down(M, D20, 4, 6, 6) /\\ \n   down(M, D21, 2, 6, 7) /\\ \n   down(M, D22, 4, 6, 9) /\\ \n   down(M, D26, 2, 8, 2) /\\ \n   down(M, D28, 2, 8, 8) /\\ \n\n\n   % Set up the clue constraints.\n%  Across\n%  1 27 across times two\n%  4 4 down plus seventy-one\n%  7 18 down plus four\n%  8 6 down divided by sixteen\n%  9 2 down minus eighteen\n% 10 Dozen in six gross\n% 11 5 down minus seventy\n% 13 26 down times 23 across\n% 15 6 down minus 350\n% 17 25 across times 23 across\n% 20 A square number\n% 23 A prime number\n% 24 A square number\n% 25 20 across divided by seventeen\n% 27 6 down divided by four\n% 28 Four dozen\n% 29 Seven gross\n% 30 22 down plus 450 \n\n   A1 = 2 * A27         /\\ \n   A4 = D4 + 71         /\\ \n   A7 = D18 + 4         /\\ \n   A8 = D6 div 16       /\\ \n   A9 = D2 - 18         /\\ \n   A10 = 6 * 144 div 12 /\\ \n   A11 = D5 - 70        /\\ \n   A13 = D26 * A23      /\\ \n   A15 = D6 - 350       /\\ \n   A17 = A25 * A23      /\\ \n   square(A20)          /\\ \n   is_prime(A23)        /\\\n   square(A24)          /\\ \n   A25 = A20 div 17     /\\ \n   A27 = D6 div 4       /\\ \n   A28 = 4 * 12         /\\ \n   A29 = 7 * 144        /\\ \n   A30 = D22 + 450      /\\ \n\n   % Down\n   %\n   %  1 1 across plus twenty-seven\n   %  2 Five dozen\n   %  3 30 across plus 888\n   %  4 Two times 17 across\n   %  5 29 across divided by twelve\n   %  6 28 across times 23 across\n   % 10 10 across plus four\n   % 12 Three times 24 across\n   % 14 13 across divided by sixteen\n   % 16 28 down times fifteen\n   % 17 13 across minus 399\n   % 18 29 across divided by eighteen\n   % 19 22 down minus ninety-four\n   % 20 20 across minus nine\n   % 21 25 across minus fifty-two\n   % 22 20 down times six\n   % 26 Five times 24 across\n   % 28 21 down plus twenty-seven \n\n   D1 = A1 + 27     /\\ \n   D2 = 5 * 12      /\\ \n   D3 = A30 + 888   /\\ \n   D4 = 2 * A17     /\\ \n   D5 = A29 div 12  /\\ \n   D6 = A28 * A23   /\\ \n   D10 = A10 + 4    /\\ \n   D12 = A24 * 3    /\\ \n   D14 = A13 div 16 /\\ \n   D16 = 15 * D28   /\\ \n   D17 = A13 - 399  /\\ \n   D18 = A29 div 18 /\\ \n   D19 = D22 - 94   /\\ \n   D20 = A20 - 9    /\\ \n   D21 = A25 - 52   /\\ \n   D22 = 6 * D20    /\\ \n   D26 = 5 * A24    /\\ \n   D28 = D21 + 27\n\n\n   % Fix the blackboxes\n   /\\\n   M[1,5] = 0 /\\\n   M[2,3] = 0 /\\\n   M[2,7] = 0 /\\\n   M[3,2] = 0 /\\\n   M[3,5] = 0 /\\\n   M[3,8] = 0 /\\\n   M[4,5] = 0 /\\\n   M[5,1] = 0 /\\\n   M[5,3] = 0 /\\\n   M[5,4] = 0 /\\\n   M[5,5] = 0 /\\\n   M[5,6] = 0 /\\\n   M[5,7] = 0 /\\\n   M[5,9] = 0 /\\\n   M[6,5] = 0 /\\\n   M[7,2] = 0 /\\\n   M[7,5] = 0 /\\\n   M[7,8] = 0 /\\\n   M[8,3] = 0 /\\\n   M[8,7] = 0 /\\\n   M[9,5] = 0\n;\n\n\noutput [\n show([A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n       D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28]), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(M[i,j])\n  | i,j  in 1..n\n] ++ [\"\\n\"];"}, "hash": "b30921bab914c1f9c661e419e48dac6803b8e7a1860d5206cbe7e6c51620e23a", "class_name": "RelatedNodeInfo"}}, "text": "name: Crossfigure Problem\n\ndescription: The Crossfigure problem is a numerical puzzle where a 9x9 grid is filled with numbers such that each row, column, and some predefined regions satisfy certain numerical clues. The clues are given in the form of arithmetic operations and comparisons involving the numbers in the grid.\n\nvariables: M[i,j] (i, j = 1..9), A1, A4, ..., A30, D1, D2, ..., D28\n\nThe variables M[i,j] represent the numbers in the 9x9 grid. The variables A1, A4, ..., A30 and D1, D2, ..., D28 represent the numerical answers to the clues, which are placed horizontally (Across) and vertically (Down) in the grid, respectively.\n\nconstraints: \nacross(M, A1, 4, 1, 1) /\\ ... /\\ down(M, D28, 2, 8, 8) /\\ \nA1 = 2 * A27 /\\ ... /\\ D28 = D21 + 27 /\\ \nM[1,5] = 0 /\\ ... /\\ M[9,5] = 0\n\nThe constraints can be divided into three categories: \n1. The across and down predicates, which ensure that the numbers in the grid are correctly placed to form the numerical answers to the clues.\n2. The clue constraints, which define the relationships between the numerical answers, such as arithmetic operations and comparisons.\n3. The blackbox constraints, which fix certain cells in the grid to be zero.\n\nobjective: The objective of the problem is to find a feasible solution that satisfies all the constraints, i.e., to fill the grid with numbers such that all the clues are satisfied. There is no objective function to minimize or maximize.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1434, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d6583452-c1ae-47bb-8007-d69624a5ac5a": {"__data__": {"id_": "d6583452-c1ae-47bb-8007-d69624a5ac5a", "embedding": null, "metadata": {"model_name": "curriculum", "source_code": "% The balanced academic curriculum problem:\n%\n% A curriculum is a set of courses with prerequisites.\n% Each course must be assigned within a set number of periods.\n% A course cannot be scheduled before its prerequisites.\n% Each course confers a number of academic credits (it's \"load\").\n% Students have lower and upper bounds on the number of credits they can study for in a given period.\n% Students have lower and upper bounds on the number of courses they can study for in a given period.\n% The goal is to assign a period to every course satisfying these criteria, minimising the load for all periods.\n\ninclude \"globals.mzn\";\n\nint: n_courses;\nint: n_periods;\nint: load_per_period_lb;\nint: load_per_period_ub;\nint: courses_per_period_lb;\nint: courses_per_period_ub;\narray [1..n_courses] of int: course_load;\nint: max_course_load = sum(c in courses)(course_load[c]);\n\nset of int: courses = 1..n_courses;\nset of int: periods = 1..n_periods;\n\n% period course is assigned to\narray [courses] of var periods: course_period;\n% whether period i has course j assigned\narray [periods, courses] of var 0..1: x;\n% total load for each period\narray [periods] of var load_per_period_lb..load_per_period_ub: load;\n% optimisation target\nvar load_per_period_lb..load_per_period_ub: objective;\n\nconstraint forall(p in periods) (\n    forall(c in courses) (x[p,c] = bool2int(course_period[c] = p)) /\\\n    sum(i in courses) (x[p,i]) >= courses_per_period_lb /\\\n    sum(i in courses) (x[p,i]) <= courses_per_period_ub /\\\n    load[p] = sum(c in courses) (x[p,c] * course_load[c]) /\\\n    load[p] >= load_per_period_lb /\\\n    load[p] <= objective\n);\n\n% prerequisite(a, b) means \"course a has prerequisite course b\".\n\npredicate prerequisite(courses: a, courses: b) =\n    course_period[b] < course_period[a];\n\n% add some redundant linear constraints\n\nconstraint forall(p in 0..n_periods-1) (\n    let {\n\t\tvar 0..max_course_load: l = sum(c in courses) (bool2int(course_period[c] > p) * course_load[c])\n\t} in \n        l >= (n_periods-p) * load_per_period_lb /\\\n        l <= (n_periods-p) * objective\n    );\n\nsolve :: seq_search([\n      int_search([x[i,j] | i in periods, j in courses], input_order, indomain_max, complete),\n      int_search([objective], input_order, indomain_min, complete)\n    ]) minimize objective;\n\noutput \n    [show(c) ++ \"-\" ++ show(course_period[c]) ++ \"\\t\" | c in courses ] ++ [\"\\n\"] ++\n    [\"objective = \", show(objective)];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "curriculum_expert", "node_type": "4", "metadata": {"model_name": "curriculum", "source_code": "% The balanced academic curriculum problem:\n%\n% A curriculum is a set of courses with prerequisites.\n% Each course must be assigned within a set number of periods.\n% A course cannot be scheduled before its prerequisites.\n% Each course confers a number of academic credits (it's \"load\").\n% Students have lower and upper bounds on the number of credits they can study for in a given period.\n% Students have lower and upper bounds on the number of courses they can study for in a given period.\n% The goal is to assign a period to every course satisfying these criteria, minimising the load for all periods.\n\ninclude \"globals.mzn\";\n\nint: n_courses;\nint: n_periods;\nint: load_per_period_lb;\nint: load_per_period_ub;\nint: courses_per_period_lb;\nint: courses_per_period_ub;\narray [1..n_courses] of int: course_load;\nint: max_course_load = sum(c in courses)(course_load[c]);\n\nset of int: courses = 1..n_courses;\nset of int: periods = 1..n_periods;\n\n% period course is assigned to\narray [courses] of var periods: course_period;\n% whether period i has course j assigned\narray [periods, courses] of var 0..1: x;\n% total load for each period\narray [periods] of var load_per_period_lb..load_per_period_ub: load;\n% optimisation target\nvar load_per_period_lb..load_per_period_ub: objective;\n\nconstraint forall(p in periods) (\n    forall(c in courses) (x[p,c] = bool2int(course_period[c] = p)) /\\\n    sum(i in courses) (x[p,i]) >= courses_per_period_lb /\\\n    sum(i in courses) (x[p,i]) <= courses_per_period_ub /\\\n    load[p] = sum(c in courses) (x[p,c] * course_load[c]) /\\\n    load[p] >= load_per_period_lb /\\\n    load[p] <= objective\n);\n\n% prerequisite(a, b) means \"course a has prerequisite course b\".\n\npredicate prerequisite(courses: a, courses: b) =\n    course_period[b] < course_period[a];\n\n% add some redundant linear constraints\n\nconstraint forall(p in 0..n_periods-1) (\n    let {\n\t\tvar 0..max_course_load: l = sum(c in courses) (bool2int(course_period[c] > p) * course_load[c])\n\t} in \n        l >= (n_periods-p) * load_per_period_lb /\\\n        l <= (n_periods-p) * objective\n    );\n\nsolve :: seq_search([\n      int_search([x[i,j] | i in periods, j in courses], input_order, indomain_max, complete),\n      int_search([objective], input_order, indomain_min, complete)\n    ]) minimize objective;\n\noutput \n    [show(c) ++ \"-\" ++ show(course_period[c]) ++ \"\\t\" | c in courses ] ++ [\"\\n\"] ++\n    [\"objective = \", show(objective)];\n"}, "hash": "e0a326f98ff30cdb92b3a155fca3ea06f010fe59159cf515acb1497af00a15f7", "class_name": "RelatedNodeInfo"}}, "text": "name: Balanced Academic Curriculum Problem\n\ndescription: The Balanced Academic Curriculum Problem is a classic constraint programming problem that involves assigning courses to periods in a curriculum while satisfying various constraints. Each course has a certain load (number of credits) and prerequisites, and students have limits on the number of credits and courses they can take in a period. The goal is to assign courses to periods such that the total load in each period is minimized.\n\nvariables: $course_period[c] \\in \\{1, ..., n_periods\\} \\forall c \\in courses, x[p, c] \\in \\{0, 1\\} \\forall p \\in periods, c \\in courses, load[p] \\in [load_per_period_lb, load_per_period_ub] \\forall p \\in periods, objective \\in [load_per_period_lb, load_per_period_ub]$\n\nThe decision variables are: \n- $course_period[c]$ represents the period to which course $c$ is assigned.\n- $x[p, c]$ is a binary variable indicating whether course $c$ is assigned to period $p$.\n- $load[p]$ represents the total load (number of credits) in period $p$.\n- $objective$ is the minimum total load across all periods.\n\nconstraints: \n$course_period[c] = p \\Leftrightarrow x[p, c] = 1 \\forall p \\in periods, c \\in courses$\n$\\sum_{i \\in courses} x[p, i] \\geq courses_per_period_lb \\forall p \\in periods$\n$\\sum_{i \\in courses} x[p, i] \\leq courses_per_period_ub \\forall p \\in periods$\n$load[p] = \\sum_{c \\in courses} x[p, c] * course_load[c] \\forall p \\in periods$\n$load[p] \\geq load_per_period_lb \\forall p \\in periods$\n$load[p] \\leq objective \\forall p \\in periods$\n$course_period[b] < course_period[a] \\forall a, b \\in courses : prerequisite(a, b)$\n$l \\geq (n_periods - p) * load_per_period_lb \\forall p \\in 0..n_periods-1$\n$l \\leq (n_periods - p) * objective \\forall p \\in 0..n_periods-1$\n\nThe constraints are:\n- Each course is assigned to exactly one period.\n- The number of courses in each period is within the bounds.\n- The total load in each period is calculated correctly.\n- The total load in each period is within the bounds.\n- The load in each period is less than or equal to the objective.\n- Courses are assigned to periods respecting their prerequisites.\n- Redundant linear constraints to help the solver.\n\nobjective: Minimize $objective$, which represents the minimum total load across all periods.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2282, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "91c10eba-9129-40a8-90c9-95bc4caac302": {"__data__": {"id_": "91c10eba-9129-40a8-90c9-95bc4caac302", "embedding": null, "metadata": {"model_name": "diamond_free_degree_sequence", "source_code": "%\n% Diamond-free Degree Sequence (CSPLib #50) in MiniZinc.\n%\n% Given a simple undirected graph G=(V,E), where V is the set of vertices and E the set of\n% undirected edges, the edge {u,v} is in E if and only if vertex u is adjacent to vertex v\u2208G.\n% The graph is simple in that there are no loop edges, i.e. we have no edges of the form {v,v}.\n% Each vertex v\u2208V has a degree dv i.e. the number of edges incident on that vertex. Consequently\n% a graph has a degree sequence d1,\u2026,dn, where di>=di+1. A diamond is a set of four vertices\n% in V such that there are at least five edges between those vertices. Conversely, a graph is\n% diamond-free if it has no diamond as an induced subgraph, i.e. for every set of four vertices\n% the number of edges between those vertices is at most four.\n%\n% In our problem we have additional properties required of the degree sequences of the graphs,\n% in particular that the degree of each vertex is greater than zero (i.e. isolated vertices\n% are disallowed), the degree of each vertex is modulo 3, and the sum of the degrees is\n% modulo 12 (i.e. |E| is modulo 6).\n%\n% The problem is then for a given value of n, produce all unique degree sequences d1,\u2026,dn such\n% that\n%\n%  * di\u2265di+1\n%  * each degree di>0 and di is modulo 3\n%  * the sum of the degrees is modulo 12\n%  * there exists a simple diamond-free graph with that degree sequence\n\n\ninclude \"globals.mzn\"; \n\nint: n = 11;\n\n% decision variables\narray[1..n,1..n] of var 0..1: x;\narray[1..n] of var 1..n: degrees;\n\n\n% solve satisfy;\nsolve :: int_search(degrees, first_fail, indomain_split, complete) satisfy;\n\nconstraint\n  forall(i,j,k,l in 1..n where i < j /\\ j < k /\\ k < l) (\n     x[i,j] + x[i,k] + x[i,l] + x[j,k] + x[j,l] + x[k,l] <= 4\n  )\n  /\\\n  forall(i in 1..n) (\n     degrees[i] = sum([x[i,j] | j in 1..n])\n     /\\ degrees[i] mod 3 = 0\n     % no loops\n     /\\ x[i,i] = 0\n  ) \n  /\\ % undirected graph\n  forall(i,j in 1..n) (\n    x[i,j] = x[j,i]\n  )\n  /\\ sum(degrees) mod 12 = 0\n\n  % symmetry breaking\n  /\\ decreasing(degrees)\n  /\\ lex2(x)\n;\n\noutput \n[ \"degrees: \", show(degrees), \"\\n\"]\n% ++\n% [\n%   if j = 1 then \"\\n\" else \" \" endif ++\n%     show(x[i,j])\n%   | i,j in 1..n\n% ]\n;\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "diamond_free_degree_sequence_expert", "node_type": "4", "metadata": {"model_name": "diamond_free_degree_sequence", "source_code": "%\n% Diamond-free Degree Sequence (CSPLib #50) in MiniZinc.\n%\n% Given a simple undirected graph G=(V,E), where V is the set of vertices and E the set of\n% undirected edges, the edge {u,v} is in E if and only if vertex u is adjacent to vertex v\u2208G.\n% The graph is simple in that there are no loop edges, i.e. we have no edges of the form {v,v}.\n% Each vertex v\u2208V has a degree dv i.e. the number of edges incident on that vertex. Consequently\n% a graph has a degree sequence d1,\u2026,dn, where di>=di+1. A diamond is a set of four vertices\n% in V such that there are at least five edges between those vertices. Conversely, a graph is\n% diamond-free if it has no diamond as an induced subgraph, i.e. for every set of four vertices\n% the number of edges between those vertices is at most four.\n%\n% In our problem we have additional properties required of the degree sequences of the graphs,\n% in particular that the degree of each vertex is greater than zero (i.e. isolated vertices\n% are disallowed), the degree of each vertex is modulo 3, and the sum of the degrees is\n% modulo 12 (i.e. |E| is modulo 6).\n%\n% The problem is then for a given value of n, produce all unique degree sequences d1,\u2026,dn such\n% that\n%\n%  * di\u2265di+1\n%  * each degree di>0 and di is modulo 3\n%  * the sum of the degrees is modulo 12\n%  * there exists a simple diamond-free graph with that degree sequence\n\n\ninclude \"globals.mzn\"; \n\nint: n = 11;\n\n% decision variables\narray[1..n,1..n] of var 0..1: x;\narray[1..n] of var 1..n: degrees;\n\n\n% solve satisfy;\nsolve :: int_search(degrees, first_fail, indomain_split, complete) satisfy;\n\nconstraint\n  forall(i,j,k,l in 1..n where i < j /\\ j < k /\\ k < l) (\n     x[i,j] + x[i,k] + x[i,l] + x[j,k] + x[j,l] + x[k,l] <= 4\n  )\n  /\\\n  forall(i in 1..n) (\n     degrees[i] = sum([x[i,j] | j in 1..n])\n     /\\ degrees[i] mod 3 = 0\n     % no loops\n     /\\ x[i,i] = 0\n  ) \n  /\\ % undirected graph\n  forall(i,j in 1..n) (\n    x[i,j] = x[j,i]\n  )\n  /\\ sum(degrees) mod 12 = 0\n\n  % symmetry breaking\n  /\\ decreasing(degrees)\n  /\\ lex2(x)\n;\n\noutput \n[ \"degrees: \", show(degrees), \"\\n\"]\n% ++\n% [\n%   if j = 1 then \"\\n\" else \" \" endif ++\n%     show(x[i,j])\n%   | i,j in 1..n\n% ]\n;\n\n"}, "hash": "e94886e26ef28e959e2820a39fc86cab1d1af794156ca911a80d55a7c3e7b4e2", "class_name": "RelatedNodeInfo"}}, "text": "name: Diamond-free Degree Sequence\n\ndescription: The Diamond-free Degree Sequence problem is a constraint satisfaction problem that involves finding all unique degree sequences of a simple, undirected, and diamond-free graph. A diamond-free graph is a graph that does not contain a diamond subgraph, which is a set of four vertices with at least five edges between them. The problem requires that each vertex has a degree greater than zero, the degree of each vertex is a multiple of 3, and the sum of the degrees is a multiple of 12.\n\nvariables: x[i,j], degrees[i]\n\nThe decision variables are x[i,j], which represents the adjacency matrix of the graph, where x[i,j] = 1 if there is an edge between vertices i and j, and x[i,j] = 0 otherwise. The variables degrees[i] represent the degree of each vertex i, which is the number of edges incident on that vertex.\n\nconstraints: \nx[i,j] + x[i,k] + x[i,l] + x[j,k] + x[j,l] + x[k,l] <= 4, \ndegrees[i] = sum([x[i,j] | j in 1..n]), \ndegrees[i] mod 3 = 0, \nx[i,i] = 0, \nx[i,j] = x[j,i], \nsum(degrees) mod 12 = 0, \ndecreasing(degrees), \nlex2(x)\n\nThe constraints ensure that the graph is diamond-free, each vertex has a degree greater than zero and a multiple of 3, the sum of the degrees is a multiple of 12, and the graph is undirected. The symmetry breaking constraints decreasing(degrees) and lex2(x) are used to reduce the number of symmetric solutions.\n\nobjective: satisfy", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1418, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5a0eac48-ae3d-494a-aa6e-3546b0d28efb": {"__data__": {"id_": "5a0eac48-ae3d-494a-aa6e-3546b0d28efb", "embedding": null, "metadata": {"model_name": "doublechannel", "source_code": "% scheduling ships entering and leaving a port through k channels\nset of int: TYPE = 1..3;\nint: entering = 1;\nint: leaving  = 2;\nint: dummy = 3;\n\nint: nC; % number of channels\nset of int: CHANNEL = 1..nC;\narray[CHANNEL] of int: len;    % length in 100m units\n\nint: nS; % number of ships\nset of int: SHIP = 1..nS; % ships ENTER then LEAVE\nset of int: SHIPE = 1..nS+nC; % ships ENTER then LEAVE then nC dummy ships\n\narray[SHIP] of int: speed;   % time in minutes to traverse 100m\narray[SHIP] of int: desired; % desired time to start to enter/leave \narray[SHIP] of entering..leaving: dirn;   % entering or leaving\n\nint: leeway;  % leeway between 2 ships in 100m units\nint: maxt;    % maximum time\nset of int: TIME = 0..maxt;\n\narray[SHIPE] of var TYPE: kind = dirn ++ [ dummy | i in 1..nC];\narray[SHIPE] of var TIME:    start; % when ships enter the channel \narray[SHIPE] of var TIME:     end; % when ships leave the channel \narray[SHIPE] of var CHANNEL: channel; % which channel a ship is assigned to\n\narray[SHIP] of var SHIPE:   next;  % the next ship in the same channel (or a dummy)\n\n% dummy ships\nconstraint forall(s in nS + 1 .. nS + nC)(start[s] = maxt /\\ end[s] = maxt);\nconstraint forall(s in nS + 1 .. nS + nC)(channel[s] = s - nS);\n\n% relationships between start and ends\nconstraint forall(s in SHIP)(end[s] = start[s] + len[channel[s]]*speed[s]);\n\n\n% the next ship are all different\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(next);\n\n% no clashes in channel\nconstraint forall(s in SHIP)(if kind[s] + kind[next[s]] = entering+leaving then\n                                end[s] <= start[next[s]]\n                             else\n                                start[s] + speed[s]*leeway <= start[next[s]] /\\\n                                end[s] + speed[s]*leeway <= end[next[s]]\n                             endif);\n\n% next ship is in same channel\nconstraint forall(s in SHIP)(channel[next[s]] = channel[s]);\n\nsolve minimize sum(s in SHIP)(abs(start[s] - desired[s]));\n\noutput [ \"start = \",show(start),\n         \";\\nend = \", show(end),\n         \";\\nchannel = \", show(channel),\n         \";\\nnext = \", show(next),\n         \";\\n\" ];\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "doublechannel_expert", "node_type": "4", "metadata": {"model_name": "doublechannel", "source_code": "% scheduling ships entering and leaving a port through k channels\nset of int: TYPE = 1..3;\nint: entering = 1;\nint: leaving  = 2;\nint: dummy = 3;\n\nint: nC; % number of channels\nset of int: CHANNEL = 1..nC;\narray[CHANNEL] of int: len;    % length in 100m units\n\nint: nS; % number of ships\nset of int: SHIP = 1..nS; % ships ENTER then LEAVE\nset of int: SHIPE = 1..nS+nC; % ships ENTER then LEAVE then nC dummy ships\n\narray[SHIP] of int: speed;   % time in minutes to traverse 100m\narray[SHIP] of int: desired; % desired time to start to enter/leave \narray[SHIP] of entering..leaving: dirn;   % entering or leaving\n\nint: leeway;  % leeway between 2 ships in 100m units\nint: maxt;    % maximum time\nset of int: TIME = 0..maxt;\n\narray[SHIPE] of var TYPE: kind = dirn ++ [ dummy | i in 1..nC];\narray[SHIPE] of var TIME:    start; % when ships enter the channel \narray[SHIPE] of var TIME:     end; % when ships leave the channel \narray[SHIPE] of var CHANNEL: channel; % which channel a ship is assigned to\n\narray[SHIP] of var SHIPE:   next;  % the next ship in the same channel (or a dummy)\n\n% dummy ships\nconstraint forall(s in nS + 1 .. nS + nC)(start[s] = maxt /\\ end[s] = maxt);\nconstraint forall(s in nS + 1 .. nS + nC)(channel[s] = s - nS);\n\n% relationships between start and ends\nconstraint forall(s in SHIP)(end[s] = start[s] + len[channel[s]]*speed[s]);\n\n\n% the next ship are all different\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(next);\n\n% no clashes in channel\nconstraint forall(s in SHIP)(if kind[s] + kind[next[s]] = entering+leaving then\n                                end[s] <= start[next[s]]\n                             else\n                                start[s] + speed[s]*leeway <= start[next[s]] /\\\n                                end[s] + speed[s]*leeway <= end[next[s]]\n                             endif);\n\n% next ship is in same channel\nconstraint forall(s in SHIP)(channel[next[s]] = channel[s]);\n\nsolve minimize sum(s in SHIP)(abs(start[s] - desired[s]));\n\noutput [ \"start = \",show(start),\n         \";\\nend = \", show(end),\n         \";\\nchannel = \", show(channel),\n         \";\\nnext = \", show(next),\n         \";\\n\" ];\n\n"}, "hash": "65a740da58c85206b099ac5627f5dc1c58db2774b2489414d90e149f7883e3c3", "class_name": "RelatedNodeInfo"}}, "text": "name: Ship Scheduling Problem\n\ndescription: The Ship Scheduling Problem is a classic constraint satisfaction problem that involves scheduling ships entering and leaving a port through multiple channels. The goal is to assign a start time, end time, and channel to each ship such that there are no clashes between ships in the same channel, and the total deviation from the desired start times is minimized.\n\nvariables: \nstart[s], end[s], channel[s], next[s], kind[s] for s in SHIPE\nThese variables represent the start time, end time, assigned channel, and the next ship in the same channel for each ship, respectively. The kind variable represents the direction of the ship (entering or leaving).\n\nconstraints: \nforall(s in nS + 1 .. nS + nC)(start[s] = maxt /\\ end[s] = maxt)\nforall(s in nS + 1 .. nS + nC)(channel[s] = s - nS)\nforall(s in SHIP)(end[s] = start[s] + len[channel[s]]*speed[s])\nalldifferent(next)\nforall(s in SHIP)(if kind[s] + kind[next[s]] = entering+leaving then end[s] <= start[next[s]] else start[s] + speed[s]*leeway <= start[next[s]] /\\ end[s] + speed[s]*leeway <= end[next[s]])\nforall(s in SHIP)(channel[next[s]] = channel[s])\n\nThese constraints ensure that dummy ships have a start and end time of maxt, and are assigned to their own channel. They also ensure that the end time of a ship is calculated based on its start time, speed, and channel length. The alldifferent constraint ensures that each ship has a unique next ship in the same channel. The remaining constraints ensure that there are no clashes between ships in the same channel, and that the next ship in the same channel is correctly assigned.\n\nobjective: \nminimize sum(s in SHIP)(abs(start[s] - desired[s]))\n\nThe objective is to minimize the total deviation from the desired start times for all ships.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1791, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e3a11130-2fb0-4c2b-9192-dfd82610836d": {"__data__": {"id_": "e3a11130-2fb0-4c2b-9192-dfd82610836d", "embedding": null, "metadata": {"model_name": "fractions", "source_code": "%\n% Fractions problem in MiniZinc.\n%\n% Prolog benchmark problem (BProlog)\n% \"\"\"\n% Find distinct non-zero digits such that the following equation holds:\n%        A        D        G\n%     ------  + ----- + ------  = 1\n%       B*C      E*F      H*I\n\ninclude \"globals.mzn\"; \n\nvar 1..9: A;\nvar 1..9: B;\nvar 1..9: C;\nvar 1..9: D;\nvar 1..9: E;\nvar 1..9: F;\nvar 1..9: G;\nvar 1..9: H;\nvar 1..9: I;\narray[1..9] of var 1..9: Vars=[A,B,C,D,E,F,G,H,I];\n\nvar 1..81: D1;\nvar 1..81: D2;\nvar 1..81: D3;\n\n\n\n% solve satisfy;\nsolve :: int_search(Vars ++ [D1,D2,D3], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   all_different(Vars) /\\\n   D1 = 10*B+C /\\\n   D2 = 10*E+F /\\\n   D3 = 10*H+I /\\\n   A*D2*D3 + D*D1*D3 + G*D1*D2 = D1*D2*D3 /\\\n   % break the symmetry\n   A*D2 >= D*D1 /\\\n   D*D3 >= G*D2 /\\\n   %redundant constraints\n   3*A >= D1 /\\\n   3*G <= D2\n\n;\n\noutput [\n  show(Vars), \"\\n\"\n]\n;"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fractions_expert", "node_type": "4", "metadata": {"model_name": "fractions", "source_code": "%\n% Fractions problem in MiniZinc.\n%\n% Prolog benchmark problem (BProlog)\n% \"\"\"\n% Find distinct non-zero digits such that the following equation holds:\n%        A        D        G\n%     ------  + ----- + ------  = 1\n%       B*C      E*F      H*I\n\ninclude \"globals.mzn\"; \n\nvar 1..9: A;\nvar 1..9: B;\nvar 1..9: C;\nvar 1..9: D;\nvar 1..9: E;\nvar 1..9: F;\nvar 1..9: G;\nvar 1..9: H;\nvar 1..9: I;\narray[1..9] of var 1..9: Vars=[A,B,C,D,E,F,G,H,I];\n\nvar 1..81: D1;\nvar 1..81: D2;\nvar 1..81: D3;\n\n\n\n% solve satisfy;\nsolve :: int_search(Vars ++ [D1,D2,D3], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   all_different(Vars) /\\\n   D1 = 10*B+C /\\\n   D2 = 10*E+F /\\\n   D3 = 10*H+I /\\\n   A*D2*D3 + D*D1*D3 + G*D1*D2 = D1*D2*D3 /\\\n   % break the symmetry\n   A*D2 >= D*D1 /\\\n   D*D3 >= G*D2 /\\\n   %redundant constraints\n   3*A >= D1 /\\\n   3*G <= D2\n\n;\n\noutput [\n  show(Vars), \"\\n\"\n]\n;"}, "hash": "cbb853ead0f153a92167f69fc105737d79593918ad700879a1205e7cdc9a4890", "class_name": "RelatedNodeInfo"}}, "text": "name: Fractions Problem\n\ndescription: The Fractions Problem is a classic constraint satisfaction problem where the goal is to find distinct non-zero digits such that the following equation holds: A/(BC) + D/(EF) + G/(HI) = 1.\n\nvariables: A, B, C, D, E, F, G, H, I, D1, D2, D3\nThese variables represent the digits in the equation. A, B, C, D, E, F, G, H, and I are the digits in the numerators and denominators of the fractions, and D1, D2, and D3 are intermediate variables used to calculate the denominators.\n\nconstraints: \nall_different(Vars) \nD1 = 10*B+C \nD2 = 10*E+F \nD3 = 10*H+I \nA*D2*D3 + D*D1*D3 + G*D1*D2 = D1*D2*D3 \nA*D2 >= D*D1 \nD*D3 >= G*D2 \n3*A >= D1 \n3*G <= D2\n\nThese constraints ensure that: \n- all digits are distinct, \n- the intermediate variables D1, D2, and D3 are correctly calculated, \n- the equation A/(BC) + D/(EF) + G/(HI) = 1 holds, \n- and some symmetry-breaking and redundant constraints are added to help the solver.\n\nobjective: satisfy\nThe objective of the problem is to find a solution that satisfies all the constraints, rather than to minimize or maximize a specific value.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1103, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e36a1efe-5300-48ee-a349-1ab315dabc84": {"__data__": {"id_": "e36a1efe-5300-48ee-a349-1ab315dabc84", "embedding": null, "metadata": {"model_name": "golfers", "source_code": "Model 1 :\n\n\n% The social golfers problem\n% A club has a number of golfers that play rounds in groups (the number of\n% golfers is a multiple of the number of groups).  Each round, a golfer\n% plays with a group of different people, such that the same pair of golfers\n% never play together twice.\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\nset of int: places = 1..n_golfers;\n\narray [rounds, places] of var golfers: round_place_golfer;\narray [golfers, golfers] of var 0..n_rounds: golfer_golfer_round;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (p in places) (round_place_golfer[r, p])\n    );\n\n    % Break some symmetry by strictly ordering each group in each round.\n    %\nconstraint\n    forall (r in rounds, p in places) (\n        if p mod n_per_group != 0\n        then round_place_golfer[r, p] < round_place_golfer[r, p + 1]\n        else true\n        endif\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (r in rounds, g in 0..(n_groups - 1), i, j in 1..n_per_group\n            where i < j) (\n        golfer_golfer_round[\n            round_place_golfer[r, n_per_group * g + i],\n            round_place_golfer[r, n_per_group * g + j]\n        ] = r\n    );\n\nsolve\n    :: int_search([round_place_golfer[r, p] | r in rounds, p in places],\n        first_fail, indomain_min, complete)\n    satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if p = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif ) ++\n    ( if p mod n_per_group = 1 then \"   \" else \" \" endif ) ++\n    show_int(2, round_place_golfer[r, p]) | r in rounds, p in places\n];\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups, group] of var golfers: round_group_i_golfer;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (g in groups, i in group) (round_group_i_golfer[r, g, i])\n    );\n\n    % We also break some symmetry\n    % here by strictly ordering each group.\n    %\nconstraint\n    forall (r in rounds, g in groups, i in group where i < n_per_group) (\n        round_group_i_golfer[r, g, i] < round_group_i_golfer[r, g, i + 1]\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups, i, j in group where i < j) (\n            bool2int(\n                round_group_i_golfer[r, g, i] = a\n            /\\  round_group_i_golfer[r, g, j] = b\n            )\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if g = 1 /\\ i = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif) ++\n    ( if i = 1 then \"   \" else \" \" endif) ++\n    show_int(2, round_group_i_golfer[r, g, i]) \n    |  r in rounds, g in groups, i in group\n];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups] of var set of golfers: round_group_golfers;\n\n    % Each group has to have the right size.\n    %\nconstraint\n    forall (r in rounds, g in groups) (\n        card(round_group_golfers[r, g]) = n_per_group\n    );\n\n    % Each group in each round has to be disjoint.\n    %\nconstraint\n    forall (r in rounds) (\n        all_disjoint (g in groups) (round_group_golfers[r, g])\n    );\n\n    % Symmetry breaking.\n    %\n% constraint\n%     forall (r in rounds, g in groups where g < n_groups) (\n%         round_group_golfers[r, g] < round_group_golfers[r, g + 1]\n%     );\n\n    % Each pair may play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups) (\n            bool2int({a, b} subset round_group_golfers[r, g])\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [    ( if   g = 1\n              then \"\\nround \" ++ show(r) ++ \":   \"\n              else \"   \"\n              endif\n            ) ++\n            show(round_group_golfers[r, g])\n       |    r in rounds, g in groups\n       ];\n\n\nModel 4 :\n\n\nint: weeks = 4;\nint: groups = 3;\nint: groupSize = 3;\nint: golfers = groups * groupSize;\n\nset of int: Golfer = 1..golfers;\nset of int: Week = 1..weeks;\nset of int: Group = 1..groups;\n\n% Search space: The set of all possible group assignments to all \n% players in each of the weeks\narray[Golfer, Week] of var Group: assign;\n\n% solve satisfy;\n% solve :: int_search([assign[i,j] | i in Golfer, j in Week ], \"first_fail\", \"indomain\", \"complete\") satisfy;\nsolve :: int_search([assign[i,j] | i in Golfer, j in Week ], \n        first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each group has exactly groupSize players\n   forall (gr in Group, w in Week)( % c1\n     sum (g in Golfer) (bool2int(assign[g,w] = gr)) = groupSize\n   )\n   /\\\n   % C2: Each pair of players only meets at most once\n   forall (g1, g2 in Golfer, w1, w2 in Week  where g1 != g2 /\\ w1 != w2) (\n     (bool2int(assign[g1,w1] = assign[g2,w1]) + bool2int(assign[g1,w2] = assign[g2,w2])) <= 1\n   )\n  /\\\n  % SBSA: Symmetry-breaking by selective assignment\n  % On the first week, the first groupSize golfers play in group 1, the \n  % second groupSize golfers play in group 2, etc. On the second week, \n  % golfer 1 plays in group 1, golfer 2 plays in group 2, etc.\n  forall(g in Golfer) (\n    assign[g,1]=((g-1) div groupSize) + 1 % \n  )\n  /\\\n  forall(g in Golfer where g <= groupSize)(\n    assign[g,2]=g\n  )\n\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n  show(assign[i,j])\n  | i in Golfer, j in Week\n] ++ [\"\\n\"];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golfers_expert", "node_type": "4", "metadata": {"model_name": "golfers", "source_code": "Model 1 :\n\n\n% The social golfers problem\n% A club has a number of golfers that play rounds in groups (the number of\n% golfers is a multiple of the number of groups).  Each round, a golfer\n% plays with a group of different people, such that the same pair of golfers\n% never play together twice.\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\nset of int: places = 1..n_golfers;\n\narray [rounds, places] of var golfers: round_place_golfer;\narray [golfers, golfers] of var 0..n_rounds: golfer_golfer_round;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (p in places) (round_place_golfer[r, p])\n    );\n\n    % Break some symmetry by strictly ordering each group in each round.\n    %\nconstraint\n    forall (r in rounds, p in places) (\n        if p mod n_per_group != 0\n        then round_place_golfer[r, p] < round_place_golfer[r, p + 1]\n        else true\n        endif\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (r in rounds, g in 0..(n_groups - 1), i, j in 1..n_per_group\n            where i < j) (\n        golfer_golfer_round[\n            round_place_golfer[r, n_per_group * g + i],\n            round_place_golfer[r, n_per_group * g + j]\n        ] = r\n    );\n\nsolve\n    :: int_search([round_place_golfer[r, p] | r in rounds, p in places],\n        first_fail, indomain_min, complete)\n    satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if p = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif ) ++\n    ( if p mod n_per_group = 1 then \"   \" else \" \" endif ) ++\n    show_int(2, round_place_golfer[r, p]) | r in rounds, p in places\n];\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups, group] of var golfers: round_group_i_golfer;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (g in groups, i in group) (round_group_i_golfer[r, g, i])\n    );\n\n    % We also break some symmetry\n    % here by strictly ordering each group.\n    %\nconstraint\n    forall (r in rounds, g in groups, i in group where i < n_per_group) (\n        round_group_i_golfer[r, g, i] < round_group_i_golfer[r, g, i + 1]\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups, i, j in group where i < j) (\n            bool2int(\n                round_group_i_golfer[r, g, i] = a\n            /\\  round_group_i_golfer[r, g, j] = b\n            )\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if g = 1 /\\ i = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif) ++\n    ( if i = 1 then \"   \" else \" \" endif) ++\n    show_int(2, round_group_i_golfer[r, g, i]) \n    |  r in rounds, g in groups, i in group\n];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups] of var set of golfers: round_group_golfers;\n\n    % Each group has to have the right size.\n    %\nconstraint\n    forall (r in rounds, g in groups) (\n        card(round_group_golfers[r, g]) = n_per_group\n    );\n\n    % Each group in each round has to be disjoint.\n    %\nconstraint\n    forall (r in rounds) (\n        all_disjoint (g in groups) (round_group_golfers[r, g])\n    );\n\n    % Symmetry breaking.\n    %\n% constraint\n%     forall (r in rounds, g in groups where g < n_groups) (\n%         round_group_golfers[r, g] < round_group_golfers[r, g + 1]\n%     );\n\n    % Each pair may play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups) (\n            bool2int({a, b} subset round_group_golfers[r, g])\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [    ( if   g = 1\n              then \"\\nround \" ++ show(r) ++ \":   \"\n              else \"   \"\n              endif\n            ) ++\n            show(round_group_golfers[r, g])\n       |    r in rounds, g in groups\n       ];\n\n\nModel 4 :\n\n\nint: weeks = 4;\nint: groups = 3;\nint: groupSize = 3;\nint: golfers = groups * groupSize;\n\nset of int: Golfer = 1..golfers;\nset of int: Week = 1..weeks;\nset of int: Group = 1..groups;\n\n% Search space: The set of all possible group assignments to all \n% players in each of the weeks\narray[Golfer, Week] of var Group: assign;\n\n% solve satisfy;\n% solve :: int_search([assign[i,j] | i in Golfer, j in Week ], \"first_fail\", \"indomain\", \"complete\") satisfy;\nsolve :: int_search([assign[i,j] | i in Golfer, j in Week ], \n        first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each group has exactly groupSize players\n   forall (gr in Group, w in Week)( % c1\n     sum (g in Golfer) (bool2int(assign[g,w] = gr)) = groupSize\n   )\n   /\\\n   % C2: Each pair of players only meets at most once\n   forall (g1, g2 in Golfer, w1, w2 in Week  where g1 != g2 /\\ w1 != w2) (\n     (bool2int(assign[g1,w1] = assign[g2,w1]) + bool2int(assign[g1,w2] = assign[g2,w2])) <= 1\n   )\n  /\\\n  % SBSA: Symmetry-breaking by selective assignment\n  % On the first week, the first groupSize golfers play in group 1, the \n  % second groupSize golfers play in group 2, etc. On the second week, \n  % golfer 1 plays in group 1, golfer 2 plays in group 2, etc.\n  forall(g in Golfer) (\n    assign[g,1]=((g-1) div groupSize) + 1 % \n  )\n  /\\\n  forall(g in Golfer where g <= groupSize)(\n    assign[g,2]=g\n  )\n\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n  show(assign[i,j])\n  | i in Golfer, j in Week\n] ++ [\"\\n\"];"}, "hash": "d11c085748364424722a0c50ae8d57426e2609d28ac63f4f6f1c253a42a23246", "class_name": "RelatedNodeInfo"}}, "text": "name: Social Golfers Problem\n\ndescription: The Social Golfers Problem is a classic constraint satisfaction problem that involves scheduling golfers into groups for multiple rounds of golf, such that each golfer plays with a different set of golfers in each round, and no two golfers play together more than once.\n\nvariables: `round_place_golfer[r, p]`, `golfer_golfer_round[g1, g2]`, `round_group_i_golfer[r, g, i]`, `round_group_golfers[r, g]`, `assign[g, w]`\n\nThese variables represent the assignment of golfers to groups and rounds. Specifically, `round_place_golfer[r, p]` represents the golfer assigned to place `p` in round `r`, `golfer_golfer_round[g1, g2]` represents the round in which golfers `g1` and `g2` play together, `round_group_i_golfer[r, g, i]` represents the golfer assigned to group `g` and position `i` in round `r`, `round_group_golfers[r, g]` represents the set of golfers assigned to group `g` in round `r`, and `assign[g, w]` represents the group assignment of golfer `g` in week `w`.\n\nconstraints: \n`alldifferent (p in places) (round_place_golfer[r, p])`, \n`round_place_golfer[r, p] < round_place_golfer[r, p + 1]`, \n`golfer_golfer_round[g1, g2] = r`, \n`alldifferent (g in groups, i in group) (round_group_i_golfer[r, g, i])`, \n`round_group_i_golfer[r, g, i] < round_group_i_golfer[r, g, i + 1]`, \n`sum (r in rounds, g in groups, i, j in group where i < j) (bool2int(round_group_i_golfer[r, g, i] = a /\\ round_group_i_golfer[r, g, j] = b)) <= 1`, \n`card(round_group_golfers[r, g]) = n_per_group`, \n`all_disjoint (g in groups) (round_group_golfers[r, g])`, \n`sum (r in rounds, g in groups) (bool2int({a, b} subset round_group_golfers[r, g])) <= 1`, \n`sum (g in Golfer) (bool2int(assign[g,w] = gr)) = groupSize`, \n`(bool2int(assign[g1,w1] = assign[g2,w1]) + bool2int(assign[g1,w2] = assign[g2,w2])) <= 1`, \n`assign[g,1]=((g-1) div groupSize) + 1`, \n`assign[g,2]=g`\n\nThese constraints ensure that each golfer is assigned to a unique group and position in each round, that each group has the correct size, that each pair of golfers plays together at most once, and that the symmetry of the problem is broken.\n\nobjective: The objective of the problem is to find a feasible assignment of golfers to groups and rounds that satisfies all the constraints. There is no objective function to minimize or maximize.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2329, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f6e8897f-a6b7-40ca-9909-97535722dca2": {"__data__": {"id_": "f6e8897f-a6b7-40ca-9909-97535722dca2", "embedding": null, "metadata": {"model_name": "golomb", "source_code": "% Golomb rulers\n% From csplib:\n% A Golomb ruler may be defined as a set of m integers 0 = a_1 < a_2 <\n% ... < a_m such that the m(m-1)/2 differences a_j - a_i, 1 <= i < j\n% <= m are distinct. Such a ruler is said to contain m marks and is of\n% length a_m. The objective is to find optimal (minimum length) or\n% near optimal rulers.\n%\n% This is the \"ternary constraints and an alldifferent\" model\n\ninclude \"globals.mzn\";\n\nint: m;\nint: n = m*m;\n\narray[1..m] of var 0..n: mark;\n\narray[1..(m*(m-1)) div 2] of var 0..n: differences =\n    [ mark[j] - mark[i] | i in 1..m, j in i+1..m];\n\nconstraint mark[1] = 0;\n\nconstraint forall ( i in 1..m-1 ) ( mark[i] < mark[i+1] );\n\nconstraint alldifferent(differences);\n\n    % Symmetry breaking\nconstraint differences[1] < differences[(m*(m-1)) div 2];\n\nsolve :: int_search(mark, input_order, indomain, complete)\n    minimize mark[m];\n\noutput [show(mark)];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golomb_expert", "node_type": "4", "metadata": {"model_name": "golomb", "source_code": "% Golomb rulers\n% From csplib:\n% A Golomb ruler may be defined as a set of m integers 0 = a_1 < a_2 <\n% ... < a_m such that the m(m-1)/2 differences a_j - a_i, 1 <= i < j\n% <= m are distinct. Such a ruler is said to contain m marks and is of\n% length a_m. The objective is to find optimal (minimum length) or\n% near optimal rulers.\n%\n% This is the \"ternary constraints and an alldifferent\" model\n\ninclude \"globals.mzn\";\n\nint: m;\nint: n = m*m;\n\narray[1..m] of var 0..n: mark;\n\narray[1..(m*(m-1)) div 2] of var 0..n: differences =\n    [ mark[j] - mark[i] | i in 1..m, j in i+1..m];\n\nconstraint mark[1] = 0;\n\nconstraint forall ( i in 1..m-1 ) ( mark[i] < mark[i+1] );\n\nconstraint alldifferent(differences);\n\n    % Symmetry breaking\nconstraint differences[1] < differences[(m*(m-1)) div 2];\n\nsolve :: int_search(mark, input_order, indomain, complete)\n    minimize mark[m];\n\noutput [show(mark)];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%\n"}, "hash": "f67dae1464c9114fbb260aae88aab0e127c8fb6590952f1be9156260cec0707b", "class_name": "RelatedNodeInfo"}}, "text": "name: Golomb Ruler Problem\n\ndescription: The Golomb Ruler Problem is a classic problem in constraint programming that involves finding a set of distinct integers, called marks, such that the differences between all pairs of marks are also distinct. The goal is to find a Golomb ruler with the minimum length, which is the maximum mark value.\n\nvariables: mark[1..m] \u2208 {0, ..., n}\n\nThe decision variables are an array of m integers, mark[i], representing the i-th mark on the ruler, where 0 \u2264 mark[i] \u2264 n. These variables determine the positions of the marks on the ruler.\n\nconstraints: \nmark[1] = 0\nmark[i] < mark[i+1] \u2200 i \u2208 {1, ..., m-1}\nalldifferent(differences)\ndifferences[1] < differences[(m*(m-1)) div 2]\n\nThe constraints are:\n- The first mark is fixed at 0.\n- Each mark is strictly greater than the previous one, ensuring that the marks are in increasing order.\n- The differences between all pairs of marks are distinct, which is the core constraint of the Golomb Ruler Problem.\n- A symmetry-breaking constraint is added to ensure that the differences are in increasing order, which helps to reduce the search space.\n\nobjective: minimize mark[m]\n\nThe objective is to minimize the maximum mark value, which represents the length of the Golomb ruler.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1254, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4f159be2-2435-43e0-90fb-8190f18bd7aa": {"__data__": {"id_": "4f159be2-2435-43e0-90fb-8190f18bd7aa", "embedding": null, "metadata": {"model_name": "graph", "source_code": "% a strange graph numbering problem\nvar 1..8: a;\nvar 1..8: b;\nvar 1..8: c;\nvar 1..8: d;\nvar 1..8: e;\nvar 1..8: f;\nvar 1..8: g;\nvar 1..8: h;\n\n% Each number is used exactly once\nconstraint a != b;\nconstraint a != c;\nconstraint a != d;\nconstraint a != e;\nconstraint a != f;\nconstraint a != g;\nconstraint a != h;\nconstraint b != c;\nconstraint b != d;\nconstraint b != e;\nconstraint b != f;\nconstraint b != g;\nconstraint b != h;\nconstraint c != d;\nconstraint c != e;\nconstraint c != f;\nconstraint c != g;\nconstraint c != h;\nconstraint d != e;\nconstraint d != f;\nconstraint d != g;\nconstraint d != h;\nconstraint e != f;\nconstraint e != g;\nconstraint e != h;\nconstraint f != g;\nconstraint f != h;\nconstraint g != h;\n\n% Adjacent vertices differ by at most two\nconstraint abs(a - b) >= 2;\nconstraint abs(a - c) >= 2;\nconstraint abs(a - d) >= 2;\nconstraint abs(b - c) >= 2;\nconstraint abs(b - e) >= 2;\nconstraint abs(b - f) >= 2;\nconstraint abs(c - d) >= 2;\nconstraint abs(c - e) >= 2;\nconstraint abs(c - f) >= 2;\nconstraint abs(c - g) >= 2;\nconstraint abs(d - f) >= 2;\nconstraint abs(d - g) >= 2;\nconstraint abs(e - f) >= 2;\nconstraint abs(e - h) >= 2;\nconstraint abs(f - g) >= 2;\nconstraint abs(f - h) >= 2;\nconstraint abs(g - h) >= 2;\n\nsolve satisfy;\n\noutput [\"  \\(b)-\\(e)\\n\",\n        \" /|*|\\\\\\n\",\n        \"\\(a)-\\(c)-\\(f)-\\(h)\\n\",\n        \" \\\\|*|/\\n\",\n        \"  \\(d)-\\(g)\\n\"] ++\n       [\"\\na = \\(a); b = \\(b); c = \\(c); d = \\(d);\",\n        \" e = \\(e); f = \\(f); g = \\(g); h = \\(h);\\n\"] \n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "graph_expert", "node_type": "4", "metadata": {"model_name": "graph", "source_code": "% a strange graph numbering problem\nvar 1..8: a;\nvar 1..8: b;\nvar 1..8: c;\nvar 1..8: d;\nvar 1..8: e;\nvar 1..8: f;\nvar 1..8: g;\nvar 1..8: h;\n\n% Each number is used exactly once\nconstraint a != b;\nconstraint a != c;\nconstraint a != d;\nconstraint a != e;\nconstraint a != f;\nconstraint a != g;\nconstraint a != h;\nconstraint b != c;\nconstraint b != d;\nconstraint b != e;\nconstraint b != f;\nconstraint b != g;\nconstraint b != h;\nconstraint c != d;\nconstraint c != e;\nconstraint c != f;\nconstraint c != g;\nconstraint c != h;\nconstraint d != e;\nconstraint d != f;\nconstraint d != g;\nconstraint d != h;\nconstraint e != f;\nconstraint e != g;\nconstraint e != h;\nconstraint f != g;\nconstraint f != h;\nconstraint g != h;\n\n% Adjacent vertices differ by at most two\nconstraint abs(a - b) >= 2;\nconstraint abs(a - c) >= 2;\nconstraint abs(a - d) >= 2;\nconstraint abs(b - c) >= 2;\nconstraint abs(b - e) >= 2;\nconstraint abs(b - f) >= 2;\nconstraint abs(c - d) >= 2;\nconstraint abs(c - e) >= 2;\nconstraint abs(c - f) >= 2;\nconstraint abs(c - g) >= 2;\nconstraint abs(d - f) >= 2;\nconstraint abs(d - g) >= 2;\nconstraint abs(e - f) >= 2;\nconstraint abs(e - h) >= 2;\nconstraint abs(f - g) >= 2;\nconstraint abs(f - h) >= 2;\nconstraint abs(g - h) >= 2;\n\nsolve satisfy;\n\noutput [\"  \\(b)-\\(e)\\n\",\n        \" /|*|\\\\\\n\",\n        \"\\(a)-\\(c)-\\(f)-\\(h)\\n\",\n        \" \\\\|*|/\\n\",\n        \"  \\(d)-\\(g)\\n\"] ++\n       [\"\\na = \\(a); b = \\(b); c = \\(c); d = \\(d);\",\n        \" e = \\(e); f = \\(f); g = \\(g); h = \\(h);\\n\"] \n\n"}, "hash": "a8204a631d47c813e9ca6a333415afa892e4a1eed6443064d1e8899795c76a5c", "class_name": "RelatedNodeInfo"}}, "text": "name: Graph Labeling Problem\n\ndescription: This problem is a variant of the graph labeling problem, where we have a graph with 8 vertices and we need to assign a unique label from 1 to 8 to each vertex such that adjacent vertices have labels that differ by at least 2.\n\nvariables: a, b, c, d, e, f, g, h \u2208 {1, ..., 8}\nThese variables represent the labels assigned to each vertex of the graph.\n\nconstraints: \na \u2260 b, a \u2260 c, ..., g \u2260 h (28 constraints)\nThese constraints ensure that each label is used exactly once, i.e., no two vertices have the same label.\n\n|a - b| \u2265 2, |a - c| \u2265 2, ..., |g - h| \u2265 2 (16 constraints)\nThese constraints ensure that adjacent vertices have labels that differ by at least 2.\n\nobjective: satisfy\nThe objective of this problem is to find a feasible assignment of labels to the vertices that satisfies all the constraints, i.e., a solution that meets the conditions of unique labeling and adjacent vertices differing by at least 2.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 957, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d1788cff-6ef4-446d-bba4-b3f6e2362c0f": {"__data__": {"id_": "d1788cff-6ef4-446d-bba4-b3f6e2362c0f", "embedding": null, "metadata": {"model_name": "itemset_mining", "source_code": "int : NrI ; \nint : NrT ; \nint : Freq ;\narray [ 1..NrT ] of set of 1..NrI : TDB;\nvar set of 1..NrI : Items ;\nconstraint card ( cover ( Items ,TDB ) ) >= Freq ;\nsolve satisfy ; \n\nfunction var set of int : cover (\n         var set of int : Items ,\n         array [ int ] of var set of int : D) = \n         let {\n                          var set of index_set (D): Trans ;\n                          constraint forall ( t in index_set (D) )\n                          ( t in Trans <-> Items subset D[ t ] );\n         } in Trans;\n\narray[1.. NrI] of int: itemprice;\nint: minUtility;\n\nconstraint sum(i in Items)(itemprice[i]) >= minUtility;\n\nNrI = 6;\nint: bread = 1;\nint: butter = 2;\nint: cheese = 3;\nint: cocoa = 4;\nint: milk = 5;\nint: vegemite = 6;\narray[1..NrI] of string: name = [\"bread\",\"butter\",\"cheese\",\"cocoa\",\"milk\",\"vegemite\"];\nitemprice = [1,2,1,2,1,1];\n\nNrT = 7;\nTDB = [ { butter, cheese, milk, vegemite },\n        { butter, cocoa, milk, vegemite },\n\t{ bread, cocoa, cheese, milk },\n\t{ bread, butter, cheese, vegemite }, \n\t{ bread, cheese, milk, vegemite },\n\t{ bread, butter, cheese, cocoa, milk },\n\t{ bread, cheese, milk }];\n\nFreq = 4;\nminUtility = 3;\n\noutput [ name[i] ++ \" \" | i in fix(Items) ];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "itemset_mining_expert", "node_type": "4", "metadata": {"model_name": "itemset_mining", "source_code": "int : NrI ; \nint : NrT ; \nint : Freq ;\narray [ 1..NrT ] of set of 1..NrI : TDB;\nvar set of 1..NrI : Items ;\nconstraint card ( cover ( Items ,TDB ) ) >= Freq ;\nsolve satisfy ; \n\nfunction var set of int : cover (\n         var set of int : Items ,\n         array [ int ] of var set of int : D) = \n         let {\n                          var set of index_set (D): Trans ;\n                          constraint forall ( t in index_set (D) )\n                          ( t in Trans <-> Items subset D[ t ] );\n         } in Trans;\n\narray[1.. NrI] of int: itemprice;\nint: minUtility;\n\nconstraint sum(i in Items)(itemprice[i]) >= minUtility;\n\nNrI = 6;\nint: bread = 1;\nint: butter = 2;\nint: cheese = 3;\nint: cocoa = 4;\nint: milk = 5;\nint: vegemite = 6;\narray[1..NrI] of string: name = [\"bread\",\"butter\",\"cheese\",\"cocoa\",\"milk\",\"vegemite\"];\nitemprice = [1,2,1,2,1,1];\n\nNrT = 7;\nTDB = [ { butter, cheese, milk, vegemite },\n        { butter, cocoa, milk, vegemite },\n\t{ bread, cocoa, cheese, milk },\n\t{ bread, butter, cheese, vegemite }, \n\t{ bread, cheese, milk, vegemite },\n\t{ bread, butter, cheese, cocoa, milk },\n\t{ bread, cheese, milk }];\n\nFreq = 4;\nminUtility = 3;\n\noutput [ name[i] ++ \" \" | i in fix(Items) ];\n"}, "hash": "9fba2d738f4e44a992bf240638ff26e1f5cac796b287b518a51188feb737f3c9", "class_name": "RelatedNodeInfo"}}, "text": "name: Market Basket Analysis\n\ndescription: The Market Basket Analysis problem is a classic problem in data mining and constraint programming. It involves finding a set of items that are frequently purchased together in a transactional database. The goal is to identify a set of items that covers a minimum number of transactions, with a minimum total utility or value.\n\nvariables: Items \u2208 2^{1..NrI}\n\nThe decision variable Items is a set of items, represented as a subset of the universe of items {1..NrI}. It represents the set of items that are frequently purchased together.\n\nconstraints: \ncard(cover(Items, TDB)) \u2265 Freq\n\u2211(i in Items)(itemprice[i]) \u2265 minUtility\n\nThe first constraint ensures that the set of items covers at least Freq transactions in the transactional database TDB. The cover function is a custom function that returns the set of transactions that are covered by the items.\n\nThe second constraint ensures that the total utility or value of the items in the set is at least minUtility.\n\nobjective: satisfy\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function. The goal is to find a set of items that covers a minimum number of transactions with a minimum total utility or value.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1294, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c2b61012-ee95-4395-a6d3-1262408c37b4": {"__data__": {"id_": "c2b61012-ee95-4395-a6d3-1262408c37b4", "embedding": null, "metadata": {"model_name": "jobshop", "source_code": "Model 1 :\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\n% only one task on any machine at one time\n%constraint forall(ma in MACH)\n%                 (forall(j1,j2 in JOB where j1 < j2)\n%                       (forall(t1,t2 in TASK where mc[j1,t1] = ma /\\ mc[j2,t2] = ma)\n%                              (nonoverlap(s[j1,t1],d[j1,t1],s[j2,t2],d[j2,t2]))));\n\nconstraint forall(j1, j2 in JOB, t1, t2 in TASK \n       where j1 < j2 /\\ mc[j1,t1] = mc[j2,t2])\n      (nonoverlap(s[j1,t1],d[j1,t1],\n                  s[j2,t2],d[j2,t2]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve :: int_search([s[j,t] | j in JOB, t in TASK], input_order, indomain_min, complete)\n      minimize makespan;\n\noutput [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 2 : \n\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n   %:: int_search([s[j,t]|j in JOB,t in TASK],input_order,indomain_min,complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],smallest, indomain_min, complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],dom_w_deg, indomain_min, complete)\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 3 : \n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n%      ::\n%      seq_search([ int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete),\n%                  int_search([makespan], input_order, indomain_min, complete)])\n%      seq_search([ int_search([makespan], input_order, indomain_min, complete),\n%                   int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete)])\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "jobshop_expert", "node_type": "4", "metadata": {"model_name": "jobshop", "source_code": "Model 1 :\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\n% only one task on any machine at one time\n%constraint forall(ma in MACH)\n%                 (forall(j1,j2 in JOB where j1 < j2)\n%                       (forall(t1,t2 in TASK where mc[j1,t1] = ma /\\ mc[j2,t2] = ma)\n%                              (nonoverlap(s[j1,t1],d[j1,t1],s[j2,t2],d[j2,t2]))));\n\nconstraint forall(j1, j2 in JOB, t1, t2 in TASK \n       where j1 < j2 /\\ mc[j1,t1] = mc[j2,t2])\n      (nonoverlap(s[j1,t1],d[j1,t1],\n                  s[j2,t2],d[j2,t2]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve :: int_search([s[j,t] | j in JOB, t in TASK], input_order, indomain_min, complete)\n      minimize makespan;\n\noutput [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 2 : \n\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n   %:: int_search([s[j,t]|j in JOB,t in TASK],input_order,indomain_min,complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],smallest, indomain_min, complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],dom_w_deg, indomain_min, complete)\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 3 : \n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n%      ::\n%      seq_search([ int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete),\n%                  int_search([makespan], input_order, indomain_min, complete)])\n%      seq_search([ int_search([makespan], input_order, indomain_min, complete),\n%                   int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete)])\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n"}, "hash": "5e4711476b9e268123585e8ab3bf52748780090d624c78edce02eecfdd1f87ee", "class_name": "RelatedNodeInfo"}}, "text": "name: Job Shop Scheduling Problem\n\ndescription: The Job Shop Scheduling Problem is a classic problem in operations research and computer science that involves scheduling a set of jobs on a set of machines. Each job consists of a sequence of tasks, and each task requires a specific machine. The goal is to find a schedule that minimizes the total time required to complete all jobs.\n\nvariables: s[j,t] (start time of task t of job j), makespan (maximum completion time of all jobs)\n\nThe decision variables s[j,t] represent the start time of task t of job j, and makespan represents the maximum completion time of all jobs.\n\nconstraints: \ns[j,t] + d[j,t] <= s[j,t+1] (tasks in a job are performed in order), \nnonoverlap(s[j1,t1],d[j1,t1],s[j2,t2],d[j2,t2]) (only one task on any machine at one time), \ndisjunctive(ss,dd) (tasks on the same machine do not overlap)\n\nThe constraints ensure that tasks in a job are performed in order, only one task on any machine can be performed at a time, and tasks on the same machine do not overlap.\n\nobjective: minimize makespan\n\nThe objective is to minimize the maximum completion time of all jobs, which is represented by the makespan variable.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1181, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1921d207-e716-4416-a015-c6fed6bdc1eb": {"__data__": {"id_": "1921d207-e716-4416-a015-c6fed6bdc1eb", "embedding": null, "metadata": {"model_name": "K4xP2Graceful", "source_code": "% K4P2 Graceful Graph in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: m = 16;\nint: n = 8;\narray[1..n] of var 0..m: nodes;\narray[1..m, 1..2] of var 1..n: graph;\narray[1..m] of var 1..m: edges;\n\n\n\nsolve :: int_search(nodes, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..m) (\n    abs(nodes[graph[i,1]] - nodes[graph[i,2]]) = edges[i]  \n  )\n  /\\\n  all_different(edges) \n  /\\ \n  all_different(nodes)\n;\n\ngraph =\narray2d(1..m, 1..2,\n[1, 2,\n1, 3,\n1, 4,\n2, 3,\n2, 4,\n3, 4,\n\n5, 6,\n5, 7,\n5, 8,\n6, 7,\n6, 8,\n7, 8,\n\n1, 5,\n2, 6,\n3, 7,\n4, 8]);\n\noutput\n[\n  \"nodes: \" ++ show(nodes) ++ \"\\n\" ++\n  \"edges: \" ++ show(edges) ++ \"\\n\"\n];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "K4xP2Graceful_expert", "node_type": "4", "metadata": {"model_name": "K4xP2Graceful", "source_code": "% K4P2 Graceful Graph in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: m = 16;\nint: n = 8;\narray[1..n] of var 0..m: nodes;\narray[1..m, 1..2] of var 1..n: graph;\narray[1..m] of var 1..m: edges;\n\n\n\nsolve :: int_search(nodes, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..m) (\n    abs(nodes[graph[i,1]] - nodes[graph[i,2]]) = edges[i]  \n  )\n  /\\\n  all_different(edges) \n  /\\ \n  all_different(nodes)\n;\n\ngraph =\narray2d(1..m, 1..2,\n[1, 2,\n1, 3,\n1, 4,\n2, 3,\n2, 4,\n3, 4,\n\n5, 6,\n5, 7,\n5, 8,\n6, 7,\n6, 8,\n7, 8,\n\n1, 5,\n2, 6,\n3, 7,\n4, 8]);\n\noutput\n[\n  \"nodes: \" ++ show(nodes) ++ \"\\n\" ++\n  \"edges: \" ++ show(edges) ++ \"\\n\"\n];"}, "hash": "d19931b0279805436aa907a4a7be411dc2ecc168567cd86f259c896e7d6b60b0", "class_name": "RelatedNodeInfo"}}, "text": "name: Graceful Graph\n\ndescription: The Graceful Graph problem is a well-known problem in graph theory and constraint programming. It involves labeling the nodes of a graph with integers from 1 to m, such that the absolute difference between the labels of two adjacent nodes is equal to the edge label. The goal is to find a labeling that satisfies these conditions and makes the edge labels distinct.\n\nvariables: nodes \u2208 {0, ..., m}^n, graph \u2208 {1, ..., n}^(m \u00d7 2), edges \u2208 {1, ..., m}^m\nThe decision variables are:\n- nodes: an array of length n, where each element represents the label of a node in the graph.\n- graph: a 2D array of size m \u00d7 2, where each row represents an edge in the graph, and the two columns represent the nodes connected by the edge.\n- edges: an array of length m, where each element represents the label of an edge in the graph.\n\nconstraints: \n\u2200i \u2208 {1, ..., m} (|nodes[graph[i,1]] - nodes[graph[i,2]]| = edges[i]) \u2227 \nall_different(edges) \u2227 \nall_different(nodes)\nThe constraints are:\n- For each edge, the absolute difference between the labels of the two nodes connected by the edge is equal to the edge label.\n- All edge labels are distinct.\n- All node labels are distinct.\n\nobjective: The problem does not have an objective function to minimize or maximize. The goal is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1357, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "03b74dd0-8753-4a79-b2b3-559f498dd170": {"__data__": {"id_": "03b74dd0-8753-4a79-b2b3-559f498dd170", "embedding": null, "metadata": {"model_name": "killer_sudoku", "source_code": "Model 1 :\n\n%\n% Killer Sudoku in MiniZinc.\n\n%   Killer sudoku (also killer su doku, sumdoku, sum doku, addoku, or\n%   samunamupure) is a puzzle that combines elements of sudoku and kakuro.\n%   Despite the name, the simpler killer sudokus can be easier to solve\n%   than regular sudokus, depending on the solver's skill at mental arithmetic;\n%   the hardest ones, however, can take hours to crack.\n \n%   The objective is to fill the grid with numbers from 1 to 9 in a way that\n%   the following conditions are met:\n \n%     * Each row, column, and nonet contains each number exactly once.\n%     * The sum of all numbers in a cage must match the small number printed\n%       in its corner.\n%     * No number appears more than once in a cage. (This is the standard rule\n%       for killer sudokus, and implies that no cage can include more\n%       than 9 cells.)\n \n%   In 'Killer X', an additional rule is that each of the long diagonals\n%   contains each number once.\n%   \"\"\"\n \n\nint: num_p = 29; % number of segments\nint: num_hints = 4;  % number of hints per segments (that's max number of hints)\nint: max_val = 100;\narray[1..num_p, 1..2*num_hints+1] of 0..max_val: P =\n  array2d(1..num_p, 1..2*num_hints+1, [\n    1,1,  1,2, 0,0, 0,0,   3,\n    1,3,  1,4, 1,5, 0,0,  15,\n    1,6,  2,5, 2,6, 3,5,  22,\n    1,7,  2,7, 0,0, 0,0,   4,\n    1,8,  2,8, 0,0, 0,0,  16,\n    1,9,  2,9, 3,9, 4,9,  15,\n    2,1,  2,2, 3,1, 3,2,  25,\n    2,3,  2,4, 0,0, 0,0,  17,\n    3,3,  3,4, 4,4, 0,0,   9,\n    3,6,  4,6, 5,6, 0,0,   8,\n    3,7,  3,8, 4,7, 0,0,  20,\n    4,1,  5,1, 0,0, 0,0,   6,\n    4,2,  4,3, 0,0, 0,0,  14,\n    4,5,  5,5, 6,5, 0,0,  17,\n    4,8,  5,7, 5,8, 0,0,  17,\n    5,2,  5,3, 6,2, 0,0,  13,\n    5,4,  6,4, 7,4, 0,0,  20,\n    5,9,  6,9, 0,0, 0,0,  12,\n    6,1,  7,1, 8,1, 9,1,  27,\n    6,3,  7,2, 7,3, 0,0,   6,\n    6,6,  7,6, 7,7, 0,0,  20,\n    6,7,  6,8, 0,0, 0,0,   6,\n    7,5,  8,4, 8,5, 9,4,  10,\n    7,8,  7,9, 8,8, 8,9,  14,\n    8,2,  9,2, 0,0, 0,0,   8,\n    8,3,  9,3, 0,0, 0,0,  16,\n    8,6,  8,7, 0,0, 0,0,  15,\n    9,5,  9,6, 9,7, 0,0,  13,\n    9,8,  9,9, 0,0, 0,0,  17\n   ]);\n\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n \n  forall(i in 1..n) (\n        all_different([x[i,j] | j in 1..n]) /\\\n        all_different([x[j,i] | j in 1..n])\n  )\n  /\\\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n  /\\ % calculate the hints\n  forall(p in 1..num_p) (\n     sum(i in 1..num_hints where P[p,2*(i-1)+1] > 0) (x[  P[p, 2*(i-1)+1], P[p,2*(i-1)+2]  ]) = P[p, 2*num_hints+1]\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\"; \nint: n = 9;\narray[1..n, 1..n] of var 1..9: x;\n\nint: num_segments = 29; % number of segments\n\narray[1..n, 1..n] of int: segments =\narray2d(1..n, 1..n,\n[\n  1, 1, 2, 2, 2, 3, 4, 5, 6, % 1\n  7, 7, 8, 8, 3, 3, 4, 5, 6, % 2\n  7, 7, 9, 9, 3,10,11,11, 6, % 3\n 13,14,14, 9,15,10,11,12, 6, % 4\n 13,16,16,17,15,10,12,12,18, % 5\n 19,16,20,17,15,21,22,22,18, % 6\n 19,20,20,17,23,21,21,24,24, % 7\n 19,25,26,23,23,27,27,24,24, % 8\n 19,25,26,23,28,28,28,29,29, % 9\n]);\n\narray[1..num_segments] of int: segment_sums =\n[\n   3, % 1\n  15, % 2\n  22, % 3\n   4, % 4\n  16, % 5\n  15, % 6\n  25, % 7\n  17, % 8\n   9, % 9\n   8, % 10\n  20, % 11\n  17, % 12\n   6, % 13\n  14, % 14\n  17, % 15\n  13, % 16\n  20, % 17\n  12, % 18\n  27, % 19\n   6, % 20\n  20, % 21\n   6, % 22\n  10, % 23\n  14, % 24\n   8, % 25\n  16, % 26\n  15, % 27\n  13, % 28\n  17  % 29\n];\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\n% Standard Sudoku constraints\nconstraint\n  % rows and columns\n  forall(i in 1..n) (\n     all_different([x[i,j] | j in 1..n]) /\\\n     all_different([x[j,i] | j in 1..n])\n  )\n  /\\ % blocks\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n;\n\n% Handle the segments\nconstraint\n  forall(p in 1..num_segments) (\n    segment_sums[p] = sum([x[i,j] | i,j in 1..n where segments[i,j] = p])\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "killer_sudoku_expert", "node_type": "4", "metadata": {"model_name": "killer_sudoku", "source_code": "Model 1 :\n\n%\n% Killer Sudoku in MiniZinc.\n\n%   Killer sudoku (also killer su doku, sumdoku, sum doku, addoku, or\n%   samunamupure) is a puzzle that combines elements of sudoku and kakuro.\n%   Despite the name, the simpler killer sudokus can be easier to solve\n%   than regular sudokus, depending on the solver's skill at mental arithmetic;\n%   the hardest ones, however, can take hours to crack.\n \n%   The objective is to fill the grid with numbers from 1 to 9 in a way that\n%   the following conditions are met:\n \n%     * Each row, column, and nonet contains each number exactly once.\n%     * The sum of all numbers in a cage must match the small number printed\n%       in its corner.\n%     * No number appears more than once in a cage. (This is the standard rule\n%       for killer sudokus, and implies that no cage can include more\n%       than 9 cells.)\n \n%   In 'Killer X', an additional rule is that each of the long diagonals\n%   contains each number once.\n%   \"\"\"\n \n\nint: num_p = 29; % number of segments\nint: num_hints = 4;  % number of hints per segments (that's max number of hints)\nint: max_val = 100;\narray[1..num_p, 1..2*num_hints+1] of 0..max_val: P =\n  array2d(1..num_p, 1..2*num_hints+1, [\n    1,1,  1,2, 0,0, 0,0,   3,\n    1,3,  1,4, 1,5, 0,0,  15,\n    1,6,  2,5, 2,6, 3,5,  22,\n    1,7,  2,7, 0,0, 0,0,   4,\n    1,8,  2,8, 0,0, 0,0,  16,\n    1,9,  2,9, 3,9, 4,9,  15,\n    2,1,  2,2, 3,1, 3,2,  25,\n    2,3,  2,4, 0,0, 0,0,  17,\n    3,3,  3,4, 4,4, 0,0,   9,\n    3,6,  4,6, 5,6, 0,0,   8,\n    3,7,  3,8, 4,7, 0,0,  20,\n    4,1,  5,1, 0,0, 0,0,   6,\n    4,2,  4,3, 0,0, 0,0,  14,\n    4,5,  5,5, 6,5, 0,0,  17,\n    4,8,  5,7, 5,8, 0,0,  17,\n    5,2,  5,3, 6,2, 0,0,  13,\n    5,4,  6,4, 7,4, 0,0,  20,\n    5,9,  6,9, 0,0, 0,0,  12,\n    6,1,  7,1, 8,1, 9,1,  27,\n    6,3,  7,2, 7,3, 0,0,   6,\n    6,6,  7,6, 7,7, 0,0,  20,\n    6,7,  6,8, 0,0, 0,0,   6,\n    7,5,  8,4, 8,5, 9,4,  10,\n    7,8,  7,9, 8,8, 8,9,  14,\n    8,2,  9,2, 0,0, 0,0,   8,\n    8,3,  9,3, 0,0, 0,0,  16,\n    8,6,  8,7, 0,0, 0,0,  15,\n    9,5,  9,6, 9,7, 0,0,  13,\n    9,8,  9,9, 0,0, 0,0,  17\n   ]);\n\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n \n  forall(i in 1..n) (\n        all_different([x[i,j] | j in 1..n]) /\\\n        all_different([x[j,i] | j in 1..n])\n  )\n  /\\\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n  /\\ % calculate the hints\n  forall(p in 1..num_p) (\n     sum(i in 1..num_hints where P[p,2*(i-1)+1] > 0) (x[  P[p, 2*(i-1)+1], P[p,2*(i-1)+2]  ]) = P[p, 2*num_hints+1]\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\"; \nint: n = 9;\narray[1..n, 1..n] of var 1..9: x;\n\nint: num_segments = 29; % number of segments\n\narray[1..n, 1..n] of int: segments =\narray2d(1..n, 1..n,\n[\n  1, 1, 2, 2, 2, 3, 4, 5, 6, % 1\n  7, 7, 8, 8, 3, 3, 4, 5, 6, % 2\n  7, 7, 9, 9, 3,10,11,11, 6, % 3\n 13,14,14, 9,15,10,11,12, 6, % 4\n 13,16,16,17,15,10,12,12,18, % 5\n 19,16,20,17,15,21,22,22,18, % 6\n 19,20,20,17,23,21,21,24,24, % 7\n 19,25,26,23,23,27,27,24,24, % 8\n 19,25,26,23,28,28,28,29,29, % 9\n]);\n\narray[1..num_segments] of int: segment_sums =\n[\n   3, % 1\n  15, % 2\n  22, % 3\n   4, % 4\n  16, % 5\n  15, % 6\n  25, % 7\n  17, % 8\n   9, % 9\n   8, % 10\n  20, % 11\n  17, % 12\n   6, % 13\n  14, % 14\n  17, % 15\n  13, % 16\n  20, % 17\n  12, % 18\n  27, % 19\n   6, % 20\n  20, % 21\n   6, % 22\n  10, % 23\n  14, % 24\n   8, % 25\n  16, % 26\n  15, % 27\n  13, % 28\n  17  % 29\n];\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\n% Standard Sudoku constraints\nconstraint\n  % rows and columns\n  forall(i in 1..n) (\n     all_different([x[i,j] | j in 1..n]) /\\\n     all_different([x[j,i] | j in 1..n])\n  )\n  /\\ % blocks\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n;\n\n% Handle the segments\nconstraint\n  forall(p in 1..num_segments) (\n    segment_sums[p] = sum([x[i,j] | i,j in 1..n where segments[i,j] = p])\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];"}, "hash": "baadad4aa4c73cb141ec2d0b03e69a6d3bb838d573ef6d99f3a632ff945cdb94", "class_name": "RelatedNodeInfo"}}, "text": "name: Killer Sudoku\n\ndescription: Killer Sudoku is a puzzle that combines elements of Sudoku and Kakuro. The objective is to fill a 9x9 grid with numbers from 1 to 9 such that each row, column, and nonet (3x3 sub-grid) contains each number exactly once. Additionally, the sum of all numbers in a \"cage\" (a group of cells) must match the small number printed in its corner.\n\nvariables: x[i, j] (i, j \u2208 {1, ..., 9}) - decision variables representing the value of each cell in the grid.\n\nconstraints:\n- \u2200i \u2208 {1, ..., 9} (\u2200j \u2208 {1, ..., 9} x[i, j] \u2260 x[i, k] \u2227 \u2200j \u2208 {1, ..., 9} x[j, i] \u2260 x[k, i]) - each row and column contains each number exactly once\n- \u2200i, j \u2208 {0, ..., 2} (\u2200r, c \u2208 {i*3+1, ..., i*3+3} \u00d7 {j*3+1, ..., j*3+3} x[r, c] \u2260 x[r', c'] for r \u2260 r' or c \u2260 c') - each nonet contains each number exactly once\n- \u2200p \u2208 {1, ..., num_segments} (\u2211(i, j) \u2208 {1, ..., n} \u00d7 {1, ..., n} where segments[i, j] = p x[i, j] = segment_sums[p]) - the sum of all numbers in a cage must match the small number printed in its corner\n\nobjective: satisfy - the objective is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1115, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f934f715-c515-4fbc-a9ee-1553a1c72c33": {"__data__": {"id_": "f934f715-c515-4fbc-a9ee-1553a1c72c33", "embedding": null, "metadata": {"model_name": "knapsack", "source_code": "Model 1 : \n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\narray[OBJ] of var int: x; % how many of each object\n\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in OBJ)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\nModel 2 : \n\n\nint: n;    set of int: OBJ = 1..n;\narray[OBJ] of int: size;\narray[OBJ] of int: value;\nint: limit;\narray[OBJ] of var int: x;\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i]*x[i])<= limit;\nsolve maximize sum(i in OBJ)(value[i]*x[i]);\nn = 4;\nsize = [5,8,9,12];\nvalue = [3,5,7,8];\nlimit = 29;\n\n\n\nModel 3 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var 0..1: x; \n\nconstraint sum(i in 1..n)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 4 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var bool: x; \n\nconstraint sum(i in 1..n)(size[i] * bool2int(x[i])) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(x[i]));\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 5 : \n\n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\nvar set of OBJ: x; \n\n\nconstraint sum(i in x)(size[i]) <= capacity;\n\nsolve maximize sum(i in x)(profit[i]);\n\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 6 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\nvar set of 1..n: x;\n\nconstraint sum(i in 1..n)(size[i] * bool2int(i in x)) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(i in x));\n\noutput [\"x = \", show(x), \"\\n\"];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "knapsack_expert", "node_type": "4", "metadata": {"model_name": "knapsack", "source_code": "Model 1 : \n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\narray[OBJ] of var int: x; % how many of each object\n\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in OBJ)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\nModel 2 : \n\n\nint: n;    set of int: OBJ = 1..n;\narray[OBJ] of int: size;\narray[OBJ] of int: value;\nint: limit;\narray[OBJ] of var int: x;\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i]*x[i])<= limit;\nsolve maximize sum(i in OBJ)(value[i]*x[i]);\nn = 4;\nsize = [5,8,9,12];\nvalue = [3,5,7,8];\nlimit = 29;\n\n\n\nModel 3 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var 0..1: x; \n\nconstraint sum(i in 1..n)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 4 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var bool: x; \n\nconstraint sum(i in 1..n)(size[i] * bool2int(x[i])) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(x[i]));\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 5 : \n\n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\nvar set of OBJ: x; \n\n\nconstraint sum(i in x)(size[i]) <= capacity;\n\nsolve maximize sum(i in x)(profit[i]);\n\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 6 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\nvar set of 1..n: x;\n\nconstraint sum(i in 1..n)(size[i] * bool2int(i in x)) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(i in x));\n\noutput [\"x = \", show(x), \"\\n\"];"}, "hash": "93033d72327a07da61a7f2de6f67a9e4bdd73e9fe7b0f1dddd9bb1428321335d", "class_name": "RelatedNodeInfo"}}, "text": "name: 0/1 Knapsack Problem\n\ndescription: The 0/1 Knapsack Problem is a classic problem in combinatorial optimization. Given a set of objects, each with a weight and a value, determine the subset of objects to include in a knapsack of limited capacity to maximize the total value while not exceeding the knapsack's capacity.\n\nvariables: x (x[i] for i in OBJ or x[i] for i in 1..n)\n\nThe decision variables x represent the number of each object to include in the knapsack. In some models, x is a binary variable (0 or 1) indicating whether to include the object or not, while in others, x is an integer variable representing the quantity of each object to include.\n\nconstraints: x[i] >= 0, sum(i in OBJ)(size[i] * x[i]) <= capacity\n\nThe constraints ensure that the number of each object included is non-negative and that the total weight of the selected objects does not exceed the knapsack's capacity.\n\nobjective: maximize sum(i in OBJ)(profit[i] * x[i])\n\nThe objective is to maximize the total value of the objects included in the knapsack.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1039, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "329e278e-151f-4e7e-ac24-184bf0e910aa": {"__data__": {"id_": "329e278e-151f-4e7e-ac24-184bf0e910aa", "embedding": null, "metadata": {"model_name": "langford", "source_code": "Model 1 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n                 (x[d,c+1] = x[d,c] + d + 1);\n\nsolve satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ if fix(x[d,c]) = p then show(d) ++ \" \" else \"\" endif\n          | p in POS, d in DIG, c in COPY ]\n       ;\n\n\n\nModel 2 : \n\n\n% Langford's number problem in MiniZinc.\n%\n% Arrange 2 sets of positive integers 1..k to a sequence,\n% such that, following the first occurence of an integer i,\n% each subsequent occurrence of i, appears i+1 indices later\n% than the last.\n% For example, for k=4, a solution would be 41312432\n\ninclude \"globals.mzn\";\n\nint: k;\nset of int: positionDomain = 1..2*k;\n\narray[positionDomain] of var positionDomain: position;\n% better presentation:\narray[positionDomain] of var 1..k: solution;\n\nsolve :: int_search(position, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..k) (\n     position[i+k] = position[i] + i+1 /\\\n     % hakank: added this\n     solution[position[i]] = i /\\ \n     solution[position[k+i]] = i\n  )\n  /\\   \n  all_different(position)\n  /\\ % symmetry breaking\n  solution[1] < solution[2*k]\n;\n\n\noutput [\n  show(solution), \"\\n\"\n\n];\n\n%\n% data\n%\nk = 4;\n% k = 7;\n% k = 8;\n% k = 10;\n% k = 20;\n\n\n\nModel 3 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"inverse.mzn\";\nconstraint inverse([x[d,c] | d in DIG, c in COPY], y);\n\n%include \"alldifferent.mzn\";\n%constraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n      (x[d,c+1] = x[d,c] + d + 1);\n\n%constraint forall(d in DIG, c in 1..m-1, p in POS)\n%                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve \n      %:: int_search(y, input_order, indomain_min, complete) \n      %:: int_search([x[d,c] | d in DIG, c in COPY], input_order, indomain_min, complete) \n      satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n\n\nModel 4 :\n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\nconstraint forall(d in DIG, c in 1..m-1, p in POS)\n                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve satisfy;\n\noutput [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "langford_expert", "node_type": "4", "metadata": {"model_name": "langford", "source_code": "Model 1 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n                 (x[d,c+1] = x[d,c] + d + 1);\n\nsolve satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ if fix(x[d,c]) = p then show(d) ++ \" \" else \"\" endif\n          | p in POS, d in DIG, c in COPY ]\n       ;\n\n\n\nModel 2 : \n\n\n% Langford's number problem in MiniZinc.\n%\n% Arrange 2 sets of positive integers 1..k to a sequence,\n% such that, following the first occurence of an integer i,\n% each subsequent occurrence of i, appears i+1 indices later\n% than the last.\n% For example, for k=4, a solution would be 41312432\n\ninclude \"globals.mzn\";\n\nint: k;\nset of int: positionDomain = 1..2*k;\n\narray[positionDomain] of var positionDomain: position;\n% better presentation:\narray[positionDomain] of var 1..k: solution;\n\nsolve :: int_search(position, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..k) (\n     position[i+k] = position[i] + i+1 /\\\n     % hakank: added this\n     solution[position[i]] = i /\\ \n     solution[position[k+i]] = i\n  )\n  /\\   \n  all_different(position)\n  /\\ % symmetry breaking\n  solution[1] < solution[2*k]\n;\n\n\noutput [\n  show(solution), \"\\n\"\n\n];\n\n%\n% data\n%\nk = 4;\n% k = 7;\n% k = 8;\n% k = 10;\n% k = 20;\n\n\n\nModel 3 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"inverse.mzn\";\nconstraint inverse([x[d,c] | d in DIG, c in COPY], y);\n\n%include \"alldifferent.mzn\";\n%constraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n      (x[d,c+1] = x[d,c] + d + 1);\n\n%constraint forall(d in DIG, c in 1..m-1, p in POS)\n%                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve \n      %:: int_search(y, input_order, indomain_min, complete) \n      %:: int_search([x[d,c] | d in DIG, c in COPY], input_order, indomain_min, complete) \n      satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n\n\nModel 4 :\n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\nconstraint forall(d in DIG, c in 1..m-1, p in POS)\n                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve satisfy;\n\noutput [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n"}, "hash": "a29ca633b5d7125a9ae527dc8b7c2b5ba58939fac9bdb367cfee55ef73a515a6", "class_name": "RelatedNodeInfo"}}, "text": "name: Langford's Problem\n\ndescription: Langford's problem is a classic constraint satisfaction problem that involves arranging m copies of digits 1 to n in a sequence such that any two consecutive copies of digit k are separated by k other digits.\n\nvariables: x[d,c], y[p] \nx[d,c] represents the position of the c-th copy of digit d in the sequence, and y[p] represents the digit at position p in the sequence. \n\nconstraints: \nalldifferent([x[d,c] | d in DIG, c in COPY]), \ninverse([x[d,c] | d in DIG, c in COPY], y), \nforall(d in DIG, c in 1..m-1) (x[d,c+1] = x[d,c] + d + 1), \nalldifferent(y), \nforall(d in DIG, c in 1..m-1, p in POS) (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1)\n\nThe first constraint ensures that all positions in the sequence are distinct. The second constraint links the x and y variables. The third constraint ensures that the Langford's condition is satisfied, i.e., any two consecutive copies of digit k are separated by k other digits. The fourth constraint ensures that all digits in the sequence are distinct. The fifth constraint is an alternative way to ensure the Langford's condition.\n\nobjective: satisfy\nThe objective of the problem is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1239, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4583cc66-6dfc-44c1-adc5-8003f6bdfbde": {"__data__": {"id_": "4583cc66-6dfc-44c1-adc5-8003f6bdfbde", "embedding": null, "metadata": {"model_name": "loan", "source_code": "% variables\nvar float: R;        % quarterly repayment\nvar float: P;        % principal initially borrowed\nvar 0.0 .. 10.0: I;  % interest rate\n\n% intermediate variables\nvar float: B1; % balance after one quarter\nvar float: B2; % balance after two quarters\nvar float: B3; % balance after three quarters\nvar float: B4; % balance owing at end\n\nconstraint B1 = P * (1.0 + I) - R;\nconstraint B2 = B1 * (1.0 + I) - R;\nconstraint B3 = B2 * (1.0 + I) - R; \nconstraint B4 = B3 * (1.0 + I) - R;\n\nsolve satisfy;\n\noutput [\n \"Borrowing \", show_float(0, 2, P), \" at \", show(I*100.0), \n \"% interest, and repaying \", show_float(0, 2, R), \n  \"\\nper quarter for 1 year leaves \", show_float(0, 2, B4), \" owing\\n\"\n];\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "loan_expert", "node_type": "4", "metadata": {"model_name": "loan", "source_code": "% variables\nvar float: R;        % quarterly repayment\nvar float: P;        % principal initially borrowed\nvar 0.0 .. 10.0: I;  % interest rate\n\n% intermediate variables\nvar float: B1; % balance after one quarter\nvar float: B2; % balance after two quarters\nvar float: B3; % balance after three quarters\nvar float: B4; % balance owing at end\n\nconstraint B1 = P * (1.0 + I) - R;\nconstraint B2 = B1 * (1.0 + I) - R;\nconstraint B3 = B2 * (1.0 + I) - R; \nconstraint B4 = B3 * (1.0 + I) - R;\n\nsolve satisfy;\n\noutput [\n \"Borrowing \", show_float(0, 2, P), \" at \", show(I*100.0), \n \"% interest, and repaying \", show_float(0, 2, R), \n  \"\\nper quarter for 1 year leaves \", show_float(0, 2, B4), \" owing\\n\"\n];\n\n"}, "hash": "8732ccd88f9aed0cf287c767b3ecc20b22fa851e9bc18f8c70d013d82e003bf0", "class_name": "RelatedNodeInfo"}}, "text": "name: Loan Repayment Problem\n\ndescription: This problem models a loan repayment scenario where a borrower takes a loan with a certain principal amount and interest rate, and repays the loan in quarterly installments over a year. The problem calculates the balance owing at the end of the year.\n\nvariables: R, P, I, B1, B2, B3, B4\nR is the quarterly repayment amount, P is the principal amount borrowed, I is the interest rate, and B1, B2, B3, B4 are the balances owing after each quarter.\n\nconstraints: B1 = P * (1.0 + I) - R, B2 = B1 * (1.0 + I) - R, B3 = B2 * (1.0 + I) - R, B4 = B3 * (1.0 + I) - R\nThese constraints model the balance update after each quarter, where the new balance is the previous balance plus the interest accrued minus the repayment amount.\n\nobjective: satisfy\nThe objective of this problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 934, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ef15b295-f1f1-4741-a03a-c0d15c614c70": {"__data__": {"id_": "ef15b295-f1f1-4741-a03a-c0d15c614c70", "embedding": null, "metadata": {"model_name": "ltsp", "source_code": "int: n; % number of cities\nset of int: CITY = 1..n;\nset of int: POS = 1..n;\narray[CITY] of int: coord; % coordinate of city \nint: m; % number of precedences\nset of int: PREC = 1..m;\narray[PREC] of CITY: left;\narray[PREC] of CITY: right;\n\narray[CITY] of var POS: order;\narray[POS] of var CITY: city;\n\ninclude \"inverse.mzn\";\nconstraint inverse(order,city);\n\nconstraint forall(i in PREC)(order[left[i]] < order[right[i]]);\n\nsolve minimize sum(i in 1..n-1)(abs(coord[city[i]] - coord[city[i+1]]));\n\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ltsp_expert", "node_type": "4", "metadata": {"model_name": "ltsp", "source_code": "int: n; % number of cities\nset of int: CITY = 1..n;\nset of int: POS = 1..n;\narray[CITY] of int: coord; % coordinate of city \nint: m; % number of precedences\nset of int: PREC = 1..m;\narray[PREC] of CITY: left;\narray[PREC] of CITY: right;\n\narray[CITY] of var POS: order;\narray[POS] of var CITY: city;\n\ninclude \"inverse.mzn\";\nconstraint inverse(order,city);\n\nconstraint forall(i in PREC)(order[left[i]] < order[right[i]]);\n\nsolve minimize sum(i in 1..n-1)(abs(coord[city[i]] - coord[city[i+1]]));\n\n\n"}, "hash": "2a09859bfa2142e8751ff32ee19daf60151eee8f9826c2033e72c78fda634012", "class_name": "RelatedNodeInfo"}}, "text": "name: Traveling Salesman Problem with Precedences\n\ndescription: The Traveling Salesman Problem with Precedences is a variant of the classic Traveling Salesman Problem. It involves finding the shortest possible tour that visits a set of cities and returns to the starting city, with the additional constraint that certain cities must be visited in a specific order.\n\nvariables: order \u2208 {1, ..., n}^n, city \u2208 {1, ..., n}^n\nThe decision variables are two arrays, order and city, which represent the order in which the cities are visited. The order array maps each city to its position in the tour, and the city array maps each position in the tour to the corresponding city.\n\nconstraints: \n\u2200i \u2208 PREC, order[left[i]] < order[right[i]]\ninverse(order, city)\nThe constraints ensure that the precedences are respected, i.e., if city A must be visited before city B, then the position of city A in the tour must be less than the position of city B. The inverse constraint ensures that the order and city arrays are inverses of each other, i.e., the position of a city in the tour is equal to the city at that position.\n\nobjective: minimize \u2211(i=1 to n-1) |coord[city[i]] - coord[city[i+1]]|\nThe objective is to minimize the total distance traveled, which is calculated as the sum of the distances between consecutive cities in the tour.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1326, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "37f8eaa5-a03e-48fb-96b3-3bb5b3566536": {"__data__": {"id_": "37f8eaa5-a03e-48fb-96b3-3bb5b3566536", "embedding": null, "metadata": {"model_name": "magic_hexagon", "source_code": "% Magic Hexagon in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nset of int: N = 1..19;\nvar N: a;\nvar N: b;\nvar N: c;\nvar N: d;\nvar N: e;\nvar N: f;\nvar N: g;\nvar N: h;\nvar N: i;\nvar N: j;\nvar N: k;\nvar N: l;\nvar N: m;\nvar N: n;\nvar N: o;\nvar N: p;\nvar N: q;\nvar N: r;\nvar N: s;\n\narray[N] of var N: LD = [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s];\n\nsolve satisfy;\n\nconstraint\n  all_different(LD) /\\\n\n  a + b + c =  38 /\\\n  d + e + f + g =  38 /\\\n  h + i + j + k + l =  38 /\\ \n  m + n + o + p =  38 /\\ \n  q + r + s =  38 /\\ \n  a + d + h =  38 /\\ \n  b + e + i + m =  38 /\\ \n  c + f + j + n + q =  38 /\\ \n  g + k + o + r =  38 /\\ \n  l + p + s =  38 /\\ \n  c + g + l =  38 /\\ \n  b + f + k + p =  38 /\\ \n  a + e + j + o + s =  38 /\\ \n  d + i + n + r =  38 /\\ \n  h + m + q =  38 /\\ \n\n  a < c /\\\n  a < h /\\\n  a < l /\\\n  a < q /\\\n  a < s /\\\n  c < h\n;\n\noutput\n[\n  show(LD)\n];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_hexagon_expert", "node_type": "4", "metadata": {"model_name": "magic_hexagon", "source_code": "% Magic Hexagon in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nset of int: N = 1..19;\nvar N: a;\nvar N: b;\nvar N: c;\nvar N: d;\nvar N: e;\nvar N: f;\nvar N: g;\nvar N: h;\nvar N: i;\nvar N: j;\nvar N: k;\nvar N: l;\nvar N: m;\nvar N: n;\nvar N: o;\nvar N: p;\nvar N: q;\nvar N: r;\nvar N: s;\n\narray[N] of var N: LD = [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s];\n\nsolve satisfy;\n\nconstraint\n  all_different(LD) /\\\n\n  a + b + c =  38 /\\\n  d + e + f + g =  38 /\\\n  h + i + j + k + l =  38 /\\ \n  m + n + o + p =  38 /\\ \n  q + r + s =  38 /\\ \n  a + d + h =  38 /\\ \n  b + e + i + m =  38 /\\ \n  c + f + j + n + q =  38 /\\ \n  g + k + o + r =  38 /\\ \n  l + p + s =  38 /\\ \n  c + g + l =  38 /\\ \n  b + f + k + p =  38 /\\ \n  a + e + j + o + s =  38 /\\ \n  d + i + n + r =  38 /\\ \n  h + m + q =  38 /\\ \n\n  a < c /\\\n  a < h /\\\n  a < l /\\\n  a < q /\\\n  a < s /\\\n  c < h\n;\n\noutput\n[\n  show(LD)\n];"}, "hash": "e72099230cc68d972c2d6761bf2d68acde338b3128379de7681f95d8d64bb6c3", "class_name": "RelatedNodeInfo"}}, "text": "name: Magic Hexagon Problem\n\ndescription: The Magic Hexagon Problem is a classic constraint satisfaction problem where the goal is to find a configuration of numbers in a hexagonal shape such that the sums of numbers along each line and diagonal are equal to a certain value.\n\nvariables: a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s \u2208 {1, ..., 19}\n\nThese variables represent the numbers to be placed in the hexagonal shape.\n\nconstraints: \nall_different(LD) \u2227 \na + b + c = 38 \u2227 \nd + e + f + g = 38 \u2227 \nh + i + j + k + l = 38 \u2227 \nm + n + o + p = 38 \u2227 \nq + r + s = 38 \u2227 \na + d + h = 38 \u2227 \nb + e + i + m = 38 \u2227 \nc + f + j + n + q = 38 \u2227 \ng + k + o + r = 38 \u2227 \nl + p + s = 38 \u2227 \nc + g + l = 38 \u2227 \nb + f + k + p = 38 \u2227 \na + e + j + o + s = 38 \u2227 \nd + i + n + r = 38 \u2227 \nh + m + q = 38 \u2227 \na < c \u2227 \na < h \u2227 \na < l \u2227 \na < q \u2227 \na < s \u2227 \nc < h\n\nThese constraints ensure that all numbers are distinct, the sums of numbers along each line and diagonal are equal to 38, and some additional ordering constraints to break symmetry.\n\nobjective: satisfy\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1193, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a693c877-aa1a-483c-a2a5-42a0b9e4ffef": {"__data__": {"id_": "a693c877-aa1a-483c-a2a5-42a0b9e4ffef", "embedding": null, "metadata": {"model_name": "magic_sequence", "source_code": "Model 1 :\n\n% Magic sequence in MiniZinc.\n% A magic sequence of length n is a sequence of integers x0 . . xn-1 between 0 and n-1, such that for all i in 0 to n-1, the number i occurs exactly xi times in the sequence. For instance, 6,2,1,0,0,0,1,0,0,0 is a magic sequence since 0 occurs 6 times in it, 1 occurs twice, ...\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n  forall(i in 0..n-1) (\n    s[i] = sum(j in 0..n-1) (bool2int(s[j] = i))\n  )\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 2 : \n\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n        forall(i in 0..n-1) (\n                s[i] = sum(j in 0..n-1) (bool2int(s[j]=i))\n        )\n        /\\ \n        sum(i in 0..n-1) (s[i])=n \n        /\\\n        sum(i in 0..n-1) (s[i]*i) =n\n;\n\n\noutput [\n       show(s), \"\\n\",\n];\n\n\n\nModel 3 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  10;\narray[0..n-1] of var 0..n-1: s;\narray[0..n-1] of int: value = array1d(0..n-1, [i | i in 0..n-1]); % helper for distribute\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   distribute(s, value, s)         /\\ \n   sum(i in 0..n-1) (s[i])   = n   /\\\n   sum(i in 0..n-1) (s[i]*i) = n\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 4 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  100;\narray[0..n-1] of var 0..n-1: s;\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   global_cardinality(s,array1d(0..n-1, set2array(index_set(s))), s) :: domain\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\nModel 5 : \n\n\n% Magic squares in MiniZinc\n\ninclude \"globals.mzn\";\n\nint: n = 3;\n\nint: total = ( n * (n*n + 1)) div 2;\narray[1..n,1..n] of var 1..n*n: magic;\n\n\n% solve satisfy;\nsolve :: int_search(\n        [magic[i,j] | i in 1..n, j in 1..n], \n        first_fail,\n        indomain_min,\n        complete) \n    satisfy;\n\n\nconstraint\n\n        all_different([magic[i,j] | i in 1..n, j in 1..n]) :: domain\n        /\\\n        forall(k in 1..n) (\n           sum(i in 1..n) (magic[k,i]) = total % :: domain\n           /\\\n           sum(i in 1..n) (magic[i,k]) = total %:: domain\n        )\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,i]) = total  %:: domain\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,n-i+1]) = total %:: domain\n;\n\n% symmetry breaking\n% Activating all these constraints we get the\n% \"standard\" way of counting the number of solutions:\n%    1, 0, 1, 880, 275305224\n% i.e. this sequence: http://oeis.org/A006052\n%\n% Without the constraints the number of solutions are:\n%  N  #solutions\n%  -------------\n%  1     1\n%  2     0\n%  3     8\n%  4  7040\n%  5  many... \n%\n% constraint\n%    magic[1,1] < magic[1,n]\n%    /\\ magic[1,n] < magic[n,1]\n%    /\\ magic[1,1] < magic[n,n]\n% ;\n\n\noutput [\n  \"Total: \" ++ show(total) ++ \"\\n\"\n] ++\n[\n    %   show(magic)\n  if j = 1 then \"\\n\" else \"\" endif ++\n    if fix(magic[i,j]) < 10 then \" \" else \"\" endif ++\n    show(magic[i,j]) ++ \" \"\n  | i,j in 1..n\n] \n++ \n[\"\\n\"];\n\n\nModel 6 : \n\n\n% Magic square integer programming version in MiniZinc.\n% In recreational mathematics, a magic square of order n is an\n% arrangement of n^2 numbers, usually distinct integers, in a square,\n% such that n numbers in all rows, all columns, and both diagonals sum\n% to the same constant. A normal magic square contains the integers\n% from 1 to n^2.\n\n\n% square order\nint: n = 3; \n\n% integers to be placed\nset of 1..n*n: N = 1..n*n;\n\n% x[i,j,k] = 1 means that cell (i,j) contains integer k\narray[1..n, 1..n, N] of var 0..1: x;\n\narray[1..n, 1..n] of var 1..n*n: square;\n\nvar int: s; % the magic sum\n\nsolve :: int_search(\n        [x[i,j,k] | i,j in 1..n, k in N] ++ \n        [square[i,j] | i,j in 1..n] ++\n        [s],\n        first_fail,\n        indomain_min, \n        complete % \"credit(640, bbs(5))\" % \"complete\"\n      ) \n    satisfy;\n\nconstraint \n  s >= 0 \n  /\\\n  s <= n*n*n\n  /\\\n  % each cell must be assigned exactly one integer\n  forall(i in 1..n, j in 1..n) (\n     sum(k in N) (x[i,j,k]) = 1\n  )\n  /\\\n  % each integer must be assigned exactly to one cell\n  forall(k in N) (\n     sum(i in 1..n, j in 1..n) (x[i,j,k]) = 1\n  )\n\n  /\\\n  % the sum in each row must be the magic sum \n  forall(i in 1..n) (\n     sum(j in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in each column must be the magic sum\n  forall(j in 1..n) (\n     sum(i in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in the diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,i,k]) = s\n\n  /\\\n  % the sum in the co-diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,n-i+1,k]) = s\n\n  /\\\n  % for output\n  forall(i,j in 1..n) ( square[i,j] = sum(k in N) (k * x[i,j,k]))\n;\n\n\noutput [ \n   \"\\ns: \", show(s)\n] ++\n[\n  if  j = 1 then \"\\n\" else \" \" endif ++\n    show(square[i,j]) \n  | i,j in 1..n\n\n] ++ [\"\\n\"];\n\n% printf \"\\n\";\n% printf \"Magic sum is %d\\n\", s;\n% printf \"\\n\";\n% for{i in 1..n}\n% {  printf{j in 1..n} \"%3d\", sum{k in N} k * x[i,j,k];\n%    printf \"\\n\";\n% }\n% printf \"\\n\";"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_sequence_expert", "node_type": "4", "metadata": {"model_name": "magic_sequence", "source_code": "Model 1 :\n\n% Magic sequence in MiniZinc.\n% A magic sequence of length n is a sequence of integers x0 . . xn-1 between 0 and n-1, such that for all i in 0 to n-1, the number i occurs exactly xi times in the sequence. For instance, 6,2,1,0,0,0,1,0,0,0 is a magic sequence since 0 occurs 6 times in it, 1 occurs twice, ...\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n  forall(i in 0..n-1) (\n    s[i] = sum(j in 0..n-1) (bool2int(s[j] = i))\n  )\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 2 : \n\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n        forall(i in 0..n-1) (\n                s[i] = sum(j in 0..n-1) (bool2int(s[j]=i))\n        )\n        /\\ \n        sum(i in 0..n-1) (s[i])=n \n        /\\\n        sum(i in 0..n-1) (s[i]*i) =n\n;\n\n\noutput [\n       show(s), \"\\n\",\n];\n\n\n\nModel 3 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  10;\narray[0..n-1] of var 0..n-1: s;\narray[0..n-1] of int: value = array1d(0..n-1, [i | i in 0..n-1]); % helper for distribute\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   distribute(s, value, s)         /\\ \n   sum(i in 0..n-1) (s[i])   = n   /\\\n   sum(i in 0..n-1) (s[i]*i) = n\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 4 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  100;\narray[0..n-1] of var 0..n-1: s;\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   global_cardinality(s,array1d(0..n-1, set2array(index_set(s))), s) :: domain\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\nModel 5 : \n\n\n% Magic squares in MiniZinc\n\ninclude \"globals.mzn\";\n\nint: n = 3;\n\nint: total = ( n * (n*n + 1)) div 2;\narray[1..n,1..n] of var 1..n*n: magic;\n\n\n% solve satisfy;\nsolve :: int_search(\n        [magic[i,j] | i in 1..n, j in 1..n], \n        first_fail,\n        indomain_min,\n        complete) \n    satisfy;\n\n\nconstraint\n\n        all_different([magic[i,j] | i in 1..n, j in 1..n]) :: domain\n        /\\\n        forall(k in 1..n) (\n           sum(i in 1..n) (magic[k,i]) = total % :: domain\n           /\\\n           sum(i in 1..n) (magic[i,k]) = total %:: domain\n        )\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,i]) = total  %:: domain\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,n-i+1]) = total %:: domain\n;\n\n% symmetry breaking\n% Activating all these constraints we get the\n% \"standard\" way of counting the number of solutions:\n%    1, 0, 1, 880, 275305224\n% i.e. this sequence: http://oeis.org/A006052\n%\n% Without the constraints the number of solutions are:\n%  N  #solutions\n%  -------------\n%  1     1\n%  2     0\n%  3     8\n%  4  7040\n%  5  many... \n%\n% constraint\n%    magic[1,1] < magic[1,n]\n%    /\\ magic[1,n] < magic[n,1]\n%    /\\ magic[1,1] < magic[n,n]\n% ;\n\n\noutput [\n  \"Total: \" ++ show(total) ++ \"\\n\"\n] ++\n[\n    %   show(magic)\n  if j = 1 then \"\\n\" else \"\" endif ++\n    if fix(magic[i,j]) < 10 then \" \" else \"\" endif ++\n    show(magic[i,j]) ++ \" \"\n  | i,j in 1..n\n] \n++ \n[\"\\n\"];\n\n\nModel 6 : \n\n\n% Magic square integer programming version in MiniZinc.\n% In recreational mathematics, a magic square of order n is an\n% arrangement of n^2 numbers, usually distinct integers, in a square,\n% such that n numbers in all rows, all columns, and both diagonals sum\n% to the same constant. A normal magic square contains the integers\n% from 1 to n^2.\n\n\n% square order\nint: n = 3; \n\n% integers to be placed\nset of 1..n*n: N = 1..n*n;\n\n% x[i,j,k] = 1 means that cell (i,j) contains integer k\narray[1..n, 1..n, N] of var 0..1: x;\n\narray[1..n, 1..n] of var 1..n*n: square;\n\nvar int: s; % the magic sum\n\nsolve :: int_search(\n        [x[i,j,k] | i,j in 1..n, k in N] ++ \n        [square[i,j] | i,j in 1..n] ++\n        [s],\n        first_fail,\n        indomain_min, \n        complete % \"credit(640, bbs(5))\" % \"complete\"\n      ) \n    satisfy;\n\nconstraint \n  s >= 0 \n  /\\\n  s <= n*n*n\n  /\\\n  % each cell must be assigned exactly one integer\n  forall(i in 1..n, j in 1..n) (\n     sum(k in N) (x[i,j,k]) = 1\n  )\n  /\\\n  % each integer must be assigned exactly to one cell\n  forall(k in N) (\n     sum(i in 1..n, j in 1..n) (x[i,j,k]) = 1\n  )\n\n  /\\\n  % the sum in each row must be the magic sum \n  forall(i in 1..n) (\n     sum(j in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in each column must be the magic sum\n  forall(j in 1..n) (\n     sum(i in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in the diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,i,k]) = s\n\n  /\\\n  % the sum in the co-diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,n-i+1,k]) = s\n\n  /\\\n  % for output\n  forall(i,j in 1..n) ( square[i,j] = sum(k in N) (k * x[i,j,k]))\n;\n\n\noutput [ \n   \"\\ns: \", show(s)\n] ++\n[\n  if  j = 1 then \"\\n\" else \" \" endif ++\n    show(square[i,j]) \n  | i,j in 1..n\n\n] ++ [\"\\n\"];\n\n% printf \"\\n\";\n% printf \"Magic sum is %d\\n\", s;\n% printf \"\\n\";\n% for{i in 1..n}\n% {  printf{j in 1..n} \"%3d\", sum{k in N} k * x[i,j,k];\n%    printf \"\\n\";\n% }\n% printf \"\\n\";"}, "hash": "2dc921137fe2d0d223ffde2ea0a3e7465f9bd45e4e0ee26a1befcc393bcd93c3", "class_name": "RelatedNodeInfo"}}, "text": "**Model 1, 2, 3, and 4: Magic Sequence**\n\nname: Magic Sequence\n\ndescription: A magic sequence of length n is a sequence of integers x0, ..., xn-1 between 0 and n-1, such that for all i in 0 to n-1, the number i occurs exactly xi times in the sequence.\n\nvariables: s (array of var 0..n-1)\n\nThe decision variable s is an array of length n, where each element si represents the number of times the integer i appears in the sequence.\n\nconstraints: \nforall(i in 0..n-1) (s[i] = sum(j in 0..n-1) (bool2int(s[j] = i)))\nsum(i in 0..n-1) (s[i]) = n\nsum(i in 0..n-1) (s[i]*i) = n\ndistribute(s, value, s)\nglobal_cardinality(s, array1d(0..n-1, set2array(index_set(s))), s)\n\nThe constraints ensure that each number i in the sequence appears exactly si times, the sum of all si is equal to n, and the sum of all si*i is equal to n. The distribute and global_cardinality constraints are used to model the magic sequence property.\n\nobjective: satisfy\n\nThe objective is to find a feasible solution that satisfies all the constraints.\n\n**Model 5: Magic Square**\n\nname: Magic Square\n\ndescription: A magic square of order n is an arrangement of n^2 numbers, usually distinct integers, in a square, such that n numbers in all rows, all columns, and both diagonals sum to the same constant.\n\nvariables: magic (array of var 1..n*n), total (int)\n\nThe decision variable magic is a 2D array of size n x n, where each element magic[i,j] represents the integer in the cell (i,j) of the magic square. The variable total is the magic sum.\n\nconstraints: \nall_different([magic[i,j] | i in 1..n, j in 1..n])\nforall(k in 1..n) (sum(i in 1..n) (magic[k,i]) = total)\nforall(k in 1..n) (sum(i in 1..n) (magic[i,k]) = total)\nsum(i in 1..n) (magic[i,i]) = total\nsum(i in 1..n) (magic[i,n-i+1]) = total\n\nThe constraints ensure that all numbers in the magic square are distinct, the sum of each row, column, and diagonal is equal to the magic sum total.\n\nobjective: satisfy\n\nThe objective is to find a feasible solution that satisfies all the constraints.\n\n**Model 6: Magic Square (Integer Programming Version)**\n\nname: Magic Square (Integer Programming Version)\n\ndescription: A magic square of order n is an arrangement of n^2 numbers, usually distinct integers, in a square, such that n numbers in all rows, all columns, and both diagonals sum to the same constant.\n\nvariables: x (array of var 0..1), square (array of var 1..n*n), s (int)\n\nThe decision variable x is a 3D array of size n x n x n, where x[i,j,k] = 1 if the cell (i,j) contains the integer k. The variable square is a 2D array of size n x n, where square[i,j] represents the integer in the cell (i,j) of the magic square. The variable s is the magic sum.\n\nconstraints: \ns >= 0 /\\ s <= n*n*n\nforall(i in 1..n, j in 1..n) (sum(k in N) (x[i,j,k]) = 1)\nforall(k in N) (sum(i in 1..n, j in 1..n) (x[i,j,k]) = 1)\nforall(i in 1..n) (sum(j in 1..n, k in N) (k * x[i,j,k]) = s)\nforall(j in 1..n) (sum(i in 1..n, k in N) (k * x[i,j,k]) = s)\nsum(i in 1..n, k in N) (k * x[i,i,k]) = s\nsum(i in 1..n, k in N) (k * x[i,n-i+1,k]) = s\nforall(i,j in 1..n) (square[i,j] = sum(k in N) (k * x[i,j,k]))\n\nThe constraints ensure that each cell contains exactly one integer, each integer is assigned to exactly one cell, the sum of each row, column, and diagonal is equal to the magic sum s, and the magic square is correctly constructed.\n\nobjective: satisfy\n\nThe objective is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3442, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9a04da90-8ea4-4bfa-8d66-f882a4711f77": {"__data__": {"id_": "9a04da90-8ea4-4bfa-8d66-f882a4711f77", "embedding": null, "metadata": {"model_name": "maximum_density_still_life", "source_code": "% Maximum density still life in MiniZinc.\n\n% include \"globals.mzn\"; \nint: size = 7; % to change\n\nset of int: objFunctionBoardCoord      = 2..size+1;\nset of int: checkConstraintsBoardCoord = 1..size+2;\nset of int: augmentedBoardCoord        = 0..size+3;\n\n% Search space: The set of all possible assignments of 0s (dead) and 1s (live) \n% to the cells of the board section. However, to be able to easily express \n% constraints on \"boundary\" cells, we take as search space the set of 0/1 \n% boards of size n+4 by n+4: the actual stable pattern appears in the sub-board \n% defined by ignoring the first/last two rows/columns.\narray[augmentedBoardCoord,augmentedBoardCoord] of var 0..1: grid;\n\nvar int: z = sum(r in objFunctionBoardCoord, c in objFunctionBoardCoord) (grid[r,c]);\n\n% Objective function: Maximize the number of live cells in the sub-board defined \n% by ignoring the first/last two/ rows/columns.\n\n\n% solve maximize z;\nsolve :: int_search(\n        [grid[i,j] | i,j in augmentedBoardCoord], \n        smallest, \n        indomain_max, \n        complete) \n    maximize z;\n\nconstraint\n\n  % C1: Cells in the first/last two rows/columns are all 0 (dead)\n  forall(x in augmentedBoardCoord) (\n    grid[0,x] = 0 /\\\n    grid[1,x] = 0 /\\\n    grid[size+2,x] = 0 /\\  \n    grid[size+3,x] = 0 /\\\n    grid[x,0] == 0 /\\       \n    grid[x,1] == 0 /\\\n    grid[x,size+2] = 0 /\\  \n    grid[x,size+3] = 0 \n  )\n  /\\\n  forall(r in checkConstraintsBoardCoord,c in checkConstraintsBoardCoord) (\n    % C2: Each cell of the board (except those of the first/last row/column) \n    %     that has exactly three live neighbors is alive. \n    %     Together with constraint C1, this implies that cells in the\n    %     second/last-but-one row/column cannot have three live neighbors.\n    (\n      ( ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] + \n          grid[r,c-1] + grid[r,c+1] + \n          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1]\n          ) = 3 \n       ) -> (grid[r,c] = 1)\n    )\n    /\\    \n\n    % C3: Each live cell must have 2 or 3 live neighbors (cells of the first/last \n    % row/column may be ignored by this constraint)\n    (\n       (grid[r,c] = 1) -> \n                      (\n                        2 <= \n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          )\n                        /\\\n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          ) <= 3\n                      )\n    )\n  )\n  \n  /\\\n  % SBSO: Symmetry-breaking by selective ordering\n  % The assignment is forced to respect an ordering on the values that occur in corner entries\n  % of the board. In particular:  \n  % - if the NW-corner cell is dead, the SE-corner cell\n  % must be dead too \n  % - if the NE-corner cell is dead, the SW-corner cell must be dead too\n  % \n  grid[2,2] >= grid[size+1,size+1] /\\\n  grid[2,size+1] >= grid[size+1,2]\n;\n\n\noutput [\n  if j = 0 then \"\\n\" else \" \" endif ++\n    show(grid[i,j])\n  | i,j in augmentedBoardCoord\n];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "maximum_density_still_life_expert", "node_type": "4", "metadata": {"model_name": "maximum_density_still_life", "source_code": "% Maximum density still life in MiniZinc.\n\n% include \"globals.mzn\"; \nint: size = 7; % to change\n\nset of int: objFunctionBoardCoord      = 2..size+1;\nset of int: checkConstraintsBoardCoord = 1..size+2;\nset of int: augmentedBoardCoord        = 0..size+3;\n\n% Search space: The set of all possible assignments of 0s (dead) and 1s (live) \n% to the cells of the board section. However, to be able to easily express \n% constraints on \"boundary\" cells, we take as search space the set of 0/1 \n% boards of size n+4 by n+4: the actual stable pattern appears in the sub-board \n% defined by ignoring the first/last two rows/columns.\narray[augmentedBoardCoord,augmentedBoardCoord] of var 0..1: grid;\n\nvar int: z = sum(r in objFunctionBoardCoord, c in objFunctionBoardCoord) (grid[r,c]);\n\n% Objective function: Maximize the number of live cells in the sub-board defined \n% by ignoring the first/last two/ rows/columns.\n\n\n% solve maximize z;\nsolve :: int_search(\n        [grid[i,j] | i,j in augmentedBoardCoord], \n        smallest, \n        indomain_max, \n        complete) \n    maximize z;\n\nconstraint\n\n  % C1: Cells in the first/last two rows/columns are all 0 (dead)\n  forall(x in augmentedBoardCoord) (\n    grid[0,x] = 0 /\\\n    grid[1,x] = 0 /\\\n    grid[size+2,x] = 0 /\\  \n    grid[size+3,x] = 0 /\\\n    grid[x,0] == 0 /\\       \n    grid[x,1] == 0 /\\\n    grid[x,size+2] = 0 /\\  \n    grid[x,size+3] = 0 \n  )\n  /\\\n  forall(r in checkConstraintsBoardCoord,c in checkConstraintsBoardCoord) (\n    % C2: Each cell of the board (except those of the first/last row/column) \n    %     that has exactly three live neighbors is alive. \n    %     Together with constraint C1, this implies that cells in the\n    %     second/last-but-one row/column cannot have three live neighbors.\n    (\n      ( ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] + \n          grid[r,c-1] + grid[r,c+1] + \n          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1]\n          ) = 3 \n       ) -> (grid[r,c] = 1)\n    )\n    /\\    \n\n    % C3: Each live cell must have 2 or 3 live neighbors (cells of the first/last \n    % row/column may be ignored by this constraint)\n    (\n       (grid[r,c] = 1) -> \n                      (\n                        2 <= \n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          )\n                        /\\\n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          ) <= 3\n                      )\n    )\n  )\n  \n  /\\\n  % SBSO: Symmetry-breaking by selective ordering\n  % The assignment is forced to respect an ordering on the values that occur in corner entries\n  % of the board. In particular:  \n  % - if the NW-corner cell is dead, the SE-corner cell\n  % must be dead too \n  % - if the NE-corner cell is dead, the SW-corner cell must be dead too\n  % \n  grid[2,2] >= grid[size+1,size+1] /\\\n  grid[2,size+1] >= grid[size+1,2]\n;\n\n\noutput [\n  if j = 0 then \"\\n\" else \" \" endif ++\n    show(grid[i,j])\n  | i,j in augmentedBoardCoord\n];\n"}, "hash": "e8252b5257e5495a900bce805a9b6067fa233e230233090181ace3f8be5d48b6", "class_name": "RelatedNodeInfo"}}, "text": "name: Maximum Density Still Life\n\ndescription: The Maximum Density Still Life problem is a classic problem in constraint programming, which involves finding a stable pattern of live and dead cells in a grid, such that the density of live cells is maximized. The problem is inspired by Conway's Game of Life, where live cells follow certain rules to survive or die in each generation. In this problem, the goal is to find a pattern that is stable, meaning it does not change over time, and has the maximum number of live cells.\n\nvariables: `grid[r,c]` for `r, c in augmentedBoardCoord`\n\nThe decision variables are the elements of the `grid` array, which represent the state of each cell in the grid. The value of `grid[r,c]` is 0 if the cell at row `r` and column `c` is dead, and 1 if it is live.\n\nconstraints: \n`grid[0,x] = 0 /\\ grid[1,x] = 0 /\\ grid[size+2,x] = 0 /\\ grid[size+3,x] = 0 /\\ grid[x,0] == 0 /\\ grid[x,1] == 0 /\\ grid[x,size+2] = 0 /\\ grid[x,size+3] = 0` for `x in augmentedBoardCoord`\n`((grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] + grid[r,c-1] + grid[r,c+1] + grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] ) = 3) -> (grid[r,c] = 1)` for `r, c in checkConstraintsBoardCoord`\n`(grid[r,c] = 1) -> (2 <= (grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] + grid[r,c-1] + grid[r,c+1] + grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] ) <= 3)` for `r, c in checkConstraintsBoardCoord`\n`grid[2,2] >= grid[size+1,size+1] /\\ grid[2,size+1] >= grid[size+1,2]`\n\nThe constraints ensure that the pattern is stable and follows the rules of Conway's Game of Life. The first constraint sets the boundary cells to be dead. The second constraint ensures that each cell with exactly three live neighbors is alive. The third constraint ensures that each live cell has two or three live neighbors. The last constraint is a symmetry-breaking constraint, which forces the assignment to respect an ordering on the values that occur in corner entries of the board.\n\nobjective: Maximize `z = sum(r in objFunctionBoardCoord, c in objFunctionBoardCoord) (grid[r,c])`\n\nThe objective is to maximize the number of live cells in the grid, which is represented by the variable `z`.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2153, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b9fd314b-802c-4389-96aa-e89e6b04066f": {"__data__": {"id_": "b9fd314b-802c-4389-96aa-e89e6b04066f", "embedding": null, "metadata": {"model_name": "mip", "source_code": "Model 1 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.0*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 2 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\n\nsolve maximize 1.0*B - 1.0*C + 1.0*D;\nconstraint 2.0*B - 1.0*C + 2.0*D <=  4.0;\nconstraint 2.0*B - 3.0*C + 1.0*D <= -5.0;\nconstraint -1.0*B + 1.0*C - 2.0*D <= -1.0;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 3 :\n\n\nvar int: B;\nvar int: C;\nvar int: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.5*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 4 :\n\n\nsolve maximize 21*x + 11*y;\n\nvar int: x;\nvar int: y;\nconstraint 7*x + 4*y <= 13;\nconstraint x >= 0 /\\ y >= 0; \n\n\n\nModel 5 : \n\n\nsolve maximize 8*x + 5*y;\n\nvar int: x;\nvar int: y;\nconstraint x + y <= 6;\nconstraint 9*x + 5*y <= 45;\nconstraint x >= 0 /\\ y >= 0; \n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "mip_expert", "node_type": "4", "metadata": {"model_name": "mip", "source_code": "Model 1 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.0*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 2 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\n\nsolve maximize 1.0*B - 1.0*C + 1.0*D;\nconstraint 2.0*B - 1.0*C + 2.0*D <=  4.0;\nconstraint 2.0*B - 3.0*C + 1.0*D <= -5.0;\nconstraint -1.0*B + 1.0*C - 2.0*D <= -1.0;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 3 :\n\n\nvar int: B;\nvar int: C;\nvar int: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.5*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 4 :\n\n\nsolve maximize 21*x + 11*y;\n\nvar int: x;\nvar int: y;\nconstraint 7*x + 4*y <= 13;\nconstraint x >= 0 /\\ y >= 0; \n\n\n\nModel 5 : \n\n\nsolve maximize 8*x + 5*y;\n\nvar int: x;\nvar int: y;\nconstraint x + y <= 6;\nconstraint 9*x + 5*y <= 45;\nconstraint x >= 0 /\\ y >= 0; \n"}, "hash": "1a2401fe73151efc79e09566eb804fe077f4d957d0399e161c047b4a7cee0324", "class_name": "RelatedNodeInfo"}}, "text": "name: Linear Programming Problem\n\ndescription: This is a classic Linear Programming Problem, which involves finding the optimal values of decision variables to maximize or minimize a linear objective function, subject to a set of linear constraints.\n\nvariables: x, y, B, C, D\nThese variables represent the quantities of different items or resources that need to be optimized. In the context of Linear Programming, they are often referred to as decision variables.\n\nconstraints: \n2.0*B + 2.0*C + 1.0*D <= 30.0, \n1.0*B + 2.0*C + 3.0*D <= 25.0, \n2.0*B + 1.0*C + 1.0*D <= 20.0, \n7*x + 4*y <= 13, \nx + y <= 6, \n9*x + 5*y <= 45, \n2.0*B - 1.0*C + 2.0*D <= 4.0, \n2.0*B - 3.0*C + 1.0*D <= -5.0, \n-1.0*B + 1.0*C - 2.0*D <= -1.0, \nB >= 0, C >= 0, D >= 0, x >= 0, y >= 0\nThese constraints represent the limitations and restrictions on the values of the decision variables. They can be interpreted as resource constraints, capacity constraints, or other types of limitations that need to be satisfied.\n\nobjective: Maximize 3.0*B + 1.0*C + 3.0*D, Maximize 1.0*B - 1.0*C + 1.0*D, Maximize 21*x + 11*y, Maximize 8*x + 5*y\nThe objective of the problem is to maximize the given linear function, which represents the profit, revenue, or other performance metric that needs to be optimized.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1270, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1a8a84ee-699c-411c-8c78-6001da0bd9ce": {"__data__": {"id_": "1a8a84ee-699c-411c-8c78-6001da0bd9ce", "embedding": null, "metadata": {"model_name": "missing_solution", "source_code": "% Missing Solutions\nint: n; % no of people\nset of int: PERSON = 1..n;\nint: male = 1; int: female = 2;\nset of int: GENDER = male..female;\narray[PERSON] of GENDER: gender;\narray[PERSON] of int: age;\n\narray[1..n] of var PERSON: order;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(order);\n\n% males and females alternate\nconstraint forall(i in 1..n)\n                 (i mod 2 = 0 <-> gender[order[i]] = female);\n\n% age does not grow bu more than 10\nconstraint forall(i in 1..n-1)\n                 (age[order[i+1]] - age[order[i]] <= 10);\n\nsolve satisfy;\n\noutput [ show(order), \"\\n\"] ++\n       [\"[\"] ++ [ show(age[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                | i in 1..n ] ++\n       [\"[\"] ++ [ show(gender[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                 | i in 1..n ];\n\n\n%n = 6;\n%gender = [male,male,male,female,female,female];\n%age = [13, 25, 34, 40, 16, 13];\n\nn = 5;\ngender = [male,male,female,female,female];\nage = [13,25,34,40,16];\n\n%order = [4,2,3,1,5];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "missing_solution_expert", "node_type": "4", "metadata": {"model_name": "missing_solution", "source_code": "% Missing Solutions\nint: n; % no of people\nset of int: PERSON = 1..n;\nint: male = 1; int: female = 2;\nset of int: GENDER = male..female;\narray[PERSON] of GENDER: gender;\narray[PERSON] of int: age;\n\narray[1..n] of var PERSON: order;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(order);\n\n% males and females alternate\nconstraint forall(i in 1..n)\n                 (i mod 2 = 0 <-> gender[order[i]] = female);\n\n% age does not grow bu more than 10\nconstraint forall(i in 1..n-1)\n                 (age[order[i+1]] - age[order[i]] <= 10);\n\nsolve satisfy;\n\noutput [ show(order), \"\\n\"] ++\n       [\"[\"] ++ [ show(age[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                | i in 1..n ] ++\n       [\"[\"] ++ [ show(gender[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                 | i in 1..n ];\n\n\n%n = 6;\n%gender = [male,male,male,female,female,female];\n%age = [13, 25, 34, 40, 16, 13];\n\nn = 5;\ngender = [male,male,female,female,female];\nage = [13,25,34,40,16];\n\n%order = [4,2,3,1,5];\n"}, "hash": "eb1e32b492504ac3a0638c51b0df8ec5c5800d984f94f0a5144eae5696e46116", "class_name": "RelatedNodeInfo"}}, "text": "name: Alternating Marriage Problem\n\ndescription: This problem involves arranging a sequence of people of different genders and ages in a specific order, subject to certain constraints. The goal is to find an ordering that satisfies the conditions.\n\nvariables: order \u2208 {1, ..., n}^n\nThe decision variable is an array `order` of length `n`, where each element `order[i]` represents the person at position `i` in the sequence.\n\nconstraints: \nalldifferent(order)\n\u2200i \u2208 {1, ..., n} : (i mod 2 = 0 \u2194 gender[order[i]] = female)\n\u2200i \u2208 {1, ..., n-1} : age[order[i+1]] - age[order[i]] \u2264 10\n\nThe constraints are:\n- `alldifferent(order)`: Each person must appear exactly once in the sequence.\n- `\u2200i \u2208 {1, ..., n} : (i mod 2 = 0 \u2194 gender[order[i]] = female)`: Males and females must alternate in the sequence.\n- `\u2200i \u2208 {1, ..., n-1} : age[order[i+1]] - age[order[i]] \u2264 10`: The age difference between consecutive people in the sequence must not exceed 10.\n\nobjective: satisfy\nThe objective is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific value.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1081, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a701b1cb-c7e6-407a-a6f8-24eea868051c": {"__data__": {"id_": "a701b1cb-c7e6-407a-a6f8-24eea868051c", "embedding": null, "metadata": {"model_name": "nonogram_create_automaton2", "source_code": "Model 1 :\n\n% Nonoram solver using regular and is written in all-MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: rows;\nint: row_rule_len;\narray[1..rows, 1..row_rule_len] of int: row_rules;\nint: cols;\nint: col_rule_len;\narray[1..cols, 1..col_rule_len] of int: col_rules;\n\n\narray[1..rows, 1..cols] of var 1..2: x;\n\nsolve :: int_search(\n     [x[i,j] | j in 1..cols, i in 1..rows], \n     first_fail, \n     indomain_min, \n     complete) \nsatisfy;\n\n%\n% The approach is rather simple:\n%  - zero_positions is a set of the positions in the state table where the \n%    state 0 should be, which also correspond to the state of the pattern \"0\"\n%  - when this have been identified everything else comes to rest\n%\n% On the other hand, the calculation of the states is hairy, very hairy.\n%\npredicate make_automaton(array[int] of var int: x, array[int] of int: pattern) =\n    let {\n        int: n = length(pattern),\n        % fix for \"zero clues\"\n        int: len = max(length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern),1),\n        int: leading_zeros = sum(i in 1..n) (bool2int(pattern[i] = 0)),\n        set of int: zero_positions = {sum(j in 1..i) (pattern[j]+1) -leading_zeros | i in 1..n where pattern[i] > 0},\n       array[1..2*len] of 0..len*2: states = \n     if (length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern)) = 0 then \n       [1,1]  % fix for \"zero clues\"\n     else \n    [1, 2] ++\n    [\n       if i div 2 in zero_positions then\n           if i mod 2 = 0 then\n            0\n           else\n            (i div 2) + 1\n           endif\n       elseif (i-1) div 2 in zero_positions then\n           if i mod 2 = 0 then\n            (i div 2)+1\n           else\n            (i div 2)+2\n           endif\n       else\n         if not( (((i-1) div 2) - 1) in zero_positions) then\n            if i mod 2 = 0 then\n               (i div 2) + 1\n            else \n              if (i div 2) + 1 in zero_positions then\n                  (i div 2) + 2\n              else \n                  0\n              endif\n            endif\n          else\n             if i mod 2 = 0 then\n                 (i div 2) + 1\n             else \n                if not((i div 2) + 1 in zero_positions) then\n                   0\n                else \n                   (i div 2) + 2 \n                endif\n             endif\n          endif\n       endif\n    | i in 3..2*(len-1)]\n    ++\n    [len, 0]\n    endif\n    } \n    in\n    regular(\n       x,\n       len, \n       2, \n       array2d(1..len, 1..2, states),\n       1, \n       {len}) % :: domain\n;\n\nconstraint\n\n      forall(j in 1..cols) (\n        make_automaton([x[i,j] | i in 1..rows], [col_rules[j,k] | k in 1..col_rule_len])\n      )\n      /\\\n      forall(i in 1..rows) (\n        make_automaton([x[i,j] | j in 1..cols], [row_rules[i,k] | k in 1..row_rule_len])\n      )\n\n;\n\noutput \n[\n  if j = 1 then \"\\n\" else \"\" endif ++\n     if fix(x[i,j]) = 1 then \" \" else \"#\" endif\n    \n  | i in 1..rows, j in 1..cols\n] \n++ \n[\n  \"\\n\"\n];\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\nint: X;\nint: Y;\n\nint: maxlen;\n\narray [1..Y,1..maxlen] of int: rows;\n\narray [1..X,1..maxlen] of int: cols;\n\narray[1..2, 1..2, 1..2] of 0..1: nonmul = \n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 1, 1,\n         1, 0, 0, 1]\n    );\n\narray[1..2, 1..2, 1..2] of 0..1: nonadd =\n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 0, 1,\n         1, 0, 0, 1]\n    );\n\n% variables\n%\narray[1..Y, 1..X] of var 1..2: A;\n\n% All variables in a region must be different\n% Ordering to ensure each variable is handled exactly once\npredicate nonogram_row(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: row) =\n    nonogram([A[row, v] | v in 1..X], cons);\n\npredicate nonogram_col(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: col) = \n    nonogram([A[v,col] | v in 1..Y], cons);\n\npredicate nonogram(array[int] of var 1..2: A, array [int] of int: cons) = \n    let {\n          int: n = if cons[1] = 0 then 0 else max(index_set(cons)) endif,\n          array [1..n + 1, 1..2] of int: consarr =\n              if cons[1] = 0 then [|1, 0|] \n              else array2d(1..n + 1, 1..2,\n                [1, 2] ++\n                [    i * nonmul[cons[i - 1] + 1, cons[i] + 1, s] + \n                     nonadd[cons[i - 1] + 1, cons[i] + 1, s] \n                     | i in 2..n, s in 1..2 \n                ] ++ \n                [n+1,0]\n              )\n              endif\n     } in (\n         regular(A, n + 1, 2, consarr, 1, {n + 1})\n     );\n\nconstraint forall(i in 1..Y) (\n    nonogram_row(A, [rows[i, j] | j in 1..maxlen where rows[i, j] >= 0], i)\n);\n\nconstraint forall(i in 1..X) (\n    nonogram_col(A, [cols[i, j] | j in 1..maxlen where cols[i, j] >= 0], i)\n);\n\nsolve :: int_search(array1d(1..X*Y,A),input_order,indomain_max,complete) satisfy;\n\noutput [\n    if fix(A[r, c]) = 1 then \" \" else \".\" endif ++ \n    if c = Y then \"\\n\" else \" \" endif\n    | r in 1..X, c in 1..Y\n];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "nonogram_create_automaton2_expert", "node_type": "4", "metadata": {"model_name": "nonogram_create_automaton2", "source_code": "Model 1 :\n\n% Nonoram solver using regular and is written in all-MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: rows;\nint: row_rule_len;\narray[1..rows, 1..row_rule_len] of int: row_rules;\nint: cols;\nint: col_rule_len;\narray[1..cols, 1..col_rule_len] of int: col_rules;\n\n\narray[1..rows, 1..cols] of var 1..2: x;\n\nsolve :: int_search(\n     [x[i,j] | j in 1..cols, i in 1..rows], \n     first_fail, \n     indomain_min, \n     complete) \nsatisfy;\n\n%\n% The approach is rather simple:\n%  - zero_positions is a set of the positions in the state table where the \n%    state 0 should be, which also correspond to the state of the pattern \"0\"\n%  - when this have been identified everything else comes to rest\n%\n% On the other hand, the calculation of the states is hairy, very hairy.\n%\npredicate make_automaton(array[int] of var int: x, array[int] of int: pattern) =\n    let {\n        int: n = length(pattern),\n        % fix for \"zero clues\"\n        int: len = max(length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern),1),\n        int: leading_zeros = sum(i in 1..n) (bool2int(pattern[i] = 0)),\n        set of int: zero_positions = {sum(j in 1..i) (pattern[j]+1) -leading_zeros | i in 1..n where pattern[i] > 0},\n       array[1..2*len] of 0..len*2: states = \n     if (length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern)) = 0 then \n       [1,1]  % fix for \"zero clues\"\n     else \n    [1, 2] ++\n    [\n       if i div 2 in zero_positions then\n           if i mod 2 = 0 then\n            0\n           else\n            (i div 2) + 1\n           endif\n       elseif (i-1) div 2 in zero_positions then\n           if i mod 2 = 0 then\n            (i div 2)+1\n           else\n            (i div 2)+2\n           endif\n       else\n         if not( (((i-1) div 2) - 1) in zero_positions) then\n            if i mod 2 = 0 then\n               (i div 2) + 1\n            else \n              if (i div 2) + 1 in zero_positions then\n                  (i div 2) + 2\n              else \n                  0\n              endif\n            endif\n          else\n             if i mod 2 = 0 then\n                 (i div 2) + 1\n             else \n                if not((i div 2) + 1 in zero_positions) then\n                   0\n                else \n                   (i div 2) + 2 \n                endif\n             endif\n          endif\n       endif\n    | i in 3..2*(len-1)]\n    ++\n    [len, 0]\n    endif\n    } \n    in\n    regular(\n       x,\n       len, \n       2, \n       array2d(1..len, 1..2, states),\n       1, \n       {len}) % :: domain\n;\n\nconstraint\n\n      forall(j in 1..cols) (\n        make_automaton([x[i,j] | i in 1..rows], [col_rules[j,k] | k in 1..col_rule_len])\n      )\n      /\\\n      forall(i in 1..rows) (\n        make_automaton([x[i,j] | j in 1..cols], [row_rules[i,k] | k in 1..row_rule_len])\n      )\n\n;\n\noutput \n[\n  if j = 1 then \"\\n\" else \"\" endif ++\n     if fix(x[i,j]) = 1 then \" \" else \"#\" endif\n    \n  | i in 1..rows, j in 1..cols\n] \n++ \n[\n  \"\\n\"\n];\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\nint: X;\nint: Y;\n\nint: maxlen;\n\narray [1..Y,1..maxlen] of int: rows;\n\narray [1..X,1..maxlen] of int: cols;\n\narray[1..2, 1..2, 1..2] of 0..1: nonmul = \n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 1, 1,\n         1, 0, 0, 1]\n    );\n\narray[1..2, 1..2, 1..2] of 0..1: nonadd =\n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 0, 1,\n         1, 0, 0, 1]\n    );\n\n% variables\n%\narray[1..Y, 1..X] of var 1..2: A;\n\n% All variables in a region must be different\n% Ordering to ensure each variable is handled exactly once\npredicate nonogram_row(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: row) =\n    nonogram([A[row, v] | v in 1..X], cons);\n\npredicate nonogram_col(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: col) = \n    nonogram([A[v,col] | v in 1..Y], cons);\n\npredicate nonogram(array[int] of var 1..2: A, array [int] of int: cons) = \n    let {\n          int: n = if cons[1] = 0 then 0 else max(index_set(cons)) endif,\n          array [1..n + 1, 1..2] of int: consarr =\n              if cons[1] = 0 then [|1, 0|] \n              else array2d(1..n + 1, 1..2,\n                [1, 2] ++\n                [    i * nonmul[cons[i - 1] + 1, cons[i] + 1, s] + \n                     nonadd[cons[i - 1] + 1, cons[i] + 1, s] \n                     | i in 2..n, s in 1..2 \n                ] ++ \n                [n+1,0]\n              )\n              endif\n     } in (\n         regular(A, n + 1, 2, consarr, 1, {n + 1})\n     );\n\nconstraint forall(i in 1..Y) (\n    nonogram_row(A, [rows[i, j] | j in 1..maxlen where rows[i, j] >= 0], i)\n);\n\nconstraint forall(i in 1..X) (\n    nonogram_col(A, [cols[i, j] | j in 1..maxlen where cols[i, j] >= 0], i)\n);\n\nsolve :: int_search(array1d(1..X*Y,A),input_order,indomain_max,complete) satisfy;\n\noutput [\n    if fix(A[r, c]) = 1 then \" \" else \".\" endif ++ \n    if c = Y then \"\\n\" else \" \" endif\n    | r in 1..X, c in 1..Y\n];"}, "hash": "86fab21b6b801b438f931cf77b8d9c7099634fe2de611c24f69e02414f6085b6", "class_name": "RelatedNodeInfo"}}, "text": "name: Nonogram\n\ndescription: A Nonogram is a puzzle where a set of clues are given to fill in a grid with two colors (usually black and white). The clues are given in the form of row and column constraints, specifying the sequence of colors in each row and column. The goal is to fill in the grid such that the clues are satisfied.\n\nvariables: A[i, j] for i in 1..Y, j in 1..X, where A[i, j] \u2208 {1, 2}\n\nThe variables A[i, j] represent the color of the cell at row i and column j in the grid, where 1 and 2 correspond to the two colors.\n\nconstraints: \n\u2200i in 1..Y, nonogram_row(A, [rows[i, j] | j in 1..maxlen where rows[i, j] >= 0], i)\n\u2200i in 1..X, nonogram_col(A, [cols[i, j] | j in 1..maxlen where cols[i, j] >= 0], i)\n\nThe constraints ensure that the row and column constraints are satisfied. The nonogram_row and nonogram_col predicates enforce the regular expression constraints for each row and column, respectively.\n\nobjective: The objective is to find a feasible solution that satisfies all the constraints, i.e., to fill in the grid such that all row and column constraints are met. There is no objective function to minimize or maximize.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1144, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0c874774-53da-446e-8309-de99c5d1bab3": {"__data__": {"id_": "0c874774-53da-446e-8309-de99c5d1bab3", "embedding": null, "metadata": {"model_name": "nurses", "source_code": "Model 1 : \n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint forall(d in DAY)\n                 (global_cardinality_low_up([x[n,d] | n in NURSE ],                                               [ day, night ], [ o, l ], [o, u])); \n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n\n\nModel 2 :\n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\nconstraint forall(d in DAY)\n                 (let {var int: on = sum(n in NURSE)\n                                        (bool2int(x[n,d]=night))        \n                      } in l <= on /\\ on <= u);\n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "nurses_expert", "node_type": "4", "metadata": {"model_name": "nurses", "source_code": "Model 1 : \n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint forall(d in DAY)\n                 (global_cardinality_low_up([x[n,d] | n in NURSE ],                                               [ day, night ], [ o, l ], [o, u])); \n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n\n\nModel 2 :\n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\nconstraint forall(d in DAY)\n                 (let {var int: on = sum(n in NURSE)\n                                        (bool2int(x[n,d]=night))        \n                      } in l <= on /\\ on <= u);\n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n"}, "hash": "26fa94a1732228cdb1e129d54eab554d18fab1bb662bb48a68f35ff7ba196712", "class_name": "RelatedNodeInfo"}}, "text": "name: Nurse Scheduling Problem\n\ndescription: The Nurse Scheduling Problem is a classic constraint satisfaction problem that involves creating a schedule for a set of nurses over a set of days, where each nurse can be assigned to one of three shifts: day, night, or day off. The problem aims to find a schedule that satisfies certain constraints, such as ensuring that a nurse who works two consecutive night shifts gets a day off on the third day, and that the number of nurses working night shifts on each day is within a certain range.\n\nvariables: x[n,d] \u2208 {1, 2, 3} \u2200n \u2208 NURSE, \u2200d \u2208 DAY\nThe decision variables x[n,d] represent the shift assigned to nurse n on day d, where 1 corresponds to a day shift, 2 corresponds to a night shift, and 3 corresponds to a day off.\n\nconstraints: \n1. \u2200n \u2208 NURSE, \u2200d \u2208 1..m-2: (x[n,d] = 2 \u2227 x[n,d+1] = 2) \u2192 x[n,d+2] = 3\nThis constraint ensures that if a nurse works two consecutive night shifts, they get a day off on the third day.\n\n2. \u2200n \u2208 NURSE, \u2200d \u2208 1..m-1: x[n,d] = 2 \u2192 x[n,d+1] \u2260 1\nThis constraint ensures that a nurse who works a night shift on one day does not work a day shift on the next day.\n\n3. \u2200d \u2208 DAY: l \u2264 \u2211(n \u2208 NURSE) (bool2int(x[n,d] = 2)) \u2264 u\nThis constraint ensures that the number of nurses working night shifts on each day is within the range [l, u].\n\nobjective: satisfy\nThe objective of the problem is to find a schedule that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1468, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3958f0e1-15cf-4742-b2ff-e9eedc06f4e0": {"__data__": {"id_": "3958f0e1-15cf-4742-b2ff-e9eedc06f4e0", "embedding": null, "metadata": {"model_name": "opd", "source_code": "%% Design of Collateralised Debt Obligations Squared (CDO^2) Transactions\n% An OPD (v, b, r) problem is to find a binary matrix of v rows\n% and b columns such that each row sums to r, and\n% the dot product beween any pair of distinct rows is minimal.\n\n%Requires MiniZinc >= 2.0.2 for the symmetry_breaking_constraint predicate\n\ninclude \"lex_greatereq.mzn\";\n\n%instance data\nint: v;\nint: b;\nint: r;\n\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\n\n%computing a lower bound for lambda\nint: rv = r*v;\nint: rvmodb = rv mod b;\nint: floorrv = rv div b;\nint: ceilrv = rv div b + bool2int(rv mod b != 0);\nint: num = (ceilrv*ceilrv*rvmodb+floorrv*floorrv*(b-rvmodb)-rv);\nint: denom = v*(v-1);\nint: lb_lambda = num div denom + bool2int( num mod denom !=0);\n\n% This line is there for debugging purposes, it can be safely removed\nint: tmp = trace(\"Computed lower bound for lambda: \"++show(lb_lambda)++\"\\n\",lb_lambda);\n\n\n% lambda is called objective for the MiniZinc Challenge\nvar lb_lambda..b: objective;\n\n\narray [rows, cols] of var 0..1: m;\n\n\n% Every row must sum to r.\nconstraint forall (i in rows) (sum (j in cols) (m[i, j]) = r);\n\n% The dot product of every pair of distinct rows must be at most lambda for an OPD and a PD, and equal to lambda for a BIBD\nconstraint forall (i_a, i_b in rows where i_a < i_b) (\n    sum (j in cols) (m[i_a, j] * m[i_b, j]) <= objective\n);\n\n\n% Break row symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(i in rows diff {max(rows)})(\n        lex_greatereq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    )\n);\n% Break column symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(j in cols diff {max(cols)})(\n        lex_greatereq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    )\n);\n\n\nsolve \n    :: seq_search([int_search([m[i, j] | i in rows, j in cols], input_order, indomain_max, complete),\n       \t\t   int_search([objective], input_order,indomain_min,complete)])\n    minimize objective; \n\n\n% Disabled the full solution. Printing only the objective value, lower bound, and parameters.\noutput  [\"opd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r), \"). Found lambda = \", show(objective),\"\\tlb: \", show(lb_lambda)]\n%       ++[\"\\n\\n\"] ++ \n%\t[ ( if j > b then \"\\n\" else \n%\t        if fix(m[i,j])=1 then \"*\" else \" \" endif\n%\t    endif )\n%       | i in rows, j in 1..(b + 1) ]\n;"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "opd_expert", "node_type": "4", "metadata": {"model_name": "opd", "source_code": "%% Design of Collateralised Debt Obligations Squared (CDO^2) Transactions\n% An OPD (v, b, r) problem is to find a binary matrix of v rows\n% and b columns such that each row sums to r, and\n% the dot product beween any pair of distinct rows is minimal.\n\n%Requires MiniZinc >= 2.0.2 for the symmetry_breaking_constraint predicate\n\ninclude \"lex_greatereq.mzn\";\n\n%instance data\nint: v;\nint: b;\nint: r;\n\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\n\n%computing a lower bound for lambda\nint: rv = r*v;\nint: rvmodb = rv mod b;\nint: floorrv = rv div b;\nint: ceilrv = rv div b + bool2int(rv mod b != 0);\nint: num = (ceilrv*ceilrv*rvmodb+floorrv*floorrv*(b-rvmodb)-rv);\nint: denom = v*(v-1);\nint: lb_lambda = num div denom + bool2int( num mod denom !=0);\n\n% This line is there for debugging purposes, it can be safely removed\nint: tmp = trace(\"Computed lower bound for lambda: \"++show(lb_lambda)++\"\\n\",lb_lambda);\n\n\n% lambda is called objective for the MiniZinc Challenge\nvar lb_lambda..b: objective;\n\n\narray [rows, cols] of var 0..1: m;\n\n\n% Every row must sum to r.\nconstraint forall (i in rows) (sum (j in cols) (m[i, j]) = r);\n\n% The dot product of every pair of distinct rows must be at most lambda for an OPD and a PD, and equal to lambda for a BIBD\nconstraint forall (i_a, i_b in rows where i_a < i_b) (\n    sum (j in cols) (m[i_a, j] * m[i_b, j]) <= objective\n);\n\n\n% Break row symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(i in rows diff {max(rows)})(\n        lex_greatereq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    )\n);\n% Break column symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(j in cols diff {max(cols)})(\n        lex_greatereq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    )\n);\n\n\nsolve \n    :: seq_search([int_search([m[i, j] | i in rows, j in cols], input_order, indomain_max, complete),\n       \t\t   int_search([objective], input_order,indomain_min,complete)])\n    minimize objective; \n\n\n% Disabled the full solution. Printing only the objective value, lower bound, and parameters.\noutput  [\"opd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r), \"). Found lambda = \", show(objective),\"\\tlb: \", show(lb_lambda)]\n%       ++[\"\\n\\n\"] ++ \n%\t[ ( if j > b then \"\\n\" else \n%\t        if fix(m[i,j])=1 then \"*\" else \" \" endif\n%\t    endif )\n%       | i in rows, j in 1..(b + 1) ]\n;"}, "hash": "4dcffcf9d354159dc1db5182bd9a4a4a8416f28c602dc687d3e30cea9d4b3fa5", "class_name": "RelatedNodeInfo"}}, "text": "name: Orthogonal Pairs of Designs (OPD) problem\n\ndescription: The OPD problem is a classical problem in combinatorial design theory, which involves finding a binary matrix of v rows and b columns such that each row sums to r, and the dot product between any pair of distinct rows is minimal. This problem has applications in the design of Collateralised Debt Obligations Squared (CDO^2) transactions.\n\nvariables: m[i, j] (i in rows, j in cols), objective\n\nThe decision variables are the elements of the binary matrix m, where m[i, j] represents the value of the element at row i and column j. The variable objective represents the minimum dot product between any pair of distinct rows.\n\nconstraints: \nsum (j in cols) (m[i, j]) = r (forall i in rows), \nsum (j in cols) (m[i_a, j] * m[i_b, j]) <= objective (forall i_a, i_b in rows where i_a < i_b), \nlex_greatereq([m[i, j] | j in cols], [m[i+1, j] | j in cols]) (forall i in rows diff {max(rows)}), \nlex_greatereq([m[i, j] | i in rows], [m[i, j+1] | i in rows]) (forall j in cols diff {max(cols)})\n\nThe constraints ensure that each row sums to r, the dot product between any pair of distinct rows is at most lambda, and the row and column symmetries are broken.\n\nobjective: minimize objective", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1241, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "83c49095-65bd-4a89-8f76-47a1c13e22db": {"__data__": {"id_": "83c49095-65bd-4a89-8f76-47a1c13e22db", "embedding": null, "metadata": {"model_name": "partition", "source_code": "Model 1 : \n\n% Partitioning problem\n% Partition 2*n numbers into two groups, each of size n, such that\n% their sums are equal and the sums of their squares are equal.\n\ninclude \"globals.mzn\";\n\n% Instance\n\nn = 32;\n\n% Model\n\nint: n;\n\narray[1..n] of var 1..2*n: x;\narray[1..n] of var 1..2*n: y;\n\nconstraint true\n    %   Break symmetries by ordering numbers in each group\n    /\\  forall (i in 2..n) (x[i-1] < x[i] /\\ y[i-1] < y[i])\n    %   Break symmetries by ordering the groups\n    /\\  x[1] < y[1]\n    \n    %   Partition the numbers\n    /\\  (alldifferent(x++y)) :: bounds\n    \n    %   The sums are equal\n    /\\  sum (x) = 2*n*(2*n+1) div 4\n    /\\  sum (y) = 2*n*(2*n+1) div 4\n    \n    %   The sums of the squares are equal\n    /\\  let {\n            array[1..n] of var 1..4*n*n: sx,\n            array[1..n] of var 1..4*n*n: sy\n        } in\n        forall (i in 1..n) (sx[i]=x[i]*x[i] /\\ sy[i] = y[i]*y[i])\n    /\\  sum (sx) = 2*n*(2*n+1)*(4*n+1) div 12\n    /\\  sum (sy) = 2*n*(2*n+1)*(4*n+1) div 12\n;\n\nsolve ::int_search(x++y,first_fail,indomain_min,complete) satisfy;\n\noutput\n    [\"x = \",show(x),\"\\n\",\"y = \",show(y),\"\\n\",\n     \"sum = \",show(2*n*(2*n+1) div 4),\"\\n\",\n     \"sum of squares = \", show(2*n*(2*n+1)*(4*n+1) div 12), \"\\n\"\n     ];\n\n\n\nModel 2 :\n\n\n\n%\n% Set partition problem in Minizinc.\n%\n%  This is a partition problem.\n%  Given the set S = {1, 2, ..., n},\n%  it consists in finding two sets A and B such that:\n%  <ul>\n%  <li>A U B = S,</li>\n%  <li>|A| = |B|,</li>\n%  <li>sum(A) = sum(B),</li>\n%  <li>sum_squares(A) = sum_squares(B).</li>\n%  </ul>\n \n%\ninclude \"globals.mzn\";\n \nint: n = 16;\nset of 1..n: S = 1..n;\nint: num_sets = 2;\narray[1..num_sets] of var set of S: a;\narray[1..num_sets] of var 0..n*n: sums;\narray[1..num_sets] of var 0..n*n*n*n: sum_squared;\n \n \n%\n% set_sum\n% sums the elements in the set s\n%\npredicate set_sum(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i)\n;\n \npredicate set_sum_squared(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i*i)\n;\n \n \nsolve :: set_search(a, first_fail, indomain_min, complete) satisfy;\n% solve maximize sums[1];\n \nconstraint\n  assert(n mod 4 == 0, \"n must be a multiple of 4\")\n;\n \nconstraint\n   % use all the elements in S and it should be disjoint sets\n   partition_set(a, S)\n   /\\\n   forall(i in 1..num_sets) (  \n     a[i] `set_sum` sums[i]\n     /\\ a[i] `set_sum_squared` sum_squared[i]\n   )\n   /\\\n   forall(i in 2..num_sets) (\n     card(a[i]) > 0 /\\ % this is needed by eclipse\n     card(a[i]) = card(a[i-1]) /\\\n     sums[i] = sums[i-1]\n     /\\ sum_squared[i] = sum_squared[i-1]\n   )\n \n  % symmetry breaking\n  /\\ 1 in a[1]\n \n;\n \noutput [\n   \"a: \" ++ show(a) ++ \"\\n\" ++\n   \"sums: \" ++ show(sums) ++ \"\\n\" ++\n   \"sum_squared: \" ++ show(sum_squared) ++ \"\\n\"\n];\n \n% For model seeker\n% output [\n%    show(set2array(fix(a[i]))) ++ \",\"\n%   | i in 1..num_sets\n% ];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "partition_expert", "node_type": "4", "metadata": {"model_name": "partition", "source_code": "Model 1 : \n\n% Partitioning problem\n% Partition 2*n numbers into two groups, each of size n, such that\n% their sums are equal and the sums of their squares are equal.\n\ninclude \"globals.mzn\";\n\n% Instance\n\nn = 32;\n\n% Model\n\nint: n;\n\narray[1..n] of var 1..2*n: x;\narray[1..n] of var 1..2*n: y;\n\nconstraint true\n    %   Break symmetries by ordering numbers in each group\n    /\\  forall (i in 2..n) (x[i-1] < x[i] /\\ y[i-1] < y[i])\n    %   Break symmetries by ordering the groups\n    /\\  x[1] < y[1]\n    \n    %   Partition the numbers\n    /\\  (alldifferent(x++y)) :: bounds\n    \n    %   The sums are equal\n    /\\  sum (x) = 2*n*(2*n+1) div 4\n    /\\  sum (y) = 2*n*(2*n+1) div 4\n    \n    %   The sums of the squares are equal\n    /\\  let {\n            array[1..n] of var 1..4*n*n: sx,\n            array[1..n] of var 1..4*n*n: sy\n        } in\n        forall (i in 1..n) (sx[i]=x[i]*x[i] /\\ sy[i] = y[i]*y[i])\n    /\\  sum (sx) = 2*n*(2*n+1)*(4*n+1) div 12\n    /\\  sum (sy) = 2*n*(2*n+1)*(4*n+1) div 12\n;\n\nsolve ::int_search(x++y,first_fail,indomain_min,complete) satisfy;\n\noutput\n    [\"x = \",show(x),\"\\n\",\"y = \",show(y),\"\\n\",\n     \"sum = \",show(2*n*(2*n+1) div 4),\"\\n\",\n     \"sum of squares = \", show(2*n*(2*n+1)*(4*n+1) div 12), \"\\n\"\n     ];\n\n\n\nModel 2 :\n\n\n\n%\n% Set partition problem in Minizinc.\n%\n%  This is a partition problem.\n%  Given the set S = {1, 2, ..., n},\n%  it consists in finding two sets A and B such that:\n%  <ul>\n%  <li>A U B = S,</li>\n%  <li>|A| = |B|,</li>\n%  <li>sum(A) = sum(B),</li>\n%  <li>sum_squares(A) = sum_squares(B).</li>\n%  </ul>\n \n%\ninclude \"globals.mzn\";\n \nint: n = 16;\nset of 1..n: S = 1..n;\nint: num_sets = 2;\narray[1..num_sets] of var set of S: a;\narray[1..num_sets] of var 0..n*n: sums;\narray[1..num_sets] of var 0..n*n*n*n: sum_squared;\n \n \n%\n% set_sum\n% sums the elements in the set s\n%\npredicate set_sum(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i)\n;\n \npredicate set_sum_squared(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i*i)\n;\n \n \nsolve :: set_search(a, first_fail, indomain_min, complete) satisfy;\n% solve maximize sums[1];\n \nconstraint\n  assert(n mod 4 == 0, \"n must be a multiple of 4\")\n;\n \nconstraint\n   % use all the elements in S and it should be disjoint sets\n   partition_set(a, S)\n   /\\\n   forall(i in 1..num_sets) (  \n     a[i] `set_sum` sums[i]\n     /\\ a[i] `set_sum_squared` sum_squared[i]\n   )\n   /\\\n   forall(i in 2..num_sets) (\n     card(a[i]) > 0 /\\ % this is needed by eclipse\n     card(a[i]) = card(a[i-1]) /\\\n     sums[i] = sums[i-1]\n     /\\ sum_squared[i] = sum_squared[i-1]\n   )\n \n  % symmetry breaking\n  /\\ 1 in a[1]\n \n;\n \noutput [\n   \"a: \" ++ show(a) ++ \"\\n\" ++\n   \"sums: \" ++ show(sums) ++ \"\\n\" ++\n   \"sum_squared: \" ++ show(sum_squared) ++ \"\\n\"\n];\n \n% For model seeker\n% output [\n%    show(set2array(fix(a[i]))) ++ \",\"\n%   | i in 1..num_sets\n% ];"}, "hash": "7383607ba8f923f1cee542ae2f703203ed010e19e4bb955d0cfcc1d5e3cd14bb", "class_name": "RelatedNodeInfo"}}, "text": "name: Partition Problem\n\ndescription: The Partition Problem is a classic problem in constraint programming that involves dividing a set of 2n numbers into two disjoint subsets, each of size n, such that the sum of the numbers in each subset is equal, and the sum of the squares of the numbers in each subset is also equal.\n\nvariables: x, y (arrays of var 1..2n), sx, sy (arrays of var 1..4n^2)\n\nx and y are arrays of decision variables representing the two subsets of numbers. sx and sy are auxiliary variables used to calculate the sum of squares of the numbers in each subset.\n\nconstraints: \nx[i-1] < x[i], y[i-1] < y[i] (ordering constraints)\nx[1] < y[1] (symmetry breaking constraint)\nalldifferent(x++y) (partitioning constraint)\nsum(x) = 2n(2n+1) div 4, sum(y) = 2n(2n+1) div 4 (sum equality constraints)\nsx[i] = x[i]*x[i], sy[i] = y[i]*y[i] (definition of sum of squares)\nsum(sx) = 2n(2n+1)(4n+1) div 12, sum(sy) = 2n(2n+1)(4n+1) div 12 (sum of squares equality constraints)\n\nThe constraints ensure that the two subsets are disjoint, have the same sum, and the same sum of squares. The ordering constraints and symmetry breaking constraint are used to reduce the search space.\n\nobjective: satisfy (there is no objective function to minimize or maximize, the goal is to find a feasible solution)", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1300, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e0ebe79c-abb1-4e23-b437-6d449a2c17fc": {"__data__": {"id_": "e0ebe79c-abb1-4e23-b437-6d449a2c17fc", "embedding": null, "metadata": {"model_name": "photo", "source_code": "int:n ;\nset of int: PERSON = 1..n;\nset of int: POS = 1..n;\narray[PERSON,PERSON] of int: friend;\n\n%array[PERSON] of var POS: x;\narray[POS] of var PERSON: y;\n\n%include \"inverse.mzn\";\n%constraint inverse(x,y);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\n%constraint alldifferent(x);\n\n%y[i] = sum(j in 1..n)(bool2int(x[j] = i) * j);\n\nsolve maximize sum(i in 1..n-1)(friend[y[i],y[i+1]]);\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "photo_expert", "node_type": "4", "metadata": {"model_name": "photo", "source_code": "int:n ;\nset of int: PERSON = 1..n;\nset of int: POS = 1..n;\narray[PERSON,PERSON] of int: friend;\n\n%array[PERSON] of var POS: x;\narray[POS] of var PERSON: y;\n\n%include \"inverse.mzn\";\n%constraint inverse(x,y);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\n%constraint alldifferent(x);\n\n%y[i] = sum(j in 1..n)(bool2int(x[j] = i) * j);\n\nsolve maximize sum(i in 1..n-1)(friend[y[i],y[i+1]]);\n\n"}, "hash": "7e93c5093794c8f32323616a1b7dd8fb59275833f3fafe3eb6e2d53732072f13", "class_name": "RelatedNodeInfo"}}, "text": "name: Social Golfer Problem\n\ndescription: The Social Golfer Problem is a classic constraint satisfaction problem that involves scheduling golfers into groups of a fixed size over a series of rounds, such that each golfer plays with every other golfer exactly once.\n\nvariables: x[i] (i in PERSON), y[j] (j in POS)\n\nThe decision variables are x and y, where x[i] represents the position of person i in the schedule, and y[j] represents the person assigned to position j in the schedule.\n\nconstraints: \ninverse(x, y), \nalldifferent(y), \n%alldifferent(x), \ny[i] = sum(j in 1..n)(bool2int(x[j] = i) * j)\n\nThe constraints ensure that each person is assigned a unique position, and each position is assigned a unique person (inverse and alldifferent constraints). The third constraint is a redundant constraint that is commented out, and the fourth constraint ensures that the y array is correctly defined as the inverse of the x array.\n\nobjective: maximize sum(i in 1..n-1)(friend[y[i],y[i+1]])\n\nThe objective is to maximize the total friendship score, which is calculated by summing the friendship values between adjacent pairs of golfers in the schedule.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1150, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8707b1a8-f48d-47bb-b1a5-d4ecc7942266": {"__data__": {"id_": "8707b1a8-f48d-47bb-b1a5-d4ecc7942266", "embedding": null, "metadata": {"model_name": "project_scheduling", "source_code": "Model 1 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\nconstraint forall(i in PREC)\n                 (start[pre[i,1]] + duration[pre[i,1]] <= start[pre[i,2]]);\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n\n\n\nModel 2 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\npredicate precedes(var int:s1, var int:d1, var int:s2)=\n          s1 + d1 <= s2; \n\nconstraint forall(i in PREC)\n                 (precedes(start[pre[i,1]],duration[pre[i,1]],start[pre[i,2]]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nset of TASK: CARPENTRY = { interior_walls, exterior_walls, roof };\nconstraint forall(t1, t2 in CARPENTRY where t1 < t2)\n      (nonoverlap(start[t1],duration[t1],start[t2],duration[t2]));\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "project_scheduling_expert", "node_type": "4", "metadata": {"model_name": "project_scheduling", "source_code": "Model 1 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\nconstraint forall(i in PREC)\n                 (start[pre[i,1]] + duration[pre[i,1]] <= start[pre[i,2]]);\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n\n\n\nModel 2 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\npredicate precedes(var int:s1, var int:d1, var int:s2)=\n          s1 + d1 <= s2; \n\nconstraint forall(i in PREC)\n                 (precedes(start[pre[i,1]],duration[pre[i,1]],start[pre[i,2]]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nset of TASK: CARPENTRY = { interior_walls, exterior_walls, roof };\nconstraint forall(t1, t2 in CARPENTRY where t1 < t2)\n      (nonoverlap(start[t1],duration[t1],start[t2],duration[t2]));\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n"}, "hash": "92f7199873452802c2413620d2075be6d542c41664511e00b87498d41cc88ddb", "class_name": "RelatedNodeInfo"}}, "text": "name: Resource-Constrained Project Scheduling Problem (RCPSP)\n\ndescription: The Resource-Constrained Project Scheduling Problem (RCPSP) is a classic problem in operations research and project management. It involves scheduling a set of tasks with given durations and precedence relationships, subject to resource constraints, to minimize the total project duration (makespan).\n\nvariables: `start[t]` for `t in TASK`, where `start[t]` represents the start time of task `t`.\n\nThe decision variables `start[t]` represent the start time of each task, which determines the schedule of the project.\n\nconstraints: \n`start[pre[i,1]] + duration[pre[i,1]] <= start[pre[i,2]]` for `i in PREC`, \n`nonoverlap(start[t1],duration[t1],start[t2],duration[t2])` for `t1, t2 in CARPENTRY` where `t1 < t2`.\n\nThe first constraint enforces the precedence relationships between tasks, ensuring that a task cannot start before its predecessors have finished. The second constraint ensures that tasks that require the same resource (in this case, carpentry) do not overlap in time.\n\nobjective: Minimize `makespan = max(t in TASK)(start[t] + duration[t])`, which represents the total project duration.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1175, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8fa9da72-3178-496b-a8bb-7b9c2b2baefe": {"__data__": {"id_": "8fa9da72-3178-496b-a8bb-7b9c2b2baefe", "embedding": null, "metadata": {"model_name": "QuasigroupCompletion", "source_code": "Model 1 :\n\n% Quasigroup with Holes (aka Latin Square Completion)\n\ninclude \"alldifferent.mzn\";\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n\narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N] of var PuzzleRange: puzzle;\n\n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j] = start[i,j] else true endif );\n\n% All different in rows\nconstraint forall (i in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | j in PuzzleRange ] ) );\n\n% All different in columns.\nconstraint forall (j in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | i in PuzzleRange ] ) );\n\nsolve satisfy;\n\noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n \narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N, 1..N] of var 0..1: puzzle;\n \n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j, start[i,j]] = 1 else true endif );\n \n% All different in rows\nconstraint forall (i,k in PuzzleRange) (\n        sum(j in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% All different in columns\nconstraint forall (j,k in PuzzleRange) (\n        sum(i in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% Each cell must have a number assigned\nconstraint forall (i,j in PuzzleRange) (\n        sum(k in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\nsolve satisfy;\n \noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasigroupCompletion_expert", "node_type": "4", "metadata": {"model_name": "QuasigroupCompletion", "source_code": "Model 1 :\n\n% Quasigroup with Holes (aka Latin Square Completion)\n\ninclude \"alldifferent.mzn\";\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n\narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N] of var PuzzleRange: puzzle;\n\n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j] = start[i,j] else true endif );\n\n% All different in rows\nconstraint forall (i in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | j in PuzzleRange ] ) );\n\n% All different in columns.\nconstraint forall (j in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | i in PuzzleRange ] ) );\n\nsolve satisfy;\n\noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n \narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N, 1..N] of var 0..1: puzzle;\n \n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j, start[i,j]] = 1 else true endif );\n \n% All different in rows\nconstraint forall (i,k in PuzzleRange) (\n        sum(j in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% All different in columns\nconstraint forall (j,k in PuzzleRange) (\n        sum(i in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% Each cell must have a number assigned\nconstraint forall (i,j in PuzzleRange) (\n        sum(k in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\nsolve satisfy;\n \noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];"}, "hash": "94bbfc62345a97ff77da7d489be1ea651bdfda2c7316d5a53daa65d1c6cb0ce5", "class_name": "RelatedNodeInfo"}}, "text": "name: Latin Square Completion\n\ndescription: The Latin Square Completion problem is a classic problem in constraint programming. It involves completing a partially filled N x N grid with numbers from 1 to N, such that each row, column, and cell contains each number exactly once.\n\nvariables: puzzle[i,j] (Model 1) or puzzle[i,j,k] (Model 2)\n\nThe decision variables represent the values to be assigned to each cell in the grid. In Model 1, puzzle[i,j] represents the value assigned to the cell at row i and column j. In Model 2, puzzle[i,j,k] represents a binary variable indicating whether the value k is assigned to the cell at row i and column j.\n\nconstraints: \nfill initial board: \u2200i,j (if start[i,j] > 0 then puzzle[i,j] = start[i,j] else true endif) (Model 1)\n\u2200i,j (if start[i,j] > 0 then puzzle[i,j, start[i,j]] = 1 else true endif) (Model 2)\n\nThese constraints ensure that the initial values in the grid are preserved.\n\nAll different in rows: \u2200i (alldifferent([puzzle[i,j] | j in PuzzleRange])) (Model 1)\n\u2200i,k (\u2211j (puzzle[i,j,k]) == 1) (Model 2)\n\nThese constraints ensure that each row contains each number exactly once.\n\nAll different in columns: \u2200j (alldifferent([puzzle[i,j] | i in PuzzleRange])) (Model 1)\n\u2200j,k (\u2211i (puzzle[i,j,k]) == 1) (Model 2)\n\nThese constraints ensure that each column contains each number exactly once.\n\nEach cell must have a number assigned: \u2200i,j (\u2211k (puzzle[i,j,k]) == 1) (Model 2)\n\nThis constraint ensures that each cell contains exactly one number.\n\nobjective: satisfy\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1655, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e99eace8-e037-4cd6-a5d3-161e93a209b2": {"__data__": {"id_": "e99eace8-e037-4cd6-a5d3-161e93a209b2", "embedding": null, "metadata": {"model_name": "QuasiGroupExistence", "source_code": "Model 1 :\n\n\n% Quasigroup problem in MiniZinc.\n% The quasiGroup existence problem\n% An m order quasigroup  is an mxm multiplication table of integers 1..m,\n% where each element occurrs exactly once in each row and column and certain\n% multiplication axioms hold (in this case, we want axiom 7 to hold).\n%\n% QG7.m problems are order m quasigroups for which (b*a)*b = a*(b*a).\n\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n% solve satisfy;\n \nconstraint\n      \n     % assign the \"reflected\" quasigroup to qGColumns to access its columns\n     %  forall row,col : nDomain .\n     %    quasiGroupColumns[col,row] = quasiGroup[row,col],\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % all values in the diagonals\n     forall( i in nDomain ) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n \n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row, col] | row in nDomain])\n     )\n     /\\\n \n     % this strange constraint\n     % corresponds to:\n     % quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i], j] \n     forall(i,j in nDomain) (\n              quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i],j]\n     )\n     /\\\n     % some implied? constraint\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n%\n% data\n%\nn = 5;\n\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 9; % solutions for n=5, n=9...\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n \nint: n = 4;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n \n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (i != j) ->\n         (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n \n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n \n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\n\nModel 4 :\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n \n     % Idempotency\n     % forall i : nDomain .\n     %     (quasiGroup[i,i] = i),\n \n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     % allDifferent(qgDiagonal) %,\n \n     % anti-Abelian\n     % forall i : nDomain .\n     %   forall j : nDomain .\n     %     (i != j) =>\n     %     (quasiGroup[i,j] != quasiGroup[j,i]),\n \n     % if (i*i)=j then (j*j) = i\n     % forall i : nDomain .\n     %  forall j : nDomain .\n     %    (quasiGroup[i,i]=j) => (quasiGroup[j,j]=i),\n \n \n     % Symmetry-breaking constraints   \n     % forall i : nDomain .\n     %      quasiGroup[i,n-1] + 2 >= i\n \n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n \n \n%\n% data\n%\nn = 4; % 4 works\n\n\nModel 5 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 6 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 5;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 7 :\n\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasiGroupExistence_expert", "node_type": "4", "metadata": {"model_name": "QuasiGroupExistence", "source_code": "Model 1 :\n\n\n% Quasigroup problem in MiniZinc.\n% The quasiGroup existence problem\n% An m order quasigroup  is an mxm multiplication table of integers 1..m,\n% where each element occurrs exactly once in each row and column and certain\n% multiplication axioms hold (in this case, we want axiom 7 to hold).\n%\n% QG7.m problems are order m quasigroups for which (b*a)*b = a*(b*a).\n\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n% solve satisfy;\n \nconstraint\n      \n     % assign the \"reflected\" quasigroup to qGColumns to access its columns\n     %  forall row,col : nDomain .\n     %    quasiGroupColumns[col,row] = quasiGroup[row,col],\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % all values in the diagonals\n     forall( i in nDomain ) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n \n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row, col] | row in nDomain])\n     )\n     /\\\n \n     % this strange constraint\n     % corresponds to:\n     % quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i], j] \n     forall(i,j in nDomain) (\n              quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i],j]\n     )\n     /\\\n     % some implied? constraint\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n%\n% data\n%\nn = 5;\n\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 9; % solutions for n=5, n=9...\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n \nint: n = 4;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n \n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (i != j) ->\n         (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n \n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n \n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\n\nModel 4 :\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n \n     % Idempotency\n     % forall i : nDomain .\n     %     (quasiGroup[i,i] = i),\n \n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     % allDifferent(qgDiagonal) %,\n \n     % anti-Abelian\n     % forall i : nDomain .\n     %   forall j : nDomain .\n     %     (i != j) =>\n     %     (quasiGroup[i,j] != quasiGroup[j,i]),\n \n     % if (i*i)=j then (j*j) = i\n     % forall i : nDomain .\n     %  forall j : nDomain .\n     %    (quasiGroup[i,i]=j) => (quasiGroup[j,j]=i),\n \n \n     % Symmetry-breaking constraints   \n     % forall i : nDomain .\n     %      quasiGroup[i,n-1] + 2 >= i\n \n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n \n \n%\n% data\n%\nn = 4; % 4 works\n\n\nModel 5 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 6 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 5;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 7 :\n\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];"}, "hash": "04955f752128fb9304668221e29295dd0c498ab27135bc232af9eb9028cdd06b", "class_name": "RelatedNodeInfo"}}, "text": "name: Quasigroup Existence Problem\n\ndescription: The Quasigroup Existence Problem is a classic problem in combinatorial mathematics, which involves finding a multiplication table of size n x n, where each element is an integer from 1 to n, such that each row and column contains each element exactly once, and certain multiplication axioms hold.\n\nvariables: quasiGroup[row, col], qgDiagonal[i]\n\nThe decision variables are a 2D array quasiGroup, where quasiGroup[row, col] represents the element at row and column in the multiplication table, and a 1D array qgDiagonal, where qgDiagonal[i] represents the diagonal element at position i.\n\nconstraints: \nall_different([quasiGroup[row,col] | col in nDomain]) /\\ \nall_different([quasiGroup[row,col] | row in nDomain]) /\\ \nquasiGroup[i,i] = i /\\ \nquasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i /\\ \nall_different(qgDiagonal) /\\ \nquasiGroup[i,j] != quasiGroup[j,i] /\\ \n(quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i) /\\ \nquasiGroup[i,n-1] + 2 >= i\n\nThe constraints ensure that:\n- Each row and column contains each element exactly once.\n- The diagonal elements are equal to their indices.\n- The multiplication axiom (b*a)*b = a*(b*a) holds.\n- The diagonal elements are all different.\n- The table is anti-Abelian, i.e., quasiGroup[i,j] is not equal to quasiGroup[j,i] for i != j.\n- If (i*i)=j then (j*j) = i.\n- Symmetry-breaking constraints to reduce the search space.\n\nobjective: The problem is a satisfaction problem, i.e., it does not have an objective function to minimize or maximize. The goal is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1601, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "357c8965-6b86-47fa-b009-3ed3d1921152": {"__data__": {"id_": "357c8965-6b86-47fa-b009-3ed3d1921152", "embedding": null, "metadata": {"model_name": "queens", "source_code": "Model 1 :\n\n% n queens problem in MiniZinc.\n\ninclude \"globals.mzn\";\n\nint: n;\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail, \n        indomain_min, \n        complete) \n    satisfy;\n\n% solve satisfy;\n\nconstraint all_different(queens);\n\nconstraint\n    forall(i, j in 1..n where i < j) (\n         queens[i] != queens[j] /\\\n         queens[i] + i != queens[j] + j /\\\n         queens[i] - i != queens[j] - j\n    ) \n ;\n\noutput [\n  show(queens) ++ \"\\n\"\n\n];\n\n% data\nn = 8;\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n;\n\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail,\n        indomain_median,\n        complete\n       )\n     satisfy;\n\n% solve satisfy;\nconstraint all_different(queens); %  :: domain;\nconstraint all_different([queens[i]+i | i in 1..n]) :: domain;\nconstraint all_different([queens[i]-i | i in 1..n]) :: domain;\n\noutput \n[\n  \"queens: \" ++ show(queens)\n] ++ \n% [\n%   if j = 1 then \"\\n\" else \"\" endif ++\n%      if fix(queens[i]) = j then          \n%         show_int(2,j)\n%      else\n%         \"__\"\n%      endif\n%   | i in 1..n, j in 1..n\n% ] ++\n[\"\\n\"]\n;\n\n% data\nn = 8;\n\n\nModel 3 :\n\n\n\nint: n;                                 % The number of queens.\n\narray [1..n] of var 1..n: q;\n\ninclude \"alldifferent.mzn\";\n\nconstraint alldifferent(q);\nconstraint alldifferent(i in 1..n)(q[i] + i);\nconstraint alldifferent(i in 1..n)(q[i] - i);\n\n\nsolve \n%      :: int_search(q, input_order, indomain_min, complete) \n%      :: int_search(q, first_fail, indomain_min, complete) \n%      :: int_search(q, smallest, indomain_min, complete)\n%      :: int_search(q, largest, indomain_min, complete)\n%      :: int_search(q, input_order, indomain_max, complete) \n%      :: int_search(q, first_fail, indomain_max, complete) \n%      :: int_search(q, smallest, indomain_max, complete)\n%      :: int_search(q, largest, indomain_max, complete)\n%      :: int_search(q, input_order, indomain_median, complete) \n%      :: int_search(q, first_fail, indomain_median, complete) \n%      :: int_search(q, smallest, indomain_median, complete)\n%      :: int_search(q, largest, indomain_median, complete)\n%      :: int_search(q, input_order, indomain_random, complete) \n%      :: int_search(q, first_fail, indomain_random, complete) \n%      :: int_search(q, smallest, indomain_random, complete)\n%      :: int_search(q, largest, indomain_random, complete)\n      satisfy;\n\n%output\t\n%%\t[\tif fix(q[i]) = j then \"Q \" else \". \" endif ++\n%\t \tif j = n then \"\\n\" else \"\" endif\n%\t|\ti, j in 1..n\n%\t];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "queens_expert", "node_type": "4", "metadata": {"model_name": "queens", "source_code": "Model 1 :\n\n% n queens problem in MiniZinc.\n\ninclude \"globals.mzn\";\n\nint: n;\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail, \n        indomain_min, \n        complete) \n    satisfy;\n\n% solve satisfy;\n\nconstraint all_different(queens);\n\nconstraint\n    forall(i, j in 1..n where i < j) (\n         queens[i] != queens[j] /\\\n         queens[i] + i != queens[j] + j /\\\n         queens[i] - i != queens[j] - j\n    ) \n ;\n\noutput [\n  show(queens) ++ \"\\n\"\n\n];\n\n% data\nn = 8;\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n;\n\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail,\n        indomain_median,\n        complete\n       )\n     satisfy;\n\n% solve satisfy;\nconstraint all_different(queens); %  :: domain;\nconstraint all_different([queens[i]+i | i in 1..n]) :: domain;\nconstraint all_different([queens[i]-i | i in 1..n]) :: domain;\n\noutput \n[\n  \"queens: \" ++ show(queens)\n] ++ \n% [\n%   if j = 1 then \"\\n\" else \"\" endif ++\n%      if fix(queens[i]) = j then          \n%         show_int(2,j)\n%      else\n%         \"__\"\n%      endif\n%   | i in 1..n, j in 1..n\n% ] ++\n[\"\\n\"]\n;\n\n% data\nn = 8;\n\n\nModel 3 :\n\n\n\nint: n;                                 % The number of queens.\n\narray [1..n] of var 1..n: q;\n\ninclude \"alldifferent.mzn\";\n\nconstraint alldifferent(q);\nconstraint alldifferent(i in 1..n)(q[i] + i);\nconstraint alldifferent(i in 1..n)(q[i] - i);\n\n\nsolve \n%      :: int_search(q, input_order, indomain_min, complete) \n%      :: int_search(q, first_fail, indomain_min, complete) \n%      :: int_search(q, smallest, indomain_min, complete)\n%      :: int_search(q, largest, indomain_min, complete)\n%      :: int_search(q, input_order, indomain_max, complete) \n%      :: int_search(q, first_fail, indomain_max, complete) \n%      :: int_search(q, smallest, indomain_max, complete)\n%      :: int_search(q, largest, indomain_max, complete)\n%      :: int_search(q, input_order, indomain_median, complete) \n%      :: int_search(q, first_fail, indomain_median, complete) \n%      :: int_search(q, smallest, indomain_median, complete)\n%      :: int_search(q, largest, indomain_median, complete)\n%      :: int_search(q, input_order, indomain_random, complete) \n%      :: int_search(q, first_fail, indomain_random, complete) \n%      :: int_search(q, smallest, indomain_random, complete)\n%      :: int_search(q, largest, indomain_random, complete)\n      satisfy;\n\n%output\t\n%%\t[\tif fix(q[i]) = j then \"Q \" else \". \" endif ++\n%\t \tif j = n then \"\\n\" else \"\" endif\n%\t|\ti, j in 1..n\n%\t];\n"}, "hash": "97b473f5055bb71507c9fa3f70e53114eedfe22b2253c076ef9307f26359c09d", "class_name": "RelatedNodeInfo"}}, "text": "name: N-Queens Problem\n\ndescription: The N-Queens Problem is a classic problem in computer science and mathematics, where the goal is to place N queens on an NxN chessboard such that no queen attacks another queen.\n\nvariables: q (or queens) \u2208 {1, ..., n}^n, where q[i] represents the column index of the queen in the i-th row.\n\nconstraints: \n\u2200i, j \u2208 {1, ..., n} (i \u2260 j) : q[i] \u2260 q[j] \u2227 q[i] + i \u2260 q[j] + j \u2227 q[i] - i \u2260 q[j] - j\n\u2200i \u2208 {1, ..., n} : q[i] is distinct\n\nThe first constraint ensures that no two queens are in the same column, and no two queens are on the same diagonal. The second constraint ensures that all queens are distinct.\n\nobjective: The objective of the problem is to find a feasible solution that satisfies all the constraints, i.e., to place N queens on an NxN chessboard such that no queen attacks another queen. There is no objective function to minimize or maximize.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 891, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "08783bbc-03d7-4e3a-b874-86e88f60d62e": {"__data__": {"id_": "08783bbc-03d7-4e3a-b874-86e88f60d62e", "embedding": null, "metadata": {"model_name": "rcpsp", "source_code": "int: n; % number of tasks\nset of int: TASK = 1..n;\narray[TASK] of int: d; % duration\n\nint: m; % number of resources\nset of int: RESOURCE = 1..m;\narray[RESOURCE] of int: L; % resource limit\narray[RESOURCE,TASK] of int: res; % usage\n\nint: l; % number of precedences\nset of int: PREC = 1..l;\narray[PREC,1..2] of TASK: pre; % predecessor/successor pairs\n\nint: maxt; % maximum time\nset of int: TIME = 0..maxt;\n\narray[TASK] of var TIME: s; % start time\n\nconstraint forall(p in PREC)(s[pre[p,1]]+d[pre[p,1]] <= s[pre[p,2]]);\n\ninclude \"cumulative.mzn\";\nconstraint forall(r in RESOURCE)\n                 (cumulative(s,d,[res[r,t]|t in TASK],L[r]));\n%constraint forall(r in RESOURCE) \n%                 ( let { array[int] of var int: ss = \n%                              [ s[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: dd = \n%                              [ d[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: rr = \n%                              [ res[r,t] | t in TASK where res[r,t] > 0 ]; } in\n%                   cumulative(ss,dd,rr,L[r]));\n\nsolve minimize max(t in TASK)(s[t] + d[t]);\n\noutput [show(s)];\n\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rcpsp_expert", "node_type": "4", "metadata": {"model_name": "rcpsp", "source_code": "int: n; % number of tasks\nset of int: TASK = 1..n;\narray[TASK] of int: d; % duration\n\nint: m; % number of resources\nset of int: RESOURCE = 1..m;\narray[RESOURCE] of int: L; % resource limit\narray[RESOURCE,TASK] of int: res; % usage\n\nint: l; % number of precedences\nset of int: PREC = 1..l;\narray[PREC,1..2] of TASK: pre; % predecessor/successor pairs\n\nint: maxt; % maximum time\nset of int: TIME = 0..maxt;\n\narray[TASK] of var TIME: s; % start time\n\nconstraint forall(p in PREC)(s[pre[p,1]]+d[pre[p,1]] <= s[pre[p,2]]);\n\ninclude \"cumulative.mzn\";\nconstraint forall(r in RESOURCE)\n                 (cumulative(s,d,[res[r,t]|t in TASK],L[r]));\n%constraint forall(r in RESOURCE) \n%                 ( let { array[int] of var int: ss = \n%                              [ s[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: dd = \n%                              [ d[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: rr = \n%                              [ res[r,t] | t in TASK where res[r,t] > 0 ]; } in\n%                   cumulative(ss,dd,rr,L[r]));\n\nsolve minimize max(t in TASK)(s[t] + d[t]);\n\noutput [show(s)];\n\n\n"}, "hash": "a9d18695dbc085fdfaf9052240358a69907ea0fb1584b7b8f793d69589ef05b5", "class_name": "RelatedNodeInfo"}}, "text": "name: Resource-Constrained Project Scheduling Problem (RCPSP)\n\ndescription: The Resource-Constrained Project Scheduling Problem (RCPSP) is a classic problem in operations research and project management. It involves scheduling a set of tasks with given durations and resource requirements, subject to resource availability constraints and precedence constraints between tasks. The goal is to find a schedule that minimizes the total project duration.\n\nvariables: s \u2208 TIME ^ TASK, where s[t] represents the start time of task t.\n\nThe decision variables are the start times of each task, which determine the schedule of the project.\n\nconstraints: \n\u2200p \u2208 PREC, s[pre[p,1]] + d[pre[p,1]] \u2264 s[pre[p,2]]\n\u2200r \u2208 RESOURCE, cumulative(s, d, [res[r,t]|t \u2208 TASK], L[r])\n\nThe first constraint enforces the precedence relationships between tasks, ensuring that a task cannot start before its predecessors have finished. The second constraint ensures that the resource usage of all tasks does not exceed the available resource limit at any time.\n\nobjective: minimize max(t \u2208 TASK)(s[t] + d[t])\n\nThe objective is to minimize the maximum completion time of all tasks, which represents the total project duration.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1193, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "83c78238-65f7-4137-9f90-89c83d422f97": {"__data__": {"id_": "83c78238-65f7-4137-9f90-89c83d422f97", "embedding": null, "metadata": {"model_name": "rehearsal", "source_code": "%\n% Scheduling a Rehearsal in MiniZinc.\n% A concert is to consist of nine pieces of music of different durations\n% each involving a different combination of the five members of the orchestra.\n% Players can arrive at rehearsals immediately before the first piece in which\n% they are involved and depart immediately after the last piece in which\n% they are involved. The problem is to devise an order in which the pieces\n% can be rehearsed so as to minimize the total time that players are waiting\n% to play, i.e. the total time when players are present but not currently\n% playing. In the table below, 1 means that the player is required for\n% the corresponding piece, 0 otherwise. The duration (i.e. rehearsal time)\n% is in some unspecified time units.\n%\n%    Piece       1    2   3    4    5  6    7   8    9\n%    Player 1    1    1   0    1    0  1    1   0    1\n%    Player 2    1    1   0    1    1  1    0   1    0\n%    Player 3    1    1   0    0    0  0    1   1    0\n%    Player 4    1    0   0    0    1  1    0   0    1\n%    Player 5    0    0   1    0    1  1    1   1    0\n%    Duration    2    4   1    3    3  2    5   7    6\n%\n% For example, if the nine pieces were rehearsed in numerical order as\n% given above, then the total waiting time would be:\n%       Player 1: 1+3+7=11\n%       Player 2: 1+5=6\n%       Player 3: 1+3+3+2=9\n%       Player 4: 4+1+3+5+7=20\n%       Player 5: 3\n% giving a total of 49 units. The optimal sequence, as we shall see,\n% is much better than this.\n%\n% ...\n%\n% The minimum waiting time for the rehearsal problem is 17 time units, and\n% an optimal sequence is 3, 8, 2, 7, 1, 6, 5, 4, 9.\n%\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \n\n\nint: num_pieces;\nint: num_players;\narray[1..num_pieces] of int: duration;\narray[1..num_players, 1..num_pieces] of 0..1: rehearsal;\n\n\n%\n% Decision variables\n%\narray[1..num_pieces] of var 1..num_pieces: rehearsal_order;\narray[1..num_players] of var 0..sum(duration): waiting_time; % waiting time for players\narray[1..num_players] of var 1..num_pieces: p_from; % first rehearsal\narray[1..num_players] of var 1..num_pieces: p_to;   % last rehearsal\nvar 0..sum(duration): total_waiting_time = sum(waiting_time); % objective\n\nsolve :: int_search(\n         rehearsal_order % ++ waiting_time% ++ p_from ++ p_to ++ [total_waiting_time]\n         , \n         first_fail, % occurrence, % max_regret, % first_fail, \n         indomain_max, % indomain_max, \n         complete) \n     minimize total_waiting_time;\n     % satisfy;\n\n% solve :: labelling_ff minimize total_waiting_time;\n\nconstraint\n  all_different(rehearsal_order) :: domain\n  /\\\n\n  % This solution is my own without glancing at Smith's models...\n  forall(p in 1..num_players) (\n     % This versions is much faster than using exists (see below)\n     % fix the range from..to, i.e. don't count all that start with 0 \n     % or ends with 0.\n     % This means that we collect the rehearsals with many 0 at the ends\n     %\n     p_from[p] < p_to[p]\n     /\\\n     % skipping rehearsal at start (don't come yet)\n     forall(i in 1..num_pieces) (\n        i < p_from[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\\n     % skipping rehearsal at end (go home after last rehearsal)\n     forall(i in 1..num_pieces) (\n        i > p_to[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\ % and now: count the waiting time for from..to\n     waiting_time[p] = \n         sum(i in 1..num_pieces) (\n              duration[rehearsal_order[i]] * bool2int(\n                                             i >= p_from[p] /\\ i <= p_to[p] \n                                             /\\\n                                             rehearsal[p,rehearsal_order[i]] = 0\n                                )\n     ) \n\n%      % alternative solution with exists. \n%      %  More elegant (= declarative) in my book but slower.\n%      exists(from, to in 1..num_pieces) ( \n%         % skipping rehearsal at start (don't come yet)\n%         forall(i in 1..from-1) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\\n%         % skipping rehearsal at end (go home after last rehearsal)\n%         forall(i in to+1..num_pieces) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\ % and now: count the waiting time for from..to\n%         waiting_time[p] = \n%             sum(i in from..to) (\n%                  duration[rehearsal_order[i]]*\n%                                  bool2int(\n%                                       rehearsal[p,rehearsal_order[i]] = 0\n%                                   )\n%          ) \n%      )\n\n\n  )\n\n  /\\ % symmetry breaking\n  rehearsal_order[1] < rehearsal_order[num_pieces]\n\n  % for all solutions\n  % /\\ total_waiting_time = 17\n;\n\n\n%\n% data\n%\n%\n% num_pieces = 9;\n% num_players = 5;\n% duration = [2, 4, 1, 3, 3, 2, 5, 7, 6];\n% rehearsal = array2d(1..num_players, 1..num_pieces, \n%     [\n%      1,1,0,1,0,1,1,0,1,\n%      1,1,0,1,1,1,0,1,0,\n%      1,1,0,0,0,0,1,1,0,\n%      1,0,0,0,1,1,0,0,1,\n%      0,0,1,0,1,1,1,1,0\n%   ]);\n\n%\n% This is the problem from the Choco v 2.1 example \n% num_pieces = 5;\n% num_players = 3;\n% duration = [4,6,3,5,7];\n% rehearsal =  array2d(1..num_players, 1..num_pieces, \n%         [\n%         1,1,0,1,0,\n%         0,1,1,0,1,\n%         1,1,0,1,1   \n%   ]);\n\n\noutput[\n  \"order: \" , show(rehearsal_order), \"\\n\",\n  \"waiting_time: \", show(waiting_time), \"\\n\",\n  \"total_waiting_time: \" , show(total_waiting_time), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(rehearsal[p, rehearsal_order[j]]) ++ \" \"\n  | p in 1..num_players, j in 1..num_pieces, \n] ++ \n[\"\\n\"]\n;\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rehearsal_expert", "node_type": "4", "metadata": {"model_name": "rehearsal", "source_code": "%\n% Scheduling a Rehearsal in MiniZinc.\n% A concert is to consist of nine pieces of music of different durations\n% each involving a different combination of the five members of the orchestra.\n% Players can arrive at rehearsals immediately before the first piece in which\n% they are involved and depart immediately after the last piece in which\n% they are involved. The problem is to devise an order in which the pieces\n% can be rehearsed so as to minimize the total time that players are waiting\n% to play, i.e. the total time when players are present but not currently\n% playing. In the table below, 1 means that the player is required for\n% the corresponding piece, 0 otherwise. The duration (i.e. rehearsal time)\n% is in some unspecified time units.\n%\n%    Piece       1    2   3    4    5  6    7   8    9\n%    Player 1    1    1   0    1    0  1    1   0    1\n%    Player 2    1    1   0    1    1  1    0   1    0\n%    Player 3    1    1   0    0    0  0    1   1    0\n%    Player 4    1    0   0    0    1  1    0   0    1\n%    Player 5    0    0   1    0    1  1    1   1    0\n%    Duration    2    4   1    3    3  2    5   7    6\n%\n% For example, if the nine pieces were rehearsed in numerical order as\n% given above, then the total waiting time would be:\n%       Player 1: 1+3+7=11\n%       Player 2: 1+5=6\n%       Player 3: 1+3+3+2=9\n%       Player 4: 4+1+3+5+7=20\n%       Player 5: 3\n% giving a total of 49 units. The optimal sequence, as we shall see,\n% is much better than this.\n%\n% ...\n%\n% The minimum waiting time for the rehearsal problem is 17 time units, and\n% an optimal sequence is 3, 8, 2, 7, 1, 6, 5, 4, 9.\n%\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \n\n\nint: num_pieces;\nint: num_players;\narray[1..num_pieces] of int: duration;\narray[1..num_players, 1..num_pieces] of 0..1: rehearsal;\n\n\n%\n% Decision variables\n%\narray[1..num_pieces] of var 1..num_pieces: rehearsal_order;\narray[1..num_players] of var 0..sum(duration): waiting_time; % waiting time for players\narray[1..num_players] of var 1..num_pieces: p_from; % first rehearsal\narray[1..num_players] of var 1..num_pieces: p_to;   % last rehearsal\nvar 0..sum(duration): total_waiting_time = sum(waiting_time); % objective\n\nsolve :: int_search(\n         rehearsal_order % ++ waiting_time% ++ p_from ++ p_to ++ [total_waiting_time]\n         , \n         first_fail, % occurrence, % max_regret, % first_fail, \n         indomain_max, % indomain_max, \n         complete) \n     minimize total_waiting_time;\n     % satisfy;\n\n% solve :: labelling_ff minimize total_waiting_time;\n\nconstraint\n  all_different(rehearsal_order) :: domain\n  /\\\n\n  % This solution is my own without glancing at Smith's models...\n  forall(p in 1..num_players) (\n     % This versions is much faster than using exists (see below)\n     % fix the range from..to, i.e. don't count all that start with 0 \n     % or ends with 0.\n     % This means that we collect the rehearsals with many 0 at the ends\n     %\n     p_from[p] < p_to[p]\n     /\\\n     % skipping rehearsal at start (don't come yet)\n     forall(i in 1..num_pieces) (\n        i < p_from[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\\n     % skipping rehearsal at end (go home after last rehearsal)\n     forall(i in 1..num_pieces) (\n        i > p_to[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\ % and now: count the waiting time for from..to\n     waiting_time[p] = \n         sum(i in 1..num_pieces) (\n              duration[rehearsal_order[i]] * bool2int(\n                                             i >= p_from[p] /\\ i <= p_to[p] \n                                             /\\\n                                             rehearsal[p,rehearsal_order[i]] = 0\n                                )\n     ) \n\n%      % alternative solution with exists. \n%      %  More elegant (= declarative) in my book but slower.\n%      exists(from, to in 1..num_pieces) ( \n%         % skipping rehearsal at start (don't come yet)\n%         forall(i in 1..from-1) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\\n%         % skipping rehearsal at end (go home after last rehearsal)\n%         forall(i in to+1..num_pieces) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\ % and now: count the waiting time for from..to\n%         waiting_time[p] = \n%             sum(i in from..to) (\n%                  duration[rehearsal_order[i]]*\n%                                  bool2int(\n%                                       rehearsal[p,rehearsal_order[i]] = 0\n%                                   )\n%          ) \n%      )\n\n\n  )\n\n  /\\ % symmetry breaking\n  rehearsal_order[1] < rehearsal_order[num_pieces]\n\n  % for all solutions\n  % /\\ total_waiting_time = 17\n;\n\n\n%\n% data\n%\n%\n% num_pieces = 9;\n% num_players = 5;\n% duration = [2, 4, 1, 3, 3, 2, 5, 7, 6];\n% rehearsal = array2d(1..num_players, 1..num_pieces, \n%     [\n%      1,1,0,1,0,1,1,0,1,\n%      1,1,0,1,1,1,0,1,0,\n%      1,1,0,0,0,0,1,1,0,\n%      1,0,0,0,1,1,0,0,1,\n%      0,0,1,0,1,1,1,1,0\n%   ]);\n\n%\n% This is the problem from the Choco v 2.1 example \n% num_pieces = 5;\n% num_players = 3;\n% duration = [4,6,3,5,7];\n% rehearsal =  array2d(1..num_players, 1..num_pieces, \n%         [\n%         1,1,0,1,0,\n%         0,1,1,0,1,\n%         1,1,0,1,1   \n%   ]);\n\n\noutput[\n  \"order: \" , show(rehearsal_order), \"\\n\",\n  \"waiting_time: \", show(waiting_time), \"\\n\",\n  \"total_waiting_time: \" , show(total_waiting_time), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(rehearsal[p, rehearsal_order[j]]) ++ \" \"\n  | p in 1..num_players, j in 1..num_pieces, \n] ++ \n[\"\\n\"]\n;\n\n"}, "hash": "3ff56b6cd55b869f42dded9154eeab6437289cb3e9c76331e9c847cfb21c5704", "class_name": "RelatedNodeInfo"}}, "text": "name: Rehearsal Scheduling Problem\n\ndescription: The problem involves scheduling a rehearsal for a concert consisting of nine pieces of music with different durations, each requiring a different combination of five orchestra players. The goal is to find an order in which the pieces can be rehearsed to minimize the total time that players are waiting to play, i.e., the total time when players are present but not currently playing.\n\nvariables: rehearsal_order \u2208 {1, ..., num_pieces}^num_pieces, waiting_time \u2208 \u2124^num_players, p_from \u2208 {1, ..., num_pieces}^num_players, p_to \u2208 {1, ..., num_pieces}^num_players, total_waiting_time \u2208 \u2124\n\nThe decision variables are:\n- rehearsal_order: an array representing the order in which the pieces are rehearsed\n- waiting_time: an array representing the waiting time for each player\n- p_from and p_to: arrays representing the first and last pieces each player is involved in, respectively\n- total_waiting_time: the total waiting time for all players\n\nconstraints: \nall_different(rehearsal_order), \np_from[p] < p_to[p] \u2200p \u2208 {1, ..., num_players}, \nrehearsal[p, rehearsal_order[i]] = 0 \u2200p \u2208 {1, ..., num_players}, i < p_from[p], \nrehearsal[p, rehearsal_order[i]] = 0 \u2200p \u2208 {1, ..., num_players}, i > p_to[p], \nwaiting_time[p] = \u2211(i \u2208 {1, ..., num_pieces}) (duration[rehearsal_order[i]] * bool2int(i \u2265 p_from[p] \u2227 i \u2264 p_to[p] \u2227 rehearsal[p, rehearsal_order[i]] = 0)) \u2200p \u2208 {1, ..., num_players}, \nrehearsal_order[1] < rehearsal_order[num_pieces]\n\nThe constraints are:\n- all_different(rehearsal_order): ensures that each piece is rehearsed exactly once\n- p_from[p] < p_to[p]: ensures that the first piece each player is involved in is before the last piece\n- rehearsal[p, rehearsal_order[i]] = 0: ensures that players are not involved in pieces before their first or after their last piece\n- waiting_time[p] = ...: calculates the waiting time for each player\n- rehearsal_order[1] < rehearsal_order[num_pieces]: breaks symmetry by ensuring that the first piece is rehearsed before the last piece\n\nobjective: minimize total_waiting_time", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2064, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "49baeef8-6e28-45cb-99df-864df0eea981": {"__data__": {"id_": "49baeef8-6e28-45cb-99df-864df0eea981", "embedding": null, "metadata": {"model_name": "restart", "source_code": "Model 1 : \n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n\nModel 2 :\n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_max, complete)\n      satisfy;\n\n\nModel 3 : \n\n\narray[1..10] of var 1..10:x;\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "restart_expert", "node_type": "4", "metadata": {"model_name": "restart", "source_code": "Model 1 : \n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n\nModel 2 :\n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_max, complete)\n      satisfy;\n\n\nModel 3 : \n\n\narray[1..10] of var 1..10:x;\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n"}, "hash": "84f4609be2c6f4ae58e4ed738bad03740516181659af93d70a4b264e361bccfc", "class_name": "RelatedNodeInfo"}}, "text": "name: Permutation with Restrictions\n\ndescription: This problem involves finding a permutation of numbers from 1 to 10, where the first element is at least 9, and all elements from the second to the tenth are at most 9. The goal is to find a permutation that satisfies these restrictions.\n\nvariables: x = (x[1], x[2], ..., x[10]) \u2208 {1, 2, ..., 10}^10\nThese variables represent the elements of the permutation, where x[i] is the i-th element of the permutation.\n\nconstraints: \n\u2200i, j \u2208 {1, 2, ..., 10} where i < j, x[i] \u2260 x[j] (alldifferent constraint)\n\u2200i \u2208 {2, 3, ..., 10}, x[i] \u2264 9\nx[1] \u2265 9\nThe first constraint ensures that all elements in the permutation are distinct. The second constraint restricts the values of elements from the second to the tenth to be at most 9. The third constraint ensures that the first element is at least 9.\n\nobjective: satisfy\nThe objective of this problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific value.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 995, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a7291c84-11ce-4d56-9ff4-af47346d9bdf": {"__data__": {"id_": "a7291c84-11ce-4d56-9ff4-af47346d9bdf", "embedding": null, "metadata": {"model_name": "RosteringProblem", "source_code": "include \"all_equal.mzn\";\ninclude \"global_cardinality.mzn\";\n\n% load parameters\ninclude \"parameters.dzn\";\n\nint: daysPerWeek = 7;\n\n% the number of weeks\nint: numberOfWeeks;\n\nint: numberOfDays = numberOfWeeks * daysPerWeek;\n\n% the minimum number of days in a row with the same shift\nint: s_min;\n\n% the maximum number of days in a row with the same shift\nint: s_max; \n\n% 3 shifts: early = 1, late = 2 and night shift = 3 + day off (rest day) = 0\nint: numberOfShifts = 3;\n\n% the shift requirement matrix, including at M_{i,j} the needed employees for day i and shift j\narray[1..daysPerWeek, 1..numberOfShifts+1] of int: shiftRequirements;\n\n\n% the variables X \narray[1..numberOfWeeks * daysPerWeek] of var 0..numberOfShifts: plan1d;\narray[1..numberOfWeeks,1..daysPerWeek] of var 0..numberOfShifts: plan2d;\narray[1..daysPerWeek,1..numberOfWeeks] of var 0..numberOfShifts: plan2dT;\n\n% helper arrays\narray[1..s_min,1..s_min] of var 0..numberOfShifts: s_min_arrays;\narray[1..s_max,1..s_max] of var 0..numberOfShifts: s_max_arrays;\n\n% convert the 2D plan into 1D\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan1d[(week-1) * daysPerWeek + day]\n           );  \n\n% transpose the 2D plan\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan2dT[day, week]\n           );\n\n% C_equalDays: constrains that weekend days (Saturday and Sunday) always have the same shift\nconstraint forall(week in 1..numberOfWeeks) (\n               plan2d[week, daysPerWeek - 1] == plan2d[week, daysPerWeek]\n           );                        \n\n                                                                                                                                \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_min, j in 1..s_min) (\n                 s_min_arrays[i, j] == plan1d[((numberOfDays - s_min - 1 + i + j) mod numberOfDays) + 1]\n           );                                            \n                                            \n% C_shiftRepetitions:for every shift type a minimum number of consecutive assignments to this shift is given\nconstraint forall(day in 1..numberOfDays - s_min) (\n               plan1d[day] != plan1d[day+1] -> all_equal(plan1d[day+1..day+s_min])\n           );     \n% the constraints over the array bounds           \nconstraint forall(d in 1..s_min) (\n               plan1d[d + numberOfDays - s_min] != plan1d[((d + numberOfDays - s_min) mod numberOfDays) +1] -> all_equal(s_min_arrays[d,1..s_min])\n           );                     \n\n           \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_max, j in 1..s_max) (\n                 s_max_arrays[i, j] == plan1d[((numberOfDays - s_max - 2 + i + j) mod numberOfDays) + 1]\n           );                      \n                                            \n% C_shiftRepetitions:for every shift type a maximum number of consecutive assignments to this shift is given           \nconstraint forall(day in 1..numberOfWeeks * daysPerWeek - s_max) (\n               (all_equal(plan1d[day..day+s_max])) -> (plan1d[day] != plan1d[day + s_max])\n           );               \n% the constraints over the array bounds             \nconstraint forall(d in 1..s_max) (\n               (all_equal(s_max_arrays[d, 1..s_max])) -> (plan1d[d + numberOfDays - s_max] != plan1d[d])\n           );                     \n\n                               \n                                                                                                   \n% C_restDays: at least 2 days must be rest days every 2 weeks.\nconstraint forall(day in 1..(numberOfWeeks - 2) * daysPerWeek) (\n               count(j in plan1d[day..day + daysPerWeek * 2])(j=0) >= 2                   \n           );            \nconstraint forall(i in 1..2 * daysPerWeek-1) (\n               count(j in plan1d[numberOfWeeks * daysPerWeek-i .. numberOfWeeks * daysPerWeek] ++ plan1d[1..2*daysPerWeek-i])(j=0) >= 2    \n           );         \n                                            \n% C_shiftOrder: restricts the order of shifts. There is a forward rotating principle. This means, that after an early shift there can only follow a shift with the same or a higher value, or a rest shift.\nconstraint forall(day in 2..numberOfWeeks * daysPerWeek - 1) (\n               plan1d[day] <= plan1d[day + 1] \\/ plan1d[day+1] == 0\n           );         \nconstraint plan1d[1] >= plan1d[numberOfDays] \\/ plan1d[1] == 0;\n                      \n% C_shiftRequirements: for every weekday for each shift the number of required staff is provided (e.g. usually less staff is required on the weekend) \nconstraint forall(day in 1..daysPerWeek) (\n              (global_cardinality(row(plan2dT,day),[0,1,2,3],row(shiftRequirements,day)))   \n           );    \n           \n% solve the problem           \nsolve :: int_search(plan1d, input_order, indomain_min, complete)\n      satisfy;           \n      \n% print the problem      \noutput [ show(row(plan2d,j)) ++ \"\\n\" | j in 1..numberOfWeeks ] ++ [\"\\n\"];      "}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "RosteringProblem_expert", "node_type": "4", "metadata": {"model_name": "RosteringProblem", "source_code": "include \"all_equal.mzn\";\ninclude \"global_cardinality.mzn\";\n\n% load parameters\ninclude \"parameters.dzn\";\n\nint: daysPerWeek = 7;\n\n% the number of weeks\nint: numberOfWeeks;\n\nint: numberOfDays = numberOfWeeks * daysPerWeek;\n\n% the minimum number of days in a row with the same shift\nint: s_min;\n\n% the maximum number of days in a row with the same shift\nint: s_max; \n\n% 3 shifts: early = 1, late = 2 and night shift = 3 + day off (rest day) = 0\nint: numberOfShifts = 3;\n\n% the shift requirement matrix, including at M_{i,j} the needed employees for day i and shift j\narray[1..daysPerWeek, 1..numberOfShifts+1] of int: shiftRequirements;\n\n\n% the variables X \narray[1..numberOfWeeks * daysPerWeek] of var 0..numberOfShifts: plan1d;\narray[1..numberOfWeeks,1..daysPerWeek] of var 0..numberOfShifts: plan2d;\narray[1..daysPerWeek,1..numberOfWeeks] of var 0..numberOfShifts: plan2dT;\n\n% helper arrays\narray[1..s_min,1..s_min] of var 0..numberOfShifts: s_min_arrays;\narray[1..s_max,1..s_max] of var 0..numberOfShifts: s_max_arrays;\n\n% convert the 2D plan into 1D\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan1d[(week-1) * daysPerWeek + day]\n           );  \n\n% transpose the 2D plan\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan2dT[day, week]\n           );\n\n% C_equalDays: constrains that weekend days (Saturday and Sunday) always have the same shift\nconstraint forall(week in 1..numberOfWeeks) (\n               plan2d[week, daysPerWeek - 1] == plan2d[week, daysPerWeek]\n           );                        \n\n                                                                                                                                \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_min, j in 1..s_min) (\n                 s_min_arrays[i, j] == plan1d[((numberOfDays - s_min - 1 + i + j) mod numberOfDays) + 1]\n           );                                            \n                                            \n% C_shiftRepetitions:for every shift type a minimum number of consecutive assignments to this shift is given\nconstraint forall(day in 1..numberOfDays - s_min) (\n               plan1d[day] != plan1d[day+1] -> all_equal(plan1d[day+1..day+s_min])\n           );     \n% the constraints over the array bounds           \nconstraint forall(d in 1..s_min) (\n               plan1d[d + numberOfDays - s_min] != plan1d[((d + numberOfDays - s_min) mod numberOfDays) +1] -> all_equal(s_min_arrays[d,1..s_min])\n           );                     \n\n           \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_max, j in 1..s_max) (\n                 s_max_arrays[i, j] == plan1d[((numberOfDays - s_max - 2 + i + j) mod numberOfDays) + 1]\n           );                      \n                                            \n% C_shiftRepetitions:for every shift type a maximum number of consecutive assignments to this shift is given           \nconstraint forall(day in 1..numberOfWeeks * daysPerWeek - s_max) (\n               (all_equal(plan1d[day..day+s_max])) -> (plan1d[day] != plan1d[day + s_max])\n           );               \n% the constraints over the array bounds             \nconstraint forall(d in 1..s_max) (\n               (all_equal(s_max_arrays[d, 1..s_max])) -> (plan1d[d + numberOfDays - s_max] != plan1d[d])\n           );                     \n\n                               \n                                                                                                   \n% C_restDays: at least 2 days must be rest days every 2 weeks.\nconstraint forall(day in 1..(numberOfWeeks - 2) * daysPerWeek) (\n               count(j in plan1d[day..day + daysPerWeek * 2])(j=0) >= 2                   \n           );            \nconstraint forall(i in 1..2 * daysPerWeek-1) (\n               count(j in plan1d[numberOfWeeks * daysPerWeek-i .. numberOfWeeks * daysPerWeek] ++ plan1d[1..2*daysPerWeek-i])(j=0) >= 2    \n           );         \n                                            \n% C_shiftOrder: restricts the order of shifts. There is a forward rotating principle. This means, that after an early shift there can only follow a shift with the same or a higher value, or a rest shift.\nconstraint forall(day in 2..numberOfWeeks * daysPerWeek - 1) (\n               plan1d[day] <= plan1d[day + 1] \\/ plan1d[day+1] == 0\n           );         \nconstraint plan1d[1] >= plan1d[numberOfDays] \\/ plan1d[1] == 0;\n                      \n% C_shiftRequirements: for every weekday for each shift the number of required staff is provided (e.g. usually less staff is required on the weekend) \nconstraint forall(day in 1..daysPerWeek) (\n              (global_cardinality(row(plan2dT,day),[0,1,2,3],row(shiftRequirements,day)))   \n           );    \n           \n% solve the problem           \nsolve :: int_search(plan1d, input_order, indomain_min, complete)\n      satisfy;           \n      \n% print the problem      \noutput [ show(row(plan2d,j)) ++ \"\\n\" | j in 1..numberOfWeeks ] ++ [\"\\n\"];      "}, "hash": "ad025b0b65da2df91d6d64e8dd61f2d98e1d42c2012934b5e4e11ef91682868a", "class_name": "RelatedNodeInfo"}}, "text": "name: Nurse Rostering Problem\n\ndescription: The Nurse Rostering Problem is a classic problem in constraint programming that involves creating a schedule for nurses to work in a hospital. The problem involves assigning shifts to nurses over a certain period of time, taking into account various constraints such as the number of nurses required for each shift, the minimum and maximum number of consecutive days a nurse can work, and the requirement for rest days.\n\nvariables: plan1d, plan2d, plan2dT, s_min_arrays, s_max_arrays\nplan1d, plan2d, and plan2dT are arrays of decision variables that represent the shift assignments for each nurse over the planning period. plan1d is a 1D array, while plan2d and plan2dT are 2D arrays that represent the same schedule in different formats. s_min_arrays and s_max_arrays are helper arrays used to model the minimum and maximum consecutive days constraints.\n\nconstraints: \nC_equalDays: plan2d[week, daysPerWeek - 1] == plan2d[week, daysPerWeek]\nC_shiftRepetitions: forall(day in 1..numberOfDays - s_min) (plan1d[day] != plan1d[day+1] -> all_equal(plan1d[day+1..day+s_min]))\nC_shiftRepetitions: forall(day in 1..numberOfWeeks * daysPerWeek - s_max) ((all_equal(plan1d[day..day+s_max])) -> (plan1d[day] != plan1d[day + s_max]))\nC_restDays: forall(day in 1..(numberOfWeeks - 2) * daysPerWeek) (count(j in plan1d[day..day + daysPerWeek * 2])(j=0) >= 2)\nC_shiftOrder: forall(day in 2..numberOfWeeks * daysPerWeek - 1) (plan1d[day] <= plan1d[day + 1] \\/ plan1d[day+1] == 0)\nC_shiftRequirements: forall(day in 1..daysPerWeek) ((global_cardinality(row(plan2dT,day),[0,1,2,3],row(shiftRequirements,day))))\n\nThese constraints ensure that: \n- weekend days have the same shift\n- there is a minimum and maximum number of consecutive days with the same shift\n- there are at least 2 rest days every 2 weeks\n- the order of shifts follows a forward rotating principle\n- the number of required staff for each shift is satisfied\n\nobjective: The objective of the problem is to find a feasible schedule that satisfies all the constraints, rather than to minimize or maximize a specific value.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2112, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8cf6f982-34cd-43e6-a45a-efe4a0c40dc2": {"__data__": {"id_": "8cf6f982-34cd-43e6-a45a-efe4a0c40dc2", "embedding": null, "metadata": {"model_name": "sb", "source_code": "% Solitaire Battleships is a puzzle where\n% we are given a partially filled in board and the number\n% of ships in each row and column and have to fill it with ships\n \n% \"Improved\" version does not introduce reified set_in\n\nint: width;   % height of board (usually 10)\nint: height;  % width of board (usually 10)\nint: maxship; % maximal length of ship (usually 4)\n\n\nset of int: ROWS = 1..width;\nset of int: COLS = 1..height;\nset of int: XROWS = 0..width+1;    % extended rows\nset of int: XCOLS = 0..height+1;   % extended cols\n\n%% ship types enumerated type\nset of int: SHIPS = 1..maxship;  % different ship types\nint: submarine = 1;\nint: destroyer = 2;\nint: cruiser = 3;\nint: battleship = 4;\n\n\n%% the PIECES enumerated type!\nset of int: PIECES = 1..7;\nint: w = 1; % water\nint: c = 2; % circle (submarine)\nint: l = 3; % left end of ship\nint: r = 4; % right end of ship\nint: t = 5; % top of ship\nint: b = 6; % bottom of ship\nint: m = 7; % middle of ship\narray[PIECES] of string: code = [\".\",\"c\",\"l\",\"r\",\"t\",\"b\",\"m\"];\n\narray[ROWS,COLS] of 0..7: hint; % the initial board configuration\narray[ROWS] of int: rowsum;     % sums for each row\narray[COLS] of int: colsum;     % sums for each col\narray[SHIPS] of int: ship; % the number of each type of ship (usually [4,3,2,1]).\n\n\n\n% variables \narray[XROWS,XCOLS] of var PIECES: board;  % the board\n \narray[XROWS,XCOLS] of var 0..1: fill;     % which pieces are ships\n\narray[PIECES] of var 0..width*height: npiece; % number of pieces of each type\n\n\n% model\n\n% ensure hints are respected\nconstraint forall(i in ROWS, j in COLS)(\n\t\t\t   if hint[i,j] != 0 then\n\t\t\t   \t\tboard[i,j] == hint[i,j]\n\t\t\t   else true endif\n\t       ); \n\n% make extended rows and cols empty\nconstraint forall(i in XROWS)(board[i,0] == w /\\ board[i,width+1] == w);\nconstraint forall(j in COLS)(board[0,j] == w /\\ board[height+1,j] == w);\n\n% ensure that the fill array matches the board\nconstraint forall(i in XROWS, j in XCOLS)(\n\t\t\t   fill[i,j] = bool2int(board[i,j] != w)\n\t       ); \n\n% spacing constraints: gaps betwen ships\nconstraint forall(i in ROWS, j in COLS)(\n\t   (board[i,j] == w \\/ board[i+1,j+1] == w)\n\t/\\ (board[i,j] == w \\/ board[i+1,j-1] == w)   % diagonal constraints\n            /\\ (board[i,j] in {c,l,r,t} -> board[i-1,j] == w)\n            /\\ (board[i,j] in {c,l,r,b} -> board[i+1,j] == w)\n            /\\ (board[i,j] in {c,l,t,b} -> board[i,j-1] == w)\n            /\\ (board[i,j] in {c,r,t,b} -> board[i,j+1] == w)\n           );\n               \t\t\t                       \n% ship shape constraints\nconstraint forall(i in ROWS, j in COLS)(\n               %% a left piece needs a right piece or middle to the right\n\t\t\t   (board[i,j] == l -> (board[i,j+1] == r \\/ board[i,j+1] == m))\n\t\t\t/\\ (board[i,j] == r -> (board[i,j-1] == l \\/ board[i,j-1] == m))\n\t\t\t/\\ (board[i,j] == t -> (board[i+1,j] == b \\/ board[i+1,j] == m))\n\t\t\t/\\ (board[i,j] == b -> (board[i-1,j] == t \\/ board[i-1,j] == m))\n\t\t\t   %% a middle piece has to have two opposite sides filled\n\t\t\t/\\ (board[i,j] == m -> (   fill[i-1,j] == fill[i+1,j]\n\t\t\t                        /\\ fill[i,j-1] == fill[i,j+1]\n\t\t\t                        /\\ fill[i-1,j] + fill[i,j-1] == 1))\n\t\t   );\n\t\t   \n% sum up pieces\nconstraint forall(p in PIECES)(\n\t\t\t   sum(i in ROWS, j in COLS)(bool2int(board[i,j] == p)) == npiece[p]\n\t\t   );\n\n% piece sum constraints\nconstraint npiece[c] == ship[submarine]; % submarines\nconstraint npiece[l] == npiece[r]; % left right (probably redundant)\nconstraint npiece[t] == npiece[b]; % top bottom\nconstraint npiece[l] + npiece[t] == sum(s in destroyer..maxship)(ship[s]); \n                                   % no of ends\nconstraint npiece[m] == sum(s in cruiser..maxship)(ship[s] * (s - 2)); \n                                   % no of middles \t\t   \n\t\t    \n% count number of bigger ships\n% at least for standard battleships you can probably simply\n% enforce this constraint for s in destroyer..destroyer\t\t\n% and still be guaranteed a correct solution    \nconstraint forall(s in destroyer..maxship)(\n\t           sum(i in ROWS,j in COLS)(bool2int(\n\t\t\t       if j + s - 1 <= width then\n\t\t\t          board[i,j] == l /\\ board[i,j+s-1] == r     % ship length s lr\n\t\t\t       /\\ forall(k in j+1..j+s-2)(board[i,k] == m)\n\t\t\t       else false endif\n\t\t\t    \\/\n\t\t\t       if i + s - 1 <= height then\n\t\t\t          board[i,j] == t /\\ board[i+s-1,j] == b     % ship length s tb\n\t\t\t       /\\ forall(k in i+1..i+s-2)(board[k,j] == m)\n\t\t\t       else false endif\n\t\t       )) = ship[s]\n\t\t   );\t\t    \n\t\t    \t\t    \n\n% row sums respected\nconstraint forall(i in ROWS)(\n               sum(j in COLS)(fill[i,j]) == rowsum[i]\n           );\n           \n% column sums respected           \nconstraint forall(j in COLS)(\n               sum(i in ROWS)(fill[i,j]) == colsum[j]\n           );           \n\n\nsolve :: int_search([ fill[i,j] | i in ROWS, j in COLS], \n      \t\t  input_order, indomain_min, complete)\n      satisfy;\n\noutput [ code[fix(board[i,j])] ++ \n\t\t if j == width then \" \" ++ show(rowsum[i]) ++ \"\\n\"\n\t\t else \"\" endif\n\t   | i in ROWS, j in COLS ]  ++\n\t   [ show(colsum[j]) | j in COLS ] ++ [\"\\n\"];\n\t   \n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sb_expert", "node_type": "4", "metadata": {"model_name": "sb", "source_code": "% Solitaire Battleships is a puzzle where\n% we are given a partially filled in board and the number\n% of ships in each row and column and have to fill it with ships\n \n% \"Improved\" version does not introduce reified set_in\n\nint: width;   % height of board (usually 10)\nint: height;  % width of board (usually 10)\nint: maxship; % maximal length of ship (usually 4)\n\n\nset of int: ROWS = 1..width;\nset of int: COLS = 1..height;\nset of int: XROWS = 0..width+1;    % extended rows\nset of int: XCOLS = 0..height+1;   % extended cols\n\n%% ship types enumerated type\nset of int: SHIPS = 1..maxship;  % different ship types\nint: submarine = 1;\nint: destroyer = 2;\nint: cruiser = 3;\nint: battleship = 4;\n\n\n%% the PIECES enumerated type!\nset of int: PIECES = 1..7;\nint: w = 1; % water\nint: c = 2; % circle (submarine)\nint: l = 3; % left end of ship\nint: r = 4; % right end of ship\nint: t = 5; % top of ship\nint: b = 6; % bottom of ship\nint: m = 7; % middle of ship\narray[PIECES] of string: code = [\".\",\"c\",\"l\",\"r\",\"t\",\"b\",\"m\"];\n\narray[ROWS,COLS] of 0..7: hint; % the initial board configuration\narray[ROWS] of int: rowsum;     % sums for each row\narray[COLS] of int: colsum;     % sums for each col\narray[SHIPS] of int: ship; % the number of each type of ship (usually [4,3,2,1]).\n\n\n\n% variables \narray[XROWS,XCOLS] of var PIECES: board;  % the board\n \narray[XROWS,XCOLS] of var 0..1: fill;     % which pieces are ships\n\narray[PIECES] of var 0..width*height: npiece; % number of pieces of each type\n\n\n% model\n\n% ensure hints are respected\nconstraint forall(i in ROWS, j in COLS)(\n\t\t\t   if hint[i,j] != 0 then\n\t\t\t   \t\tboard[i,j] == hint[i,j]\n\t\t\t   else true endif\n\t       ); \n\n% make extended rows and cols empty\nconstraint forall(i in XROWS)(board[i,0] == w /\\ board[i,width+1] == w);\nconstraint forall(j in COLS)(board[0,j] == w /\\ board[height+1,j] == w);\n\n% ensure that the fill array matches the board\nconstraint forall(i in XROWS, j in XCOLS)(\n\t\t\t   fill[i,j] = bool2int(board[i,j] != w)\n\t       ); \n\n% spacing constraints: gaps betwen ships\nconstraint forall(i in ROWS, j in COLS)(\n\t   (board[i,j] == w \\/ board[i+1,j+1] == w)\n\t/\\ (board[i,j] == w \\/ board[i+1,j-1] == w)   % diagonal constraints\n            /\\ (board[i,j] in {c,l,r,t} -> board[i-1,j] == w)\n            /\\ (board[i,j] in {c,l,r,b} -> board[i+1,j] == w)\n            /\\ (board[i,j] in {c,l,t,b} -> board[i,j-1] == w)\n            /\\ (board[i,j] in {c,r,t,b} -> board[i,j+1] == w)\n           );\n               \t\t\t                       \n% ship shape constraints\nconstraint forall(i in ROWS, j in COLS)(\n               %% a left piece needs a right piece or middle to the right\n\t\t\t   (board[i,j] == l -> (board[i,j+1] == r \\/ board[i,j+1] == m))\n\t\t\t/\\ (board[i,j] == r -> (board[i,j-1] == l \\/ board[i,j-1] == m))\n\t\t\t/\\ (board[i,j] == t -> (board[i+1,j] == b \\/ board[i+1,j] == m))\n\t\t\t/\\ (board[i,j] == b -> (board[i-1,j] == t \\/ board[i-1,j] == m))\n\t\t\t   %% a middle piece has to have two opposite sides filled\n\t\t\t/\\ (board[i,j] == m -> (   fill[i-1,j] == fill[i+1,j]\n\t\t\t                        /\\ fill[i,j-1] == fill[i,j+1]\n\t\t\t                        /\\ fill[i-1,j] + fill[i,j-1] == 1))\n\t\t   );\n\t\t   \n% sum up pieces\nconstraint forall(p in PIECES)(\n\t\t\t   sum(i in ROWS, j in COLS)(bool2int(board[i,j] == p)) == npiece[p]\n\t\t   );\n\n% piece sum constraints\nconstraint npiece[c] == ship[submarine]; % submarines\nconstraint npiece[l] == npiece[r]; % left right (probably redundant)\nconstraint npiece[t] == npiece[b]; % top bottom\nconstraint npiece[l] + npiece[t] == sum(s in destroyer..maxship)(ship[s]); \n                                   % no of ends\nconstraint npiece[m] == sum(s in cruiser..maxship)(ship[s] * (s - 2)); \n                                   % no of middles \t\t   \n\t\t    \n% count number of bigger ships\n% at least for standard battleships you can probably simply\n% enforce this constraint for s in destroyer..destroyer\t\t\n% and still be guaranteed a correct solution    \nconstraint forall(s in destroyer..maxship)(\n\t           sum(i in ROWS,j in COLS)(bool2int(\n\t\t\t       if j + s - 1 <= width then\n\t\t\t          board[i,j] == l /\\ board[i,j+s-1] == r     % ship length s lr\n\t\t\t       /\\ forall(k in j+1..j+s-2)(board[i,k] == m)\n\t\t\t       else false endif\n\t\t\t    \\/\n\t\t\t       if i + s - 1 <= height then\n\t\t\t          board[i,j] == t /\\ board[i+s-1,j] == b     % ship length s tb\n\t\t\t       /\\ forall(k in i+1..i+s-2)(board[k,j] == m)\n\t\t\t       else false endif\n\t\t       )) = ship[s]\n\t\t   );\t\t    \n\t\t    \t\t    \n\n% row sums respected\nconstraint forall(i in ROWS)(\n               sum(j in COLS)(fill[i,j]) == rowsum[i]\n           );\n           \n% column sums respected           \nconstraint forall(j in COLS)(\n               sum(i in ROWS)(fill[i,j]) == colsum[j]\n           );           \n\n\nsolve :: int_search([ fill[i,j] | i in ROWS, j in COLS], \n      \t\t  input_order, indomain_min, complete)\n      satisfy;\n\noutput [ code[fix(board[i,j])] ++ \n\t\t if j == width then \" \" ++ show(rowsum[i]) ++ \"\\n\"\n\t\t else \"\" endif\n\t   | i in ROWS, j in COLS ]  ++\n\t   [ show(colsum[j]) | j in COLS ] ++ [\"\\n\"];\n\t   \n"}, "hash": "3281914b6ae40e43263647d24ca5eb7a375bc59dffdbd21d6565a76c239f355e", "class_name": "RelatedNodeInfo"}}, "text": "name: Solitaire Battleships\n\ndescription: Solitaire Battleships is a puzzle where a partially filled board is given along with the number of ships in each row and column. The goal is to fill the board with ships of different lengths, respecting the given constraints.\n\nvariables: `board[i, j], fill[i, j], npiece[p]`\n\n* `board[i, j]`: a variable representing the type of piece (water, submarine, left/right/top/bottom of a ship, or middle of a ship) at position `(i, j)` on the board.\n* `fill[i, j]`: a binary variable indicating whether the piece at position `(i, j)` is part of a ship or not.\n* `npiece[p]`: a variable representing the number of pieces of type `p` on the board.\n\nconstraints: \n`hint[i, j] != 0 -> board[i, j] == hint[i, j], \nboard[i, 0] == w, board[i, width + 1] == w, \nboard[0, j] == w, board[height + 1, j] == w, \nfill[i, j] = bool2int(board[i, j] != w), \nspacing constraints, \nship shape constraints, \nsum up pieces, \npiece sum constraints, \ncount number of bigger ships, \nrow sums respected, \ncolumn sums respected`\n\n* `hint[i, j] != 0 -> board[i, j] == hint[i, j]`: ensure that the initial hints are respected.\n* `board[i, 0] == w, board[i, width + 1] == w, board[0, j] == w, board[height + 1, j] == w`: ensure that the extended rows and columns are empty.\n* `fill[i, j] = bool2int(board[i, j] != w)`: ensure that the fill array matches the board.\n* `spacing constraints`: ensure that there are gaps between ships.\n* `ship shape constraints`: ensure that ships are correctly formed.\n* `sum up pieces`: count the number of each type of piece.\n* `piece sum constraints`: ensure that the number of pieces of each type matches the given ship lengths.\n* `count number of bigger ships`: count the number of ships of each length.\n* `row sums respected`: ensure that the sum of pieces in each row matches the given row sum.\n* `column sums respected`: ensure that the sum of pieces in each column matches the given column sum.\n\nobjective: The objective is to satisfy all the constraints, i.e., to find a feasible solution. There is no objective function to minimize or maximize.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2093, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "460f7ffb-e565-4044-89e0-d75f71ae277d": {"__data__": {"id_": "460f7ffb-e565-4044-89e0-d75f71ae277d", "embedding": null, "metadata": {"model_name": "schur", "source_code": "%% schurs numbers\n%%\n%% determine if n balls labelled 1..n\n%% can be placed in c boxes with no box containing a triple {x,y,z} where x+y=z\n \n\nint: n; %% number of balls\nint: c; %% number of boxes\n\narray[1..n] of var 1..c: box;\n\nconstraint forall(i in 1..n-1, j in i+1 .. n - i)(\n\t   \t    box[i] != box[j] \\/ \n\t\t    box[i] != box[i+j] \\/ \n\t\t    box[j] != box[i+j]);\n\nsolve satisfy;\n\noutput [\"n = \", show(n), \";\\nc = \", show(c), \";\\nbox = \",show(box),\";\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "schur_expert", "node_type": "4", "metadata": {"model_name": "schur", "source_code": "%% schurs numbers\n%%\n%% determine if n balls labelled 1..n\n%% can be placed in c boxes with no box containing a triple {x,y,z} where x+y=z\n \n\nint: n; %% number of balls\nint: c; %% number of boxes\n\narray[1..n] of var 1..c: box;\n\nconstraint forall(i in 1..n-1, j in i+1 .. n - i)(\n\t   \t    box[i] != box[j] \\/ \n\t\t    box[i] != box[i+j] \\/ \n\t\t    box[j] != box[i+j]);\n\nsolve satisfy;\n\noutput [\"n = \", show(n), \";\\nc = \", show(c), \";\\nbox = \",show(box),\";\\n\"];\n"}, "hash": "52db4ee6fd0877e170114eccac4d2ec290de54ecb40b28d3736dc6dfa3472c6b", "class_name": "RelatedNodeInfo"}}, "text": "name: Schur's Numbers Problem\n\ndescription: The Schur's Numbers Problem is a classic problem in constraint programming that involves placing n balls labeled 1 to n into c boxes such that no box contains a triple of balls {x, y, z} where x + y = z.\n\nvariables: box = (box[1], ..., box[n]) \u2208 {1, ..., c}^n\nThe decision variables are the box assignments for each ball, where box[i] represents the box that ball i is placed in.\n\nconstraints: \u2200i \u2208 {1, ..., n-1}, \u2200j \u2208 {i+1, ..., n-i} : box[i] \u2260 box[j] \u2228 box[i] \u2260 box[i+j] \u2228 box[j] \u2260 box[i+j]\nThe constraints ensure that for any two balls i and j, if ball i is in box k, then ball j cannot be in box k, and ball i+j cannot be in box k.\n\nobjective: satisfy\nThe objective is to find a feasible solution that satisfies all the constraints, i.e., to determine if it is possible to place the balls in the boxes according to the given rules.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 879, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "876feadd-53f7-4f0c-8921-433be12f81b2": {"__data__": {"id_": "876feadd-53f7-4f0c-8921-433be12f81b2", "embedding": null, "metadata": {"model_name": "setselect", "source_code": "Model 1 :\n\n\n% setselect\nint: n; % number of elements\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 2 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\nconstraint card(x) = u;\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 3 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 1..n: x;\n%constraint forall(i in 1..u-1)(x[i] < x[i+1]);\nconstraint forall(i,j in 1..u where i < j)(x[i] != x[j]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 4 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality bound of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 0..n: x;\nconstraint forall(i in 1..u-1)(x[i] >= (x[i] != 0) + x[i+1]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "setselect_expert", "node_type": "4", "metadata": {"model_name": "setselect", "source_code": "Model 1 :\n\n\n% setselect\nint: n; % number of elements\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 2 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\nconstraint card(x) = u;\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 3 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 1..n: x;\n%constraint forall(i in 1..u-1)(x[i] < x[i+1]);\nconstraint forall(i,j in 1..u where i < j)(x[i] != x[j]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 4 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality bound of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 0..n: x;\nconstraint forall(i in 1..u-1)(x[i] >= (x[i] != 0) + x[i+1]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n"}, "hash": "ff725dd7f41c157d93be82d60b300866baab74889989152c3ce456685c09699a", "class_name": "RelatedNodeInfo"}}, "text": "name: Set Covering Problem\n\ndescription: The Set Covering Problem is a classic problem in computer science and operations research that involves finding a subset of elements that covers all subsets of a given set. In this problem, we have a set of elements and a collection of subsets of these elements. The goal is to select a subset of the elements such that each subset in the collection contains at most one element from the selected subset.\n\nvariables: x (Model 1), x (Model 2), x[1..u] (Model 3), x[1..u] (Model 4)\nThe decision variables represent the elements to be selected from the set of elements. In Models 1 and 2, x is a set of elements, while in Models 3 and 4, x is an array of variables representing the selected elements.\n\nconstraints: \ncard(x intersect s[i]) <= 1 (Model 1, 2), \ncard(x) = u (Model 2), \nx[i] < x[i+1] (Model 3), \nx[i] != x[j] (Model 3), \nsum(j in 1..u)(x[j] in s[i]) <= 1 (Model 3, 4), \nx[i] >= (x[i] != 0) + x[i+1] (Model 4)\nThe constraints ensure that each subset in the collection contains at most one element from the selected subset (card(x intersect s[i]) <= 1). In Model 2, the cardinality of the selected subset is fixed to u. In Model 3, the selected elements are distinct and in increasing order. In Model 4, the selected elements are also distinct, and the constraint ensures that the elements are in decreasing order.\n\nobjective: maximize sum(i in x)(i) (Model 1, 2), maximize sum(x) (Model 3, 4)\nThe objective is to maximize the sum of the selected elements.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1505, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "617ba7f2-d498-436c-b09c-8dd5138ac1fa": {"__data__": {"id_": "617ba7f2-d498-436c-b09c-8dd5138ac1fa", "embedding": null, "metadata": {"model_name": "shipping", "source_code": "int: W; % number of Warehousse\nset of int: WARE = 1..W;\nint: F; % number of Factories\nset of int: FACT = 1..F;\n\narray[WARE] of int: demand;\narray[FACT] of int: production;\n\narray[FACT,WARE] of int: cost;\n\narray[FACT,WARE] of var int: ship;\n\n%int: m = max(demand);\n%array[FACT,WARE] of var 0..m: ship;\nconstraint forall(f in FACT, w in WARE)(ship[f,w] >= 0);\n\nconstraint forall(w in WARE)\n                 (sum(f in FACT)(ship[f,w]) >= demand[w]);\n\nconstraint forall(f in FACT)\n                 (sum(w in WARE)(ship[f,w]) <= production[f]);\n\nsolve minimize sum(f in FACT, w in WARE)\n                  (cost[f,w]*ship[f,w]);\n\n\noutput [ show_int(2,ship[f,w]) ++\n         if w == W then \"\\n\" else \" \" endif\n       | f in FACT, w in WARE ];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "shipping_expert", "node_type": "4", "metadata": {"model_name": "shipping", "source_code": "int: W; % number of Warehousse\nset of int: WARE = 1..W;\nint: F; % number of Factories\nset of int: FACT = 1..F;\n\narray[WARE] of int: demand;\narray[FACT] of int: production;\n\narray[FACT,WARE] of int: cost;\n\narray[FACT,WARE] of var int: ship;\n\n%int: m = max(demand);\n%array[FACT,WARE] of var 0..m: ship;\nconstraint forall(f in FACT, w in WARE)(ship[f,w] >= 0);\n\nconstraint forall(w in WARE)\n                 (sum(f in FACT)(ship[f,w]) >= demand[w]);\n\nconstraint forall(f in FACT)\n                 (sum(w in WARE)(ship[f,w]) <= production[f]);\n\nsolve minimize sum(f in FACT, w in WARE)\n                  (cost[f,w]*ship[f,w]);\n\n\noutput [ show_int(2,ship[f,w]) ++\n         if w == W then \"\\n\" else \" \" endif\n       | f in FACT, w in WARE ];"}, "hash": "8d51525a8b43bdeecd2549b294d146f6600aa5a538a556df69be068dc15c7b83", "class_name": "RelatedNodeInfo"}}, "text": "name: Transportation Problem\n\ndescription: The Transportation Problem is a classic problem in Operations Research and Management Science that involves finding the most cost-effective way to transport goods from a set of factories to a set of warehouses. Each factory has a limited production capacity, and each warehouse has a certain demand that must be met. The goal is to determine the optimal shipment quantities from each factory to each warehouse to minimize the total transportation cost.\n\nvariables: ship[f,w] (f \u2208 FACT, w \u2208 WARE) - The decision variables represent the quantity of goods to be shipped from factory f to warehouse w.\n\nconstraints: \n\u2200f \u2208 FACT, w \u2208 WARE : ship[f,w] \u2265 0 - Each shipment quantity must be non-negative.\n\u2200w \u2208 WARE : \u2211(f \u2208 FACT) ship[f,w] \u2265 demand[w] - The total quantity shipped to each warehouse must meet its demand.\n\u2200f \u2208 FACT : \u2211(w \u2208 WARE) ship[f,w] \u2264 production[f] - The total quantity shipped from each factory must not exceed its production capacity.\n\nobjective: Minimize \u2211(f \u2208 FACT, w \u2208 WARE) cost[f,w]*ship[f,w] - The objective is to minimize the total transportation cost, which is the sum of the product of the cost of shipping from each factory to each warehouse and the corresponding shipment quantity.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1249, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "867da411-7ed7-4a06-a382-6f160274173b": {"__data__": {"id_": "867da411-7ed7-4a06-a382-6f160274173b", "embedding": null, "metadata": {"model_name": "simple-prod-planning", "source_code": "% Number of different products\nint: nproducts; \nset of int: Products = 1..nproducts;  \n\n%profit per unit for each product\narray[Products] of int: profit;\narray[Products] of string: pname; \n\n%Number of resources\nint: nresources; \nset of int: Resources = 1..nresources; \n\n%amount of each resource available\narray[Resources] of int: capacity; \narray[Resources] of string: rname;\n\n%units of each resource required to produce 1 unit of product\narray[Products, Resources] of int: consumption; \nconstraint assert(forall (r in Resources, p in Products) \n           (consumption[p,r] >= 0), \"Error: negative consumption\");\n\n% bound on number of Products\nint: mproducts = max (p in Products) \n                     (min (r in Resources where consumption[p,r] > 0) \n                          (capacity[r] div consumption[p,r]));\n\n% Variables: how much should we make of each product\narray[Products] of var 0..mproducts: produce;\narray[Resources] of var 0..max(capacity): used;\n\n% Production cannot use more than the available Resources:\nconstraint forall (r in Resources) (     \n      used[r] = sum (p in Products)(consumption[p, r] * produce[p]) \n      /\\ used[r] <= capacity[r]\n);    \n\n% Maximize profit\nsolve maximize sum (p in Products) (profit[p]*produce[p]);\n\noutput [ show(pname[p]) ++ \" = \" ++ show(produce[p]) ++ \";\\n\" |\n         p in Products ] ++\n       [ show(rname[r]) ++ \" = \" ++ show(used[r]) ++ \";\\n\" |\n         r in Resources ];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "simple-prod-planning_expert", "node_type": "4", "metadata": {"model_name": "simple-prod-planning", "source_code": "% Number of different products\nint: nproducts; \nset of int: Products = 1..nproducts;  \n\n%profit per unit for each product\narray[Products] of int: profit;\narray[Products] of string: pname; \n\n%Number of resources\nint: nresources; \nset of int: Resources = 1..nresources; \n\n%amount of each resource available\narray[Resources] of int: capacity; \narray[Resources] of string: rname;\n\n%units of each resource required to produce 1 unit of product\narray[Products, Resources] of int: consumption; \nconstraint assert(forall (r in Resources, p in Products) \n           (consumption[p,r] >= 0), \"Error: negative consumption\");\n\n% bound on number of Products\nint: mproducts = max (p in Products) \n                     (min (r in Resources where consumption[p,r] > 0) \n                          (capacity[r] div consumption[p,r]));\n\n% Variables: how much should we make of each product\narray[Products] of var 0..mproducts: produce;\narray[Resources] of var 0..max(capacity): used;\n\n% Production cannot use more than the available Resources:\nconstraint forall (r in Resources) (     \n      used[r] = sum (p in Products)(consumption[p, r] * produce[p]) \n      /\\ used[r] <= capacity[r]\n);    \n\n% Maximize profit\nsolve maximize sum (p in Products) (profit[p]*produce[p]);\n\noutput [ show(pname[p]) ++ \" = \" ++ show(produce[p]) ++ \";\\n\" |\n         p in Products ] ++\n       [ show(rname[r]) ++ \" = \" ++ show(used[r]) ++ \";\\n\" |\n         r in Resources ];"}, "hash": "1b9839717b681c903c0aded1abb17f8e6f4d4b029973e07da84ee71b1e7b5da0", "class_name": "RelatedNodeInfo"}}, "text": "name: Production Planning Problem\n\ndescription: The Production Planning Problem is a classic problem in Operations Research and Management Science. It involves determining the optimal production levels of different products to maximize profit, given limited resources and production constraints.\n\nvariables: produce[p] (p \u2208 Products), used[r] (r \u2208 Resources)\nThese variables represent the decision variables in the problem. produce[p] represents the quantity of product p to be produced, and used[r] represents the amount of resource r used in the production process.\n\nconstraints: \n\u2200r \u2208 Resources, used[r] = \u2211(p \u2208 Products)(consumption[p, r] * produce[p]) \u2227 used[r] \u2264 capacity[r]\nThese constraints ensure that the total amount of each resource used does not exceed the available capacity. The first part of the constraint calculates the total amount of resource r used, and the second part ensures that it does not exceed the capacity.\n\nobjective: Maximize \u2211(p \u2208 Products)(profit[p]*produce[p])\nThe objective of the problem is to maximize the total profit, which is calculated by summing the profit of each product multiplied by its production quantity.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1154, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "31e6c7ce-b4df-43f0-afa9-b61624bd36c3": {"__data__": {"id_": "31e6c7ce-b4df-43f0-afa9-b61624bd36c3", "embedding": null, "metadata": {"model_name": "sonet_problem", "source_code": "% The SONET problem is a network design problem: set up a network between\n% n nodes, where only certain nodes require a connection.\n% Nodes are connected by putting them on a ring, where all nodes\n% on a ring can communicate. Putting a node on a ring requires a so-called\n% ADM, and each ring has a capacity of nodes, i.e. ADMs. There is a certain\n% amount of rings, r, that is available. The objective is to set up a network\n% by using a minimal amount of ADMs.\n%\n%\n% About the problem model\n%\n% The problem model has the amount of rings ('r'), amount of nodes('n'),\n% the 'demand' (which nodes require communication) and node-capacity of each\n% ring ('capacity_nodes') as parameters.\n% The assignement of nodes to rings is modelled by a 2-dimensional matrix 'rings',\n% indexed by the amnount of rings and nodes. The matrix-domain is boolean:\n% If the node in column j is assigned to the ring in row i, then rings[i,j] = 1\n% and 0 otherwise. So all the '1's in the matrix 'rings' stand for an ADM.\n% Hence the objective is to minimise the sum over all columns and rows of matrix\n% 'rings'.\n% \"\"\"\n\nint: r;  % upper bound for amount of rings\nint: n;  % amount of clients\n\n\n% original comment: \n% we have double entries here because of the symmetric structure!\narray[1..n, 1..n] of 0..1: demand;\narray[1..r] of 1..n: capacity_nodes;\n\narray[1..r, 1..n] of var 0..1: rings;\nvar int: z =  sum(ring in 1..r, client in 1..n) (rings[ring, client]);\n\nsolve minimize z;\n% solve satisfy;\n\n\nconstraint\n%   z <= 7 % for solve satisfy\n%   /\\\n\n   % original comment:\n   % if there is a demand between 2 nodes, then there has to exist \n   % a ring, on which they are both installed\n   forall(client1,client2 in 1..n where client1 < client2) (\n      (demand[client1,client2] = 1) ->\n           exists(ring in 1..r) (\n                 rings[ring,client1] + rings[ring, client2] >= 2\n           )\n   )   \n   /\\\n   % original comment:\n   % capacity of each ring must not be exceeded     \n   forall(ring in 1..r) (\n        sum(client in 1..n) (\n              rings[ring, client]\n              ) <= capacity_nodes[ring] \n   )\n;\n\n\n%\n% data\n% (sonet_problem1nu.param)\n%\nr = 4;\nn = 5;\n\ndemand =\narray2d(1..n, 1..n,\n        [0,1,0,1,0,\n         1,0,1,0,0,\n         0,1,0,0,1,\n         1,0,0,0,0,\n         0,0,1,0,0])\n;\n\ncapacity_nodes = [3,2,2,1];\n\n\noutput \n[\n  \"z: \", show(z)\n] ++\n[\n  if client = 1 then \"\\n\" else \" \" endif ++\n    show(rings[ring, client])\n  | ring in 1..r, client in 1..n\n] ++ [\"\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sonet_problem_expert", "node_type": "4", "metadata": {"model_name": "sonet_problem", "source_code": "% The SONET problem is a network design problem: set up a network between\n% n nodes, where only certain nodes require a connection.\n% Nodes are connected by putting them on a ring, where all nodes\n% on a ring can communicate. Putting a node on a ring requires a so-called\n% ADM, and each ring has a capacity of nodes, i.e. ADMs. There is a certain\n% amount of rings, r, that is available. The objective is to set up a network\n% by using a minimal amount of ADMs.\n%\n%\n% About the problem model\n%\n% The problem model has the amount of rings ('r'), amount of nodes('n'),\n% the 'demand' (which nodes require communication) and node-capacity of each\n% ring ('capacity_nodes') as parameters.\n% The assignement of nodes to rings is modelled by a 2-dimensional matrix 'rings',\n% indexed by the amnount of rings and nodes. The matrix-domain is boolean:\n% If the node in column j is assigned to the ring in row i, then rings[i,j] = 1\n% and 0 otherwise. So all the '1's in the matrix 'rings' stand for an ADM.\n% Hence the objective is to minimise the sum over all columns and rows of matrix\n% 'rings'.\n% \"\"\"\n\nint: r;  % upper bound for amount of rings\nint: n;  % amount of clients\n\n\n% original comment: \n% we have double entries here because of the symmetric structure!\narray[1..n, 1..n] of 0..1: demand;\narray[1..r] of 1..n: capacity_nodes;\n\narray[1..r, 1..n] of var 0..1: rings;\nvar int: z =  sum(ring in 1..r, client in 1..n) (rings[ring, client]);\n\nsolve minimize z;\n% solve satisfy;\n\n\nconstraint\n%   z <= 7 % for solve satisfy\n%   /\\\n\n   % original comment:\n   % if there is a demand between 2 nodes, then there has to exist \n   % a ring, on which they are both installed\n   forall(client1,client2 in 1..n where client1 < client2) (\n      (demand[client1,client2] = 1) ->\n           exists(ring in 1..r) (\n                 rings[ring,client1] + rings[ring, client2] >= 2\n           )\n   )   \n   /\\\n   % original comment:\n   % capacity of each ring must not be exceeded     \n   forall(ring in 1..r) (\n        sum(client in 1..n) (\n              rings[ring, client]\n              ) <= capacity_nodes[ring] \n   )\n;\n\n\n%\n% data\n% (sonet_problem1nu.param)\n%\nr = 4;\nn = 5;\n\ndemand =\narray2d(1..n, 1..n,\n        [0,1,0,1,0,\n         1,0,1,0,0,\n         0,1,0,0,1,\n         1,0,0,0,0,\n         0,0,1,0,0])\n;\n\ncapacity_nodes = [3,2,2,1];\n\n\noutput \n[\n  \"z: \", show(z)\n] ++\n[\n  if client = 1 then \"\\n\" else \" \" endif ++\n    show(rings[ring, client])\n  | ring in 1..r, client in 1..n\n] ++ [\"\\n\"];\n"}, "hash": "dd7873a3b9f3e2cb49983fc94cf30d285282f65a39a9ddd3d253d2626a98d794", "class_name": "RelatedNodeInfo"}}, "text": "name: SONET Problem\n\ndescription: The SONET problem is a network design problem where a network needs to be set up between a set of nodes, with some nodes requiring a connection. The nodes are connected by putting them on a ring, where all nodes on a ring can communicate. The goal is to set up a network using a minimal amount of Add-Drop Multiplexers (ADMs).\n\nvariables: $rings_{i,j} \\in \\{0,1\\}$ for $i \\in \\{1, \\ldots, r\\}$ and $j \\in \\{1, \\ldots, n\\}$. These variables represent the assignment of nodes to rings, where $rings_{i,j} = 1$ if node $j$ is assigned to ring $i$ and $0$ otherwise.\n\nconstraints: \n$\\sum_{i=1}^r rings_{i,j} + \\sum_{i=1}^r rings_{i,k} \\geq 2$ for all $j, k \\in \\{1, \\ldots, n\\}$ such that $j < k$ and $demand_{j,k} = 1$.\n$\\sum_{j=1}^n rings_{i,j} \\leq capacity\\_nodes_i$ for all $i \\in \\{1, \\ldots, r\\}$.\n\nThe first constraint ensures that if there is a demand between two nodes, then there exists a ring on which both nodes are installed. The second constraint ensures that the capacity of each ring is not exceeded.\n\nobjective: Minimize the total number of ADMs used, which is represented by the variable $z = \\sum_{i=1}^r \\sum_{j=1}^n rings_{i,j}$.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1181, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a8b9b47b-08cd-4c22-ab76-cfed35152b91": {"__data__": {"id_": "a8b9b47b-08cd-4c22-ab76-cfed35152b91", "embedding": null, "metadata": {"model_name": "square_pack", "source_code": "int: n; % number of squares\nset of int: SQUARE = 1..n;\nint: maxl = sum(i in SQUARE)(i);\nint: mina = sum(i in SQUARE)(i*i);\n\nvar n..maxl: height;\nvar n..maxl: width;\nvar mina .. n*maxl: area = height * width;\n\narray[SQUARE] of var 0..maxl: x;\narray[SQUARE] of var 0..maxl: y;\n\n% squares fit in the rectangle\nconstraint forall(s in SQUARE)(x[s] + s <= width);\nconstraint forall(s in SQUARE)(y[s] + s <= height);\n\n% non overlap\nconstraint forall(s1, s2 in SQUARE where s1 < s2)\n                 (x[s1] + s1 <= x[s2] \\/\n                  x[s2] + s2 <= x[s1] \\/  \n                  y[s1] + s1 <= y[s2] \\/ \n                  y[s2] + s2 <= y[s1]);\narray[SQUARE] of int: size = [ i | i in SQUARE ];\n\n% non overlap with global diffn\ninclude \"diffn.mzn\";\n%constraint diffn(x,y,size,size);\n\n% redundant cumulative constraints\ninclude \"cumulative.mzn\";\n%constraint cumulative(x,size,size,height);\n%constraint cumulative(y,size,size,width);\n\n% variables ordered in reverse size x[n], y[n], x[n-1], y[n-1], ..., x[1], y[1]\n%array[1..2*n] of var 0..maxl: vs = [ if i mod 2 = 0 then x[n+1 - i div 2] \n%                                     else y[n+1 - i div 2] endif | i in 2..2*n+1 ];\n\nsolve :: seq_search([\n         int_search([area,height,width], input_order, indomain_min, complete) \n         %,int_search(vs, input_order, indomain_min, complete)\n         ])\n      minimize area;\n\noutput [\"area = \",show(area), \"\\n\"] ++\n[\"height = \",show(height), \"\\n\"] ++\n[\"width = \",show(width), \"\\n\"] ++\n[\"x = \", show(x), \"\\n\"] ++\n[\"y = \", show(y), \"\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "square_pack_expert", "node_type": "4", "metadata": {"model_name": "square_pack", "source_code": "int: n; % number of squares\nset of int: SQUARE = 1..n;\nint: maxl = sum(i in SQUARE)(i);\nint: mina = sum(i in SQUARE)(i*i);\n\nvar n..maxl: height;\nvar n..maxl: width;\nvar mina .. n*maxl: area = height * width;\n\narray[SQUARE] of var 0..maxl: x;\narray[SQUARE] of var 0..maxl: y;\n\n% squares fit in the rectangle\nconstraint forall(s in SQUARE)(x[s] + s <= width);\nconstraint forall(s in SQUARE)(y[s] + s <= height);\n\n% non overlap\nconstraint forall(s1, s2 in SQUARE where s1 < s2)\n                 (x[s1] + s1 <= x[s2] \\/\n                  x[s2] + s2 <= x[s1] \\/  \n                  y[s1] + s1 <= y[s2] \\/ \n                  y[s2] + s2 <= y[s1]);\narray[SQUARE] of int: size = [ i | i in SQUARE ];\n\n% non overlap with global diffn\ninclude \"diffn.mzn\";\n%constraint diffn(x,y,size,size);\n\n% redundant cumulative constraints\ninclude \"cumulative.mzn\";\n%constraint cumulative(x,size,size,height);\n%constraint cumulative(y,size,size,width);\n\n% variables ordered in reverse size x[n], y[n], x[n-1], y[n-1], ..., x[1], y[1]\n%array[1..2*n] of var 0..maxl: vs = [ if i mod 2 = 0 then x[n+1 - i div 2] \n%                                     else y[n+1 - i div 2] endif | i in 2..2*n+1 ];\n\nsolve :: seq_search([\n         int_search([area,height,width], input_order, indomain_min, complete) \n         %,int_search(vs, input_order, indomain_min, complete)\n         ])\n      minimize area;\n\noutput [\"area = \",show(area), \"\\n\"] ++\n[\"height = \",show(height), \"\\n\"] ++\n[\"width = \",show(width), \"\\n\"] ++\n[\"x = \", show(x), \"\\n\"] ++\n[\"y = \", show(y), \"\\n\"];\n"}, "hash": "0fec7097c61033c5b81c1501c78a72d40940c9c7ae3b2587b3f12aa3511ed5dc", "class_name": "RelatedNodeInfo"}}, "text": "name: 2D Rectangular Packing Problem\n\ndescription: The 2D Rectangular Packing Problem is a classic problem in constraint programming where we are given a set of rectangles of different sizes and we need to pack them into a larger rectangle of minimum area, such that no two rectangles overlap and all rectangles are fully contained within the larger rectangle.\n\nvariables: height, width, area, x, y\n\nheight and width are the dimensions of the larger rectangle, area is the area of the larger rectangle, x and y are arrays of variables representing the x and y coordinates of the top-left corner of each rectangle.\n\nconstraints: \nx[s] + s <= width, y[s] + s <= height, \n(x[s1] + s1 <= x[s2] \\/ x[s2] + s2 <= x[s1] \\/ y[s1] + s1 <= y[s2] \\/ y[s2] + s2 <= y[s1])\n\nThe first two constraints ensure that each rectangle is fully contained within the larger rectangle. The third constraint ensures that no two rectangles overlap.\n\nobjective: minimize area", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 948, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c1852542-f99e-4272-b2fc-8592ff768941": {"__data__": {"id_": "c1852542-f99e-4272-b2fc-8592ff768941", "embedding": null, "metadata": {"model_name": "stableroommates", "source_code": "Model 1 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\nset of int: AGENT0 = 0..n;    % zero indicates no agent\narray[AGENT,1..n-1] of AGENT0: pref; % preference order for each agent\n     % the preference order is padded by zeros\narray[AGENT] of int: npref = [ sum(j in 1..n-1)(bool2int(pref[i,j] > 0))\n                             | i in AGENT ];\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..n-1)\n                               (pref[i,j] != i /\\ \n                                (pref[i,j] = 0 <-> j > npref[i])) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref[i,j1] != pref[i,j2]),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n%% ranking information: rank = 0 means not ranked\narray[AGENT,AGENT] of 0..n-1: rank = \n     array2d(AGENT,AGENT, [ max([bool2int(pref[i1,j] = i2) * j | j in 1..n-1])\n                          | i1, i2 in AGENT ]);\n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] > rank[i,j] -> a[j] < rank[j,i]\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] = rank[i,j] -> a[j] = rank[j,i]\n                 );\n\nsolve satisfy;\n\noutput  [ if i < fix(pref[i,a[i]]) then \"(\" ++ show(i) ++ \",\" ++ show(pref[i,a[i]]) ++ \")\\n\"\n          else \"\" endif\n        | i in AGENT ]\n       ++ [show(rank),\"\\n\"] \n %      ++ [show(npref),\"\\n\"] \n %      ++ [show(a),\"\\n\"]\n        ;\n       \n\n\nModel 2 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\n\narray[AGENT] of int: npref; % number of preferences of each agent\narray[AGENT] of int: cum_npref = [ sum(j in 1..i-1)(npref[j]) | i in AGENT];\narray[1..sum(npref)] of int: preferences;  % all preferences in one list\n\nfunction AGENT: pref(AGENT: i, 1..n-1: j) = \n         assert(j in 1..npref[i], \"Called pref(\" ++ show(i) ++ \",\" ++ show(j) ++ \") too large preference\\n\",\n         preferences[cum_npref[i] + j]);\n\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..npref[i])\n                               (pref(i,j) != i) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref(i,j1) != pref(i,j2)),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n\n\n%% ranking information: rank = 0 means not ranked but shoulnt occur!\nfunction 0..n-1: rank(AGENT: i1, AGENT: i2) = \n                 max([bool2int(pref(i1,j) = i2) * j | j in 1..npref[i1]]); \n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] > rank(i,j) -> a[j] < rank(j,i)\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] = rank(i,j) -> a[j] = rank(j,i)\n                 );\n\nsolve satisfy;\n\n   output  [ if fix(a[i]) < npref[i] /\\ i < pref(i,fix(a[i]))\n             then \"(\" ++ show(i) ++ \",\" ++ show(pref(i,fix(a[i]))) ++ \")\\n\"\n             else \"\" endif\n           | i in AGENT ]\n %      ++ [show(rank),\"\\n\"] \n       ++\n       [show(npref),\"\\n\"] \n       ++ [show(a),\"\\n\"]\n        ;\n       \n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "stableroommates_expert", "node_type": "4", "metadata": {"model_name": "stableroommates", "source_code": "Model 1 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\nset of int: AGENT0 = 0..n;    % zero indicates no agent\narray[AGENT,1..n-1] of AGENT0: pref; % preference order for each agent\n     % the preference order is padded by zeros\narray[AGENT] of int: npref = [ sum(j in 1..n-1)(bool2int(pref[i,j] > 0))\n                             | i in AGENT ];\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..n-1)\n                               (pref[i,j] != i /\\ \n                                (pref[i,j] = 0 <-> j > npref[i])) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref[i,j1] != pref[i,j2]),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n%% ranking information: rank = 0 means not ranked\narray[AGENT,AGENT] of 0..n-1: rank = \n     array2d(AGENT,AGENT, [ max([bool2int(pref[i1,j] = i2) * j | j in 1..n-1])\n                          | i1, i2 in AGENT ]);\n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] > rank[i,j] -> a[j] < rank[j,i]\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] = rank[i,j] -> a[j] = rank[j,i]\n                 );\n\nsolve satisfy;\n\noutput  [ if i < fix(pref[i,a[i]]) then \"(\" ++ show(i) ++ \",\" ++ show(pref[i,a[i]]) ++ \")\\n\"\n          else \"\" endif\n        | i in AGENT ]\n       ++ [show(rank),\"\\n\"] \n %      ++ [show(npref),\"\\n\"] \n %      ++ [show(a),\"\\n\"]\n        ;\n       \n\n\nModel 2 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\n\narray[AGENT] of int: npref; % number of preferences of each agent\narray[AGENT] of int: cum_npref = [ sum(j in 1..i-1)(npref[j]) | i in AGENT];\narray[1..sum(npref)] of int: preferences;  % all preferences in one list\n\nfunction AGENT: pref(AGENT: i, 1..n-1: j) = \n         assert(j in 1..npref[i], \"Called pref(\" ++ show(i) ++ \",\" ++ show(j) ++ \") too large preference\\n\",\n         preferences[cum_npref[i] + j]);\n\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..npref[i])\n                               (pref(i,j) != i) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref(i,j1) != pref(i,j2)),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n\n\n%% ranking information: rank = 0 means not ranked but shoulnt occur!\nfunction 0..n-1: rank(AGENT: i1, AGENT: i2) = \n                 max([bool2int(pref(i1,j) = i2) * j | j in 1..npref[i1]]); \n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] > rank(i,j) -> a[j] < rank(j,i)\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] = rank(i,j) -> a[j] = rank(j,i)\n                 );\n\nsolve satisfy;\n\n   output  [ if fix(a[i]) < npref[i] /\\ i < pref(i,fix(a[i]))\n             then \"(\" ++ show(i) ++ \",\" ++ show(pref(i,fix(a[i]))) ++ \")\\n\"\n             else \"\" endif\n           | i in AGENT ]\n %      ++ [show(rank),\"\\n\"] \n       ++\n       [show(npref),\"\\n\"] \n       ++ [show(a),\"\\n\"]\n        ;\n       \n\n"}, "hash": "1aa9f7738dd799beaf060fd10144ba1d4687c5151966f8805af5ec1a5f4ec0b2", "class_name": "RelatedNodeInfo"}}, "text": "name: Stable Roommates Problem\n\ndescription: The Stable Roommates Problem is a classic problem in constraint programming that involves finding a stable matching between a set of agents, where each agent has a preference order over the other agents. The goal is to find a matching such that there is no pair of agents who prefer each other to their current match.\n\nvariables: a[i] (i in AGENT)\n\nThe decision variables a[i] represent the ranking of agent i in the stable matching.\n\nconstraints:\n- a[i] <= npref[i] + 1 (i in AGENT)\n- a[i] > rank[i,j] -> a[j] < rank[j,i] (i in AGENT, p in 1..npref[i], j = pref[i,p])\n- a[i] = rank[i,j] -> a[j] = rank[j,i] (i in AGENT, p in 1..npref[i], j = pref[i,p])\n\nThe constraints ensure that each agent is matched with one of their top npref[i] preferences, and that the matching is stable. The first constraint ensures that each agent is matched with a rank no higher than their number of preferences plus one. The second and third constraints ensure that if agent i prefers agent j to their current match, then agent j must prefer their current match to agent i, and vice versa.\n\nobjective: satisfy\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1287, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fbdc559a-d050-4322-8f15-1de559c2d56f": {"__data__": {"id_": "fbdc559a-d050-4322-8f15-1de559c2d56f", "embedding": null, "metadata": {"model_name": "steiner", "source_code": "% The ternary Steiner problem of order n is to find n(n-1)/6 sets of elements in {1,2,...,n}\n% such that each set contains three elements and any two sets have at most one element in common.\n% For example, the following shows a solution for size n=7:\n%\n%      {1,2,3}, {1,4,5}, {1,6,7}, {2,4,6}, {2,5,7}, {3,4,7}, {3,5,6}\n\ninclude \"globals.mzn\";\n\nint: N = 7; \nint: NB = N *(N-1) div 6;\narray[1..NB] of var set of 1..N: Sets;\n\n% solve satisfy;\nsolve::set_search(Sets, first_fail, indomain_min, complete) satisfy;\n\n\n\nconstraint\n   forall(i in index_set(Sets)) (\n      card(Sets[i]) = 3\n   )\n   /\\ \n   forall(i,j in index_set(Sets) where i < j) (\n      card( Sets[i] intersect Sets[j]) <= 1\n   )\n   /\\ % symmetry breaking\n   decreasing(Sets)\n\n;\n\noutput [\n       \"N: \", show(N), \" NB: \", show(NB), \"\\n\",\n       \"Sets: \", show(Sets)\n];\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "steiner_expert", "node_type": "4", "metadata": {"model_name": "steiner", "source_code": "% The ternary Steiner problem of order n is to find n(n-1)/6 sets of elements in {1,2,...,n}\n% such that each set contains three elements and any two sets have at most one element in common.\n% For example, the following shows a solution for size n=7:\n%\n%      {1,2,3}, {1,4,5}, {1,6,7}, {2,4,6}, {2,5,7}, {3,4,7}, {3,5,6}\n\ninclude \"globals.mzn\";\n\nint: N = 7; \nint: NB = N *(N-1) div 6;\narray[1..NB] of var set of 1..N: Sets;\n\n% solve satisfy;\nsolve::set_search(Sets, first_fail, indomain_min, complete) satisfy;\n\n\n\nconstraint\n   forall(i in index_set(Sets)) (\n      card(Sets[i]) = 3\n   )\n   /\\ \n   forall(i,j in index_set(Sets) where i < j) (\n      card( Sets[i] intersect Sets[j]) <= 1\n   )\n   /\\ % symmetry breaking\n   decreasing(Sets)\n\n;\n\noutput [\n       \"N: \", show(N), \" NB: \", show(NB), \"\\n\",\n       \"Sets: \", show(Sets)\n];\n\n"}, "hash": "4b645fb666d5a5eaa0e137b768741948e07ec061280fb6ee16f8e2f722a747d2", "class_name": "RelatedNodeInfo"}}, "text": "name: Ternary Steiner Problem\n\ndescription: The Ternary Steiner Problem is a classic problem in combinatorial mathematics that involves finding a collection of sets, each containing three elements, such that any two sets have at most one element in common.\n\nvariables: Sets = {S_1, S_2, ..., S_NB}, where S_i \u2286 {1, 2, ..., N}\n\nThe decision variables are the sets S_i, which are subsets of {1, 2, ..., N}, and NB is the number of sets, calculated as N*(N-1)/6.\n\nconstraints: \ncard(S_i) = 3 \u2200i \u2208 {1, 2, ..., NB}\ncard(S_i \u2229 S_j) \u2264 1 \u2200i, j \u2208 {1, 2, ..., NB} where i < j\ndecreasing(Sets)\n\nThe constraints ensure that each set S_i has exactly three elements, any two sets S_i and S_j have at most one element in common, and the sets are ordered in a decreasing manner (symmetry breaking).\n\nobjective: satisfy\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific value. The problem is a satisfaction problem, where the goal is to find a valid assignment of values to the decision variables that meets all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1092, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fe19315d-e90b-4f06-b8b4-500c32dd0fa8": {"__data__": {"id_": "fe19315d-e90b-4f06-b8b4-500c32dd0fa8", "embedding": null, "metadata": {"model_name": "stoch_fjsp", "source_code": "% Stochastic General Assignment Problem \n% First stage:\n%    assign task to machines \n% Second stage:\n%    based on observed processign times, schedule taks on respective machines\n% Objective:\n%    minimise expected makespan\n\ninclude \"globals.mzn\";\n\n% Parameters\n\nint: no_mach;   % Number of machines\nint: no_jobs;   % Number of jobs\nint: no_task;   % Number of total tasks\nint: no_optt;   % Number of total optional tasks\n\nset of int: Mach  = 1..no_mach;\nset of int: Jobs  = 1..no_jobs;\nset of int: Tasks = 1..no_task;\nset of int: OptTs = 1..no_optt;\n\narray [Jobs] of set of int: tasks;\narray [Tasks] of set of int: optts;\n\narray [OptTs] of int: optt_mach;\narray [SCENARIOS1,OptTs] of int: optt_dur;\n\n\narray [Jobs] of int: last_task = [ max(tasks[j]) | j in Jobs ];\n%---------implications for multi scenarion solving ---------------\nint: nbScenarios;\nset of int: SCENARIOS1 = 1..nbScenarios;\nint: first_scen;\nint: last_scen;\nset of int: SCENARIOS = first_scen..last_scen;\narray[SCENARIOS1] of int: weights;\n\n%-------end of multi scenario addons ----------------\narray [Tasks] of int: task_job = \n    [ min(j in Jobs where t in tasks[j])(j) | t in Tasks ];\narray [SCENARIOS,Tasks] of int: task_mins =\n    array2d(SCENARIOS,Tasks,[ sum(k in tasks[task_job[t]])(if k < t then task_mind[s,k] else 0 endif)\n    |   s in SCENARIOS, t in Tasks ]);\narray [SCENARIOS,Tasks] of int: task_maxs =\n    array2d(SCENARIOS,Tasks,[ t_max[s] -\n        sum(k in tasks[task_job[t]])(if k < t then 0 else task_mind[s,k] endif)\n    |   s in SCENARIOS,  t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_mind =\n    array2d(SCENARIOS,Tasks,[ min(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS,t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_maxd = \n    array2d(SCENARIOS,Tasks,[ max(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS, t in Tasks ]);\n\n    % Additional deirved parameters for optional tasks\n    %\narray [OptTs] of int: optt_task =\n    [ min(t in Tasks where o in optts[t])(t) | o in OptTs ];\n\narray[SCENARIOS1] of int: min_dur = [ min([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\narray[SCENARIOS1] of int: max_dur = [ max([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\nset of int: Durs = min(min_dur)..max(max_dur);\n\n    % Parameters related to the planning horizon\n    %\narray[SCENARIOS1] of int: t_max = [sum(t in Tasks)(max(o in optts[t])(optt_dur[s,o])) | s in SCENARIOS1];\n\nset of int: Times = 0..max(t_max);\n\n%-----------------------------------------------------------------------------%\n% Variables\n\n    % Start time variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Times: start =\n    array2d(SCENARIOS,Tasks,[ let { var task_mins[s,t]..task_maxs[s,t]: k } in k | s in SCENARIOS, t in Tasks ]);\n\n    % Duration variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Durs: dur =\n    array2d(SCENARIOS,Tasks,[ if task_mind[s,t] = task_maxd[s,t] then task_mind[s,t] else\n        let { var task_mind[s,t]..task_maxd[s,t]: d } in d endif\n    |   s in SCENARIOS,t in Tasks ]);\n\n    % Variables whether an optional task is executed\n    %\narray [OptTs] of var bool: b;\n\narray[SCENARIOS] of var Times: de_objective;\n\nset of int: StochTimes = 0..sum(t_max);\nvar StochTimes: objective;\n%-----------------------------------------------------------------------------%\n% Constraints\n\n    % Precedence relations\n    %\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs, i in tasks[j] where i < last_task[j])(\n            start[s,i] + dur[s,i] <= start[s,i + 1]\n        )    \n    );\n\n    % Duration constraints\n    %\nconstraint\n    forall(o in OptTs,s in SCENARIOS)(\n        let { int: t = optt_task[o] } in (\n            if card(optts[t]) = 1 then\n                b[o] = true\n            else\n                b[o] -> dur[s,t] = optt_dur[s,o]\n            endif\n        )\n    );\n\n    % Optional tasks' constraints\n    %\nconstraint\n    forall(t in Tasks where card(optts[t]) > 1)(\n        ( sum(o in optts[t])(bool2int(b[o])) <= 1     )\n    /\\  ( exists(o in optts[t])(b[o])                 )\n    );\n\nconstraint\n    forall(t in Tasks where card(optts[t]) = 2)(\n        let {\n            int: o1 = min(optts[t]),\n            int: o2 = max(optts[t])\n        } in ( b[o1] <-> not(b[o2]) )\n    );\n\n    % Resource constraints\n    %\nconstraint\n    forall(m in Mach,s in SCENARIOS)(\n        let {\n            set of int: MTasks = { o | o in OptTs where optt_mach[o] = m }\n        } in (\n            cumulative(\n                [ start[s,optt_task[o]] | o in MTasks ],\n                [ optt_dur[s,o]         | o in MTasks ],\n                [ bool2int(b[o])      | o in MTasks ],\n                1\n            )\n        )\n    );\n\n% Objective constraint\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs)(start[s,last_task[j]] + dur[s,last_task[j]] <= de_objective[s])\n    );\nconstraint \n        objective = sum(s in SCENARIOS)(weights[s]*de_objective[s]);\n%-----------------------------------------------------------------------------%\n% Solve item\n\nsolve \n    :: search\n    minimize objective;\n\n%------------------------------------------------------------------------------%\n% Searches\n\nann: s_mindur   = int_search([dur[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_minstart = int_search([start[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_bool     = bool_search(b, input_order, indomain_max, complete);\nann: s_obj      = int_search(de_objective, input_order, indomain_min, complete);\n\nann: search = seq_search([s_mindur, s_bool, s_minstart, s_obj]);\n\n%-----------------------------------------------------------------------------%\n% Output\n\noutput \n[   \"objective = \", show(de_objective), \";\\n\",\n    \"stoch obj = \", show(objective), \";\\n\",\n    \"start = \", show(start), \";\\n\",\n    \"dur = \", show(dur), \";\\n\",\n    \"b = \", show(b), \";\\n\",\n];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "stoch_fjsp_expert", "node_type": "4", "metadata": {"model_name": "stoch_fjsp", "source_code": "% Stochastic General Assignment Problem \n% First stage:\n%    assign task to machines \n% Second stage:\n%    based on observed processign times, schedule taks on respective machines\n% Objective:\n%    minimise expected makespan\n\ninclude \"globals.mzn\";\n\n% Parameters\n\nint: no_mach;   % Number of machines\nint: no_jobs;   % Number of jobs\nint: no_task;   % Number of total tasks\nint: no_optt;   % Number of total optional tasks\n\nset of int: Mach  = 1..no_mach;\nset of int: Jobs  = 1..no_jobs;\nset of int: Tasks = 1..no_task;\nset of int: OptTs = 1..no_optt;\n\narray [Jobs] of set of int: tasks;\narray [Tasks] of set of int: optts;\n\narray [OptTs] of int: optt_mach;\narray [SCENARIOS1,OptTs] of int: optt_dur;\n\n\narray [Jobs] of int: last_task = [ max(tasks[j]) | j in Jobs ];\n%---------implications for multi scenarion solving ---------------\nint: nbScenarios;\nset of int: SCENARIOS1 = 1..nbScenarios;\nint: first_scen;\nint: last_scen;\nset of int: SCENARIOS = first_scen..last_scen;\narray[SCENARIOS1] of int: weights;\n\n%-------end of multi scenario addons ----------------\narray [Tasks] of int: task_job = \n    [ min(j in Jobs where t in tasks[j])(j) | t in Tasks ];\narray [SCENARIOS,Tasks] of int: task_mins =\n    array2d(SCENARIOS,Tasks,[ sum(k in tasks[task_job[t]])(if k < t then task_mind[s,k] else 0 endif)\n    |   s in SCENARIOS, t in Tasks ]);\narray [SCENARIOS,Tasks] of int: task_maxs =\n    array2d(SCENARIOS,Tasks,[ t_max[s] -\n        sum(k in tasks[task_job[t]])(if k < t then 0 else task_mind[s,k] endif)\n    |   s in SCENARIOS,  t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_mind =\n    array2d(SCENARIOS,Tasks,[ min(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS,t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_maxd = \n    array2d(SCENARIOS,Tasks,[ max(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS, t in Tasks ]);\n\n    % Additional deirved parameters for optional tasks\n    %\narray [OptTs] of int: optt_task =\n    [ min(t in Tasks where o in optts[t])(t) | o in OptTs ];\n\narray[SCENARIOS1] of int: min_dur = [ min([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\narray[SCENARIOS1] of int: max_dur = [ max([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\nset of int: Durs = min(min_dur)..max(max_dur);\n\n    % Parameters related to the planning horizon\n    %\narray[SCENARIOS1] of int: t_max = [sum(t in Tasks)(max(o in optts[t])(optt_dur[s,o])) | s in SCENARIOS1];\n\nset of int: Times = 0..max(t_max);\n\n%-----------------------------------------------------------------------------%\n% Variables\n\n    % Start time variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Times: start =\n    array2d(SCENARIOS,Tasks,[ let { var task_mins[s,t]..task_maxs[s,t]: k } in k | s in SCENARIOS, t in Tasks ]);\n\n    % Duration variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Durs: dur =\n    array2d(SCENARIOS,Tasks,[ if task_mind[s,t] = task_maxd[s,t] then task_mind[s,t] else\n        let { var task_mind[s,t]..task_maxd[s,t]: d } in d endif\n    |   s in SCENARIOS,t in Tasks ]);\n\n    % Variables whether an optional task is executed\n    %\narray [OptTs] of var bool: b;\n\narray[SCENARIOS] of var Times: de_objective;\n\nset of int: StochTimes = 0..sum(t_max);\nvar StochTimes: objective;\n%-----------------------------------------------------------------------------%\n% Constraints\n\n    % Precedence relations\n    %\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs, i in tasks[j] where i < last_task[j])(\n            start[s,i] + dur[s,i] <= start[s,i + 1]\n        )    \n    );\n\n    % Duration constraints\n    %\nconstraint\n    forall(o in OptTs,s in SCENARIOS)(\n        let { int: t = optt_task[o] } in (\n            if card(optts[t]) = 1 then\n                b[o] = true\n            else\n                b[o] -> dur[s,t] = optt_dur[s,o]\n            endif\n        )\n    );\n\n    % Optional tasks' constraints\n    %\nconstraint\n    forall(t in Tasks where card(optts[t]) > 1)(\n        ( sum(o in optts[t])(bool2int(b[o])) <= 1     )\n    /\\  ( exists(o in optts[t])(b[o])                 )\n    );\n\nconstraint\n    forall(t in Tasks where card(optts[t]) = 2)(\n        let {\n            int: o1 = min(optts[t]),\n            int: o2 = max(optts[t])\n        } in ( b[o1] <-> not(b[o2]) )\n    );\n\n    % Resource constraints\n    %\nconstraint\n    forall(m in Mach,s in SCENARIOS)(\n        let {\n            set of int: MTasks = { o | o in OptTs where optt_mach[o] = m }\n        } in (\n            cumulative(\n                [ start[s,optt_task[o]] | o in MTasks ],\n                [ optt_dur[s,o]         | o in MTasks ],\n                [ bool2int(b[o])      | o in MTasks ],\n                1\n            )\n        )\n    );\n\n% Objective constraint\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs)(start[s,last_task[j]] + dur[s,last_task[j]] <= de_objective[s])\n    );\nconstraint \n        objective = sum(s in SCENARIOS)(weights[s]*de_objective[s]);\n%-----------------------------------------------------------------------------%\n% Solve item\n\nsolve \n    :: search\n    minimize objective;\n\n%------------------------------------------------------------------------------%\n% Searches\n\nann: s_mindur   = int_search([dur[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_minstart = int_search([start[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_bool     = bool_search(b, input_order, indomain_max, complete);\nann: s_obj      = int_search(de_objective, input_order, indomain_min, complete);\n\nann: search = seq_search([s_mindur, s_bool, s_minstart, s_obj]);\n\n%-----------------------------------------------------------------------------%\n% Output\n\noutput \n[   \"objective = \", show(de_objective), \";\\n\",\n    \"stoch obj = \", show(objective), \";\\n\",\n    \"start = \", show(start), \";\\n\",\n    \"dur = \", show(dur), \";\\n\",\n    \"b = \", show(b), \";\\n\",\n];\n"}, "hash": "55dc7adf31d90b7ba7a026eac41cb636d11635938ce67d83dfee0bc0e7c5b268", "class_name": "RelatedNodeInfo"}}, "text": "name: Stochastic General Assignment Problem\n\ndescription: The Stochastic General Assignment Problem is a variant of the classic assignment problem, where tasks need to be assigned to machines and scheduled to minimize the expected makespan. The problem is stochastic because the processing times of the tasks are uncertain and are represented by multiple scenarios. The problem involves two stages: in the first stage, tasks are assigned to machines, and in the second stage, the tasks are scheduled on the machines based on the observed processing times.\n\nvariables: `start[s,t], dur[s,t], b[o], de_objective[s], objective`\n\n* `start[s,t]`: the start time of task `t` in scenario `s`\n* `dur[s,t]`: the duration of task `t` in scenario `s`\n* `b[o]`: a boolean variable indicating whether optional task `o` is executed\n* `de_objective[s]`: the makespan of scenario `s`\n* `objective`: the expected makespan over all scenarios\n\nconstraints: \n`start[s,i] + dur[s,i] <= start[s,i + 1], \ndur[s,t] = optt_dur[s,o] <-> b[o], \nsum(o in optts[t])(bool2int(b[o])) <= 1, \nexists(o in optts[t])(b[o]), \nb[o1] <-> not(b[o2]), \ncumulative(start, dur, b, 1), \nstart[s,last_task[j]] + dur[s,last_task[j]] <= de_objective[s], \nobjective = sum(s in SCENARIOS)(weights[s]*de_objective[s])`\n\n* Precedence relations: each task must start after its predecessor\n* Duration constraints: the duration of a task is equal to the duration of the selected optional task\n* Optional tasks' constraints: at most one optional task can be executed for each task, and if an optional task is executed, its duration is used\n* Resource constraints: the cumulative duration of tasks on each machine does not exceed the machine's capacity\n* Objective constraint: the makespan of each scenario is the maximum completion time of all tasks\n* Objective function: the expected makespan over all scenarios\n\nobjective: Minimize the expected makespan over all scenarios.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1921, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6c154017-4684-4517-834f-7068e5ad220b": {"__data__": {"id_": "6c154017-4684-4517-834f-7068e5ad220b", "embedding": null, "metadata": {"model_name": "submultisetsum", "source_code": "% subsetsum problem\narray[int] of int: number;\nint: target;\n\nset of int: NUMBER = index_set(number);\nvar set of NUMBER: selected;\n\nconstraint sum(i in selected)\n              (number[i]) = target;\nsolve satisfy;\n\noutput [show(selected)];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "submultisetsum_expert", "node_type": "4", "metadata": {"model_name": "submultisetsum", "source_code": "% subsetsum problem\narray[int] of int: number;\nint: target;\n\nset of int: NUMBER = index_set(number);\nvar set of NUMBER: selected;\n\nconstraint sum(i in selected)\n              (number[i]) = target;\nsolve satisfy;\n\noutput [show(selected)];"}, "hash": "d811b6a7d4b0ceaf37182d324cddc75ddd686e29825394803015beb9fea90b6b", "class_name": "RelatedNodeInfo"}}, "text": "name: Subset Sum Problem\n\ndescription: The Subset Sum Problem is a classic problem in computer science and mathematics that involves finding a subset of a given set of integers that sums up to a target value.\n\nvariables: selected \u2286 NUMBER\nThe decision variable is a set of indices selected from the set NUMBER, which represents the subset of numbers to be selected.\n\nconstraints: \u2211(i \u2208 selected) number[i] = target\nThe constraint ensures that the sum of the numbers corresponding to the selected indices is equal to the target value.\n\nobjective: satisfy\nThe objective of the problem is to find a feasible solution that satisfies the constraint, i.e., to find a subset of numbers that sums up to the target value.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 712, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3b3c979f-d158-4329-923a-fbc8c642b276": {"__data__": {"id_": "3b3c979f-d158-4329-923a-fbc8c642b276", "embedding": null, "metadata": {"model_name": "table_seating", "source_code": "Model 1 :\n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n          forall(t in TABLE)(not ({p1,p2} subset table[t]));\n\nconstraint forall(t in TABLE)(card(table[t]) <= S);\n\nconstraint forall(p in PERSON)(exists(t in TABLE)(p in table[t]));\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))\n                  ( let { var TABLE: tn1 = sum(t in TABLE)(t * bool2int(couples[c,1] in table[t]));\n                          var TABLE: tn2 = sum(t in TABLE)(t * bool2int(couples[c,2] in table[t]));\n                    } in  tn1 + tn2);\n\n\n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n\n\n\nModel 2 : \n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\narray[PERSON] of var TABLE: seat;\n\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n                        seat[p1] != seat[p2];\n\nconstraint global_cardinality_low_up(seat, [t|t in TABLE], [0|t in TABLE], [S|t in TABLE]);\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))(seat[couples[c,1]] + seat[couples[c,2]]);\n\nconstraint forall(t in TABLE, p in PERSON)(p in table[t] <-> seat[p] = t);    \n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "table_seating_expert", "node_type": "4", "metadata": {"model_name": "table_seating", "source_code": "Model 1 :\n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n          forall(t in TABLE)(not ({p1,p2} subset table[t]));\n\nconstraint forall(t in TABLE)(card(table[t]) <= S);\n\nconstraint forall(p in PERSON)(exists(t in TABLE)(p in table[t]));\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))\n                  ( let { var TABLE: tn1 = sum(t in TABLE)(t * bool2int(couples[c,1] in table[t]));\n                          var TABLE: tn2 = sum(t in TABLE)(t * bool2int(couples[c,2] in table[t]));\n                    } in  tn1 + tn2);\n\n\n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n\n\n\nModel 2 : \n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\narray[PERSON] of var TABLE: seat;\n\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n                        seat[p1] != seat[p2];\n\nconstraint global_cardinality_low_up(seat, [t|t in TABLE], [0|t in TABLE], [S|t in TABLE]);\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))(seat[couples[c,1]] + seat[couples[c,2]]);\n\nconstraint forall(t in TABLE, p in PERSON)(p in table[t] <-> seat[p] = t);    \n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n"}, "hash": "16fee3cbac315570c551f7ebd5e6c31d99bcb4a474d343b576d2bce77cdd2410", "class_name": "RelatedNodeInfo"}}, "text": "name: Social Golfers Problem\n\ndescription: The Social Golfers Problem is a classic constraint satisfaction problem that involves assigning golfers to tables of a fixed size, subject to certain constraints. The problem is to find an assignment that minimizes the total sum of table numbers for all couples.\n\nvariables: table[t] (t in TABLE), seat[p] (p in PERSON)\n\nThe decision variables are table[t], which represents the set of people assigned to table t, and seat[p], which represents the table number assigned to person p.\n\nconstraints: \nforall(t in TABLE)(card(table[t]) <= S), \nforall(p in PERSON)(exists(t in TABLE)(p in table[t])), \nforall(c in index_set_1of2(couples))(not_same_table(couples[c,1],couples[c,2])), \nforall(p1,p2 in key where p1 < p2)(not_same_table(p1,p2)), \nforall(t in TABLE, p in PERSON)(p in table[t] <-> seat[p] = t)\n\nThe constraints ensure that each table has at most S people, each person is assigned to a table, couples are not assigned to the same table, people in the key set are not assigned to the same table, and the relationship between table and seat variables is maintained.\n\nobjective: minimize obj\n\nThe objective is to minimize the total sum of table numbers for all couples, where obj is the sum of table numbers for each couple.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1271, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cf86ef0c-8b0f-41bb-99e9-f503b64a75c0": {"__data__": {"id_": "cf86ef0c-8b0f-41bb-99e9-f503b64a75c0", "embedding": null, "metadata": {"model_name": "teamselect", "source_code": "Model 1 :\n\n\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\narray[CAPTAIN] of var set of PLAYER: team = [Xavier,Yuri,Zena];\n\nset of int: CAPTAIN = 1..3;\narray[CAPTAIN,PLAYER] of int: value;\n \nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |]; \n\nconstraint card(Xavier intersect GOALIE) >= 1;\nconstraint card(Xavier intersect DEFENCE) >= 2;\nconstraint card(Xavier intersect OFFENCE) >= 2;\nconstraint card(Xavier) = 6;\n\n\nconstraint card(Yuri intersect GOALIE) >= 1;\nconstraint card(Yuri intersect DEFENCE) >= 2;\nconstraint card(Yuri intersect OFFENCE) >= 2;\nconstraint card(Yuri) = 6;\n\nconstraint card(Zena intersect GOALIE) >= 1;\nconstraint card(Zena intersect DEFENCE) >= 2;\nconstraint card(Zena intersect OFFENCE) >= 2;\nconstraint card(Zena) = 6;\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nsolve maximize obj;\n\nvar int: obj = sum(c in CAPTAIN)(sum(p in team[c])(value[c,p]));\n\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n\n\nModel 2 :\n\n\n% team select problem\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\nset of int: CAPTAIN = 1..3;\nint: xavier = 1; int: yuri = 2; int: zena = 3;\narray[CAPTAIN,PLAYER] of int: value;\nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |];\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\npredicate correct_team(var set of PLAYER: team) = \n          card(team) = 6 /\\ \n          card(team intersect GOALIE) >= 1 /\\\n          card(team intersect DEFENCE) >= 2 /\\\n          card(team intersect OFFENCE) >= 2;\n\nconstraint correct_team(Xavier) /\\ correct_team(Yuri) /\\ correct_team(Zena);\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nvar int: obj = sum(p in Xavier)(value[xavier,p]) +\n               sum(p in Yuri)(value[yuri,p]) +\n               sum(p in Zena)(value[zena,p]);\n\nsolve maximize obj;\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "teamselect_expert", "node_type": "4", "metadata": {"model_name": "teamselect", "source_code": "Model 1 :\n\n\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\narray[CAPTAIN] of var set of PLAYER: team = [Xavier,Yuri,Zena];\n\nset of int: CAPTAIN = 1..3;\narray[CAPTAIN,PLAYER] of int: value;\n \nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |]; \n\nconstraint card(Xavier intersect GOALIE) >= 1;\nconstraint card(Xavier intersect DEFENCE) >= 2;\nconstraint card(Xavier intersect OFFENCE) >= 2;\nconstraint card(Xavier) = 6;\n\n\nconstraint card(Yuri intersect GOALIE) >= 1;\nconstraint card(Yuri intersect DEFENCE) >= 2;\nconstraint card(Yuri intersect OFFENCE) >= 2;\nconstraint card(Yuri) = 6;\n\nconstraint card(Zena intersect GOALIE) >= 1;\nconstraint card(Zena intersect DEFENCE) >= 2;\nconstraint card(Zena intersect OFFENCE) >= 2;\nconstraint card(Zena) = 6;\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nsolve maximize obj;\n\nvar int: obj = sum(c in CAPTAIN)(sum(p in team[c])(value[c,p]));\n\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n\n\nModel 2 :\n\n\n% team select problem\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\nset of int: CAPTAIN = 1..3;\nint: xavier = 1; int: yuri = 2; int: zena = 3;\narray[CAPTAIN,PLAYER] of int: value;\nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |];\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\npredicate correct_team(var set of PLAYER: team) = \n          card(team) = 6 /\\ \n          card(team intersect GOALIE) >= 1 /\\\n          card(team intersect DEFENCE) >= 2 /\\\n          card(team intersect OFFENCE) >= 2;\n\nconstraint correct_team(Xavier) /\\ correct_team(Yuri) /\\ correct_team(Zena);\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nvar int: obj = sum(p in Xavier)(value[xavier,p]) +\n               sum(p in Yuri)(value[yuri,p]) +\n               sum(p in Zena)(value[zena,p]);\n\nsolve maximize obj;\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n"}, "hash": "eef6ecae2e55d2553b03fe54b946b624d678e621c5bbef9385d2fd3eb0e13e8a", "class_name": "RelatedNodeInfo"}}, "text": "name: Team Selection Problem\n\ndescription: The Team Selection Problem is a classic problem in constraint programming that involves selecting three teams of six players each from a pool of 11 players, such that each team has at least one goalie, two defenders, and two forwards, and the total value of the players in each team is maximized.\n\nvariables: Xavier, Yuri, Zena \u2286 {1, ..., 11} \nThese variables represent the sets of players selected for each of the three teams, Xavier, Yuri, and Zena.\n\nconstraints: \ncard(Xavier) = 6, card(Yuri) = 6, card(Zena) = 6 \nThese constraints ensure that each team has exactly six players.\n\ncard(Xavier \u2229 GOALIE) \u2265 1, card(Yuri \u2229 GOALIE) \u2265 1, card(Zena \u2229 GOALIE) \u2265 1 \nThese constraints ensure that each team has at least one goalie.\n\ncard(Xavier \u2229 DEFENCE) \u2265 2, card(Yuri \u2229 DEFENCE) \u2265 2, card(Zena \u2229 DEFENCE) \u2265 2 \nThese constraints ensure that each team has at least two defenders.\n\ncard(Xavier \u2229 OFFENCE) \u2265 2, card(Yuri \u2229 OFFENCE) \u2265 2, card(Zena \u2229 OFFENCE) \u2265 2 \nThese constraints ensure that each team has at least two forwards.\n\ncard(Xavier \u2229 Yuri) \u2264 2, card(Xavier \u2229 Zena) \u2264 2 \nThese constraints ensure that no more than two players are shared between any two teams.\n\nobjective: maximize \u2211(c in CAPTAIN)(\u2211(p in team[c])(value[c,p])) \nThe objective is to maximize the total value of the players in all three teams.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1351, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "117c106b-5043-469c-8a54-a0b261e29310": {"__data__": {"id_": "117c106b-5043-469c-8a54-a0b261e29310", "embedding": null, "metadata": {"model_name": "template_design", "source_code": "% Template design\ninclude \"globals.mzn\";\n\nint: S;   \t\t% Number of slots per template.\nint: t;   \t\t% Number of templates.\nint: n;   \t\t% Number of variations.\narray[1..n] of int: d; \t% How much of each variation we must print?\n\n% Lower and upper bounds for the total production.\n%\nint: llower = ceil(sum(i in 1..n)(int2float(d[i]))/int2float(S));\nint: lupper = 2*llower; % If t>1, this should be the optimal Production_{t-1}-1.\n\n% # Slots allocated to variation i in template j\narray[1..n,1..t] of var 0..S: p;\n\n% # Pressings of template j.\narray[1..t] of var 1..lupper: R;\n\n% Sum of all Rj.\nvar llower..lupper: Production;\n\n% Production x S - sum(d[i])\nvar 0..lupper-llower: Surplus;\n\n% First, set up Production to be the sum of the Rj\nconstraint\n\tProduction = sum(i in 1..t)(R[i]);\n\n% the limits on production\nconstraint\n\tProduction >= llower /\\ Production <= lupper;\n\n% The number of slots occupied in each template is S.\nconstraint\n\tforall(j in 1..t)\n\t\t (sum(i in 1..n)(p[i,j]) = S);\n\n% Enough of each variation is printed.\nconstraint\n\tforall(i in 1..n)\n\t\t (sum(j in 1..t)(p[i,j]*R[j]) >= d[i]);\n\n% Symmetry constraints.\n% Variations with the same demand are symmetric.\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] == d[i+1] then\n\t\t\tlex_lesseq([p[i,  j] | j in 1..t],\n\t\t\t\t[p[i+1,j] | j in 1..t])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% pseudo symmetry\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] < d[i+1] then\n\t\t       sum (j in 1..t) (p[i,j]*R[j])\n\t\t     <= sum (j in 1..t) (p[i+1,j]*R[j])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% implied constraints on the surplus\n\n% These are presented in the paper as necessary to get good\n% performance for this model, but I think bounds consistency on the\n% sum(R[i]) constraint would produce the same amount of propagation\n\n% Set up surplus, which is bounded as production is bounded.\nconstraint\n\tSurplus = Production*S - sum(i in 1..n)(d[i]);\n\n% The surplus of each variation is also limited by the surplus.\nconstraint\n\tforall(k in 1..n)\n\t\t (sum(j in 1..t)(p[k,j]*R[j]-d[k]) <= Surplus);\n\n% The surplus of the first k variations is limited by the surplus.\nconstraint\n\tforall(k in 2..n-1)\n\t\t (sum(j in 1..t, m in 1..k)( p[m,j]*R[j]-d[m] ) <= Surplus);\n\n% Implied constraints on the run length.\nconstraint\n\tif t=2 then (\n\t\tR[1] <= Production div 2\n\t/\\\tR[2] >= Production div 2\n\t) else true endif;\n\nconstraint\n\tif t=3 then (\n\t\tR[1] <= Production div 3\n\t/\\\tR[2] <= Production div 2\n\t/\\\tR[3] >= Production div 3\n\t) else true endif;\n\n% Minimize the production.\nsolve :: int_search(array1d(1..n*t,p) ++ R, input_order, indomain_min, complete)\n    minimize Production;\n\noutput [\n    if v = 1 then \"template #\" ++ show(i) ++ \": [\" else \"\" endif ++\n    show(p[v, i]) ++\n    if v = n then \"], pressings: \" ++ show(R[i]) ++ \"\\n\" else \", \" endif\n\t| i in 1..t, v in 1..n]\n    ++ [\"Total pressings: \", show(Production), \"\\n%\\n\"];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "template_design_expert", "node_type": "4", "metadata": {"model_name": "template_design", "source_code": "% Template design\ninclude \"globals.mzn\";\n\nint: S;   \t\t% Number of slots per template.\nint: t;   \t\t% Number of templates.\nint: n;   \t\t% Number of variations.\narray[1..n] of int: d; \t% How much of each variation we must print?\n\n% Lower and upper bounds for the total production.\n%\nint: llower = ceil(sum(i in 1..n)(int2float(d[i]))/int2float(S));\nint: lupper = 2*llower; % If t>1, this should be the optimal Production_{t-1}-1.\n\n% # Slots allocated to variation i in template j\narray[1..n,1..t] of var 0..S: p;\n\n% # Pressings of template j.\narray[1..t] of var 1..lupper: R;\n\n% Sum of all Rj.\nvar llower..lupper: Production;\n\n% Production x S - sum(d[i])\nvar 0..lupper-llower: Surplus;\n\n% First, set up Production to be the sum of the Rj\nconstraint\n\tProduction = sum(i in 1..t)(R[i]);\n\n% the limits on production\nconstraint\n\tProduction >= llower /\\ Production <= lupper;\n\n% The number of slots occupied in each template is S.\nconstraint\n\tforall(j in 1..t)\n\t\t (sum(i in 1..n)(p[i,j]) = S);\n\n% Enough of each variation is printed.\nconstraint\n\tforall(i in 1..n)\n\t\t (sum(j in 1..t)(p[i,j]*R[j]) >= d[i]);\n\n% Symmetry constraints.\n% Variations with the same demand are symmetric.\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] == d[i+1] then\n\t\t\tlex_lesseq([p[i,  j] | j in 1..t],\n\t\t\t\t[p[i+1,j] | j in 1..t])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% pseudo symmetry\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] < d[i+1] then\n\t\t       sum (j in 1..t) (p[i,j]*R[j])\n\t\t     <= sum (j in 1..t) (p[i+1,j]*R[j])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% implied constraints on the surplus\n\n% These are presented in the paper as necessary to get good\n% performance for this model, but I think bounds consistency on the\n% sum(R[i]) constraint would produce the same amount of propagation\n\n% Set up surplus, which is bounded as production is bounded.\nconstraint\n\tSurplus = Production*S - sum(i in 1..n)(d[i]);\n\n% The surplus of each variation is also limited by the surplus.\nconstraint\n\tforall(k in 1..n)\n\t\t (sum(j in 1..t)(p[k,j]*R[j]-d[k]) <= Surplus);\n\n% The surplus of the first k variations is limited by the surplus.\nconstraint\n\tforall(k in 2..n-1)\n\t\t (sum(j in 1..t, m in 1..k)( p[m,j]*R[j]-d[m] ) <= Surplus);\n\n% Implied constraints on the run length.\nconstraint\n\tif t=2 then (\n\t\tR[1] <= Production div 2\n\t/\\\tR[2] >= Production div 2\n\t) else true endif;\n\nconstraint\n\tif t=3 then (\n\t\tR[1] <= Production div 3\n\t/\\\tR[2] <= Production div 2\n\t/\\\tR[3] >= Production div 3\n\t) else true endif;\n\n% Minimize the production.\nsolve :: int_search(array1d(1..n*t,p) ++ R, input_order, indomain_min, complete)\n    minimize Production;\n\noutput [\n    if v = 1 then \"template #\" ++ show(i) ++ \": [\" else \"\" endif ++\n    show(p[v, i]) ++\n    if v = n then \"], pressings: \" ++ show(R[i]) ++ \"\\n\" else \", \" endif\n\t| i in 1..t, v in 1..n]\n    ++ [\"Total pressings: \", show(Production), \"\\n%\\n\"];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%\n"}, "hash": "a9b0950cbcd91b6be9b52a4ce1b8a5d16f9def0b0f8a9ebb0dc6afbdd9eb6724", "class_name": "RelatedNodeInfo"}}, "text": "name: Template Design Problem\n\ndescription: The Template Design Problem is a classic problem in constraint programming that involves designing templates for printing variations of a product. The goal is to determine the optimal allocation of slots on each template to meet the demand for each variation while minimizing the total production.\n\nvariables: p[i, j], R[j], Production, Surplus\n\np[i, j] represents the number of slots allocated to variation i in template j. R[j] represents the number of pressings of template j. Production represents the total number of pressings. Surplus represents the excess production beyond the total demand.\n\nconstraints: \nProduction = sum(R[j]), \nProduction >= llower /\\ Production <= lupper, \nsum(p[i, j]) = S, \nsum(p[i, j]*R[j]) >= d[i], \nlex_lesseq([p[i,  j] | j in 1..t], [p[i+1,j] | j in 1..t]), \nsum(p[i, j]*R[j]) <= sum(p[i+1, j]*R[j]), \nSurplus = Production*S - sum(d[i]), \nsum(p[k, j]*R[j]-d[k]) <= Surplus, \nsum(p[m, j]*R[j]-d[m]) <= Surplus, \nR[1] <= Production div 2, \nR[2] >= Production div 2, \nR[1] <= Production div 3, \nR[2] <= Production div 2, \nR[3] >= Production div 3\n\nThese constraints ensure that the total production is the sum of the pressings, the production is within the bounds, each template has S slots, the demand for each variation is met, symmetry and pseudo-symmetry constraints are satisfied, the surplus is correctly calculated, and the run length constraints are satisfied.\n\nobjective: minimize Production", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1476, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9c59ce8f-ee1f-442f-9a85-64e809abb3a9": {"__data__": {"id_": "9c59ce8f-ee1f-442f-9a85-64e809abb3a9", "embedding": null, "metadata": {"model_name": "toomany", "source_code": "%% TooMany.mzn (too many solutions)\nint: n; % number of machines\nset of int: MACHINE = 1..n;\nint: k; % production per day\nint: red = 1; int: white = 2; int: black = 3; int: blue = 4;\nset of int: COLOR = 1..4;\narray[COLOR] of int: l; % lower bound on production\narray[COLOR] of int: u; % upper bound on production\n\narray[MACHINE,COLOR] of var 0..k div 2: produce;\n\nconstraint forall(m in MACHINE)\n                 (sum(c in COLOR)(produce[m,c]) <= k);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) >= l[c]);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) <= u[c]);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] > 0 /\\ produce[m,black] > 0 -> produce[m,blue] = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,blue] <= produce[m,red]);\nconstraint forall(m in MACHINE)\n                 (produce[m,red] mod 4 = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] mod 3 = 0);\n\n\nsolve maximize sum(m in MACHINE, c in COLOR)(produce[m,c]);\n\noutput [ show_int(3,produce[m,c]) ++\n         if c = 4 then \"\\n\" else \" \" endif\n       | m in MACHINE, c in COLOR ];\n\nn = 4;\nk = 11;\nl = [8,7,10,6];\nu = [14,16,12,20];\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "toomany_expert", "node_type": "4", "metadata": {"model_name": "toomany", "source_code": "%% TooMany.mzn (too many solutions)\nint: n; % number of machines\nset of int: MACHINE = 1..n;\nint: k; % production per day\nint: red = 1; int: white = 2; int: black = 3; int: blue = 4;\nset of int: COLOR = 1..4;\narray[COLOR] of int: l; % lower bound on production\narray[COLOR] of int: u; % upper bound on production\n\narray[MACHINE,COLOR] of var 0..k div 2: produce;\n\nconstraint forall(m in MACHINE)\n                 (sum(c in COLOR)(produce[m,c]) <= k);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) >= l[c]);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) <= u[c]);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] > 0 /\\ produce[m,black] > 0 -> produce[m,blue] = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,blue] <= produce[m,red]);\nconstraint forall(m in MACHINE)\n                 (produce[m,red] mod 4 = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] mod 3 = 0);\n\n\nsolve maximize sum(m in MACHINE, c in COLOR)(produce[m,c]);\n\noutput [ show_int(3,produce[m,c]) ++\n         if c = 4 then \"\\n\" else \" \" endif\n       | m in MACHINE, c in COLOR ];\n\nn = 4;\nk = 11;\nl = [8,7,10,6];\nu = [14,16,12,20];\n\n"}, "hash": "5bc8ea7ea0175334621dd9fdd3af4509bc0a7433aad97c362474daf49d4b905c", "class_name": "RelatedNodeInfo"}}, "text": "name: Production Planning Problem\n\ndescription: This problem involves planning the production of different colored items on multiple machines, subject to various constraints on the production capacity of each machine and the total production of each color. The goal is to maximize the total production across all machines and colors.\n\nvariables: produce[m,c] (m \u2208 MACHINE, c \u2208 COLOR)\n\nThe decision variables represent the amount of each color produced on each machine, where produce[m,c] is the amount of color c produced on machine m.\n\nconstraints: \n\u2200m \u2208 MACHINE: \u2211(c \u2208 COLOR)(produce[m,c]) \u2264 k\n\u2200c \u2208 COLOR: \u2211(m \u2208 MACHINE)(produce[m,c]) \u2265 l[c]\n\u2200c \u2208 COLOR: \u2211(m \u2208 MACHINE)(produce[m,c]) \u2264 u[c]\n\u2200m \u2208 MACHINE: produce[m,white] > 0 \u2227 produce[m,black] > 0 \u2192 produce[m,blue] = 0\n\u2200m \u2208 MACHINE: produce[m,blue] \u2264 produce[m,red]\n\u2200m \u2208 MACHINE: produce[m,red] mod 4 = 0\n\u2200m \u2208 MACHINE: produce[m,white] mod 3 = 0\n\nThe constraints ensure that:\n- Each machine does not produce more than k units in total.\n- The total production of each color meets the lower bound l[c] and does not exceed the upper bound u[c].\n- If a machine produces both white and black, it cannot produce blue.\n- The production of blue on a machine does not exceed the production of red on the same machine.\n- The production of red on a machine is a multiple of 4.\n- The production of white on a machine is a multiple of 3.\n\nobjective: Maximize \u2211(m \u2208 MACHINE, c \u2208 COLOR)(produce[m,c])\n\nThe objective is to maximize the total production across all machines and colors.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1521, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "13f2cb95-7177-43ef-bd2e-460a083aca31": {"__data__": {"id_": "13f2cb95-7177-43ef-bd2e-460a083aca31", "embedding": null, "metadata": {"model_name": "traffic_lights_table", "source_code": "Model 1 :\n\n%Traffic lights problem in MiniZinc.\n% Specification:\n% Consider a four way traffic junction with eight traffic lights. Four of\n% the traffic lights are for the vehicles and can be represented by the\n% variables V1 to V4 with domains\n% {r,ry,g,y} (for red, red-yellow, green and yellow).\n%  The other four traffic lights are for the pedestrians and can be\n%  represented by the variables P1 to P4 with domains {r,g}.\n%\n% The constraints on these variables can be modelled by quaternary\n% constraints on\n% (Vi, Pi, Vj, Pj ) for 1<=i<=4, j=(1+i)mod 4 which allow just the tuples\n% {(r,r,g,g), (ry,r,y,r), (g,g,r,r), (y,r,ry,r)}.\n%\n% It would be interesting to consider other types of junction (e.g. five roads\n% intersecting) as well as modelling the evolution over time of the\n% traffic light sequence.\n\ninclude \"globals.mzn\";\n\nint: n = 4;\nint: r  = 1; % red\nint: ry = 2; % red-yellow\nint: g  = 3; % green\nint: y  = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V;\narray[1..n] of var Pedestrians: P;\n\n\nsolve satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   table([V[i], P[i], V[j], P[j]], allowed)\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\n% output [\n%  \"V: \", show(V), \"\\nP: \", show(P), \"\\n\"\n% ];\noutput [\n show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: n = 4;\nint: r = 1; % red\nint: ry = 2; % red-yellow\nint: g = 3; % green\nint: y = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V; % ;\narray[1..n] of var Pedestrians: P; %;\n\npredicate cp1d(array[int] of var int: x, array[int] of var int: y) =\n  assert(index_set(x) = index_set(y),\n           \"cp1d: x and y have different sizes\",\n     forall(i in index_set(x)) ( x[i] = y[i] ))\n; \n\n% solve satisfy;\nsolve :: int_search(V ++ P, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   exists(a in 1..4) (\n      cp1d([V[i], P[i], V[j], P[j]], [allowed[a,k] | k in 1..4])\n   )\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\noutput [\n  show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "traffic_lights_table_expert", "node_type": "4", "metadata": {"model_name": "traffic_lights_table", "source_code": "Model 1 :\n\n%Traffic lights problem in MiniZinc.\n% Specification:\n% Consider a four way traffic junction with eight traffic lights. Four of\n% the traffic lights are for the vehicles and can be represented by the\n% variables V1 to V4 with domains\n% {r,ry,g,y} (for red, red-yellow, green and yellow).\n%  The other four traffic lights are for the pedestrians and can be\n%  represented by the variables P1 to P4 with domains {r,g}.\n%\n% The constraints on these variables can be modelled by quaternary\n% constraints on\n% (Vi, Pi, Vj, Pj ) for 1<=i<=4, j=(1+i)mod 4 which allow just the tuples\n% {(r,r,g,g), (ry,r,y,r), (g,g,r,r), (y,r,ry,r)}.\n%\n% It would be interesting to consider other types of junction (e.g. five roads\n% intersecting) as well as modelling the evolution over time of the\n% traffic light sequence.\n\ninclude \"globals.mzn\";\n\nint: n = 4;\nint: r  = 1; % red\nint: ry = 2; % red-yellow\nint: g  = 3; % green\nint: y  = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V;\narray[1..n] of var Pedestrians: P;\n\n\nsolve satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   table([V[i], P[i], V[j], P[j]], allowed)\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\n% output [\n%  \"V: \", show(V), \"\\nP: \", show(P), \"\\n\"\n% ];\noutput [\n show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: n = 4;\nint: r = 1; % red\nint: ry = 2; % red-yellow\nint: g = 3; % green\nint: y = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V; % ;\narray[1..n] of var Pedestrians: P; %;\n\npredicate cp1d(array[int] of var int: x, array[int] of var int: y) =\n  assert(index_set(x) = index_set(y),\n           \"cp1d: x and y have different sizes\",\n     forall(i in index_set(x)) ( x[i] = y[i] ))\n; \n\n% solve satisfy;\nsolve :: int_search(V ++ P, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   exists(a in 1..4) (\n      cp1d([V[i], P[i], V[j], P[j]], [allowed[a,k] | k in 1..4])\n   )\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\noutput [\n  show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n"}, "hash": "23d9bcc31ada08179f8aaf01c49aa31eb5a6042ffe5d6672ede18513783ebd32", "class_name": "RelatedNodeInfo"}}, "text": "name: Traffic Lights Problem\n\ndescription: The Traffic Lights Problem is a classic constraint satisfaction problem that involves finding a valid configuration of traffic lights at a four-way junction. The problem consists of eight traffic lights, four for vehicles and four for pedestrians, each with a specific domain of possible states (red, red-yellow, green, and yellow for vehicles, and red and green for pedestrians). The goal is to find an assignment of states to the traffic lights that satisfies certain constraints, ensuring safe and efficient traffic flow.\n\nvariables: V = (V1, V2, V3, V4) \u2208 {r, ry, g, y}\u2074, P = (P1, P2, P3, P4) \u2208 {r, g}\u2074\nThe decision variables V and P represent the states of the traffic lights for vehicles and pedestrians, respectively, at each of the four intersections.\n\nconstraints: \u2200i, j \u2208 {1, 2, 3, 4} where j = (1+i) mod 4, (Vi, Pi, Vj, Pj) \u2208 {(r, r, g, g), (ry, r, y, r), (g, g, r, r), (y, r, ry, r)}\nThe constraints ensure that the traffic lights are configured in a way that allows safe and efficient traffic flow. Specifically, they enforce the rules that when a vehicle light is red, the corresponding pedestrian light is also red, and when a vehicle light is green, the corresponding pedestrian light is also green.\n\nobjective: satisfy\nThe objective of the problem is to find a feasible assignment of states to the traffic lights that satisfies all the constraints, without any specific optimization goal.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1448, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a0f58007-0662-48ff-94fe-189f41e7f1d0": {"__data__": {"id_": "a0f58007-0662-48ff-94fe-189f41e7f1d0", "embedding": null, "metadata": {"model_name": "TTPPV", "source_code": "% Traveling Tournament Problem with Predefined Venues\n%\n% Compact single round robin schedule minimizing total travel distance\n% The venue of each game has already been decided\n% Specialized for CIRC instances (circular distances)\n\ninclude \"globals.mzn\";\n\nint: nbTeams;\nint: nbRounds = nbTeams-1;\n\nset of int: Teams = 1..nbTeams;\nset of int: Rounds = 1..nbRounds;\nset of int: Travels = 1..nbRounds+1;\n\n% predefined venue: pv[i][j] = 1 iff i is playing at home against j\narray[Teams,Teams] of 1..2: pv; \n\n% circular distances: for i>=j, distance[i][j]=min{i-j,j-i+nbTeams}\narray[Teams,Teams] of int: distance = \n  array2d(Teams,Teams,[ if i>=j then (if i-j < j-i+nbTeams then i-j else j-i+nbTeams endif) \n                                else (if j-i < i-j+nbTeams then j-i else i-j+nbTeams endif) \n                                endif | i,j in Teams]);\n\n% output related\nint: digs = ceil(log(10.0,int2float(nbTeams)));\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% decision variables: in round k, team i plays against team opponent[i,k]\narray[Teams,Rounds] of var Teams: opponent;\n\n% auxiliary variables: venue[i,k] = 1 iff team i plays at home in round k\narray[Teams,Rounds] of var 1..2: venue;\nconstraint forall (i in Teams, k in Rounds) (venue[i,k] = pv[i,opponent[i,k]]);\n\n% auxiliary variables: travel[i,k] is the distance travelled by team i to go play in round k (includes travelling back home after last round)\narray[Teams,Travels] of var 0..(nbTeams div 2): travel;\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n% a team cannot play against itself\nconstraint forall (i in Teams, k in Rounds) (opponent[i,k] != i);\n\n% in round k, i plays j means j plays i\nconstraint forall (i in Teams, k in Rounds) (opponent[opponent[i,k],k] = i);\n\n% for each team i, all opponents are different\nconstraint forall (i in Teams) (alldifferent([opponent[i,k] | k in Rounds]));\n\n% for each round k, all opponents are different (implied constraint)\nconstraint forall (k in Rounds) (alldifferent([opponent[i,k] | i in Teams]));\n\n% for each team i, there can be at most 3 consecutive home games and at most 3 consecutive away games\nint: nbStates = 7;\nset of int: States = 1..nbStates;\narray[States,1..2] of int: delta = \n  [| 2, 5\n   | 3, 5\n   | 4, 5\n   | 0, 5\n   | 2, 6\n   | 2, 7\n   | 2, 0 |];\nconstraint forall (i in Teams) (regular( [venue[i,k] | k in Rounds], nbStates, 2, delta, 1, States));\n\n% symmetry breaking: distances are symmetric so reversing the rounds yields a schedule of same cost\nconstraint (opponent[1,1] < opponent[1,nbRounds]);\n\n% define travel variables wrt venues of current- and next-round games\nconstraint forall (i in Teams) (\n\t(venue[i,1]=1 -> travel[i,1] = 0) /\\\n\t(venue[i,1]=2 -> travel[i,1] = distance[i,opponent[i,1]]) );\nconstraint forall (i in Teams, k in 1..nbRounds-1) (\n\t((venue[i,k]=1 /\\ venue[i,k+1]=1) -> travel[i,k+1] = 0) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=1) -> travel[i,k+1] = distance[opponent[i,k],i]) /\\\n\t((venue[i,k]=1 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[i,opponent[i,k+1]]) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[opponent[i,k],opponent[i,k+1]]) );\nconstraint forall (i in Teams) (\n\t(venue[i,nbRounds]=1 -> travel[i,nbRounds+1] = 0) /\\\n\t(venue[i,nbRounds]=2 -> travel[i,nbRounds+1] = distance[opponent[i,nbRounds],i]) );\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nvar int: totalTravel;\nconstraint totalTravel = sum (i in Teams, k in Travels) (travel[i,k]);\nsolve minimize totalTravel;\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\noutput [\"SCHEDULE\\n\"] ++ \n       [ if fix(venue[i,k]) == 1 then \" \" else \"@\" endif ++\n\t show_int(digs,opponent[i,k]) ++ \" \" ++ \n         if k == nbRounds /\\ i != nbTeams then \"\\n\" else \"\" endif\n         | i in Teams, k in Rounds ] ++ [\"\\n\"] ++\n       [\"total travel = \"] ++ [show(totalTravel)] ++ [\"\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "TTPPV_expert", "node_type": "4", "metadata": {"model_name": "TTPPV", "source_code": "% Traveling Tournament Problem with Predefined Venues\n%\n% Compact single round robin schedule minimizing total travel distance\n% The venue of each game has already been decided\n% Specialized for CIRC instances (circular distances)\n\ninclude \"globals.mzn\";\n\nint: nbTeams;\nint: nbRounds = nbTeams-1;\n\nset of int: Teams = 1..nbTeams;\nset of int: Rounds = 1..nbRounds;\nset of int: Travels = 1..nbRounds+1;\n\n% predefined venue: pv[i][j] = 1 iff i is playing at home against j\narray[Teams,Teams] of 1..2: pv; \n\n% circular distances: for i>=j, distance[i][j]=min{i-j,j-i+nbTeams}\narray[Teams,Teams] of int: distance = \n  array2d(Teams,Teams,[ if i>=j then (if i-j < j-i+nbTeams then i-j else j-i+nbTeams endif) \n                                else (if j-i < i-j+nbTeams then j-i else i-j+nbTeams endif) \n                                endif | i,j in Teams]);\n\n% output related\nint: digs = ceil(log(10.0,int2float(nbTeams)));\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% decision variables: in round k, team i plays against team opponent[i,k]\narray[Teams,Rounds] of var Teams: opponent;\n\n% auxiliary variables: venue[i,k] = 1 iff team i plays at home in round k\narray[Teams,Rounds] of var 1..2: venue;\nconstraint forall (i in Teams, k in Rounds) (venue[i,k] = pv[i,opponent[i,k]]);\n\n% auxiliary variables: travel[i,k] is the distance travelled by team i to go play in round k (includes travelling back home after last round)\narray[Teams,Travels] of var 0..(nbTeams div 2): travel;\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n% a team cannot play against itself\nconstraint forall (i in Teams, k in Rounds) (opponent[i,k] != i);\n\n% in round k, i plays j means j plays i\nconstraint forall (i in Teams, k in Rounds) (opponent[opponent[i,k],k] = i);\n\n% for each team i, all opponents are different\nconstraint forall (i in Teams) (alldifferent([opponent[i,k] | k in Rounds]));\n\n% for each round k, all opponents are different (implied constraint)\nconstraint forall (k in Rounds) (alldifferent([opponent[i,k] | i in Teams]));\n\n% for each team i, there can be at most 3 consecutive home games and at most 3 consecutive away games\nint: nbStates = 7;\nset of int: States = 1..nbStates;\narray[States,1..2] of int: delta = \n  [| 2, 5\n   | 3, 5\n   | 4, 5\n   | 0, 5\n   | 2, 6\n   | 2, 7\n   | 2, 0 |];\nconstraint forall (i in Teams) (regular( [venue[i,k] | k in Rounds], nbStates, 2, delta, 1, States));\n\n% symmetry breaking: distances are symmetric so reversing the rounds yields a schedule of same cost\nconstraint (opponent[1,1] < opponent[1,nbRounds]);\n\n% define travel variables wrt venues of current- and next-round games\nconstraint forall (i in Teams) (\n\t(venue[i,1]=1 -> travel[i,1] = 0) /\\\n\t(venue[i,1]=2 -> travel[i,1] = distance[i,opponent[i,1]]) );\nconstraint forall (i in Teams, k in 1..nbRounds-1) (\n\t((venue[i,k]=1 /\\ venue[i,k+1]=1) -> travel[i,k+1] = 0) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=1) -> travel[i,k+1] = distance[opponent[i,k],i]) /\\\n\t((venue[i,k]=1 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[i,opponent[i,k+1]]) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[opponent[i,k],opponent[i,k+1]]) );\nconstraint forall (i in Teams) (\n\t(venue[i,nbRounds]=1 -> travel[i,nbRounds+1] = 0) /\\\n\t(venue[i,nbRounds]=2 -> travel[i,nbRounds+1] = distance[opponent[i,nbRounds],i]) );\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nvar int: totalTravel;\nconstraint totalTravel = sum (i in Teams, k in Travels) (travel[i,k]);\nsolve minimize totalTravel;\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\noutput [\"SCHEDULE\\n\"] ++ \n       [ if fix(venue[i,k]) == 1 then \" \" else \"@\" endif ++\n\t show_int(digs,opponent[i,k]) ++ \" \" ++ \n         if k == nbRounds /\\ i != nbTeams then \"\\n\" else \"\" endif\n         | i in Teams, k in Rounds ] ++ [\"\\n\"] ++\n       [\"total travel = \"] ++ [show(totalTravel)] ++ [\"\\n\"];\n"}, "hash": "e0d6a1982dd4a4a2280a177af0eb729872db6a51d49b58ec1bf19682f7cba9c0", "class_name": "RelatedNodeInfo"}}, "text": "name: Traveling Tournament Problem with Predefined Venues\n\ndescription: The Traveling Tournament Problem with Predefined Venues is a classical problem in constraint programming that involves scheduling a round-robin tournament for a set of teams, where each team plays every other team exactly once, and the venue of each game has already been decided. The goal is to find a schedule that minimizes the total travel distance of all teams.\n\nvariables: opponent[i,k], venue[i,k], travel[i,k]\n\nThe decision variables are:\n- opponent[i,k]: the opponent of team i in round k\n- venue[i,k]: 1 if team i plays at home in round k, 2 otherwise\n- travel[i,k]: the distance travelled by team i to go play in round k (includes travelling back home after the last round)\n\nconstraints: \nopponent[i,k] != i, \nopponent[opponent[i,k],k] = i, \nalldifferent([opponent[i,k] | k in Rounds]), \nalldifferent([opponent[i,k] | i in Teams]), \nregular( [venue[i,k] | k in Rounds], nbStates, 2, delta, 1, States), \nopponent[1,1] < opponent[1,nbRounds], \nvenue[i,k] = pv[i,opponent[i,k]], \ntravel constraints (5 constraints)\n\nThe constraints are:\n- a team cannot play against itself\n- in round k, i plays j means j plays i\n- for each team i, all opponents are different\n- for each round k, all opponents are different\n- for each team i, there can be at most 3 consecutive home games and at most 3 consecutive away games\n- symmetry breaking: distances are symmetric so reversing the rounds yields a schedule of same cost\n- the venue of each game has already been decided\n- the travel variables are defined wrt venues of current- and next-round games\n\nobjective: minimize totalTravel", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1651, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b84890a9-e170-4c03-a142-6eff1f9f01ec": {"__data__": {"id_": "b84890a9-e170-4c03-a142-6eff1f9f01ec", "embedding": null, "metadata": {"model_name": "vessel-loading", "source_code": "% Vessel Loading\n\nint: deck_width; % width of deck\nint: deck_length; % height of deck\nint: n_containers; % number of containers\nint: n_classes; % number of container classes\n\narray[int] of int: width;\n% width[c] = width of container c\narray[int] of int: length;\n% length[c] = length of container c\narray[int] of int: class;\n% class[c] = class of container c\narray[int, int] of int: separation;\n% separation[a, b] = the minimum allowed separation between\n%                    containers of classes a and b\n\nset of int: Containers = 1..n_containers;\n\narray[Containers] of var 0..deck_width: Left;\n% Left[c] = leftmost point of container c\narray[Containers] of var 0..deck_width: Right;\n% Right[c] = rightmost point of container c\narray[Containers] of var 0..deck_length: Bottom;\n% Bottom[c] = bottommost point of container c\narray[Containers] of var 0..deck_length: Top;\n% Top[c] = topmost point of container c\n\narray[Containers] of var 1..2: orientation;\n% orientation[c] = 2 if container c is turned 90 degrees, else 1.\n\nconstraint\n  forall (c in Containers) (\n    let {\n      array[1..2] of int: ElemWidth = [width[c], length[c]];\n      array[1..2] of int: ElemLength = [length[c], width[c]]\n    }\n    in \n      Right[c] = Left[c] + ElemWidth[orientation[c]] /\\\n      Top[c] = Bottom[c] + ElemLength[orientation[c]]\n  )\n;\n\nconstraint\n  forall(c, k in Containers where c < k) (\n    Left[c] >= Right[k] + separation[class[c], class[k]] \\/\n    Right[c] + separation[class[c], class[k]] <= Left[k] \\/\n    Bottom[c] >= Top[k] + separation[class[c], class[k]] \\/\n    Top[c] + separation[class[c], class[k]] <= Bottom[k]\n  )\n;\n\n% Excessive (pretty) output\noutput [\"\u250c\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2510\\n\"] ++\n       [if x == 0 then \"\u2502\" else \"\" endif ++\n        let {\n          bool: l = exists([fix(Left[c])   = x | c in Containers]);\n          bool: r = exists([fix(Right[c])  = x | c in Containers]);\n          bool: b = exists([fix(Bottom[c]) = y | c in Containers]);\n          bool: t = exists([fix(Top[c])    = y | c in Containers])\n        } in\n          if     l /\\ r /\\ b /\\ t then \"\u253c\"\n          elseif l /\\ r /\\ b      then \"\u252c\"\n          elseif l /\\ r /\\      t then \"\u2534\"\n          elseif l /\\      b /\\ t then \"\u251c\"\n          elseif      r /\\ b /\\ t then \"\u2524\"\n          elseif l /\\      b      then \"\u250c\"\n          elseif l /\\           t then \"\u2514\"\n          elseif      r /\\ b      then \"\u2510\"\n          elseif      r /\\      t then \"\u2518\"\n          elseif l \\/ r           then \"\u2502\"\n          elseif           b \\/ t then \"\u2500\" \n          else \" \" endif ++\n        if x == deck_width then \"\u2502\\n\" else \"\" endif\n        | y in 0..deck_length, x in 0..deck_width] ++\n        [\"\u2514\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2518\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "vessel-loading_expert", "node_type": "4", "metadata": {"model_name": "vessel-loading", "source_code": "% Vessel Loading\n\nint: deck_width; % width of deck\nint: deck_length; % height of deck\nint: n_containers; % number of containers\nint: n_classes; % number of container classes\n\narray[int] of int: width;\n% width[c] = width of container c\narray[int] of int: length;\n% length[c] = length of container c\narray[int] of int: class;\n% class[c] = class of container c\narray[int, int] of int: separation;\n% separation[a, b] = the minimum allowed separation between\n%                    containers of classes a and b\n\nset of int: Containers = 1..n_containers;\n\narray[Containers] of var 0..deck_width: Left;\n% Left[c] = leftmost point of container c\narray[Containers] of var 0..deck_width: Right;\n% Right[c] = rightmost point of container c\narray[Containers] of var 0..deck_length: Bottom;\n% Bottom[c] = bottommost point of container c\narray[Containers] of var 0..deck_length: Top;\n% Top[c] = topmost point of container c\n\narray[Containers] of var 1..2: orientation;\n% orientation[c] = 2 if container c is turned 90 degrees, else 1.\n\nconstraint\n  forall (c in Containers) (\n    let {\n      array[1..2] of int: ElemWidth = [width[c], length[c]];\n      array[1..2] of int: ElemLength = [length[c], width[c]]\n    }\n    in \n      Right[c] = Left[c] + ElemWidth[orientation[c]] /\\\n      Top[c] = Bottom[c] + ElemLength[orientation[c]]\n  )\n;\n\nconstraint\n  forall(c, k in Containers where c < k) (\n    Left[c] >= Right[k] + separation[class[c], class[k]] \\/\n    Right[c] + separation[class[c], class[k]] <= Left[k] \\/\n    Bottom[c] >= Top[k] + separation[class[c], class[k]] \\/\n    Top[c] + separation[class[c], class[k]] <= Bottom[k]\n  )\n;\n\n% Excessive (pretty) output\noutput [\"\u250c\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2510\\n\"] ++\n       [if x == 0 then \"\u2502\" else \"\" endif ++\n        let {\n          bool: l = exists([fix(Left[c])   = x | c in Containers]);\n          bool: r = exists([fix(Right[c])  = x | c in Containers]);\n          bool: b = exists([fix(Bottom[c]) = y | c in Containers]);\n          bool: t = exists([fix(Top[c])    = y | c in Containers])\n        } in\n          if     l /\\ r /\\ b /\\ t then \"\u253c\"\n          elseif l /\\ r /\\ b      then \"\u252c\"\n          elseif l /\\ r /\\      t then \"\u2534\"\n          elseif l /\\      b /\\ t then \"\u251c\"\n          elseif      r /\\ b /\\ t then \"\u2524\"\n          elseif l /\\      b      then \"\u250c\"\n          elseif l /\\           t then \"\u2514\"\n          elseif      r /\\ b      then \"\u2510\"\n          elseif      r /\\      t then \"\u2518\"\n          elseif l \\/ r           then \"\u2502\"\n          elseif           b \\/ t then \"\u2500\" \n          else \" \" endif ++\n        if x == deck_width then \"\u2502\\n\" else \"\" endif\n        | y in 0..deck_length, x in 0..deck_width] ++\n        [\"\u2514\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2518\"];\n"}, "hash": "d3d5bfdcc9922a64f5c5ff64440cff69e56cb3728de767b1a4bb2a7049972c0a", "class_name": "RelatedNodeInfo"}}, "text": "name: Vessel Loading Problem\n\ndescription: The Vessel Loading Problem is a classic problem in constraint programming that involves loading a set of containers of different sizes and classes onto a vessel with a fixed deck width and length, subject to certain constraints. The goal is to find an arrangement of containers on the deck that maximizes the use of space while satisfying the constraints.\n\nvariables: \nLeft[c], Right[c], Bottom[c], Top[c] \u2208 {0, ..., deck_width} \u00d7 {0, ..., deck_length}, orientation[c] \u2208 {1, 2}\n\nThese variables represent the position and orientation of each container c on the deck. Left[c] and Right[c] are the leftmost and rightmost points of container c, respectively, while Bottom[c] and Top[c] are the bottommost and topmost points, respectively. The orientation variable determines whether the container is placed horizontally (orientation[c] = 1) or vertically (orientation[c] = 2).\n\nconstraints: \n\u2200c \u2208 Containers, Right[c] = Left[c] + ElemWidth[orientation[c]] \u2227 Top[c] = Bottom[c] + ElemLength[orientation[c]]\n\u2200c, k \u2208 Containers, c < k, Left[c] \u2265 Right[k] + separation[class[c], class[k]] \u2228 ... (three more disjuncts)\n\nThe first constraint ensures that the width and length of each container are correctly calculated based on its orientation. The second constraint ensures that containers of different classes are separated by a minimum distance, specified by the separation matrix.\n\nobjective: \nThere is no explicit objective function in this model. The goal is to find a feasible arrangement of containers that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1579, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4f9fc22c-c7d1-488f-8a71-15b9b7e6f5c5": {"__data__": {"id_": "4f9fc22c-c7d1-488f-8a71-15b9b7e6f5c5", "embedding": null, "metadata": {"model_name": "warehouses", "source_code": "% Warehouse allocation\n\n% vim: ft=zinc ts=2 sw=2 et tw=0\n\n% A company needs to construct warehouses to supply stores with goods.  Each\n% warehouse possibly to be constructed has a certain capacity defining how many\n% stores it can supply.  Constructing a warehouse incurs a fixed cost.  Costs\n% for transportation from warehouses to stores depend on the locations of\n% warehouses and stores.\n%\n% Determine which warehouses should be constructed and which warehouse should\n% supply which store such that overall cost (transportation cost plus\n% construction cost) is smallest.\n%-----------------------------------------------------------------------------\n\ninclude \"globals.mzn\";\n\n%-----------------------------------------------------------------------------\n% Instance\n\nn_suppliers = 5;\nn_stores = 10;\nbuilding_cost = 30;\n\ncapacity = [1,4,2,1,3];\n\ncost_matrix =\n [|20, 24, 11, 25, 30\n  |28, 27, 82, 83, 74\n  |74, 97, 71, 96, 70\n  | 2, 55, 73, 69, 61\n  |46, 96, 59, 83,  4\n  |42, 22, 29, 67, 59\n  | 1,  5, 73, 59, 56\n  |10, 73, 13, 43, 96\n  |93, 35, 63, 85, 46\n  |47, 65, 55, 71, 95|]; \n\n%-----------------------------------------------------------------------------\n% Model\n\nint: n_suppliers;\nint: n_stores;\nint: building_cost;\narray[1..n_suppliers] of int: capacity;\narray[1..n_stores,1..n_suppliers] of int: cost_matrix;\n\nint: MaxCost = max(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]);\nint: MaxTotal =   (n_suppliers * building_cost) \n                + sum(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]); \n\narray[1..n_stores] of var 1..n_suppliers: supplier;\narray[1..n_suppliers] of var bool: open;\narray[1..n_stores] of var 1..MaxCost: cost;\nvar 1..MaxTotal: tot;\n\nconstraint\n  sum (i in 1..n_suppliers) (building_cost * bool2int(open[i])) +\n  sum (i in 1..n_stores) (cost[i])\n  = tot;\n\nconstraint\n  forall (i in 1..n_stores) (\n    cost_matrix[i,supplier[i]] = cost[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    let {\n      var int: use\n     } in\n    count(supplier,i,use) /\\ use <= capacity[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    (exists (j in 1..n_stores) (supplier[j] == i)) == open[i]\n  );\n\nsolve\n  :: int_search(\n    supplier ++ cost ++ [bool2int(open[i]) | i in 1..n_suppliers],\n    first_fail,\n    indomain_split,\n    complete\n  )\n  minimize tot;\n\noutput\n  [ \"warehouses:\" ]\n  ++\n  [ \"\\ntot = \", show(tot) ]\n  ++\n  [ \"\\nsupplier = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(supplier[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\ncost = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(cost[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\nopen = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(open[i]) ++\n    if i = n_suppliers then \"\\n]\\n\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_suppliers\n  ]\n\n%-----------------------------------------------------------------------------\n%-----------------------------------------------------------------------------\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "warehouses_expert", "node_type": "4", "metadata": {"model_name": "warehouses", "source_code": "% Warehouse allocation\n\n% vim: ft=zinc ts=2 sw=2 et tw=0\n\n% A company needs to construct warehouses to supply stores with goods.  Each\n% warehouse possibly to be constructed has a certain capacity defining how many\n% stores it can supply.  Constructing a warehouse incurs a fixed cost.  Costs\n% for transportation from warehouses to stores depend on the locations of\n% warehouses and stores.\n%\n% Determine which warehouses should be constructed and which warehouse should\n% supply which store such that overall cost (transportation cost plus\n% construction cost) is smallest.\n%-----------------------------------------------------------------------------\n\ninclude \"globals.mzn\";\n\n%-----------------------------------------------------------------------------\n% Instance\n\nn_suppliers = 5;\nn_stores = 10;\nbuilding_cost = 30;\n\ncapacity = [1,4,2,1,3];\n\ncost_matrix =\n [|20, 24, 11, 25, 30\n  |28, 27, 82, 83, 74\n  |74, 97, 71, 96, 70\n  | 2, 55, 73, 69, 61\n  |46, 96, 59, 83,  4\n  |42, 22, 29, 67, 59\n  | 1,  5, 73, 59, 56\n  |10, 73, 13, 43, 96\n  |93, 35, 63, 85, 46\n  |47, 65, 55, 71, 95|]; \n\n%-----------------------------------------------------------------------------\n% Model\n\nint: n_suppliers;\nint: n_stores;\nint: building_cost;\narray[1..n_suppliers] of int: capacity;\narray[1..n_stores,1..n_suppliers] of int: cost_matrix;\n\nint: MaxCost = max(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]);\nint: MaxTotal =   (n_suppliers * building_cost) \n                + sum(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]); \n\narray[1..n_stores] of var 1..n_suppliers: supplier;\narray[1..n_suppliers] of var bool: open;\narray[1..n_stores] of var 1..MaxCost: cost;\nvar 1..MaxTotal: tot;\n\nconstraint\n  sum (i in 1..n_suppliers) (building_cost * bool2int(open[i])) +\n  sum (i in 1..n_stores) (cost[i])\n  = tot;\n\nconstraint\n  forall (i in 1..n_stores) (\n    cost_matrix[i,supplier[i]] = cost[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    let {\n      var int: use\n     } in\n    count(supplier,i,use) /\\ use <= capacity[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    (exists (j in 1..n_stores) (supplier[j] == i)) == open[i]\n  );\n\nsolve\n  :: int_search(\n    supplier ++ cost ++ [bool2int(open[i]) | i in 1..n_suppliers],\n    first_fail,\n    indomain_split,\n    complete\n  )\n  minimize tot;\n\noutput\n  [ \"warehouses:\" ]\n  ++\n  [ \"\\ntot = \", show(tot) ]\n  ++\n  [ \"\\nsupplier = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(supplier[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\ncost = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(cost[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\nopen = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(open[i]) ++\n    if i = n_suppliers then \"\\n]\\n\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_suppliers\n  ]\n\n%-----------------------------------------------------------------------------\n%-----------------------------------------------------------------------------\n"}, "hash": "432011d20a3c553170a07aaab0dbe6bb7f6cb10c500f8594b8322f2b1ec55a4c", "class_name": "RelatedNodeInfo"}}, "text": "name: Warehouse Allocation Problem\n\ndescription: The Warehouse Allocation Problem is a classic problem in operations research and logistics. It involves determining the optimal allocation of warehouses to supply stores with goods, while minimizing the overall cost, which includes the construction cost of warehouses and the transportation cost from warehouses to stores.\n\nvariables: \nsupplier[i] \u2208 {1, ..., n_suppliers}, open[i] \u2208 {true, false}, cost[i] \u2208 {1, ..., MaxCost}, tot \u2208 {1, ..., MaxTotal}\n\nThe decision variables are:\n- supplier[i]: the warehouse that supplies store i\n- open[i]: a boolean indicating whether warehouse i is constructed or not\n- cost[i]: the transportation cost from the warehouse that supplies store i to store i\n- tot: the total cost, which is the sum of the construction costs of the warehouses and the transportation costs from the warehouses to the stores\n\nconstraints: \n\u2211(i in 1..n_suppliers) (building_cost * bool2int(open[i])) + \u2211(i in 1..n_stores) (cost[i]) = tot\ncost_matrix[i,supplier[i]] = cost[i]\ncount(supplier,i,use) \u2227 use \u2264 capacity[i]\n(exists (j in 1..n_stores) (supplier[j] == i)) == open[i]\n\nThe constraints are:\n- The total cost is the sum of the construction costs of the warehouses and the transportation costs from the warehouses to the stores\n- The transportation cost from the warehouse that supplies store i to store i is equal to the cost_matrix value at the corresponding row and column\n- The number of stores supplied by warehouse i does not exceed its capacity\n- A warehouse is constructed if and only if it supplies at least one store\n\nobjective: \nminimize tot\n\nThe objective is to minimize the total cost, which is the sum of the construction costs of the warehouses and the transportation costs from the warehouses to the stores.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1790, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dec65d8f-faba-42ea-b8a7-1bd526517378": {"__data__": {"id_": "dec65d8f-faba-42ea-b8a7-1bd526517378", "embedding": null, "metadata": {"model_name": "water_buckets1", "source_code": "Model 1 :\n\n% Water buckets problem in Minizinc\n% \"\"\"\n% Problem description\n% This is a generalization of the CSPLib specification, which is as follows: Given an 8 pint bucket of water, and two empty buckets which can contain 5 and 3 pints respectively, the problem requires to divide the water into two by pouring water between buckets (that is, to end up with 4 pints in the 8 pint bucket, and 4 pints in the 5 pint bucket) in the smallest number of transfers.\n%\n% The generalization consists in making the specification parametric with respect to the start and goal configurations, which are now inputs to the problem.\n%\n% Problem input\n%\n% * Function start, assigning an initial amount of water to each bucket\n% * Function goal, assigning the goal amount of water to each bucket \n%\n% Search space\n% The set of all possibile sequences of configurations (states), where a configuration is a triple encoding the amount of water in each bucket at a given time-step\n%\n% Constraints\n%\n% * C1: At beginning, buckets contain the amount of water specified by function start\n% * C2: At the end, buckets contain the amount of water specified by function goal\n% * C3: The configuration at each step differs from that of the next one in that the amount of water of exactly 2 buckets changes (that in the others remain the same)\n% * C4: The overall amount of water is the same at each time step\n% * C5: After each transition (involving buckets b1 and b2), either the source bucket becomes empty, or the target becomes full\n% \"\"\"\n\n\nint: nb_buckets = 3;\nint: max_step = 10; % 8 for satisfy\nset of int: buckets = 1..nb_buckets;\nset of int: steps = 1..max_step;\narray[buckets] of int: capacity = [8,5,3];\narray[buckets] of int: start = [8,0,0];\narray[buckets] of int: goal = [4,4,0];\n\n% Search space: The set of all possibile sequences of configurations (states), \n% where a configuration is a triple encoding the amount of water in each \n% bucket at a given time-step\narray[steps, buckets] of var int: state;\nvar 1..max_step: goal_step;\n\n% Objective function\nsolve minimize goal_step;\n% solve :: int_search( [ state[i,j] | i in steps, j in buckets ] , \"first_fail\", \"indomain\", \"complete\")  minimize goal_step;\n\nconstraint\n%   goal_step <= 8 % for solve satisfy\n%   /\\\n   % assertions\n   forall(b in buckets) (\n      (start[b] <= capacity[b]) /\\ (goal[b] <= capacity[b])\n   )\n   /\\\n   sum(b in buckets)(start[b]) = sum(b in buckets)(goal[b])\n   /\\\n   forall(s in steps, b in buckets) (\n      state[s,b] >= 0 /\\\n      state[s,b] <= capacity[b]\n   )\n   /\\\n   forall(b in buckets) (\n      % C1: At beginning, buckets contain the amount of water specified by function start\n      state[1,b]=start[b]\n      /\\\n      % C2: At the end, buckets contain the amount of water specified by function goal\n      state[goal_step,b] = goal[b]\n   )\n   /\\\n   forall(step in 1..max_step-1) (\n      % C3: The configuration at each step differs from that of the next one in that the amount of\n      % water of exactly 2 buckets changes (that in the others remain the same)\n      sum(b in buckets)( bool2int(state[step,b] != state[step+1, b])) = 2\n      /\\\n      % C4: The overall amount of water is the same at each time step\n      sum(b in buckets)(state[step,b]) = sum(b in buckets)(state[step+1,b])\n      /\\\n\n      % C5: After each transition (involving buckets b1 and b2), either the source\n      % bucket becomes empty, or the target becomes full\n      forall(b1, b2 in buckets where b1 != b2) (\n         ((state[step, b1] != state[step+1, b1]) /\\ (state[step, b2] != state[step+1, b2])) ->\n            (state[step+1,b1] = 0 \\/ state[step+1,b1] = capacity[b1] \\/\n             state[step+1,b2] = 0 \\/ state[step+1,b2] = capacity[b2])\n     )\n   )\n;\n\n\noutput [\n  if s = 1 /\\ b = 1 then \n    \"goal_step: \" ++ show(goal_step)\n  else \"\" endif ++\n  if b = 1 then \"\\n\" else \" \" endif ++\n  show(state[s, b])\n  | s in steps, b in buckets\n\n] \n++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\n\ninclude \"globals.mzn\";\n\nint: n_states = 15;\nint: input_max = 15;\nint: initial_state = 1;\nset of int: accepting_states = {15};\n\n\n% distance\narray[1..n_states, 1..n_states] of 0..input_max: transition_fn =\narray2d(1..n_states, 1..n_states,\n[%1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n  0, 2, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 1\n  0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 2 \n  0, 0, 0, 4, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 3\n  0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 4\n  0, 0, 0, 0, 0, 6, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 5\n  0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, % 6\n  0, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 0, 0, 0, 0, % 7\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, % 8 \n  0, 0, 0, 0, 0, 0, 0, 0, 0,10, 0, 0, 0, 0, 0, % 9\n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0,11, 0, 0, 0, 0, %10\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,12, 0, 0, 0, %11 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,13, 0, 0, %12\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,14, 0, %13 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %14\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %15\n]);\n\n\narray[1..n_states] of string:  nodes = [\n        \"8,0,0\", % 1 start\n        \"5,0,3\", % 2\n        \"5,3,0\", % 3 \n        \"2,3,3\", % 4 \n        \"2,5,1\", % 5\n        \"7,0,1\", % 6\n        \"7,1,0\", % 7\n        \"4,1,3\", % 8\n        \"3,5,0\", % 9\n        \"3,2,3\", % 10\n        \"6,2,0\", % 11\n        \"6,0,2\", % 12\n        \"1,5,2\", % 13\n        \"1,4,3\", % 14\n        \"4,4,0\"  % 15 goal\n        ];\n\n\narray[1..input_max] of var 0..input_max: x;\nvar 0..input_max: cost;\n\n% solve satisfy;\nsolve minimize cost;\n\nconstraint\nregular(x, n_states, input_max, transition_fn,\n        initial_state, accepting_states)\n;\n\nconstraint\n   cost = 2+sum([bool2int(x[i-1] != x[i] ) | i in 2..input_max])\n;\n\noutput \n[\"cost: \" ++ show(cost) ++ \"\\n\"] ++\n[show(initial_state) ++ \" \"] ++\n[\n  if fix(x[i]) < input_max then show(x[i]) ++ \" \" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(input_max) ++ \"\\n\"] ++ \n[\"\\n\\n\"] ++\n\n[show(nodes[initial_state]) ++ \"\\n\"] ++\n[\n  if fix(x[i]) < input_max then show(nodes[fix(x[i])]) ++ \"\\n\" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(nodes[input_max]) ++ \"\\n\"] ++ \n[\"\\n\"];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "water_buckets1_expert", "node_type": "4", "metadata": {"model_name": "water_buckets1", "source_code": "Model 1 :\n\n% Water buckets problem in Minizinc\n% \"\"\"\n% Problem description\n% This is a generalization of the CSPLib specification, which is as follows: Given an 8 pint bucket of water, and two empty buckets which can contain 5 and 3 pints respectively, the problem requires to divide the water into two by pouring water between buckets (that is, to end up with 4 pints in the 8 pint bucket, and 4 pints in the 5 pint bucket) in the smallest number of transfers.\n%\n% The generalization consists in making the specification parametric with respect to the start and goal configurations, which are now inputs to the problem.\n%\n% Problem input\n%\n% * Function start, assigning an initial amount of water to each bucket\n% * Function goal, assigning the goal amount of water to each bucket \n%\n% Search space\n% The set of all possibile sequences of configurations (states), where a configuration is a triple encoding the amount of water in each bucket at a given time-step\n%\n% Constraints\n%\n% * C1: At beginning, buckets contain the amount of water specified by function start\n% * C2: At the end, buckets contain the amount of water specified by function goal\n% * C3: The configuration at each step differs from that of the next one in that the amount of water of exactly 2 buckets changes (that in the others remain the same)\n% * C4: The overall amount of water is the same at each time step\n% * C5: After each transition (involving buckets b1 and b2), either the source bucket becomes empty, or the target becomes full\n% \"\"\"\n\n\nint: nb_buckets = 3;\nint: max_step = 10; % 8 for satisfy\nset of int: buckets = 1..nb_buckets;\nset of int: steps = 1..max_step;\narray[buckets] of int: capacity = [8,5,3];\narray[buckets] of int: start = [8,0,0];\narray[buckets] of int: goal = [4,4,0];\n\n% Search space: The set of all possibile sequences of configurations (states), \n% where a configuration is a triple encoding the amount of water in each \n% bucket at a given time-step\narray[steps, buckets] of var int: state;\nvar 1..max_step: goal_step;\n\n% Objective function\nsolve minimize goal_step;\n% solve :: int_search( [ state[i,j] | i in steps, j in buckets ] , \"first_fail\", \"indomain\", \"complete\")  minimize goal_step;\n\nconstraint\n%   goal_step <= 8 % for solve satisfy\n%   /\\\n   % assertions\n   forall(b in buckets) (\n      (start[b] <= capacity[b]) /\\ (goal[b] <= capacity[b])\n   )\n   /\\\n   sum(b in buckets)(start[b]) = sum(b in buckets)(goal[b])\n   /\\\n   forall(s in steps, b in buckets) (\n      state[s,b] >= 0 /\\\n      state[s,b] <= capacity[b]\n   )\n   /\\\n   forall(b in buckets) (\n      % C1: At beginning, buckets contain the amount of water specified by function start\n      state[1,b]=start[b]\n      /\\\n      % C2: At the end, buckets contain the amount of water specified by function goal\n      state[goal_step,b] = goal[b]\n   )\n   /\\\n   forall(step in 1..max_step-1) (\n      % C3: The configuration at each step differs from that of the next one in that the amount of\n      % water of exactly 2 buckets changes (that in the others remain the same)\n      sum(b in buckets)( bool2int(state[step,b] != state[step+1, b])) = 2\n      /\\\n      % C4: The overall amount of water is the same at each time step\n      sum(b in buckets)(state[step,b]) = sum(b in buckets)(state[step+1,b])\n      /\\\n\n      % C5: After each transition (involving buckets b1 and b2), either the source\n      % bucket becomes empty, or the target becomes full\n      forall(b1, b2 in buckets where b1 != b2) (\n         ((state[step, b1] != state[step+1, b1]) /\\ (state[step, b2] != state[step+1, b2])) ->\n            (state[step+1,b1] = 0 \\/ state[step+1,b1] = capacity[b1] \\/\n             state[step+1,b2] = 0 \\/ state[step+1,b2] = capacity[b2])\n     )\n   )\n;\n\n\noutput [\n  if s = 1 /\\ b = 1 then \n    \"goal_step: \" ++ show(goal_step)\n  else \"\" endif ++\n  if b = 1 then \"\\n\" else \" \" endif ++\n  show(state[s, b])\n  | s in steps, b in buckets\n\n] \n++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\n\ninclude \"globals.mzn\";\n\nint: n_states = 15;\nint: input_max = 15;\nint: initial_state = 1;\nset of int: accepting_states = {15};\n\n\n% distance\narray[1..n_states, 1..n_states] of 0..input_max: transition_fn =\narray2d(1..n_states, 1..n_states,\n[%1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n  0, 2, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 1\n  0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 2 \n  0, 0, 0, 4, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 3\n  0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 4\n  0, 0, 0, 0, 0, 6, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 5\n  0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, % 6\n  0, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 0, 0, 0, 0, % 7\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, % 8 \n  0, 0, 0, 0, 0, 0, 0, 0, 0,10, 0, 0, 0, 0, 0, % 9\n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0,11, 0, 0, 0, 0, %10\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,12, 0, 0, 0, %11 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,13, 0, 0, %12\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,14, 0, %13 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %14\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %15\n]);\n\n\narray[1..n_states] of string:  nodes = [\n        \"8,0,0\", % 1 start\n        \"5,0,3\", % 2\n        \"5,3,0\", % 3 \n        \"2,3,3\", % 4 \n        \"2,5,1\", % 5\n        \"7,0,1\", % 6\n        \"7,1,0\", % 7\n        \"4,1,3\", % 8\n        \"3,5,0\", % 9\n        \"3,2,3\", % 10\n        \"6,2,0\", % 11\n        \"6,0,2\", % 12\n        \"1,5,2\", % 13\n        \"1,4,3\", % 14\n        \"4,4,0\"  % 15 goal\n        ];\n\n\narray[1..input_max] of var 0..input_max: x;\nvar 0..input_max: cost;\n\n% solve satisfy;\nsolve minimize cost;\n\nconstraint\nregular(x, n_states, input_max, transition_fn,\n        initial_state, accepting_states)\n;\n\nconstraint\n   cost = 2+sum([bool2int(x[i-1] != x[i] ) | i in 2..input_max])\n;\n\noutput \n[\"cost: \" ++ show(cost) ++ \"\\n\"] ++\n[show(initial_state) ++ \" \"] ++\n[\n  if fix(x[i]) < input_max then show(x[i]) ++ \" \" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(input_max) ++ \"\\n\"] ++ \n[\"\\n\\n\"] ++\n\n[show(nodes[initial_state]) ++ \"\\n\"] ++\n[\n  if fix(x[i]) < input_max then show(nodes[fix(x[i])]) ++ \"\\n\" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(nodes[input_max]) ++ \"\\n\"] ++ \n[\"\\n\"];"}, "hash": "27a3247ebf0d977bb8c9560d6db24018b29f42ad77cd769688c8ac73a313fdad", "class_name": "RelatedNodeInfo"}}, "text": "name: Water Buckets Problem\n\ndescription: The Water Buckets Problem is a classic problem in constraint programming. It involves dividing a certain amount of water into two buckets of specific capacities using a series of pouring operations. The goal is to find the minimum number of transfers required to achieve a specific goal configuration of water in the buckets.\n\nvariables: `state[steps, buckets]`, `goal_step`\n\nThe decision variables are `state[steps, buckets]`, which represents the amount of water in each bucket at each time step, and `goal_step`, which represents the minimum number of steps required to reach the goal configuration.\n\nconstraints: \n`start[b] <= capacity[b]`, `goal[b] <= capacity[b]`, \n`sum(b in buckets)(start[b]) = sum(b in buckets)(goal[b])`, \n`state[1,b]=start[b]`, `state[goal_step,b] = goal[b]`, \n`sum(b in buckets)(bool2int(state[step,b] != state[step+1, b])) = 2`, \n`sum(b in buckets)(state[step,b]) = sum(b in buckets)(state[step+1,b])`, \n`((state[step, b1] != state[step+1, b1]) /\\ (state[step, b2] != state[step, b2])) -> (state[step+1,b1] = 0 \\/ state[step+1,b1] = capacity[b1] \\/ state[step+1,b2] = 0 \\/ state[step+1,b2] = capacity[b2])`\n\nThe constraints ensure that the initial and goal configurations are within the capacity of the buckets, the total amount of water is conserved, the initial and goal configurations are reached, exactly two buckets change in each step, the total amount of water is conserved in each step, and the pouring operation is valid (i.e., the source bucket becomes empty or the target bucket becomes full).\n\nobjective: `minimize goal_step`\n\nThe objective is to minimize the number of steps required to reach the goal configuration.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1701, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"all_interval_expert": {"node_ids": ["3c48f97a-16cf-46fb-9778-777c1713b1c8"], "metadata": {"model_name": "all_interval", "source_code": "Model 1 : \n\n\n%\n% All interval problem in MiniZinc\n%\n% \"\"\"\n% Given the twelve standard pitch-classes (c, c%, d, ...), represented by\n% numbers 0,1,...,11, find a series in which each pitch-class occurs exactly\n% once and in which the musical intervals between neighbouring notes cover\n% the full set of intervals from the minor second (1 semitone) to the major\n% seventh (11 semitones). That is, for each of the intervals, there is a\n% pair of neigbhouring pitch-classes in the series, between which this\n% interval appears. The problem of finding such a series can be easily\n% formulated as an instance of a more general arithmetic problem on Z_n,\n% the set of integer residues modulo n. Given n in N, find a vector\n% s = (s_1, ..., s_n), such that (i) s is a permutation of\n% Z_n = {0,1,...,n-1}; and (ii) the interval vector\n% v = (|s_2-s_1|, |s_3-s_2|, ... |s_n-s_{n-1}|) is a permutation of\n% Z_n-{0} = {1,2,...,n-1}. A vector v satisfying these conditions is\n% called an all-interval series of size n; the problem of finding such\n% a series is the all-interval series problem of size n. We may also be\n% interested in finding all possible series of a given size.\n\ninclude \"globals.mzn\";\n\nint: n = 12;\n% array[1..n] of var 1..n: x;\narray[1..n] of var 1..n: x;\narray[1..n-1] of var 1..n-1: diffs;\nint: sum_distinct = ((n+1)*n) div 2;\n\n% max_regret seems to be quite good....\nsolve :: int_search(x, max_regret, indomain_split, complete) satisfy;\n\nconstraint      \n  all_different(diffs) :: domain\n  /\\  \n  all_different(x) :: domain\n  /\\ \n  forall(k in 1..n-1) (\n      diffs[k] = abs(x[k+1] - x[k])\n  )\n  /\\ % symmetry breaking\n  x[1] < x[n-1]\n  /\\\n  diffs[1] < diffs[2]\n;\n\n\noutput [\n       show(x) ++ \",\" % , \" \", show(sum_distinct), \" diffs: \", show(diffs)\n]\n\n\nModel 2 : \n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n%    all_different(series) /\\\n\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i != j)  (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n;\n\noutput\n[  show(series)\n];\n\n\nModel 3 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   %  C1: Each pitch class occurs exactly once\n   forall(i, j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i!=j) (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput\n[ show(series)\n];\n\n\nModel 4 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[differ] of var differ: differences;\n\nsolve satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 1..n-2) (\n       differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in differ where i != j) (\n       differences[i] != differences[j]\n   )\n;\n\noutput [\n  show(series)\n];\n\n\nModel 5 : \n\n\ninclude \"globals.mzn\";\n\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_median, complete) satisfy;\n\nconstraint\n  % C1: Each pitch class occurs exactly once\n  % GCAD: Exploitation of alldifferent() global constraint\n  all_different(series)\n  /\\\n\n  % C2: Differences between neighbouring notes are all different\n  % GCAD: Exploitation of alldifferent() global constraint\n  % alldifferent(all (i in classes: i <> n-1) abs(series[i+1] - series[i]));\n  all_different( \n         [ abs(series[i+1] - series[i]) | i in classes where i != n-1]\n  )\n  \n;\n\noutput [\n  show(series)\n];\n\n\nModel 6 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\n% solve satisfy;\nsolve :: int_search(series, occurrence, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n      differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in 0..n-2 where i != j) (\n      differences[i] != differences[j]\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\noutput [\n  show(series)\n];\n\n\nModel 7 : \n\n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\nsolve ::int_search(series, first_fail, indomain_max, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(series)\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n          differences[i] = abs(series[i+1] - series[i])\n   )\n   /\\\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(differences)\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput [\n   \"series: \" ++ show(series) ++ \"\\n\" ++\n   \"differences: \" ++ show(differences) \n];"}}, "assign_expert": {"node_ids": ["e3490413-2df2-4bea-ae16-9c49a0955d39"], "metadata": {"model_name": "assign", "source_code": "Model 1 :\n\nint: n;\nset of int: WORK = 1..n;\nint: m;\nset of int: TASK = 1..m;\narray[WORK,TASK] of int: profit;\narray[WORK] of var TASK: x;\n% new\narray[WORK] of var int: px =\n     [ profit[w,x[w]] | w in WORK ];\nvar int: obj = sum(w in WORK)(px[w]);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\n\nann: varselect;\nann: valselect;\n\nsolve :: int_search(px, varselect, valselect, complete)\n      maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x);\\n\"];\n\n\nvarselect = largest;\nvalselect = indomain_min;\n\n\nModel 2 : \n\n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[DOM] of var COD: task;\narray[COD] of var DOM: worker;\n\ninclude \"inverse.mzn\";\nconstraint inverse(task,worker);\n\n\nsolve maximize sum(w in COD)\n            (profit[w,task[w]]);\n\noutput [show(task)];\n\n\n\nModel 3 : \n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[COD] of var DOM: worker;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(worker);\n\n\nsolve maximize sum(t in COD)\n            (profit[worker[t],t]);\n\noutput [show(worker)];\n"}}, "aust_color_expert": {"node_ids": ["ff70edfc-d9dc-47d0-acf7-03831450871f"], "metadata": {"model_name": "aust_color", "source_code": "Model 1 :\n\n% Colouring Australia using 4 colors \nint: nc = 4;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n\n\n Model 2 :\n\n % Colouring Australia using nc colors \nint: nc;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n"}}, "bibd_expert": {"node_ids": ["b85d2124-b231-4b75-b593-2a2aa834a0d6"], "metadata": {"model_name": "bibd", "source_code": "% bibd.mzn\n% vim: ft=zinc ts=4 sw=4 et tw=0\n% Ralph Becket <rafe@csse.unimelb.edu.au>\n% Tue Oct 23 11:28:06 EST 2007\n%\n% Balanced incomplete block designs.  See the following:\n% http://mathworld.wolfram.com/BlockDesign.html\n% http://www.dcs.st-and.ac.uk/~ianm/CSPLib/prob/prob028/spec.html\n%\n%\n%\n% A BIBD (v, b, r, k, lambda) problem is to find a binary matrix of v rows\n% of b columns such that each row sums to r, each column sums to k, and\n% the dot product beween any pair of distinct rows is lambda.\n\ninclude \"lex_lesseq.mzn\";\n\nint: v;\nint: k;\nint: lambda;\n\nint: b = (lambda * v * (v - 1)) div (k * (k - 1));\nint: r = (lambda * (v - 1)) div (k - 1);\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\narray [rows, cols] of var bool: m;\n\n    % Every row must sum to r.\n    %\nconstraint forall (i in rows) (sum (j in cols) (bool2int(m[i, j])) = r);\n\n    % Every column must sum to k.\n    %\nconstraint forall (j in cols) (sum (i in rows) (bool2int(m[i, j])) = k);\n\n    % The dot product of every pair of distinct rows must be lambda.\n    %\nconstraint\n    forall (i_a, i_b in rows where i_a < i_b) (\n        sum (j in cols) (bool2int(m[i_a, j] /\\ m[i_b, j])) = lambda\n    );\n\n    % Break row symmetry in the incidence matrix.\n    %\nconstraint forall(i in rows diff {max(rows)})(\n        lex_lesseq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    );\n\n    % Break column symmetry in the incidence matrix.\n    %\nconstraint forall(j in cols diff {max(cols)})(\n        lex_lesseq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    );\n\nsolve :: bool_search([m[i, j] | i in rows, j in cols],\n    input_order, indomain_min, complete)\n    satisfy;\n\noutput  [\"bibd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r),\n        \", k = \", show(k), \", lambda = \", show(lambda), \")\\n\\n\"] ++\n        [ ( if j > b then \"\\n\" else show(bool2int(m[i, j])) endif )\n        | i in rows, j in 1..(b + 1)\n        ];\n\n%----------------------------------------------------------------------------%\n%----------------------------------------------------------------------------%\n"}}, "bus_scheduling_csplib_expert": {"node_ids": ["c44065c7-ef5d-479e-9438-7123e75ca229"], "metadata": {"model_name": "bus_scheduling_csplib", "source_code": "%\n% Bus driver scheduling problem (prob022 in CSPLib) in MiniZinc.\n%\n% Specification\n% Bus driver scheduling can be formulated as a set paritioning problem.\n% We propose 12 set partitioning problems derived from small bus driver\n% scheduling problems. These consist of a given set of tasks (pieces of\n% work) to cover and a large set of possible shifts, where each shift\n% covers a subset of the tasks and has an associated cost. We must select\n% a subset of possible shifts that covers each piece of work once and\n% only once: this is called a partition. Further,\n%\n% In the driver scheduling (unlike air crew scheduling) the main aim is\n% to reduce the number of shifts used in the solution partition and the\n% total cost of the partition is secondary. To simplify the problem we have\n% made the cost of each shift the same. This means that the goal is to\n% minimise the number of shifts.\n%\n% The problems come from four different bus companies:\n% Reading (r1 to r5a),\n% CentreWest Ealing area (c1, c1a, c2),\n% the former London Transport (t1 and t2).\n%\n% The problems have differing regulations and features (e.g. urban and\n% short distance rural bus schedules can have very different features). Note\n% that r1 and r1a are the same problem, but have different numbers of\n% generated shifts. Similarly with the problems: c1, c1a and r5, r5a.\n%\n% Problems are presented in the same format as the set partitioning\n% examples in ORLIB. The first line gives the number of rows (pieces of work),\n% columns (shifts) and the minimum number of columns need for a partition.\n% Then each line after that corresponds to one column. It starts with\n% the cost (which is always 1 in our case) then the number of rows it\n% covers, followed by the rows it covers.\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \nint: num_work;\nint: num_shifts;\nint: min_num_shifts;\narray[1..num_shifts] of set of int: shifts;\n\narray[1..num_shifts] of var 0..1: x;\nvar 0..num_shifts: tot_shifts;\n\n% solve minimize tot_shifts;\nsolve :: int_search(\n        x ++ [tot_shifts], \n        first_fail, \n        indomain_min, \n        complete) \n    minimize tot_shifts;\n    % satisfy;\n\nconstraint\n   tot_shifts = sum(x)\n   /\\\n   forall(j in 0..num_work-1) (\n       sum(i in 1..num_shifts) (x[i]*bool2int(j in shifts[i])) = 1\n   )\n   /\\\n   tot_shifts >= min_num_shifts\n\n   % /\\ % for solve satisfy (t1)\n   % tot_shifts = 7\n;\n\n\noutput [\n  \"tot_shifts: \" ++ show(tot_shifts) ++ \"\\n\" ++ \n  \"x: \" ++ show(x) ++ \"\\n\"\n] ++ \n[\n  if fix(x[i]) = 1 then show(shifts[i]) else \"\" endif\n  | i in 1..num_shifts\n] ++ \n[\"\\n\"] ++\n[\n  if fix(x[i]) = 1 then show(i) ++ \" \" else \"\" endif\n  | i in 1..num_shifts\n] ++ [\"\\n\"];\n"}}, "car_expert": {"node_ids": ["bd94337e-fefc-46a9-9a33-7f05a37f2ae3"], "metadata": {"model_name": "car", "source_code": "%\n% Car sequencing in MiniZinc.\n% include \"globals.mzn\";\n\nint: numclasses;\nint: numoptions;\nint: numcars;\nset of int: Classes = 1..numclasses;\nset of int: Options = 1..numoptions;\nset of int: Slots = 1..numcars;\n\narray[Classes] of int: numberPerClass;\n\narray[Classes,Options] of int: optionsRequired;\narray[Options] of int: windowSize;\narray[Options] of int: optMax;\n\narray[Options] of int: optionNumberPerClass = [sum(j in Classes) (numberPerClass[j] * optionsRequired[j,i]) | i in Options];\n\n% decision variables\n\narray[Slots] of var Classes: slot;\narray[Options, Slots] of var 0..1: setup;\n\n\nvar int: z = sum(s in Classes) (s*slot[s]);\n\n% solve minimize z;\nsolve :: int_search(slot, input_order, indomain_min, complete)\n  satisfy;\n\nconstraint\n  forall(c in Classes ) (\n    sum(s in Slots ) (bool2int(slot[s] = c)) = numberPerClass[c]\n  )\n  /\\\n  forall(o in Options, s in 1..numcars - windowSize[o] + 1) (\n    sum(j in s..s + windowSize[o]- 1) (setup[o,j]) <= optMax[o]\n  )\n  /\\\n  forall(o in Options, s in Slots ) (\n    setup[o,s] = optionsRequired[slot[s],o]\n  )\n  /\\\n  forall(o in Options, i in 1..optionNumberPerClass[o]) (\n    sum(s in 1..(numcars - i * windowSize[o])) (setup[o,s]) >=\n           (optionNumberPerClass[o] - i * optMax[o])\n  )\n;\n\n% for solve satisfy\n% constraint z = 82;\n\n\noutput [\n \"z: \" ++ show(z) ++ \"\\n\" ++\n \"slot: \" ++ show(slot) ++ \"\\n\"\n] ++\n[\n  if j = 1 then \"\\n\" else \" \" endif ++ \n    show(setup[i,j])\n  | i in Options, j in Slots\n];\n"}}, "carpet_cutting_expert": {"node_ids": ["252f0455-165a-45da-a421-027460f998a0"], "metadata": {"model_name": "carpet_cutting", "source_code": "Model 1 :\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\narray[ROOM] of var ROT: rot;\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)(shape[i,rot[i]] != {});\n\nconstraint forall(i in ROOM)(forall(r in ROFF)\n  (r in shape[i,rot[i]] -> \n  (x[i] + d[r,1] + d[r,3] <= l /\\\n   y[i] + d[r,2] + d[r,4] <= h)));\n\nconstraint forall(i,j in ROOM where i < j)\n  (forall(r1,r2 in ROFF)\n (r1 in shape[i,rot[i]] /\\ \n  r2 in shape[j,rot[j]] -> \n(x[i] + d[r1,1] + d[r1,3] <= x[j] + d[r2,1]\n                   \\/\n x[j] + d[r2,1] + d[r2,3] <= x[i] + d[r1,1]\n                   \\/\n y[i] + d[r1,2] + d[r1,4] <= y[j] + d[r2,2]\n                   \\/\ny[j] + d[r2,2] + d[r2,4] <= y[i] + d[r1,2])\n   ));\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nrot = \\(rot);\\n\"];\n\n\n\nModel 2 :\n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: DIM = 1..2;\narray[ROFF,DIM] of int: rect_size = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 3..4]);\narray[ROFF,DIM] of int: rect_offset = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 1..2]);\narray[int] of set of ROFF: shapes = [ {1,3,4}, {2,5,6}, {1}, {7} ];\nset of int: SHAPE = index_set(shapes);\n%array[int] of set of RECT: s = sort([shapes[i,j] | i in 1..n, j in 1..4]);\n\narray[ROOM] of var SHAPE: kind;\narray[ROOM,DIM] of var int: coords =\n      array2d(ROOM,DIM, [ if j = 1 then x[i] else y[i] endif\n                         | i in ROOM, j in 1..2 ]);\n\n\n\ninclude \"geost.mzn\";\n\nconstraint geost_bb(2,\n                    rect_size,\n                    rect_offset,\n                    shapes,\n                    coords,\n                    kind,\n                    [0,0],\n                    [l,h]);\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)\n                 (exists(r in ROT where shape[i,r] != {})\n                        (shapes[kind[i]] = shape[i,r]));\n\n\noutput [\"rect_size = \\(rect_size);\\nrect_offset = \\(rect_offset);\\n\"] ++\n       [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];\n\n\n\nModel 3 : \n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: SHAPE = 1..4;\narray[ROOM] of var SHAPE: kind;\n\nconstraint geost_bb(2,\n       [| 3,4 | 4,3 | 1,1 | 1,2 | 1,1 | 2,1 | 4,3 |],\n       [| 0,0 | 0,1 | 1,4 | 3,1 | 4,2 | 1,0 | 0,0 |],\n       [ {1,3,4}, {2,5,6}, {1}, {7} ],\n       [| x[1], y[1] | x[2],y[2] | x[3],y[3] |],\n       kind,\n       [ 0,0 ],\n       [ l, h]);\n\nconstraint kind[1] in {1,2};\nconstraint kind[2] in {1,2};\nconstraint kind[3] in {3,4}; \ninclude \"geost.mzn\";\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];"}}, "cell_block_expert": {"node_ids": ["c42a6330-50e8-4df1-9f48-fcb20fc536a0"], "metadata": {"model_name": "cell_block", "source_code": "Model 1 :\n\n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\n%constraint forall(p1, p2 in PRISONER where p1 < p2)\n%                 (abs(r[p1] - r[p2]) + abs(c[p1] - c[p2]) > 0); \ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nconstraint forall(p in PRISONER, d in danger where p != d)\n                 ( abs(r[p] - r[d]) + abs(c[p] - c[d]) > 1 );\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n\n\n\nModel 2 : \n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nfunction var int: \n     manhattan(var int:x1, var int:y1,\n               var int:x2, var int:y2) =\n     abs(x2 - x1) + abs(y2 - y1);\n\nconstraint forall(p in PRISONER, d in danger where p != d) \n                 (manhattan(r[p],c[p],r[d],c[d]) > 1);\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n"}}, "clique_expert": {"node_ids": ["6758bed3-eefd-4c94-a8af-b1dde5398644"], "metadata": {"model_name": "clique", "source_code": "% Maximum Clique Problem\n\nint: n = 5;\narray[1..n, 1..n] of int: adj =\n    [| 0, 1, 0, 1, 0\n     | 1, 0, 1, 0, 0\n     | 0, 1, 0, 1, 1\n     | 1, 0, 1, 0, 1\n     | 0, 0, 1, 1, 0 |];\n\n% --- naive model ---\n\n% decision variables: which vertices are in the clique?\narray[1..n] of var bool: c;\nvar int: size;\n\n% how many vertices have we selected?\nconstraint size = sum(c);\n\n% we can only pick one of any non-adjacent pair of vertices\nconstraint forall (i, j in 1..n where i < j /\\ 0 == adj[i,j]) (bool2int(c[i]) + bool2int(c[j]) <= 1);\n\nsolve maximize size;\n\n"}}, "cluster_expert": {"node_ids": ["0db0e6a7-89b3-47f6-8deb-848745bf9e4c"], "metadata": {"model_name": "cluster", "source_code": "int: n; % points to be clustered\nset of int: POINT = 1..n;\narray[POINT,POINT] of int: dist; % distance between two points\nint: maxdist = max([ dist[i,j] | i,j in POINT]);\n\n\nint: k; % number of clusters\nset of int: CLUSTER = 1..k;\n\nint: maxdiam;\n\narray[POINT] of var CLUSTER: x;\n\nconstraint forall(i,j in POINT where i < j /\\ x[i] = x[j])\n                 (dist[i,j] <= maxdiam);\n\nconstraint forall(i in 1..k-1)\n                 (  min([ j | j in POINT where x[j] = i])\n                  < min([ j | j in POINT where x[j] = i+1]));\n\nvar 0..maxdist: obj = min( i,j in POINT where i < j )\n                         ( dist[i,j] + maxdist * (x[i] != x[j]) );\n\ninclude \"value_precede_chain.mzn\";\nconstraint value_precede_chain([ i | i in 1..k ],x);\n\nsolve maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x)\\n\"];\n"}}, "compatible_assignment_expert": {"node_ids": ["53a3c95f-b618-4174-8956-8ed6c14ea2f9"], "metadata": {"model_name": "compatible_assignment", "source_code": "Model 1 :\n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(task);\nconstraint forall(w1, w2 in W)\n                 (task[w1] != m /\\ task[w2] = task[w1] + 1 ->\n                   compatible[w1,w2]);\n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ \"task = \\(task)\\n\" ] ;\n\n\nModel 2 : \n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\narray[T] of var opt W: worker;\n\nconstraint inverse(task,worker);\nconstraint forall(t in T where t mod m != 0)\n                 (compatible[worker[t],worker[t+1]]);\n           \n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ if fix(occurs(worker[t])) then show(worker[t]) else \" \" endif ++ \" \"\n       | t in T ] \n       ++ [ show(task), \"\\n\" ]\n       ;\n\npredicate inverse(array[int] of var opt int: f, array[int] of var opt int: g) = \n          forall(i in index_set(f), j in index_set(g))\n                (occurs(f[i]) /\\ occurs(g[j]) ->\n                 (deopt(f[i]) = j <-> deopt(g[j]) = i)); \n"}}, "constrained_connected_expert": {"node_ids": ["2c173bcc-99e8-4b1e-9bc5-c13286194d4f"], "metadata": {"model_name": "constrained_connected", "source_code": "% constrained clustering \n% Pick a maximal subset of edges so that no two nodes\n% given by the pairs (first[i],second[i]) \n% are connected.\n\nint: n;\nset of int: NODE = 1..n;\nint: m;\nset of int: EDGE = 1..m;\narray[EDGE] of NODE: pre;\narray[EDGE] of NODE: suc;\nint: d;\nset of int: DPAIR = 1..d;\narray[DPAIR] of NODE: first;\narray[DPAIR] of NODE: second;\n\nvar set of EDGE: selected;\n% a representative for each cluster\narray[NODE] of var NODE: rep;\n\n%constraint forall(e in selected)\n%                 (rep[pre[e]] = rep[suc[e]]);\nconstraint forall(e in EDGE)\n                 (e in selected -> rep[pre[e]] = rep[suc[e]]);\n\nconstraint forall(d in DPAIR)\n                 (rep[first[d]] != rep[second[d]]);\n\nsolve maximize card(selected);\n\noutput [ \"(\" ++ show(pre[e]) ++ \",\" ++ show(suc[e]) ++ \")\\n\"\n       | e in fix(selected) ]\n       ++ [show(rep),\"\\n\"]\n       ;\n\n\n\n                 \n"}}, "crazy_sets_expert": {"node_ids": ["199261a2-7322-4010-80d0-1eb08304cc79"], "metadata": {"model_name": "crazy_sets", "source_code": "Model 1 :\n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m] of var set of NUMBER: s;\n\nconstraint forall(i,j,k in 1..m where i < j /\\ j < k)\n     ( s[i] intersect s[j] intersect s[k] = {} );\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\nconstraint forall(i in 1..m, o in NUMBER)\n      (o in s[i] \n       -> exists(j in 1..c)(x[i,j] = o));\nconstraint forall(i in 1..m, j in 1..c)(x[i,j] in s[i]);\n\nsolve satisfy;\n\noutput [show(s)];\n\nn = 10;\nc = 4;\nm = 4;\n\n\n\nModel 2 : \n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint global_cardinality_low_up( [ x[i,j] | i in 1..m, j in 1..c ],\n                              [ i | i in 1..n ],\n                              [ 0 | i in 1..n ],\n                              [ 2 | i in 1..n ]);\n\n\nsolve satisfy;\n\n   output [ if j = 1 then \"{\" else \"\" endif ++\n   show(x[i,j])\n   ++ if j = c then \"}\" else \", \" endif\n   ++ if j = c /\\ i < m then \", \" else \"\" endif\n   | i in 1..m, j in 1..c ];\n   \n\nn = 10;\nc = 4;\nm = 4;\n"}}, "crossfigure_expert": {"node_ids": ["b767ffc8-a765-4afe-9cd9-dff54c5ff537"], "metadata": {"model_name": "crossfigure", "source_code": "% Crossfigure problem in MiniZinc.\n% \"\"\"\n% Crossfigures are the numerical equivalent of crosswords. You have a grid and some\n% clues with numerical answers to place on this grid. Clues come in several different\n% forms (for example: Across 1. 25 across times two, 2. five dozen, 5. a square number,\n% 10. prime, 14. 29 across times 21 down ...).\n% \"\"\"\n\n\nint: n = 9;\narray[1..n, 1..n] of var 0..9: M;\n\nset of int: D = 0..9999; % the max length of the numbers in this problem is 4\nvar D: A1;\nvar D: A4;\nvar D: A7;\nvar D: A8;\nvar D: A9;\nvar D: A10;\nvar D: A11;\nvar D: A13;\nvar D: A15;\nvar D: A17;\nvar D: A20;\nvar D: A23;\nvar D: A24;\nvar D: A25;\nvar D: A27;\nvar D: A28;\nvar D: A29;\nvar D: A30;\n\nvar D: D1;\nvar D: D2;\nvar D: D3;\nvar D: D4;\nvar D: D5;\nvar D: D6;\nvar D: D10;\nvar D: D12;\nvar D: D14;\nvar D: D16;\nvar D: D17;\nvar D: D18;\nvar D: D19;\nvar D: D20;\nvar D: D21;\nvar D: D22;\nvar D: D26;\nvar D: D28;\n\n\n%\n% across(Matrix, Across, Len, Row, Col)\n%\tConstrains 'Across' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding across.\n%\npredicate across(array[int, int] of var D: Matrix, var D: Across, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Across)\n   /\\\n   forall(i in 0..Len-1) (\n\n       Matrix[Row,Col+i] = tmp[i+1]\n   )\n;\n\n%\n% down(Matrix, Down, Len, Row, Col):\n%\tConstrains 'Down' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding down.\n%\npredicate down(array[int,int] of var D: Matrix, var D: Down, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Down)\n   /\\\n   forall(i in 0..Len-1) (\n      Matrix[Row+i,Col] = tmp[i+1]\n   )\n;\n\n\n%\n% converts a number <-> array\n%\npredicate toNum10(array[int] of var D: a, var D: n) =\n          let { int: len = length(a) }\n          in\n          n = sum(i in 1..len) (\n            ceil(pow(10.0, int2float(len-i))) * a[i]\n          )\n          /\\ forall(i in 1..len) (a[i] >= 0)\n;\n\n\n%\n% x is a square\n% \npredicate square(var D: x) =\n   exists(y in D) (\n      y*y = x\n   )\n;\n\n\n%\n% very simple primality test\n%\npredicate is_prime(var int: x) =\n   forall(i in 2..ceil(sqrt(9999.0))) ( \n        (i < x) -> (x mod i > 0)\n   )\n;\n\n\nsolve :: int_search(\n         [M[i,j] | i,j in 1..n] ++\n         [A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n         D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28],\n         occurrence,\n         indomain_min,\n         complete\n         ) \n     satisfy;\n\n\nconstraint\n\n   % Set up the constraints between the matrix elements and the\n   % clue numbers.\n   across(M, A1, 4, 1, 1)  /\\ \n   across(M, A4, 4, 1, 6)  /\\ \n   across(M, A7, 2, 2, 1)  /\\ \n   across(M, A8, 3, 2, 4)  /\\ \n   across(M, A9, 2, 2, 8)  /\\ \n   across(M, A10, 2, 3, 3) /\\ \n   across(M, A11, 2, 3, 6) /\\ \n   across(M, A13, 4, 4, 1) /\\ \n   across(M, A15, 4, 4, 6) /\\ \n   across(M, A17, 4, 6, 1) /\\ \n   across(M, A20, 4, 6, 6) /\\ \n   across(M, A23, 2, 7, 3) /\\ \n   across(M, A24, 2, 7, 6) /\\ \n   across(M, A25, 2, 8, 1) /\\ \n   across(M, A27, 3, 8, 4) /\\ \n   across(M, A28, 2, 8, 8) /\\ \n   across(M, A29, 4, 9, 1) /\\ \n   across(M, A30, 4, 9, 6) /\\ \n\n   down(M, D1, 4, 1, 1)  /\\ \n   down(M, D2, 2, 1, 2)  /\\ \n   down(M, D3, 4, 1, 4)  /\\ \n   down(M, D4, 4, 1, 6)  /\\ \n   down(M, D5, 2, 1, 8)  /\\ \n   down(M, D6, 4, 1, 9)  /\\ \n   down(M, D10, 2, 3, 3) /\\ \n   down(M, D12, 2, 3, 7) /\\ \n   down(M, D14, 3, 4, 2) /\\ \n   down(M, D16, 3, 4, 8) /\\ \n   down(M, D17, 4, 6, 1) /\\ \n   down(M, D18, 2, 6, 3) /\\ \n   down(M, D19, 4, 6, 4) /\\ \n   down(M, D20, 4, 6, 6) /\\ \n   down(M, D21, 2, 6, 7) /\\ \n   down(M, D22, 4, 6, 9) /\\ \n   down(M, D26, 2, 8, 2) /\\ \n   down(M, D28, 2, 8, 8) /\\ \n\n\n   % Set up the clue constraints.\n%  Across\n%  1 27 across times two\n%  4 4 down plus seventy-one\n%  7 18 down plus four\n%  8 6 down divided by sixteen\n%  9 2 down minus eighteen\n% 10 Dozen in six gross\n% 11 5 down minus seventy\n% 13 26 down times 23 across\n% 15 6 down minus 350\n% 17 25 across times 23 across\n% 20 A square number\n% 23 A prime number\n% 24 A square number\n% 25 20 across divided by seventeen\n% 27 6 down divided by four\n% 28 Four dozen\n% 29 Seven gross\n% 30 22 down plus 450 \n\n   A1 = 2 * A27         /\\ \n   A4 = D4 + 71         /\\ \n   A7 = D18 + 4         /\\ \n   A8 = D6 div 16       /\\ \n   A9 = D2 - 18         /\\ \n   A10 = 6 * 144 div 12 /\\ \n   A11 = D5 - 70        /\\ \n   A13 = D26 * A23      /\\ \n   A15 = D6 - 350       /\\ \n   A17 = A25 * A23      /\\ \n   square(A20)          /\\ \n   is_prime(A23)        /\\\n   square(A24)          /\\ \n   A25 = A20 div 17     /\\ \n   A27 = D6 div 4       /\\ \n   A28 = 4 * 12         /\\ \n   A29 = 7 * 144        /\\ \n   A30 = D22 + 450      /\\ \n\n   % Down\n   %\n   %  1 1 across plus twenty-seven\n   %  2 Five dozen\n   %  3 30 across plus 888\n   %  4 Two times 17 across\n   %  5 29 across divided by twelve\n   %  6 28 across times 23 across\n   % 10 10 across plus four\n   % 12 Three times 24 across\n   % 14 13 across divided by sixteen\n   % 16 28 down times fifteen\n   % 17 13 across minus 399\n   % 18 29 across divided by eighteen\n   % 19 22 down minus ninety-four\n   % 20 20 across minus nine\n   % 21 25 across minus fifty-two\n   % 22 20 down times six\n   % 26 Five times 24 across\n   % 28 21 down plus twenty-seven \n\n   D1 = A1 + 27     /\\ \n   D2 = 5 * 12      /\\ \n   D3 = A30 + 888   /\\ \n   D4 = 2 * A17     /\\ \n   D5 = A29 div 12  /\\ \n   D6 = A28 * A23   /\\ \n   D10 = A10 + 4    /\\ \n   D12 = A24 * 3    /\\ \n   D14 = A13 div 16 /\\ \n   D16 = 15 * D28   /\\ \n   D17 = A13 - 399  /\\ \n   D18 = A29 div 18 /\\ \n   D19 = D22 - 94   /\\ \n   D20 = A20 - 9    /\\ \n   D21 = A25 - 52   /\\ \n   D22 = 6 * D20    /\\ \n   D26 = 5 * A24    /\\ \n   D28 = D21 + 27\n\n\n   % Fix the blackboxes\n   /\\\n   M[1,5] = 0 /\\\n   M[2,3] = 0 /\\\n   M[2,7] = 0 /\\\n   M[3,2] = 0 /\\\n   M[3,5] = 0 /\\\n   M[3,8] = 0 /\\\n   M[4,5] = 0 /\\\n   M[5,1] = 0 /\\\n   M[5,3] = 0 /\\\n   M[5,4] = 0 /\\\n   M[5,5] = 0 /\\\n   M[5,6] = 0 /\\\n   M[5,7] = 0 /\\\n   M[5,9] = 0 /\\\n   M[6,5] = 0 /\\\n   M[7,2] = 0 /\\\n   M[7,5] = 0 /\\\n   M[7,8] = 0 /\\\n   M[8,3] = 0 /\\\n   M[8,7] = 0 /\\\n   M[9,5] = 0\n;\n\n\noutput [\n show([A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n       D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28]), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(M[i,j])\n  | i,j  in 1..n\n] ++ [\"\\n\"];"}}, "curriculum_expert": {"node_ids": ["d6583452-c1ae-47bb-8007-d69624a5ac5a"], "metadata": {"model_name": "curriculum", "source_code": "% The balanced academic curriculum problem:\n%\n% A curriculum is a set of courses with prerequisites.\n% Each course must be assigned within a set number of periods.\n% A course cannot be scheduled before its prerequisites.\n% Each course confers a number of academic credits (it's \"load\").\n% Students have lower and upper bounds on the number of credits they can study for in a given period.\n% Students have lower and upper bounds on the number of courses they can study for in a given period.\n% The goal is to assign a period to every course satisfying these criteria, minimising the load for all periods.\n\ninclude \"globals.mzn\";\n\nint: n_courses;\nint: n_periods;\nint: load_per_period_lb;\nint: load_per_period_ub;\nint: courses_per_period_lb;\nint: courses_per_period_ub;\narray [1..n_courses] of int: course_load;\nint: max_course_load = sum(c in courses)(course_load[c]);\n\nset of int: courses = 1..n_courses;\nset of int: periods = 1..n_periods;\n\n% period course is assigned to\narray [courses] of var periods: course_period;\n% whether period i has course j assigned\narray [periods, courses] of var 0..1: x;\n% total load for each period\narray [periods] of var load_per_period_lb..load_per_period_ub: load;\n% optimisation target\nvar load_per_period_lb..load_per_period_ub: objective;\n\nconstraint forall(p in periods) (\n    forall(c in courses) (x[p,c] = bool2int(course_period[c] = p)) /\\\n    sum(i in courses) (x[p,i]) >= courses_per_period_lb /\\\n    sum(i in courses) (x[p,i]) <= courses_per_period_ub /\\\n    load[p] = sum(c in courses) (x[p,c] * course_load[c]) /\\\n    load[p] >= load_per_period_lb /\\\n    load[p] <= objective\n);\n\n% prerequisite(a, b) means \"course a has prerequisite course b\".\n\npredicate prerequisite(courses: a, courses: b) =\n    course_period[b] < course_period[a];\n\n% add some redundant linear constraints\n\nconstraint forall(p in 0..n_periods-1) (\n    let {\n\t\tvar 0..max_course_load: l = sum(c in courses) (bool2int(course_period[c] > p) * course_load[c])\n\t} in \n        l >= (n_periods-p) * load_per_period_lb /\\\n        l <= (n_periods-p) * objective\n    );\n\nsolve :: seq_search([\n      int_search([x[i,j] | i in periods, j in courses], input_order, indomain_max, complete),\n      int_search([objective], input_order, indomain_min, complete)\n    ]) minimize objective;\n\noutput \n    [show(c) ++ \"-\" ++ show(course_period[c]) ++ \"\\t\" | c in courses ] ++ [\"\\n\"] ++\n    [\"objective = \", show(objective)];\n"}}, "diamond_free_degree_sequence_expert": {"node_ids": ["91c10eba-9129-40a8-90c9-95bc4caac302"], "metadata": {"model_name": "diamond_free_degree_sequence", "source_code": "%\n% Diamond-free Degree Sequence (CSPLib #50) in MiniZinc.\n%\n% Given a simple undirected graph G=(V,E), where V is the set of vertices and E the set of\n% undirected edges, the edge {u,v} is in E if and only if vertex u is adjacent to vertex v\u2208G.\n% The graph is simple in that there are no loop edges, i.e. we have no edges of the form {v,v}.\n% Each vertex v\u2208V has a degree dv i.e. the number of edges incident on that vertex. Consequently\n% a graph has a degree sequence d1,\u2026,dn, where di>=di+1. A diamond is a set of four vertices\n% in V such that there are at least five edges between those vertices. Conversely, a graph is\n% diamond-free if it has no diamond as an induced subgraph, i.e. for every set of four vertices\n% the number of edges between those vertices is at most four.\n%\n% In our problem we have additional properties required of the degree sequences of the graphs,\n% in particular that the degree of each vertex is greater than zero (i.e. isolated vertices\n% are disallowed), the degree of each vertex is modulo 3, and the sum of the degrees is\n% modulo 12 (i.e. |E| is modulo 6).\n%\n% The problem is then for a given value of n, produce all unique degree sequences d1,\u2026,dn such\n% that\n%\n%  * di\u2265di+1\n%  * each degree di>0 and di is modulo 3\n%  * the sum of the degrees is modulo 12\n%  * there exists a simple diamond-free graph with that degree sequence\n\n\ninclude \"globals.mzn\"; \n\nint: n = 11;\n\n% decision variables\narray[1..n,1..n] of var 0..1: x;\narray[1..n] of var 1..n: degrees;\n\n\n% solve satisfy;\nsolve :: int_search(degrees, first_fail, indomain_split, complete) satisfy;\n\nconstraint\n  forall(i,j,k,l in 1..n where i < j /\\ j < k /\\ k < l) (\n     x[i,j] + x[i,k] + x[i,l] + x[j,k] + x[j,l] + x[k,l] <= 4\n  )\n  /\\\n  forall(i in 1..n) (\n     degrees[i] = sum([x[i,j] | j in 1..n])\n     /\\ degrees[i] mod 3 = 0\n     % no loops\n     /\\ x[i,i] = 0\n  ) \n  /\\ % undirected graph\n  forall(i,j in 1..n) (\n    x[i,j] = x[j,i]\n  )\n  /\\ sum(degrees) mod 12 = 0\n\n  % symmetry breaking\n  /\\ decreasing(degrees)\n  /\\ lex2(x)\n;\n\noutput \n[ \"degrees: \", show(degrees), \"\\n\"]\n% ++\n% [\n%   if j = 1 then \"\\n\" else \" \" endif ++\n%     show(x[i,j])\n%   | i,j in 1..n\n% ]\n;\n\n"}}, "doublechannel_expert": {"node_ids": ["5a0eac48-ae3d-494a-aa6e-3546b0d28efb"], "metadata": {"model_name": "doublechannel", "source_code": "% scheduling ships entering and leaving a port through k channels\nset of int: TYPE = 1..3;\nint: entering = 1;\nint: leaving  = 2;\nint: dummy = 3;\n\nint: nC; % number of channels\nset of int: CHANNEL = 1..nC;\narray[CHANNEL] of int: len;    % length in 100m units\n\nint: nS; % number of ships\nset of int: SHIP = 1..nS; % ships ENTER then LEAVE\nset of int: SHIPE = 1..nS+nC; % ships ENTER then LEAVE then nC dummy ships\n\narray[SHIP] of int: speed;   % time in minutes to traverse 100m\narray[SHIP] of int: desired; % desired time to start to enter/leave \narray[SHIP] of entering..leaving: dirn;   % entering or leaving\n\nint: leeway;  % leeway between 2 ships in 100m units\nint: maxt;    % maximum time\nset of int: TIME = 0..maxt;\n\narray[SHIPE] of var TYPE: kind = dirn ++ [ dummy | i in 1..nC];\narray[SHIPE] of var TIME:    start; % when ships enter the channel \narray[SHIPE] of var TIME:     end; % when ships leave the channel \narray[SHIPE] of var CHANNEL: channel; % which channel a ship is assigned to\n\narray[SHIP] of var SHIPE:   next;  % the next ship in the same channel (or a dummy)\n\n% dummy ships\nconstraint forall(s in nS + 1 .. nS + nC)(start[s] = maxt /\\ end[s] = maxt);\nconstraint forall(s in nS + 1 .. nS + nC)(channel[s] = s - nS);\n\n% relationships between start and ends\nconstraint forall(s in SHIP)(end[s] = start[s] + len[channel[s]]*speed[s]);\n\n\n% the next ship are all different\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(next);\n\n% no clashes in channel\nconstraint forall(s in SHIP)(if kind[s] + kind[next[s]] = entering+leaving then\n                                end[s] <= start[next[s]]\n                             else\n                                start[s] + speed[s]*leeway <= start[next[s]] /\\\n                                end[s] + speed[s]*leeway <= end[next[s]]\n                             endif);\n\n% next ship is in same channel\nconstraint forall(s in SHIP)(channel[next[s]] = channel[s]);\n\nsolve minimize sum(s in SHIP)(abs(start[s] - desired[s]));\n\noutput [ \"start = \",show(start),\n         \";\\nend = \", show(end),\n         \";\\nchannel = \", show(channel),\n         \";\\nnext = \", show(next),\n         \";\\n\" ];\n\n"}}, "fractions_expert": {"node_ids": ["e3a11130-2fb0-4c2b-9192-dfd82610836d"], "metadata": {"model_name": "fractions", "source_code": "%\n% Fractions problem in MiniZinc.\n%\n% Prolog benchmark problem (BProlog)\n% \"\"\"\n% Find distinct non-zero digits such that the following equation holds:\n%        A        D        G\n%     ------  + ----- + ------  = 1\n%       B*C      E*F      H*I\n\ninclude \"globals.mzn\"; \n\nvar 1..9: A;\nvar 1..9: B;\nvar 1..9: C;\nvar 1..9: D;\nvar 1..9: E;\nvar 1..9: F;\nvar 1..9: G;\nvar 1..9: H;\nvar 1..9: I;\narray[1..9] of var 1..9: Vars=[A,B,C,D,E,F,G,H,I];\n\nvar 1..81: D1;\nvar 1..81: D2;\nvar 1..81: D3;\n\n\n\n% solve satisfy;\nsolve :: int_search(Vars ++ [D1,D2,D3], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   all_different(Vars) /\\\n   D1 = 10*B+C /\\\n   D2 = 10*E+F /\\\n   D3 = 10*H+I /\\\n   A*D2*D3 + D*D1*D3 + G*D1*D2 = D1*D2*D3 /\\\n   % break the symmetry\n   A*D2 >= D*D1 /\\\n   D*D3 >= G*D2 /\\\n   %redundant constraints\n   3*A >= D1 /\\\n   3*G <= D2\n\n;\n\noutput [\n  show(Vars), \"\\n\"\n]\n;"}}, "golfers_expert": {"node_ids": ["e36a1efe-5300-48ee-a349-1ab315dabc84"], "metadata": {"model_name": "golfers", "source_code": "Model 1 :\n\n\n% The social golfers problem\n% A club has a number of golfers that play rounds in groups (the number of\n% golfers is a multiple of the number of groups).  Each round, a golfer\n% plays with a group of different people, such that the same pair of golfers\n% never play together twice.\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\nset of int: places = 1..n_golfers;\n\narray [rounds, places] of var golfers: round_place_golfer;\narray [golfers, golfers] of var 0..n_rounds: golfer_golfer_round;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (p in places) (round_place_golfer[r, p])\n    );\n\n    % Break some symmetry by strictly ordering each group in each round.\n    %\nconstraint\n    forall (r in rounds, p in places) (\n        if p mod n_per_group != 0\n        then round_place_golfer[r, p] < round_place_golfer[r, p + 1]\n        else true\n        endif\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (r in rounds, g in 0..(n_groups - 1), i, j in 1..n_per_group\n            where i < j) (\n        golfer_golfer_round[\n            round_place_golfer[r, n_per_group * g + i],\n            round_place_golfer[r, n_per_group * g + j]\n        ] = r\n    );\n\nsolve\n    :: int_search([round_place_golfer[r, p] | r in rounds, p in places],\n        first_fail, indomain_min, complete)\n    satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if p = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif ) ++\n    ( if p mod n_per_group = 1 then \"   \" else \" \" endif ) ++\n    show_int(2, round_place_golfer[r, p]) | r in rounds, p in places\n];\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups, group] of var golfers: round_group_i_golfer;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (g in groups, i in group) (round_group_i_golfer[r, g, i])\n    );\n\n    % We also break some symmetry\n    % here by strictly ordering each group.\n    %\nconstraint\n    forall (r in rounds, g in groups, i in group where i < n_per_group) (\n        round_group_i_golfer[r, g, i] < round_group_i_golfer[r, g, i + 1]\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups, i, j in group where i < j) (\n            bool2int(\n                round_group_i_golfer[r, g, i] = a\n            /\\  round_group_i_golfer[r, g, j] = b\n            )\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if g = 1 /\\ i = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif) ++\n    ( if i = 1 then \"   \" else \" \" endif) ++\n    show_int(2, round_group_i_golfer[r, g, i]) \n    |  r in rounds, g in groups, i in group\n];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups] of var set of golfers: round_group_golfers;\n\n    % Each group has to have the right size.\n    %\nconstraint\n    forall (r in rounds, g in groups) (\n        card(round_group_golfers[r, g]) = n_per_group\n    );\n\n    % Each group in each round has to be disjoint.\n    %\nconstraint\n    forall (r in rounds) (\n        all_disjoint (g in groups) (round_group_golfers[r, g])\n    );\n\n    % Symmetry breaking.\n    %\n% constraint\n%     forall (r in rounds, g in groups where g < n_groups) (\n%         round_group_golfers[r, g] < round_group_golfers[r, g + 1]\n%     );\n\n    % Each pair may play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups) (\n            bool2int({a, b} subset round_group_golfers[r, g])\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [    ( if   g = 1\n              then \"\\nround \" ++ show(r) ++ \":   \"\n              else \"   \"\n              endif\n            ) ++\n            show(round_group_golfers[r, g])\n       |    r in rounds, g in groups\n       ];\n\n\nModel 4 :\n\n\nint: weeks = 4;\nint: groups = 3;\nint: groupSize = 3;\nint: golfers = groups * groupSize;\n\nset of int: Golfer = 1..golfers;\nset of int: Week = 1..weeks;\nset of int: Group = 1..groups;\n\n% Search space: The set of all possible group assignments to all \n% players in each of the weeks\narray[Golfer, Week] of var Group: assign;\n\n% solve satisfy;\n% solve :: int_search([assign[i,j] | i in Golfer, j in Week ], \"first_fail\", \"indomain\", \"complete\") satisfy;\nsolve :: int_search([assign[i,j] | i in Golfer, j in Week ], \n        first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each group has exactly groupSize players\n   forall (gr in Group, w in Week)( % c1\n     sum (g in Golfer) (bool2int(assign[g,w] = gr)) = groupSize\n   )\n   /\\\n   % C2: Each pair of players only meets at most once\n   forall (g1, g2 in Golfer, w1, w2 in Week  where g1 != g2 /\\ w1 != w2) (\n     (bool2int(assign[g1,w1] = assign[g2,w1]) + bool2int(assign[g1,w2] = assign[g2,w2])) <= 1\n   )\n  /\\\n  % SBSA: Symmetry-breaking by selective assignment\n  % On the first week, the first groupSize golfers play in group 1, the \n  % second groupSize golfers play in group 2, etc. On the second week, \n  % golfer 1 plays in group 1, golfer 2 plays in group 2, etc.\n  forall(g in Golfer) (\n    assign[g,1]=((g-1) div groupSize) + 1 % \n  )\n  /\\\n  forall(g in Golfer where g <= groupSize)(\n    assign[g,2]=g\n  )\n\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n  show(assign[i,j])\n  | i in Golfer, j in Week\n] ++ [\"\\n\"];"}}, "golomb_expert": {"node_ids": ["f6e8897f-a6b7-40ca-9909-97535722dca2"], "metadata": {"model_name": "golomb", "source_code": "% Golomb rulers\n% From csplib:\n% A Golomb ruler may be defined as a set of m integers 0 = a_1 < a_2 <\n% ... < a_m such that the m(m-1)/2 differences a_j - a_i, 1 <= i < j\n% <= m are distinct. Such a ruler is said to contain m marks and is of\n% length a_m. The objective is to find optimal (minimum length) or\n% near optimal rulers.\n%\n% This is the \"ternary constraints and an alldifferent\" model\n\ninclude \"globals.mzn\";\n\nint: m;\nint: n = m*m;\n\narray[1..m] of var 0..n: mark;\n\narray[1..(m*(m-1)) div 2] of var 0..n: differences =\n    [ mark[j] - mark[i] | i in 1..m, j in i+1..m];\n\nconstraint mark[1] = 0;\n\nconstraint forall ( i in 1..m-1 ) ( mark[i] < mark[i+1] );\n\nconstraint alldifferent(differences);\n\n    % Symmetry breaking\nconstraint differences[1] < differences[(m*(m-1)) div 2];\n\nsolve :: int_search(mark, input_order, indomain, complete)\n    minimize mark[m];\n\noutput [show(mark)];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%\n"}}, "graph_expert": {"node_ids": ["4f159be2-2435-43e0-90fb-8190f18bd7aa"], "metadata": {"model_name": "graph", "source_code": "% a strange graph numbering problem\nvar 1..8: a;\nvar 1..8: b;\nvar 1..8: c;\nvar 1..8: d;\nvar 1..8: e;\nvar 1..8: f;\nvar 1..8: g;\nvar 1..8: h;\n\n% Each number is used exactly once\nconstraint a != b;\nconstraint a != c;\nconstraint a != d;\nconstraint a != e;\nconstraint a != f;\nconstraint a != g;\nconstraint a != h;\nconstraint b != c;\nconstraint b != d;\nconstraint b != e;\nconstraint b != f;\nconstraint b != g;\nconstraint b != h;\nconstraint c != d;\nconstraint c != e;\nconstraint c != f;\nconstraint c != g;\nconstraint c != h;\nconstraint d != e;\nconstraint d != f;\nconstraint d != g;\nconstraint d != h;\nconstraint e != f;\nconstraint e != g;\nconstraint e != h;\nconstraint f != g;\nconstraint f != h;\nconstraint g != h;\n\n% Adjacent vertices differ by at most two\nconstraint abs(a - b) >= 2;\nconstraint abs(a - c) >= 2;\nconstraint abs(a - d) >= 2;\nconstraint abs(b - c) >= 2;\nconstraint abs(b - e) >= 2;\nconstraint abs(b - f) >= 2;\nconstraint abs(c - d) >= 2;\nconstraint abs(c - e) >= 2;\nconstraint abs(c - f) >= 2;\nconstraint abs(c - g) >= 2;\nconstraint abs(d - f) >= 2;\nconstraint abs(d - g) >= 2;\nconstraint abs(e - f) >= 2;\nconstraint abs(e - h) >= 2;\nconstraint abs(f - g) >= 2;\nconstraint abs(f - h) >= 2;\nconstraint abs(g - h) >= 2;\n\nsolve satisfy;\n\noutput [\"  \\(b)-\\(e)\\n\",\n        \" /|*|\\\\\\n\",\n        \"\\(a)-\\(c)-\\(f)-\\(h)\\n\",\n        \" \\\\|*|/\\n\",\n        \"  \\(d)-\\(g)\\n\"] ++\n       [\"\\na = \\(a); b = \\(b); c = \\(c); d = \\(d);\",\n        \" e = \\(e); f = \\(f); g = \\(g); h = \\(h);\\n\"] \n\n"}}, "itemset_mining_expert": {"node_ids": ["d1788cff-6ef4-446d-bba4-b3f6e2362c0f"], "metadata": {"model_name": "itemset_mining", "source_code": "int : NrI ; \nint : NrT ; \nint : Freq ;\narray [ 1..NrT ] of set of 1..NrI : TDB;\nvar set of 1..NrI : Items ;\nconstraint card ( cover ( Items ,TDB ) ) >= Freq ;\nsolve satisfy ; \n\nfunction var set of int : cover (\n         var set of int : Items ,\n         array [ int ] of var set of int : D) = \n         let {\n                          var set of index_set (D): Trans ;\n                          constraint forall ( t in index_set (D) )\n                          ( t in Trans <-> Items subset D[ t ] );\n         } in Trans;\n\narray[1.. NrI] of int: itemprice;\nint: minUtility;\n\nconstraint sum(i in Items)(itemprice[i]) >= minUtility;\n\nNrI = 6;\nint: bread = 1;\nint: butter = 2;\nint: cheese = 3;\nint: cocoa = 4;\nint: milk = 5;\nint: vegemite = 6;\narray[1..NrI] of string: name = [\"bread\",\"butter\",\"cheese\",\"cocoa\",\"milk\",\"vegemite\"];\nitemprice = [1,2,1,2,1,1];\n\nNrT = 7;\nTDB = [ { butter, cheese, milk, vegemite },\n        { butter, cocoa, milk, vegemite },\n\t{ bread, cocoa, cheese, milk },\n\t{ bread, butter, cheese, vegemite }, \n\t{ bread, cheese, milk, vegemite },\n\t{ bread, butter, cheese, cocoa, milk },\n\t{ bread, cheese, milk }];\n\nFreq = 4;\nminUtility = 3;\n\noutput [ name[i] ++ \" \" | i in fix(Items) ];\n"}}, "jobshop_expert": {"node_ids": ["c2b61012-ee95-4395-a6d3-1262408c37b4"], "metadata": {"model_name": "jobshop", "source_code": "Model 1 :\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\n% only one task on any machine at one time\n%constraint forall(ma in MACH)\n%                 (forall(j1,j2 in JOB where j1 < j2)\n%                       (forall(t1,t2 in TASK where mc[j1,t1] = ma /\\ mc[j2,t2] = ma)\n%                              (nonoverlap(s[j1,t1],d[j1,t1],s[j2,t2],d[j2,t2]))));\n\nconstraint forall(j1, j2 in JOB, t1, t2 in TASK \n       where j1 < j2 /\\ mc[j1,t1] = mc[j2,t2])\n      (nonoverlap(s[j1,t1],d[j1,t1],\n                  s[j2,t2],d[j2,t2]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve :: int_search([s[j,t] | j in JOB, t in TASK], input_order, indomain_min, complete)\n      minimize makespan;\n\noutput [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 2 : \n\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n   %:: int_search([s[j,t]|j in JOB,t in TASK],input_order,indomain_min,complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],smallest, indomain_min, complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],dom_w_deg, indomain_min, complete)\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 3 : \n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n%      ::\n%      seq_search([ int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete),\n%                  int_search([makespan], input_order, indomain_min, complete)])\n%      seq_search([ int_search([makespan], input_order, indomain_min, complete),\n%                   int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete)])\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n"}}, "K4xP2Graceful_expert": {"node_ids": ["1921d207-e716-4416-a015-c6fed6bdc1eb"], "metadata": {"model_name": "K4xP2Graceful", "source_code": "% K4P2 Graceful Graph in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: m = 16;\nint: n = 8;\narray[1..n] of var 0..m: nodes;\narray[1..m, 1..2] of var 1..n: graph;\narray[1..m] of var 1..m: edges;\n\n\n\nsolve :: int_search(nodes, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..m) (\n    abs(nodes[graph[i,1]] - nodes[graph[i,2]]) = edges[i]  \n  )\n  /\\\n  all_different(edges) \n  /\\ \n  all_different(nodes)\n;\n\ngraph =\narray2d(1..m, 1..2,\n[1, 2,\n1, 3,\n1, 4,\n2, 3,\n2, 4,\n3, 4,\n\n5, 6,\n5, 7,\n5, 8,\n6, 7,\n6, 8,\n7, 8,\n\n1, 5,\n2, 6,\n3, 7,\n4, 8]);\n\noutput\n[\n  \"nodes: \" ++ show(nodes) ++ \"\\n\" ++\n  \"edges: \" ++ show(edges) ++ \"\\n\"\n];"}}, "killer_sudoku_expert": {"node_ids": ["03b74dd0-8753-4a79-b2b3-559f498dd170"], "metadata": {"model_name": "killer_sudoku", "source_code": "Model 1 :\n\n%\n% Killer Sudoku in MiniZinc.\n\n%   Killer sudoku (also killer su doku, sumdoku, sum doku, addoku, or\n%   samunamupure) is a puzzle that combines elements of sudoku and kakuro.\n%   Despite the name, the simpler killer sudokus can be easier to solve\n%   than regular sudokus, depending on the solver's skill at mental arithmetic;\n%   the hardest ones, however, can take hours to crack.\n \n%   The objective is to fill the grid with numbers from 1 to 9 in a way that\n%   the following conditions are met:\n \n%     * Each row, column, and nonet contains each number exactly once.\n%     * The sum of all numbers in a cage must match the small number printed\n%       in its corner.\n%     * No number appears more than once in a cage. (This is the standard rule\n%       for killer sudokus, and implies that no cage can include more\n%       than 9 cells.)\n \n%   In 'Killer X', an additional rule is that each of the long diagonals\n%   contains each number once.\n%   \"\"\"\n \n\nint: num_p = 29; % number of segments\nint: num_hints = 4;  % number of hints per segments (that's max number of hints)\nint: max_val = 100;\narray[1..num_p, 1..2*num_hints+1] of 0..max_val: P =\n  array2d(1..num_p, 1..2*num_hints+1, [\n    1,1,  1,2, 0,0, 0,0,   3,\n    1,3,  1,4, 1,5, 0,0,  15,\n    1,6,  2,5, 2,6, 3,5,  22,\n    1,7,  2,7, 0,0, 0,0,   4,\n    1,8,  2,8, 0,0, 0,0,  16,\n    1,9,  2,9, 3,9, 4,9,  15,\n    2,1,  2,2, 3,1, 3,2,  25,\n    2,3,  2,4, 0,0, 0,0,  17,\n    3,3,  3,4, 4,4, 0,0,   9,\n    3,6,  4,6, 5,6, 0,0,   8,\n    3,7,  3,8, 4,7, 0,0,  20,\n    4,1,  5,1, 0,0, 0,0,   6,\n    4,2,  4,3, 0,0, 0,0,  14,\n    4,5,  5,5, 6,5, 0,0,  17,\n    4,8,  5,7, 5,8, 0,0,  17,\n    5,2,  5,3, 6,2, 0,0,  13,\n    5,4,  6,4, 7,4, 0,0,  20,\n    5,9,  6,9, 0,0, 0,0,  12,\n    6,1,  7,1, 8,1, 9,1,  27,\n    6,3,  7,2, 7,3, 0,0,   6,\n    6,6,  7,6, 7,7, 0,0,  20,\n    6,7,  6,8, 0,0, 0,0,   6,\n    7,5,  8,4, 8,5, 9,4,  10,\n    7,8,  7,9, 8,8, 8,9,  14,\n    8,2,  9,2, 0,0, 0,0,   8,\n    8,3,  9,3, 0,0, 0,0,  16,\n    8,6,  8,7, 0,0, 0,0,  15,\n    9,5,  9,6, 9,7, 0,0,  13,\n    9,8,  9,9, 0,0, 0,0,  17\n   ]);\n\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n \n  forall(i in 1..n) (\n        all_different([x[i,j] | j in 1..n]) /\\\n        all_different([x[j,i] | j in 1..n])\n  )\n  /\\\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n  /\\ % calculate the hints\n  forall(p in 1..num_p) (\n     sum(i in 1..num_hints where P[p,2*(i-1)+1] > 0) (x[  P[p, 2*(i-1)+1], P[p,2*(i-1)+2]  ]) = P[p, 2*num_hints+1]\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\"; \nint: n = 9;\narray[1..n, 1..n] of var 1..9: x;\n\nint: num_segments = 29; % number of segments\n\narray[1..n, 1..n] of int: segments =\narray2d(1..n, 1..n,\n[\n  1, 1, 2, 2, 2, 3, 4, 5, 6, % 1\n  7, 7, 8, 8, 3, 3, 4, 5, 6, % 2\n  7, 7, 9, 9, 3,10,11,11, 6, % 3\n 13,14,14, 9,15,10,11,12, 6, % 4\n 13,16,16,17,15,10,12,12,18, % 5\n 19,16,20,17,15,21,22,22,18, % 6\n 19,20,20,17,23,21,21,24,24, % 7\n 19,25,26,23,23,27,27,24,24, % 8\n 19,25,26,23,28,28,28,29,29, % 9\n]);\n\narray[1..num_segments] of int: segment_sums =\n[\n   3, % 1\n  15, % 2\n  22, % 3\n   4, % 4\n  16, % 5\n  15, % 6\n  25, % 7\n  17, % 8\n   9, % 9\n   8, % 10\n  20, % 11\n  17, % 12\n   6, % 13\n  14, % 14\n  17, % 15\n  13, % 16\n  20, % 17\n  12, % 18\n  27, % 19\n   6, % 20\n  20, % 21\n   6, % 22\n  10, % 23\n  14, % 24\n   8, % 25\n  16, % 26\n  15, % 27\n  13, % 28\n  17  % 29\n];\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\n% Standard Sudoku constraints\nconstraint\n  % rows and columns\n  forall(i in 1..n) (\n     all_different([x[i,j] | j in 1..n]) /\\\n     all_different([x[j,i] | j in 1..n])\n  )\n  /\\ % blocks\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n;\n\n% Handle the segments\nconstraint\n  forall(p in 1..num_segments) (\n    segment_sums[p] = sum([x[i,j] | i,j in 1..n where segments[i,j] = p])\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];"}}, "knapsack_expert": {"node_ids": ["f934f715-c515-4fbc-a9ee-1553a1c72c33"], "metadata": {"model_name": "knapsack", "source_code": "Model 1 : \n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\narray[OBJ] of var int: x; % how many of each object\n\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in OBJ)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\nModel 2 : \n\n\nint: n;    set of int: OBJ = 1..n;\narray[OBJ] of int: size;\narray[OBJ] of int: value;\nint: limit;\narray[OBJ] of var int: x;\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i]*x[i])<= limit;\nsolve maximize sum(i in OBJ)(value[i]*x[i]);\nn = 4;\nsize = [5,8,9,12];\nvalue = [3,5,7,8];\nlimit = 29;\n\n\n\nModel 3 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var 0..1: x; \n\nconstraint sum(i in 1..n)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 4 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var bool: x; \n\nconstraint sum(i in 1..n)(size[i] * bool2int(x[i])) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(x[i]));\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 5 : \n\n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\nvar set of OBJ: x; \n\n\nconstraint sum(i in x)(size[i]) <= capacity;\n\nsolve maximize sum(i in x)(profit[i]);\n\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 6 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\nvar set of 1..n: x;\n\nconstraint sum(i in 1..n)(size[i] * bool2int(i in x)) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(i in x));\n\noutput [\"x = \", show(x), \"\\n\"];"}}, "langford_expert": {"node_ids": ["329e278e-151f-4e7e-ac24-184bf0e910aa"], "metadata": {"model_name": "langford", "source_code": "Model 1 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n                 (x[d,c+1] = x[d,c] + d + 1);\n\nsolve satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ if fix(x[d,c]) = p then show(d) ++ \" \" else \"\" endif\n          | p in POS, d in DIG, c in COPY ]\n       ;\n\n\n\nModel 2 : \n\n\n% Langford's number problem in MiniZinc.\n%\n% Arrange 2 sets of positive integers 1..k to a sequence,\n% such that, following the first occurence of an integer i,\n% each subsequent occurrence of i, appears i+1 indices later\n% than the last.\n% For example, for k=4, a solution would be 41312432\n\ninclude \"globals.mzn\";\n\nint: k;\nset of int: positionDomain = 1..2*k;\n\narray[positionDomain] of var positionDomain: position;\n% better presentation:\narray[positionDomain] of var 1..k: solution;\n\nsolve :: int_search(position, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..k) (\n     position[i+k] = position[i] + i+1 /\\\n     % hakank: added this\n     solution[position[i]] = i /\\ \n     solution[position[k+i]] = i\n  )\n  /\\   \n  all_different(position)\n  /\\ % symmetry breaking\n  solution[1] < solution[2*k]\n;\n\n\noutput [\n  show(solution), \"\\n\"\n\n];\n\n%\n% data\n%\nk = 4;\n% k = 7;\n% k = 8;\n% k = 10;\n% k = 20;\n\n\n\nModel 3 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"inverse.mzn\";\nconstraint inverse([x[d,c] | d in DIG, c in COPY], y);\n\n%include \"alldifferent.mzn\";\n%constraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n      (x[d,c+1] = x[d,c] + d + 1);\n\n%constraint forall(d in DIG, c in 1..m-1, p in POS)\n%                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve \n      %:: int_search(y, input_order, indomain_min, complete) \n      %:: int_search([x[d,c] | d in DIG, c in COPY], input_order, indomain_min, complete) \n      satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n\n\nModel 4 :\n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\nconstraint forall(d in DIG, c in 1..m-1, p in POS)\n                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve satisfy;\n\noutput [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n"}}, "loan_expert": {"node_ids": ["4583cc66-6dfc-44c1-adc5-8003f6bdfbde"], "metadata": {"model_name": "loan", "source_code": "% variables\nvar float: R;        % quarterly repayment\nvar float: P;        % principal initially borrowed\nvar 0.0 .. 10.0: I;  % interest rate\n\n% intermediate variables\nvar float: B1; % balance after one quarter\nvar float: B2; % balance after two quarters\nvar float: B3; % balance after three quarters\nvar float: B4; % balance owing at end\n\nconstraint B1 = P * (1.0 + I) - R;\nconstraint B2 = B1 * (1.0 + I) - R;\nconstraint B3 = B2 * (1.0 + I) - R; \nconstraint B4 = B3 * (1.0 + I) - R;\n\nsolve satisfy;\n\noutput [\n \"Borrowing \", show_float(0, 2, P), \" at \", show(I*100.0), \n \"% interest, and repaying \", show_float(0, 2, R), \n  \"\\nper quarter for 1 year leaves \", show_float(0, 2, B4), \" owing\\n\"\n];\n\n"}}, "ltsp_expert": {"node_ids": ["ef15b295-f1f1-4741-a03a-c0d15c614c70"], "metadata": {"model_name": "ltsp", "source_code": "int: n; % number of cities\nset of int: CITY = 1..n;\nset of int: POS = 1..n;\narray[CITY] of int: coord; % coordinate of city \nint: m; % number of precedences\nset of int: PREC = 1..m;\narray[PREC] of CITY: left;\narray[PREC] of CITY: right;\n\narray[CITY] of var POS: order;\narray[POS] of var CITY: city;\n\ninclude \"inverse.mzn\";\nconstraint inverse(order,city);\n\nconstraint forall(i in PREC)(order[left[i]] < order[right[i]]);\n\nsolve minimize sum(i in 1..n-1)(abs(coord[city[i]] - coord[city[i+1]]));\n\n\n"}}, "magic_hexagon_expert": {"node_ids": ["37f8eaa5-a03e-48fb-96b3-3bb5b3566536"], "metadata": {"model_name": "magic_hexagon", "source_code": "% Magic Hexagon in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nset of int: N = 1..19;\nvar N: a;\nvar N: b;\nvar N: c;\nvar N: d;\nvar N: e;\nvar N: f;\nvar N: g;\nvar N: h;\nvar N: i;\nvar N: j;\nvar N: k;\nvar N: l;\nvar N: m;\nvar N: n;\nvar N: o;\nvar N: p;\nvar N: q;\nvar N: r;\nvar N: s;\n\narray[N] of var N: LD = [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s];\n\nsolve satisfy;\n\nconstraint\n  all_different(LD) /\\\n\n  a + b + c =  38 /\\\n  d + e + f + g =  38 /\\\n  h + i + j + k + l =  38 /\\ \n  m + n + o + p =  38 /\\ \n  q + r + s =  38 /\\ \n  a + d + h =  38 /\\ \n  b + e + i + m =  38 /\\ \n  c + f + j + n + q =  38 /\\ \n  g + k + o + r =  38 /\\ \n  l + p + s =  38 /\\ \n  c + g + l =  38 /\\ \n  b + f + k + p =  38 /\\ \n  a + e + j + o + s =  38 /\\ \n  d + i + n + r =  38 /\\ \n  h + m + q =  38 /\\ \n\n  a < c /\\\n  a < h /\\\n  a < l /\\\n  a < q /\\\n  a < s /\\\n  c < h\n;\n\noutput\n[\n  show(LD)\n];"}}, "magic_sequence_expert": {"node_ids": ["a693c877-aa1a-483c-a2a5-42a0b9e4ffef"], "metadata": {"model_name": "magic_sequence", "source_code": "Model 1 :\n\n% Magic sequence in MiniZinc.\n% A magic sequence of length n is a sequence of integers x0 . . xn-1 between 0 and n-1, such that for all i in 0 to n-1, the number i occurs exactly xi times in the sequence. For instance, 6,2,1,0,0,0,1,0,0,0 is a magic sequence since 0 occurs 6 times in it, 1 occurs twice, ...\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n  forall(i in 0..n-1) (\n    s[i] = sum(j in 0..n-1) (bool2int(s[j] = i))\n  )\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 2 : \n\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n        forall(i in 0..n-1) (\n                s[i] = sum(j in 0..n-1) (bool2int(s[j]=i))\n        )\n        /\\ \n        sum(i in 0..n-1) (s[i])=n \n        /\\\n        sum(i in 0..n-1) (s[i]*i) =n\n;\n\n\noutput [\n       show(s), \"\\n\",\n];\n\n\n\nModel 3 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  10;\narray[0..n-1] of var 0..n-1: s;\narray[0..n-1] of int: value = array1d(0..n-1, [i | i in 0..n-1]); % helper for distribute\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   distribute(s, value, s)         /\\ \n   sum(i in 0..n-1) (s[i])   = n   /\\\n   sum(i in 0..n-1) (s[i]*i) = n\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 4 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  100;\narray[0..n-1] of var 0..n-1: s;\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   global_cardinality(s,array1d(0..n-1, set2array(index_set(s))), s) :: domain\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\nModel 5 : \n\n\n% Magic squares in MiniZinc\n\ninclude \"globals.mzn\";\n\nint: n = 3;\n\nint: total = ( n * (n*n + 1)) div 2;\narray[1..n,1..n] of var 1..n*n: magic;\n\n\n% solve satisfy;\nsolve :: int_search(\n        [magic[i,j] | i in 1..n, j in 1..n], \n        first_fail,\n        indomain_min,\n        complete) \n    satisfy;\n\n\nconstraint\n\n        all_different([magic[i,j] | i in 1..n, j in 1..n]) :: domain\n        /\\\n        forall(k in 1..n) (\n           sum(i in 1..n) (magic[k,i]) = total % :: domain\n           /\\\n           sum(i in 1..n) (magic[i,k]) = total %:: domain\n        )\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,i]) = total  %:: domain\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,n-i+1]) = total %:: domain\n;\n\n% symmetry breaking\n% Activating all these constraints we get the\n% \"standard\" way of counting the number of solutions:\n%    1, 0, 1, 880, 275305224\n% i.e. this sequence: http://oeis.org/A006052\n%\n% Without the constraints the number of solutions are:\n%  N  #solutions\n%  -------------\n%  1     1\n%  2     0\n%  3     8\n%  4  7040\n%  5  many... \n%\n% constraint\n%    magic[1,1] < magic[1,n]\n%    /\\ magic[1,n] < magic[n,1]\n%    /\\ magic[1,1] < magic[n,n]\n% ;\n\n\noutput [\n  \"Total: \" ++ show(total) ++ \"\\n\"\n] ++\n[\n    %   show(magic)\n  if j = 1 then \"\\n\" else \"\" endif ++\n    if fix(magic[i,j]) < 10 then \" \" else \"\" endif ++\n    show(magic[i,j]) ++ \" \"\n  | i,j in 1..n\n] \n++ \n[\"\\n\"];\n\n\nModel 6 : \n\n\n% Magic square integer programming version in MiniZinc.\n% In recreational mathematics, a magic square of order n is an\n% arrangement of n^2 numbers, usually distinct integers, in a square,\n% such that n numbers in all rows, all columns, and both diagonals sum\n% to the same constant. A normal magic square contains the integers\n% from 1 to n^2.\n\n\n% square order\nint: n = 3; \n\n% integers to be placed\nset of 1..n*n: N = 1..n*n;\n\n% x[i,j,k] = 1 means that cell (i,j) contains integer k\narray[1..n, 1..n, N] of var 0..1: x;\n\narray[1..n, 1..n] of var 1..n*n: square;\n\nvar int: s; % the magic sum\n\nsolve :: int_search(\n        [x[i,j,k] | i,j in 1..n, k in N] ++ \n        [square[i,j] | i,j in 1..n] ++\n        [s],\n        first_fail,\n        indomain_min, \n        complete % \"credit(640, bbs(5))\" % \"complete\"\n      ) \n    satisfy;\n\nconstraint \n  s >= 0 \n  /\\\n  s <= n*n*n\n  /\\\n  % each cell must be assigned exactly one integer\n  forall(i in 1..n, j in 1..n) (\n     sum(k in N) (x[i,j,k]) = 1\n  )\n  /\\\n  % each integer must be assigned exactly to one cell\n  forall(k in N) (\n     sum(i in 1..n, j in 1..n) (x[i,j,k]) = 1\n  )\n\n  /\\\n  % the sum in each row must be the magic sum \n  forall(i in 1..n) (\n     sum(j in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in each column must be the magic sum\n  forall(j in 1..n) (\n     sum(i in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in the diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,i,k]) = s\n\n  /\\\n  % the sum in the co-diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,n-i+1,k]) = s\n\n  /\\\n  % for output\n  forall(i,j in 1..n) ( square[i,j] = sum(k in N) (k * x[i,j,k]))\n;\n\n\noutput [ \n   \"\\ns: \", show(s)\n] ++\n[\n  if  j = 1 then \"\\n\" else \" \" endif ++\n    show(square[i,j]) \n  | i,j in 1..n\n\n] ++ [\"\\n\"];\n\n% printf \"\\n\";\n% printf \"Magic sum is %d\\n\", s;\n% printf \"\\n\";\n% for{i in 1..n}\n% {  printf{j in 1..n} \"%3d\", sum{k in N} k * x[i,j,k];\n%    printf \"\\n\";\n% }\n% printf \"\\n\";"}}, "maximum_density_still_life_expert": {"node_ids": ["9a04da90-8ea4-4bfa-8d66-f882a4711f77"], "metadata": {"model_name": "maximum_density_still_life", "source_code": "% Maximum density still life in MiniZinc.\n\n% include \"globals.mzn\"; \nint: size = 7; % to change\n\nset of int: objFunctionBoardCoord      = 2..size+1;\nset of int: checkConstraintsBoardCoord = 1..size+2;\nset of int: augmentedBoardCoord        = 0..size+3;\n\n% Search space: The set of all possible assignments of 0s (dead) and 1s (live) \n% to the cells of the board section. However, to be able to easily express \n% constraints on \"boundary\" cells, we take as search space the set of 0/1 \n% boards of size n+4 by n+4: the actual stable pattern appears in the sub-board \n% defined by ignoring the first/last two rows/columns.\narray[augmentedBoardCoord,augmentedBoardCoord] of var 0..1: grid;\n\nvar int: z = sum(r in objFunctionBoardCoord, c in objFunctionBoardCoord) (grid[r,c]);\n\n% Objective function: Maximize the number of live cells in the sub-board defined \n% by ignoring the first/last two/ rows/columns.\n\n\n% solve maximize z;\nsolve :: int_search(\n        [grid[i,j] | i,j in augmentedBoardCoord], \n        smallest, \n        indomain_max, \n        complete) \n    maximize z;\n\nconstraint\n\n  % C1: Cells in the first/last two rows/columns are all 0 (dead)\n  forall(x in augmentedBoardCoord) (\n    grid[0,x] = 0 /\\\n    grid[1,x] = 0 /\\\n    grid[size+2,x] = 0 /\\  \n    grid[size+3,x] = 0 /\\\n    grid[x,0] == 0 /\\       \n    grid[x,1] == 0 /\\\n    grid[x,size+2] = 0 /\\  \n    grid[x,size+3] = 0 \n  )\n  /\\\n  forall(r in checkConstraintsBoardCoord,c in checkConstraintsBoardCoord) (\n    % C2: Each cell of the board (except those of the first/last row/column) \n    %     that has exactly three live neighbors is alive. \n    %     Together with constraint C1, this implies that cells in the\n    %     second/last-but-one row/column cannot have three live neighbors.\n    (\n      ( ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] + \n          grid[r,c-1] + grid[r,c+1] + \n          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1]\n          ) = 3 \n       ) -> (grid[r,c] = 1)\n    )\n    /\\    \n\n    % C3: Each live cell must have 2 or 3 live neighbors (cells of the first/last \n    % row/column may be ignored by this constraint)\n    (\n       (grid[r,c] = 1) -> \n                      (\n                        2 <= \n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          )\n                        /\\\n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          ) <= 3\n                      )\n    )\n  )\n  \n  /\\\n  % SBSO: Symmetry-breaking by selective ordering\n  % The assignment is forced to respect an ordering on the values that occur in corner entries\n  % of the board. In particular:  \n  % - if the NW-corner cell is dead, the SE-corner cell\n  % must be dead too \n  % - if the NE-corner cell is dead, the SW-corner cell must be dead too\n  % \n  grid[2,2] >= grid[size+1,size+1] /\\\n  grid[2,size+1] >= grid[size+1,2]\n;\n\n\noutput [\n  if j = 0 then \"\\n\" else \" \" endif ++\n    show(grid[i,j])\n  | i,j in augmentedBoardCoord\n];\n"}}, "mip_expert": {"node_ids": ["b9fd314b-802c-4389-96aa-e89e6b04066f"], "metadata": {"model_name": "mip", "source_code": "Model 1 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.0*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 2 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\n\nsolve maximize 1.0*B - 1.0*C + 1.0*D;\nconstraint 2.0*B - 1.0*C + 2.0*D <=  4.0;\nconstraint 2.0*B - 3.0*C + 1.0*D <= -5.0;\nconstraint -1.0*B + 1.0*C - 2.0*D <= -1.0;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 3 :\n\n\nvar int: B;\nvar int: C;\nvar int: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.5*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 4 :\n\n\nsolve maximize 21*x + 11*y;\n\nvar int: x;\nvar int: y;\nconstraint 7*x + 4*y <= 13;\nconstraint x >= 0 /\\ y >= 0; \n\n\n\nModel 5 : \n\n\nsolve maximize 8*x + 5*y;\n\nvar int: x;\nvar int: y;\nconstraint x + y <= 6;\nconstraint 9*x + 5*y <= 45;\nconstraint x >= 0 /\\ y >= 0; \n"}}, "missing_solution_expert": {"node_ids": ["1a8a84ee-699c-411c-8c78-6001da0bd9ce"], "metadata": {"model_name": "missing_solution", "source_code": "% Missing Solutions\nint: n; % no of people\nset of int: PERSON = 1..n;\nint: male = 1; int: female = 2;\nset of int: GENDER = male..female;\narray[PERSON] of GENDER: gender;\narray[PERSON] of int: age;\n\narray[1..n] of var PERSON: order;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(order);\n\n% males and females alternate\nconstraint forall(i in 1..n)\n                 (i mod 2 = 0 <-> gender[order[i]] = female);\n\n% age does not grow bu more than 10\nconstraint forall(i in 1..n-1)\n                 (age[order[i+1]] - age[order[i]] <= 10);\n\nsolve satisfy;\n\noutput [ show(order), \"\\n\"] ++\n       [\"[\"] ++ [ show(age[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                | i in 1..n ] ++\n       [\"[\"] ++ [ show(gender[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                 | i in 1..n ];\n\n\n%n = 6;\n%gender = [male,male,male,female,female,female];\n%age = [13, 25, 34, 40, 16, 13];\n\nn = 5;\ngender = [male,male,female,female,female];\nage = [13,25,34,40,16];\n\n%order = [4,2,3,1,5];\n"}}, "nonogram_create_automaton2_expert": {"node_ids": ["a701b1cb-c7e6-407a-a6f8-24eea868051c"], "metadata": {"model_name": "nonogram_create_automaton2", "source_code": "Model 1 :\n\n% Nonoram solver using regular and is written in all-MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: rows;\nint: row_rule_len;\narray[1..rows, 1..row_rule_len] of int: row_rules;\nint: cols;\nint: col_rule_len;\narray[1..cols, 1..col_rule_len] of int: col_rules;\n\n\narray[1..rows, 1..cols] of var 1..2: x;\n\nsolve :: int_search(\n     [x[i,j] | j in 1..cols, i in 1..rows], \n     first_fail, \n     indomain_min, \n     complete) \nsatisfy;\n\n%\n% The approach is rather simple:\n%  - zero_positions is a set of the positions in the state table where the \n%    state 0 should be, which also correspond to the state of the pattern \"0\"\n%  - when this have been identified everything else comes to rest\n%\n% On the other hand, the calculation of the states is hairy, very hairy.\n%\npredicate make_automaton(array[int] of var int: x, array[int] of int: pattern) =\n    let {\n        int: n = length(pattern),\n        % fix for \"zero clues\"\n        int: len = max(length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern),1),\n        int: leading_zeros = sum(i in 1..n) (bool2int(pattern[i] = 0)),\n        set of int: zero_positions = {sum(j in 1..i) (pattern[j]+1) -leading_zeros | i in 1..n where pattern[i] > 0},\n       array[1..2*len] of 0..len*2: states = \n     if (length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern)) = 0 then \n       [1,1]  % fix for \"zero clues\"\n     else \n    [1, 2] ++\n    [\n       if i div 2 in zero_positions then\n           if i mod 2 = 0 then\n            0\n           else\n            (i div 2) + 1\n           endif\n       elseif (i-1) div 2 in zero_positions then\n           if i mod 2 = 0 then\n            (i div 2)+1\n           else\n            (i div 2)+2\n           endif\n       else\n         if not( (((i-1) div 2) - 1) in zero_positions) then\n            if i mod 2 = 0 then\n               (i div 2) + 1\n            else \n              if (i div 2) + 1 in zero_positions then\n                  (i div 2) + 2\n              else \n                  0\n              endif\n            endif\n          else\n             if i mod 2 = 0 then\n                 (i div 2) + 1\n             else \n                if not((i div 2) + 1 in zero_positions) then\n                   0\n                else \n                   (i div 2) + 2 \n                endif\n             endif\n          endif\n       endif\n    | i in 3..2*(len-1)]\n    ++\n    [len, 0]\n    endif\n    } \n    in\n    regular(\n       x,\n       len, \n       2, \n       array2d(1..len, 1..2, states),\n       1, \n       {len}) % :: domain\n;\n\nconstraint\n\n      forall(j in 1..cols) (\n        make_automaton([x[i,j] | i in 1..rows], [col_rules[j,k] | k in 1..col_rule_len])\n      )\n      /\\\n      forall(i in 1..rows) (\n        make_automaton([x[i,j] | j in 1..cols], [row_rules[i,k] | k in 1..row_rule_len])\n      )\n\n;\n\noutput \n[\n  if j = 1 then \"\\n\" else \"\" endif ++\n     if fix(x[i,j]) = 1 then \" \" else \"#\" endif\n    \n  | i in 1..rows, j in 1..cols\n] \n++ \n[\n  \"\\n\"\n];\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\nint: X;\nint: Y;\n\nint: maxlen;\n\narray [1..Y,1..maxlen] of int: rows;\n\narray [1..X,1..maxlen] of int: cols;\n\narray[1..2, 1..2, 1..2] of 0..1: nonmul = \n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 1, 1,\n         1, 0, 0, 1]\n    );\n\narray[1..2, 1..2, 1..2] of 0..1: nonadd =\n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 0, 1,\n         1, 0, 0, 1]\n    );\n\n% variables\n%\narray[1..Y, 1..X] of var 1..2: A;\n\n% All variables in a region must be different\n% Ordering to ensure each variable is handled exactly once\npredicate nonogram_row(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: row) =\n    nonogram([A[row, v] | v in 1..X], cons);\n\npredicate nonogram_col(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: col) = \n    nonogram([A[v,col] | v in 1..Y], cons);\n\npredicate nonogram(array[int] of var 1..2: A, array [int] of int: cons) = \n    let {\n          int: n = if cons[1] = 0 then 0 else max(index_set(cons)) endif,\n          array [1..n + 1, 1..2] of int: consarr =\n              if cons[1] = 0 then [|1, 0|] \n              else array2d(1..n + 1, 1..2,\n                [1, 2] ++\n                [    i * nonmul[cons[i - 1] + 1, cons[i] + 1, s] + \n                     nonadd[cons[i - 1] + 1, cons[i] + 1, s] \n                     | i in 2..n, s in 1..2 \n                ] ++ \n                [n+1,0]\n              )\n              endif\n     } in (\n         regular(A, n + 1, 2, consarr, 1, {n + 1})\n     );\n\nconstraint forall(i in 1..Y) (\n    nonogram_row(A, [rows[i, j] | j in 1..maxlen where rows[i, j] >= 0], i)\n);\n\nconstraint forall(i in 1..X) (\n    nonogram_col(A, [cols[i, j] | j in 1..maxlen where cols[i, j] >= 0], i)\n);\n\nsolve :: int_search(array1d(1..X*Y,A),input_order,indomain_max,complete) satisfy;\n\noutput [\n    if fix(A[r, c]) = 1 then \" \" else \".\" endif ++ \n    if c = Y then \"\\n\" else \" \" endif\n    | r in 1..X, c in 1..Y\n];"}}, "nurses_expert": {"node_ids": ["0c874774-53da-446e-8309-de99c5d1bab3"], "metadata": {"model_name": "nurses", "source_code": "Model 1 : \n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint forall(d in DAY)\n                 (global_cardinality_low_up([x[n,d] | n in NURSE ],                                               [ day, night ], [ o, l ], [o, u])); \n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n\n\nModel 2 :\n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\nconstraint forall(d in DAY)\n                 (let {var int: on = sum(n in NURSE)\n                                        (bool2int(x[n,d]=night))        \n                      } in l <= on /\\ on <= u);\n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n"}}, "opd_expert": {"node_ids": ["3958f0e1-15cf-4742-b2ff-e9eedc06f4e0"], "metadata": {"model_name": "opd", "source_code": "%% Design of Collateralised Debt Obligations Squared (CDO^2) Transactions\n% An OPD (v, b, r) problem is to find a binary matrix of v rows\n% and b columns such that each row sums to r, and\n% the dot product beween any pair of distinct rows is minimal.\n\n%Requires MiniZinc >= 2.0.2 for the symmetry_breaking_constraint predicate\n\ninclude \"lex_greatereq.mzn\";\n\n%instance data\nint: v;\nint: b;\nint: r;\n\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\n\n%computing a lower bound for lambda\nint: rv = r*v;\nint: rvmodb = rv mod b;\nint: floorrv = rv div b;\nint: ceilrv = rv div b + bool2int(rv mod b != 0);\nint: num = (ceilrv*ceilrv*rvmodb+floorrv*floorrv*(b-rvmodb)-rv);\nint: denom = v*(v-1);\nint: lb_lambda = num div denom + bool2int( num mod denom !=0);\n\n% This line is there for debugging purposes, it can be safely removed\nint: tmp = trace(\"Computed lower bound for lambda: \"++show(lb_lambda)++\"\\n\",lb_lambda);\n\n\n% lambda is called objective for the MiniZinc Challenge\nvar lb_lambda..b: objective;\n\n\narray [rows, cols] of var 0..1: m;\n\n\n% Every row must sum to r.\nconstraint forall (i in rows) (sum (j in cols) (m[i, j]) = r);\n\n% The dot product of every pair of distinct rows must be at most lambda for an OPD and a PD, and equal to lambda for a BIBD\nconstraint forall (i_a, i_b in rows where i_a < i_b) (\n    sum (j in cols) (m[i_a, j] * m[i_b, j]) <= objective\n);\n\n\n% Break row symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(i in rows diff {max(rows)})(\n        lex_greatereq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    )\n);\n% Break column symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(j in cols diff {max(cols)})(\n        lex_greatereq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    )\n);\n\n\nsolve \n    :: seq_search([int_search([m[i, j] | i in rows, j in cols], input_order, indomain_max, complete),\n       \t\t   int_search([objective], input_order,indomain_min,complete)])\n    minimize objective; \n\n\n% Disabled the full solution. Printing only the objective value, lower bound, and parameters.\noutput  [\"opd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r), \"). Found lambda = \", show(objective),\"\\tlb: \", show(lb_lambda)]\n%       ++[\"\\n\\n\"] ++ \n%\t[ ( if j > b then \"\\n\" else \n%\t        if fix(m[i,j])=1 then \"*\" else \" \" endif\n%\t    endif )\n%       | i in rows, j in 1..(b + 1) ]\n;"}}, "partition_expert": {"node_ids": ["83c49095-65bd-4a89-8f76-47a1c13e22db"], "metadata": {"model_name": "partition", "source_code": "Model 1 : \n\n% Partitioning problem\n% Partition 2*n numbers into two groups, each of size n, such that\n% their sums are equal and the sums of their squares are equal.\n\ninclude \"globals.mzn\";\n\n% Instance\n\nn = 32;\n\n% Model\n\nint: n;\n\narray[1..n] of var 1..2*n: x;\narray[1..n] of var 1..2*n: y;\n\nconstraint true\n    %   Break symmetries by ordering numbers in each group\n    /\\  forall (i in 2..n) (x[i-1] < x[i] /\\ y[i-1] < y[i])\n    %   Break symmetries by ordering the groups\n    /\\  x[1] < y[1]\n    \n    %   Partition the numbers\n    /\\  (alldifferent(x++y)) :: bounds\n    \n    %   The sums are equal\n    /\\  sum (x) = 2*n*(2*n+1) div 4\n    /\\  sum (y) = 2*n*(2*n+1) div 4\n    \n    %   The sums of the squares are equal\n    /\\  let {\n            array[1..n] of var 1..4*n*n: sx,\n            array[1..n] of var 1..4*n*n: sy\n        } in\n        forall (i in 1..n) (sx[i]=x[i]*x[i] /\\ sy[i] = y[i]*y[i])\n    /\\  sum (sx) = 2*n*(2*n+1)*(4*n+1) div 12\n    /\\  sum (sy) = 2*n*(2*n+1)*(4*n+1) div 12\n;\n\nsolve ::int_search(x++y,first_fail,indomain_min,complete) satisfy;\n\noutput\n    [\"x = \",show(x),\"\\n\",\"y = \",show(y),\"\\n\",\n     \"sum = \",show(2*n*(2*n+1) div 4),\"\\n\",\n     \"sum of squares = \", show(2*n*(2*n+1)*(4*n+1) div 12), \"\\n\"\n     ];\n\n\n\nModel 2 :\n\n\n\n%\n% Set partition problem in Minizinc.\n%\n%  This is a partition problem.\n%  Given the set S = {1, 2, ..., n},\n%  it consists in finding two sets A and B such that:\n%  <ul>\n%  <li>A U B = S,</li>\n%  <li>|A| = |B|,</li>\n%  <li>sum(A) = sum(B),</li>\n%  <li>sum_squares(A) = sum_squares(B).</li>\n%  </ul>\n \n%\ninclude \"globals.mzn\";\n \nint: n = 16;\nset of 1..n: S = 1..n;\nint: num_sets = 2;\narray[1..num_sets] of var set of S: a;\narray[1..num_sets] of var 0..n*n: sums;\narray[1..num_sets] of var 0..n*n*n*n: sum_squared;\n \n \n%\n% set_sum\n% sums the elements in the set s\n%\npredicate set_sum(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i)\n;\n \npredicate set_sum_squared(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i*i)\n;\n \n \nsolve :: set_search(a, first_fail, indomain_min, complete) satisfy;\n% solve maximize sums[1];\n \nconstraint\n  assert(n mod 4 == 0, \"n must be a multiple of 4\")\n;\n \nconstraint\n   % use all the elements in S and it should be disjoint sets\n   partition_set(a, S)\n   /\\\n   forall(i in 1..num_sets) (  \n     a[i] `set_sum` sums[i]\n     /\\ a[i] `set_sum_squared` sum_squared[i]\n   )\n   /\\\n   forall(i in 2..num_sets) (\n     card(a[i]) > 0 /\\ % this is needed by eclipse\n     card(a[i]) = card(a[i-1]) /\\\n     sums[i] = sums[i-1]\n     /\\ sum_squared[i] = sum_squared[i-1]\n   )\n \n  % symmetry breaking\n  /\\ 1 in a[1]\n \n;\n \noutput [\n   \"a: \" ++ show(a) ++ \"\\n\" ++\n   \"sums: \" ++ show(sums) ++ \"\\n\" ++\n   \"sum_squared: \" ++ show(sum_squared) ++ \"\\n\"\n];\n \n% For model seeker\n% output [\n%    show(set2array(fix(a[i]))) ++ \",\"\n%   | i in 1..num_sets\n% ];"}}, "photo_expert": {"node_ids": ["e0ebe79c-abb1-4e23-b437-6d449a2c17fc"], "metadata": {"model_name": "photo", "source_code": "int:n ;\nset of int: PERSON = 1..n;\nset of int: POS = 1..n;\narray[PERSON,PERSON] of int: friend;\n\n%array[PERSON] of var POS: x;\narray[POS] of var PERSON: y;\n\n%include \"inverse.mzn\";\n%constraint inverse(x,y);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\n%constraint alldifferent(x);\n\n%y[i] = sum(j in 1..n)(bool2int(x[j] = i) * j);\n\nsolve maximize sum(i in 1..n-1)(friend[y[i],y[i+1]]);\n\n"}}, "project_scheduling_expert": {"node_ids": ["8707b1a8-f48d-47bb-b1a5-d4ecc7942266"], "metadata": {"model_name": "project_scheduling", "source_code": "Model 1 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\nconstraint forall(i in PREC)\n                 (start[pre[i,1]] + duration[pre[i,1]] <= start[pre[i,2]]);\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n\n\n\nModel 2 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\npredicate precedes(var int:s1, var int:d1, var int:s2)=\n          s1 + d1 <= s2; \n\nconstraint forall(i in PREC)\n                 (precedes(start[pre[i,1]],duration[pre[i,1]],start[pre[i,2]]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nset of TASK: CARPENTRY = { interior_walls, exterior_walls, roof };\nconstraint forall(t1, t2 in CARPENTRY where t1 < t2)\n      (nonoverlap(start[t1],duration[t1],start[t2],duration[t2]));\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n"}}, "QuasigroupCompletion_expert": {"node_ids": ["8fa9da72-3178-496b-a8bb-7b9c2b2baefe"], "metadata": {"model_name": "QuasigroupCompletion", "source_code": "Model 1 :\n\n% Quasigroup with Holes (aka Latin Square Completion)\n\ninclude \"alldifferent.mzn\";\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n\narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N] of var PuzzleRange: puzzle;\n\n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j] = start[i,j] else true endif );\n\n% All different in rows\nconstraint forall (i in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | j in PuzzleRange ] ) );\n\n% All different in columns.\nconstraint forall (j in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | i in PuzzleRange ] ) );\n\nsolve satisfy;\n\noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n \narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N, 1..N] of var 0..1: puzzle;\n \n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j, start[i,j]] = 1 else true endif );\n \n% All different in rows\nconstraint forall (i,k in PuzzleRange) (\n        sum(j in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% All different in columns\nconstraint forall (j,k in PuzzleRange) (\n        sum(i in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% Each cell must have a number assigned\nconstraint forall (i,j in PuzzleRange) (\n        sum(k in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\nsolve satisfy;\n \noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];"}}, "QuasiGroupExistence_expert": {"node_ids": ["e99eace8-e037-4cd6-a5d3-161e93a209b2"], "metadata": {"model_name": "QuasiGroupExistence", "source_code": "Model 1 :\n\n\n% Quasigroup problem in MiniZinc.\n% The quasiGroup existence problem\n% An m order quasigroup  is an mxm multiplication table of integers 1..m,\n% where each element occurrs exactly once in each row and column and certain\n% multiplication axioms hold (in this case, we want axiom 7 to hold).\n%\n% QG7.m problems are order m quasigroups for which (b*a)*b = a*(b*a).\n\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n% solve satisfy;\n \nconstraint\n      \n     % assign the \"reflected\" quasigroup to qGColumns to access its columns\n     %  forall row,col : nDomain .\n     %    quasiGroupColumns[col,row] = quasiGroup[row,col],\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % all values in the diagonals\n     forall( i in nDomain ) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n \n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row, col] | row in nDomain])\n     )\n     /\\\n \n     % this strange constraint\n     % corresponds to:\n     % quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i], j] \n     forall(i,j in nDomain) (\n              quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i],j]\n     )\n     /\\\n     % some implied? constraint\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n%\n% data\n%\nn = 5;\n\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 9; % solutions for n=5, n=9...\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n \nint: n = 4;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n \n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (i != j) ->\n         (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n \n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n \n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\n\nModel 4 :\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n \n     % Idempotency\n     % forall i : nDomain .\n     %     (quasiGroup[i,i] = i),\n \n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     % allDifferent(qgDiagonal) %,\n \n     % anti-Abelian\n     % forall i : nDomain .\n     %   forall j : nDomain .\n     %     (i != j) =>\n     %     (quasiGroup[i,j] != quasiGroup[j,i]),\n \n     % if (i*i)=j then (j*j) = i\n     % forall i : nDomain .\n     %  forall j : nDomain .\n     %    (quasiGroup[i,i]=j) => (quasiGroup[j,j]=i),\n \n \n     % Symmetry-breaking constraints   \n     % forall i : nDomain .\n     %      quasiGroup[i,n-1] + 2 >= i\n \n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n \n \n%\n% data\n%\nn = 4; % 4 works\n\n\nModel 5 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 6 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 5;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 7 :\n\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];"}}, "queens_expert": {"node_ids": ["357c8965-6b86-47fa-b009-3ed3d1921152"], "metadata": {"model_name": "queens", "source_code": "Model 1 :\n\n% n queens problem in MiniZinc.\n\ninclude \"globals.mzn\";\n\nint: n;\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail, \n        indomain_min, \n        complete) \n    satisfy;\n\n% solve satisfy;\n\nconstraint all_different(queens);\n\nconstraint\n    forall(i, j in 1..n where i < j) (\n         queens[i] != queens[j] /\\\n         queens[i] + i != queens[j] + j /\\\n         queens[i] - i != queens[j] - j\n    ) \n ;\n\noutput [\n  show(queens) ++ \"\\n\"\n\n];\n\n% data\nn = 8;\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n;\n\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail,\n        indomain_median,\n        complete\n       )\n     satisfy;\n\n% solve satisfy;\nconstraint all_different(queens); %  :: domain;\nconstraint all_different([queens[i]+i | i in 1..n]) :: domain;\nconstraint all_different([queens[i]-i | i in 1..n]) :: domain;\n\noutput \n[\n  \"queens: \" ++ show(queens)\n] ++ \n% [\n%   if j = 1 then \"\\n\" else \"\" endif ++\n%      if fix(queens[i]) = j then          \n%         show_int(2,j)\n%      else\n%         \"__\"\n%      endif\n%   | i in 1..n, j in 1..n\n% ] ++\n[\"\\n\"]\n;\n\n% data\nn = 8;\n\n\nModel 3 :\n\n\n\nint: n;                                 % The number of queens.\n\narray [1..n] of var 1..n: q;\n\ninclude \"alldifferent.mzn\";\n\nconstraint alldifferent(q);\nconstraint alldifferent(i in 1..n)(q[i] + i);\nconstraint alldifferent(i in 1..n)(q[i] - i);\n\n\nsolve \n%      :: int_search(q, input_order, indomain_min, complete) \n%      :: int_search(q, first_fail, indomain_min, complete) \n%      :: int_search(q, smallest, indomain_min, complete)\n%      :: int_search(q, largest, indomain_min, complete)\n%      :: int_search(q, input_order, indomain_max, complete) \n%      :: int_search(q, first_fail, indomain_max, complete) \n%      :: int_search(q, smallest, indomain_max, complete)\n%      :: int_search(q, largest, indomain_max, complete)\n%      :: int_search(q, input_order, indomain_median, complete) \n%      :: int_search(q, first_fail, indomain_median, complete) \n%      :: int_search(q, smallest, indomain_median, complete)\n%      :: int_search(q, largest, indomain_median, complete)\n%      :: int_search(q, input_order, indomain_random, complete) \n%      :: int_search(q, first_fail, indomain_random, complete) \n%      :: int_search(q, smallest, indomain_random, complete)\n%      :: int_search(q, largest, indomain_random, complete)\n      satisfy;\n\n%output\t\n%%\t[\tif fix(q[i]) = j then \"Q \" else \". \" endif ++\n%\t \tif j = n then \"\\n\" else \"\" endif\n%\t|\ti, j in 1..n\n%\t];\n"}}, "rcpsp_expert": {"node_ids": ["08783bbc-03d7-4e3a-b874-86e88f60d62e"], "metadata": {"model_name": "rcpsp", "source_code": "int: n; % number of tasks\nset of int: TASK = 1..n;\narray[TASK] of int: d; % duration\n\nint: m; % number of resources\nset of int: RESOURCE = 1..m;\narray[RESOURCE] of int: L; % resource limit\narray[RESOURCE,TASK] of int: res; % usage\n\nint: l; % number of precedences\nset of int: PREC = 1..l;\narray[PREC,1..2] of TASK: pre; % predecessor/successor pairs\n\nint: maxt; % maximum time\nset of int: TIME = 0..maxt;\n\narray[TASK] of var TIME: s; % start time\n\nconstraint forall(p in PREC)(s[pre[p,1]]+d[pre[p,1]] <= s[pre[p,2]]);\n\ninclude \"cumulative.mzn\";\nconstraint forall(r in RESOURCE)\n                 (cumulative(s,d,[res[r,t]|t in TASK],L[r]));\n%constraint forall(r in RESOURCE) \n%                 ( let { array[int] of var int: ss = \n%                              [ s[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: dd = \n%                              [ d[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: rr = \n%                              [ res[r,t] | t in TASK where res[r,t] > 0 ]; } in\n%                   cumulative(ss,dd,rr,L[r]));\n\nsolve minimize max(t in TASK)(s[t] + d[t]);\n\noutput [show(s)];\n\n\n"}}, "rehearsal_expert": {"node_ids": ["83c78238-65f7-4137-9f90-89c83d422f97"], "metadata": {"model_name": "rehearsal", "source_code": "%\n% Scheduling a Rehearsal in MiniZinc.\n% A concert is to consist of nine pieces of music of different durations\n% each involving a different combination of the five members of the orchestra.\n% Players can arrive at rehearsals immediately before the first piece in which\n% they are involved and depart immediately after the last piece in which\n% they are involved. The problem is to devise an order in which the pieces\n% can be rehearsed so as to minimize the total time that players are waiting\n% to play, i.e. the total time when players are present but not currently\n% playing. In the table below, 1 means that the player is required for\n% the corresponding piece, 0 otherwise. The duration (i.e. rehearsal time)\n% is in some unspecified time units.\n%\n%    Piece       1    2   3    4    5  6    7   8    9\n%    Player 1    1    1   0    1    0  1    1   0    1\n%    Player 2    1    1   0    1    1  1    0   1    0\n%    Player 3    1    1   0    0    0  0    1   1    0\n%    Player 4    1    0   0    0    1  1    0   0    1\n%    Player 5    0    0   1    0    1  1    1   1    0\n%    Duration    2    4   1    3    3  2    5   7    6\n%\n% For example, if the nine pieces were rehearsed in numerical order as\n% given above, then the total waiting time would be:\n%       Player 1: 1+3+7=11\n%       Player 2: 1+5=6\n%       Player 3: 1+3+3+2=9\n%       Player 4: 4+1+3+5+7=20\n%       Player 5: 3\n% giving a total of 49 units. The optimal sequence, as we shall see,\n% is much better than this.\n%\n% ...\n%\n% The minimum waiting time for the rehearsal problem is 17 time units, and\n% an optimal sequence is 3, 8, 2, 7, 1, 6, 5, 4, 9.\n%\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \n\n\nint: num_pieces;\nint: num_players;\narray[1..num_pieces] of int: duration;\narray[1..num_players, 1..num_pieces] of 0..1: rehearsal;\n\n\n%\n% Decision variables\n%\narray[1..num_pieces] of var 1..num_pieces: rehearsal_order;\narray[1..num_players] of var 0..sum(duration): waiting_time; % waiting time for players\narray[1..num_players] of var 1..num_pieces: p_from; % first rehearsal\narray[1..num_players] of var 1..num_pieces: p_to;   % last rehearsal\nvar 0..sum(duration): total_waiting_time = sum(waiting_time); % objective\n\nsolve :: int_search(\n         rehearsal_order % ++ waiting_time% ++ p_from ++ p_to ++ [total_waiting_time]\n         , \n         first_fail, % occurrence, % max_regret, % first_fail, \n         indomain_max, % indomain_max, \n         complete) \n     minimize total_waiting_time;\n     % satisfy;\n\n% solve :: labelling_ff minimize total_waiting_time;\n\nconstraint\n  all_different(rehearsal_order) :: domain\n  /\\\n\n  % This solution is my own without glancing at Smith's models...\n  forall(p in 1..num_players) (\n     % This versions is much faster than using exists (see below)\n     % fix the range from..to, i.e. don't count all that start with 0 \n     % or ends with 0.\n     % This means that we collect the rehearsals with many 0 at the ends\n     %\n     p_from[p] < p_to[p]\n     /\\\n     % skipping rehearsal at start (don't come yet)\n     forall(i in 1..num_pieces) (\n        i < p_from[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\\n     % skipping rehearsal at end (go home after last rehearsal)\n     forall(i in 1..num_pieces) (\n        i > p_to[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\ % and now: count the waiting time for from..to\n     waiting_time[p] = \n         sum(i in 1..num_pieces) (\n              duration[rehearsal_order[i]] * bool2int(\n                                             i >= p_from[p] /\\ i <= p_to[p] \n                                             /\\\n                                             rehearsal[p,rehearsal_order[i]] = 0\n                                )\n     ) \n\n%      % alternative solution with exists. \n%      %  More elegant (= declarative) in my book but slower.\n%      exists(from, to in 1..num_pieces) ( \n%         % skipping rehearsal at start (don't come yet)\n%         forall(i in 1..from-1) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\\n%         % skipping rehearsal at end (go home after last rehearsal)\n%         forall(i in to+1..num_pieces) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\ % and now: count the waiting time for from..to\n%         waiting_time[p] = \n%             sum(i in from..to) (\n%                  duration[rehearsal_order[i]]*\n%                                  bool2int(\n%                                       rehearsal[p,rehearsal_order[i]] = 0\n%                                   )\n%          ) \n%      )\n\n\n  )\n\n  /\\ % symmetry breaking\n  rehearsal_order[1] < rehearsal_order[num_pieces]\n\n  % for all solutions\n  % /\\ total_waiting_time = 17\n;\n\n\n%\n% data\n%\n%\n% num_pieces = 9;\n% num_players = 5;\n% duration = [2, 4, 1, 3, 3, 2, 5, 7, 6];\n% rehearsal = array2d(1..num_players, 1..num_pieces, \n%     [\n%      1,1,0,1,0,1,1,0,1,\n%      1,1,0,1,1,1,0,1,0,\n%      1,1,0,0,0,0,1,1,0,\n%      1,0,0,0,1,1,0,0,1,\n%      0,0,1,0,1,1,1,1,0\n%   ]);\n\n%\n% This is the problem from the Choco v 2.1 example \n% num_pieces = 5;\n% num_players = 3;\n% duration = [4,6,3,5,7];\n% rehearsal =  array2d(1..num_players, 1..num_pieces, \n%         [\n%         1,1,0,1,0,\n%         0,1,1,0,1,\n%         1,1,0,1,1   \n%   ]);\n\n\noutput[\n  \"order: \" , show(rehearsal_order), \"\\n\",\n  \"waiting_time: \", show(waiting_time), \"\\n\",\n  \"total_waiting_time: \" , show(total_waiting_time), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(rehearsal[p, rehearsal_order[j]]) ++ \" \"\n  | p in 1..num_players, j in 1..num_pieces, \n] ++ \n[\"\\n\"]\n;\n\n"}}, "restart_expert": {"node_ids": ["49baeef8-6e28-45cb-99df-864df0eea981"], "metadata": {"model_name": "restart", "source_code": "Model 1 : \n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n\nModel 2 :\n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_max, complete)\n      satisfy;\n\n\nModel 3 : \n\n\narray[1..10] of var 1..10:x;\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n"}}, "RosteringProblem_expert": {"node_ids": ["a7291c84-11ce-4d56-9ff4-af47346d9bdf"], "metadata": {"model_name": "RosteringProblem", "source_code": "include \"all_equal.mzn\";\ninclude \"global_cardinality.mzn\";\n\n% load parameters\ninclude \"parameters.dzn\";\n\nint: daysPerWeek = 7;\n\n% the number of weeks\nint: numberOfWeeks;\n\nint: numberOfDays = numberOfWeeks * daysPerWeek;\n\n% the minimum number of days in a row with the same shift\nint: s_min;\n\n% the maximum number of days in a row with the same shift\nint: s_max; \n\n% 3 shifts: early = 1, late = 2 and night shift = 3 + day off (rest day) = 0\nint: numberOfShifts = 3;\n\n% the shift requirement matrix, including at M_{i,j} the needed employees for day i and shift j\narray[1..daysPerWeek, 1..numberOfShifts+1] of int: shiftRequirements;\n\n\n% the variables X \narray[1..numberOfWeeks * daysPerWeek] of var 0..numberOfShifts: plan1d;\narray[1..numberOfWeeks,1..daysPerWeek] of var 0..numberOfShifts: plan2d;\narray[1..daysPerWeek,1..numberOfWeeks] of var 0..numberOfShifts: plan2dT;\n\n% helper arrays\narray[1..s_min,1..s_min] of var 0..numberOfShifts: s_min_arrays;\narray[1..s_max,1..s_max] of var 0..numberOfShifts: s_max_arrays;\n\n% convert the 2D plan into 1D\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan1d[(week-1) * daysPerWeek + day]\n           );  \n\n% transpose the 2D plan\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan2dT[day, week]\n           );\n\n% C_equalDays: constrains that weekend days (Saturday and Sunday) always have the same shift\nconstraint forall(week in 1..numberOfWeeks) (\n               plan2d[week, daysPerWeek - 1] == plan2d[week, daysPerWeek]\n           );                        \n\n                                                                                                                                \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_min, j in 1..s_min) (\n                 s_min_arrays[i, j] == plan1d[((numberOfDays - s_min - 1 + i + j) mod numberOfDays) + 1]\n           );                                            \n                                            \n% C_shiftRepetitions:for every shift type a minimum number of consecutive assignments to this shift is given\nconstraint forall(day in 1..numberOfDays - s_min) (\n               plan1d[day] != plan1d[day+1] -> all_equal(plan1d[day+1..day+s_min])\n           );     \n% the constraints over the array bounds           \nconstraint forall(d in 1..s_min) (\n               plan1d[d + numberOfDays - s_min] != plan1d[((d + numberOfDays - s_min) mod numberOfDays) +1] -> all_equal(s_min_arrays[d,1..s_min])\n           );                     \n\n           \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_max, j in 1..s_max) (\n                 s_max_arrays[i, j] == plan1d[((numberOfDays - s_max - 2 + i + j) mod numberOfDays) + 1]\n           );                      \n                                            \n% C_shiftRepetitions:for every shift type a maximum number of consecutive assignments to this shift is given           \nconstraint forall(day in 1..numberOfWeeks * daysPerWeek - s_max) (\n               (all_equal(plan1d[day..day+s_max])) -> (plan1d[day] != plan1d[day + s_max])\n           );               \n% the constraints over the array bounds             \nconstraint forall(d in 1..s_max) (\n               (all_equal(s_max_arrays[d, 1..s_max])) -> (plan1d[d + numberOfDays - s_max] != plan1d[d])\n           );                     \n\n                               \n                                                                                                   \n% C_restDays: at least 2 days must be rest days every 2 weeks.\nconstraint forall(day in 1..(numberOfWeeks - 2) * daysPerWeek) (\n               count(j in plan1d[day..day + daysPerWeek * 2])(j=0) >= 2                   \n           );            \nconstraint forall(i in 1..2 * daysPerWeek-1) (\n               count(j in plan1d[numberOfWeeks * daysPerWeek-i .. numberOfWeeks * daysPerWeek] ++ plan1d[1..2*daysPerWeek-i])(j=0) >= 2    \n           );         \n                                            \n% C_shiftOrder: restricts the order of shifts. There is a forward rotating principle. This means, that after an early shift there can only follow a shift with the same or a higher value, or a rest shift.\nconstraint forall(day in 2..numberOfWeeks * daysPerWeek - 1) (\n               plan1d[day] <= plan1d[day + 1] \\/ plan1d[day+1] == 0\n           );         \nconstraint plan1d[1] >= plan1d[numberOfDays] \\/ plan1d[1] == 0;\n                      \n% C_shiftRequirements: for every weekday for each shift the number of required staff is provided (e.g. usually less staff is required on the weekend) \nconstraint forall(day in 1..daysPerWeek) (\n              (global_cardinality(row(plan2dT,day),[0,1,2,3],row(shiftRequirements,day)))   \n           );    \n           \n% solve the problem           \nsolve :: int_search(plan1d, input_order, indomain_min, complete)\n      satisfy;           \n      \n% print the problem      \noutput [ show(row(plan2d,j)) ++ \"\\n\" | j in 1..numberOfWeeks ] ++ [\"\\n\"];      "}}, "sb_expert": {"node_ids": ["8cf6f982-34cd-43e6-a45a-efe4a0c40dc2"], "metadata": {"model_name": "sb", "source_code": "% Solitaire Battleships is a puzzle where\n% we are given a partially filled in board and the number\n% of ships in each row and column and have to fill it with ships\n \n% \"Improved\" version does not introduce reified set_in\n\nint: width;   % height of board (usually 10)\nint: height;  % width of board (usually 10)\nint: maxship; % maximal length of ship (usually 4)\n\n\nset of int: ROWS = 1..width;\nset of int: COLS = 1..height;\nset of int: XROWS = 0..width+1;    % extended rows\nset of int: XCOLS = 0..height+1;   % extended cols\n\n%% ship types enumerated type\nset of int: SHIPS = 1..maxship;  % different ship types\nint: submarine = 1;\nint: destroyer = 2;\nint: cruiser = 3;\nint: battleship = 4;\n\n\n%% the PIECES enumerated type!\nset of int: PIECES = 1..7;\nint: w = 1; % water\nint: c = 2; % circle (submarine)\nint: l = 3; % left end of ship\nint: r = 4; % right end of ship\nint: t = 5; % top of ship\nint: b = 6; % bottom of ship\nint: m = 7; % middle of ship\narray[PIECES] of string: code = [\".\",\"c\",\"l\",\"r\",\"t\",\"b\",\"m\"];\n\narray[ROWS,COLS] of 0..7: hint; % the initial board configuration\narray[ROWS] of int: rowsum;     % sums for each row\narray[COLS] of int: colsum;     % sums for each col\narray[SHIPS] of int: ship; % the number of each type of ship (usually [4,3,2,1]).\n\n\n\n% variables \narray[XROWS,XCOLS] of var PIECES: board;  % the board\n \narray[XROWS,XCOLS] of var 0..1: fill;     % which pieces are ships\n\narray[PIECES] of var 0..width*height: npiece; % number of pieces of each type\n\n\n% model\n\n% ensure hints are respected\nconstraint forall(i in ROWS, j in COLS)(\n\t\t\t   if hint[i,j] != 0 then\n\t\t\t   \t\tboard[i,j] == hint[i,j]\n\t\t\t   else true endif\n\t       ); \n\n% make extended rows and cols empty\nconstraint forall(i in XROWS)(board[i,0] == w /\\ board[i,width+1] == w);\nconstraint forall(j in COLS)(board[0,j] == w /\\ board[height+1,j] == w);\n\n% ensure that the fill array matches the board\nconstraint forall(i in XROWS, j in XCOLS)(\n\t\t\t   fill[i,j] = bool2int(board[i,j] != w)\n\t       ); \n\n% spacing constraints: gaps betwen ships\nconstraint forall(i in ROWS, j in COLS)(\n\t   (board[i,j] == w \\/ board[i+1,j+1] == w)\n\t/\\ (board[i,j] == w \\/ board[i+1,j-1] == w)   % diagonal constraints\n            /\\ (board[i,j] in {c,l,r,t} -> board[i-1,j] == w)\n            /\\ (board[i,j] in {c,l,r,b} -> board[i+1,j] == w)\n            /\\ (board[i,j] in {c,l,t,b} -> board[i,j-1] == w)\n            /\\ (board[i,j] in {c,r,t,b} -> board[i,j+1] == w)\n           );\n               \t\t\t                       \n% ship shape constraints\nconstraint forall(i in ROWS, j in COLS)(\n               %% a left piece needs a right piece or middle to the right\n\t\t\t   (board[i,j] == l -> (board[i,j+1] == r \\/ board[i,j+1] == m))\n\t\t\t/\\ (board[i,j] == r -> (board[i,j-1] == l \\/ board[i,j-1] == m))\n\t\t\t/\\ (board[i,j] == t -> (board[i+1,j] == b \\/ board[i+1,j] == m))\n\t\t\t/\\ (board[i,j] == b -> (board[i-1,j] == t \\/ board[i-1,j] == m))\n\t\t\t   %% a middle piece has to have two opposite sides filled\n\t\t\t/\\ (board[i,j] == m -> (   fill[i-1,j] == fill[i+1,j]\n\t\t\t                        /\\ fill[i,j-1] == fill[i,j+1]\n\t\t\t                        /\\ fill[i-1,j] + fill[i,j-1] == 1))\n\t\t   );\n\t\t   \n% sum up pieces\nconstraint forall(p in PIECES)(\n\t\t\t   sum(i in ROWS, j in COLS)(bool2int(board[i,j] == p)) == npiece[p]\n\t\t   );\n\n% piece sum constraints\nconstraint npiece[c] == ship[submarine]; % submarines\nconstraint npiece[l] == npiece[r]; % left right (probably redundant)\nconstraint npiece[t] == npiece[b]; % top bottom\nconstraint npiece[l] + npiece[t] == sum(s in destroyer..maxship)(ship[s]); \n                                   % no of ends\nconstraint npiece[m] == sum(s in cruiser..maxship)(ship[s] * (s - 2)); \n                                   % no of middles \t\t   \n\t\t    \n% count number of bigger ships\n% at least for standard battleships you can probably simply\n% enforce this constraint for s in destroyer..destroyer\t\t\n% and still be guaranteed a correct solution    \nconstraint forall(s in destroyer..maxship)(\n\t           sum(i in ROWS,j in COLS)(bool2int(\n\t\t\t       if j + s - 1 <= width then\n\t\t\t          board[i,j] == l /\\ board[i,j+s-1] == r     % ship length s lr\n\t\t\t       /\\ forall(k in j+1..j+s-2)(board[i,k] == m)\n\t\t\t       else false endif\n\t\t\t    \\/\n\t\t\t       if i + s - 1 <= height then\n\t\t\t          board[i,j] == t /\\ board[i+s-1,j] == b     % ship length s tb\n\t\t\t       /\\ forall(k in i+1..i+s-2)(board[k,j] == m)\n\t\t\t       else false endif\n\t\t       )) = ship[s]\n\t\t   );\t\t    \n\t\t    \t\t    \n\n% row sums respected\nconstraint forall(i in ROWS)(\n               sum(j in COLS)(fill[i,j]) == rowsum[i]\n           );\n           \n% column sums respected           \nconstraint forall(j in COLS)(\n               sum(i in ROWS)(fill[i,j]) == colsum[j]\n           );           \n\n\nsolve :: int_search([ fill[i,j] | i in ROWS, j in COLS], \n      \t\t  input_order, indomain_min, complete)\n      satisfy;\n\noutput [ code[fix(board[i,j])] ++ \n\t\t if j == width then \" \" ++ show(rowsum[i]) ++ \"\\n\"\n\t\t else \"\" endif\n\t   | i in ROWS, j in COLS ]  ++\n\t   [ show(colsum[j]) | j in COLS ] ++ [\"\\n\"];\n\t   \n"}}, "schur_expert": {"node_ids": ["460f7ffb-e565-4044-89e0-d75f71ae277d"], "metadata": {"model_name": "schur", "source_code": "%% schurs numbers\n%%\n%% determine if n balls labelled 1..n\n%% can be placed in c boxes with no box containing a triple {x,y,z} where x+y=z\n \n\nint: n; %% number of balls\nint: c; %% number of boxes\n\narray[1..n] of var 1..c: box;\n\nconstraint forall(i in 1..n-1, j in i+1 .. n - i)(\n\t   \t    box[i] != box[j] \\/ \n\t\t    box[i] != box[i+j] \\/ \n\t\t    box[j] != box[i+j]);\n\nsolve satisfy;\n\noutput [\"n = \", show(n), \";\\nc = \", show(c), \";\\nbox = \",show(box),\";\\n\"];\n"}}, "setselect_expert": {"node_ids": ["876feadd-53f7-4f0c-8921-433be12f81b2"], "metadata": {"model_name": "setselect", "source_code": "Model 1 :\n\n\n% setselect\nint: n; % number of elements\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 2 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\nconstraint card(x) = u;\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 3 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 1..n: x;\n%constraint forall(i in 1..u-1)(x[i] < x[i+1]);\nconstraint forall(i,j in 1..u where i < j)(x[i] != x[j]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 4 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality bound of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 0..n: x;\nconstraint forall(i in 1..u-1)(x[i] >= (x[i] != 0) + x[i+1]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n"}}, "shipping_expert": {"node_ids": ["617ba7f2-d498-436c-b09c-8dd5138ac1fa"], "metadata": {"model_name": "shipping", "source_code": "int: W; % number of Warehousse\nset of int: WARE = 1..W;\nint: F; % number of Factories\nset of int: FACT = 1..F;\n\narray[WARE] of int: demand;\narray[FACT] of int: production;\n\narray[FACT,WARE] of int: cost;\n\narray[FACT,WARE] of var int: ship;\n\n%int: m = max(demand);\n%array[FACT,WARE] of var 0..m: ship;\nconstraint forall(f in FACT, w in WARE)(ship[f,w] >= 0);\n\nconstraint forall(w in WARE)\n                 (sum(f in FACT)(ship[f,w]) >= demand[w]);\n\nconstraint forall(f in FACT)\n                 (sum(w in WARE)(ship[f,w]) <= production[f]);\n\nsolve minimize sum(f in FACT, w in WARE)\n                  (cost[f,w]*ship[f,w]);\n\n\noutput [ show_int(2,ship[f,w]) ++\n         if w == W then \"\\n\" else \" \" endif\n       | f in FACT, w in WARE ];"}}, "simple-prod-planning_expert": {"node_ids": ["867da411-7ed7-4a06-a382-6f160274173b"], "metadata": {"model_name": "simple-prod-planning", "source_code": "% Number of different products\nint: nproducts; \nset of int: Products = 1..nproducts;  \n\n%profit per unit for each product\narray[Products] of int: profit;\narray[Products] of string: pname; \n\n%Number of resources\nint: nresources; \nset of int: Resources = 1..nresources; \n\n%amount of each resource available\narray[Resources] of int: capacity; \narray[Resources] of string: rname;\n\n%units of each resource required to produce 1 unit of product\narray[Products, Resources] of int: consumption; \nconstraint assert(forall (r in Resources, p in Products) \n           (consumption[p,r] >= 0), \"Error: negative consumption\");\n\n% bound on number of Products\nint: mproducts = max (p in Products) \n                     (min (r in Resources where consumption[p,r] > 0) \n                          (capacity[r] div consumption[p,r]));\n\n% Variables: how much should we make of each product\narray[Products] of var 0..mproducts: produce;\narray[Resources] of var 0..max(capacity): used;\n\n% Production cannot use more than the available Resources:\nconstraint forall (r in Resources) (     \n      used[r] = sum (p in Products)(consumption[p, r] * produce[p]) \n      /\\ used[r] <= capacity[r]\n);    \n\n% Maximize profit\nsolve maximize sum (p in Products) (profit[p]*produce[p]);\n\noutput [ show(pname[p]) ++ \" = \" ++ show(produce[p]) ++ \";\\n\" |\n         p in Products ] ++\n       [ show(rname[r]) ++ \" = \" ++ show(used[r]) ++ \";\\n\" |\n         r in Resources ];"}}, "sonet_problem_expert": {"node_ids": ["31e6c7ce-b4df-43f0-afa9-b61624bd36c3"], "metadata": {"model_name": "sonet_problem", "source_code": "% The SONET problem is a network design problem: set up a network between\n% n nodes, where only certain nodes require a connection.\n% Nodes are connected by putting them on a ring, where all nodes\n% on a ring can communicate. Putting a node on a ring requires a so-called\n% ADM, and each ring has a capacity of nodes, i.e. ADMs. There is a certain\n% amount of rings, r, that is available. The objective is to set up a network\n% by using a minimal amount of ADMs.\n%\n%\n% About the problem model\n%\n% The problem model has the amount of rings ('r'), amount of nodes('n'),\n% the 'demand' (which nodes require communication) and node-capacity of each\n% ring ('capacity_nodes') as parameters.\n% The assignement of nodes to rings is modelled by a 2-dimensional matrix 'rings',\n% indexed by the amnount of rings and nodes. The matrix-domain is boolean:\n% If the node in column j is assigned to the ring in row i, then rings[i,j] = 1\n% and 0 otherwise. So all the '1's in the matrix 'rings' stand for an ADM.\n% Hence the objective is to minimise the sum over all columns and rows of matrix\n% 'rings'.\n% \"\"\"\n\nint: r;  % upper bound for amount of rings\nint: n;  % amount of clients\n\n\n% original comment: \n% we have double entries here because of the symmetric structure!\narray[1..n, 1..n] of 0..1: demand;\narray[1..r] of 1..n: capacity_nodes;\n\narray[1..r, 1..n] of var 0..1: rings;\nvar int: z =  sum(ring in 1..r, client in 1..n) (rings[ring, client]);\n\nsolve minimize z;\n% solve satisfy;\n\n\nconstraint\n%   z <= 7 % for solve satisfy\n%   /\\\n\n   % original comment:\n   % if there is a demand between 2 nodes, then there has to exist \n   % a ring, on which they are both installed\n   forall(client1,client2 in 1..n where client1 < client2) (\n      (demand[client1,client2] = 1) ->\n           exists(ring in 1..r) (\n                 rings[ring,client1] + rings[ring, client2] >= 2\n           )\n   )   \n   /\\\n   % original comment:\n   % capacity of each ring must not be exceeded     \n   forall(ring in 1..r) (\n        sum(client in 1..n) (\n              rings[ring, client]\n              ) <= capacity_nodes[ring] \n   )\n;\n\n\n%\n% data\n% (sonet_problem1nu.param)\n%\nr = 4;\nn = 5;\n\ndemand =\narray2d(1..n, 1..n,\n        [0,1,0,1,0,\n         1,0,1,0,0,\n         0,1,0,0,1,\n         1,0,0,0,0,\n         0,0,1,0,0])\n;\n\ncapacity_nodes = [3,2,2,1];\n\n\noutput \n[\n  \"z: \", show(z)\n] ++\n[\n  if client = 1 then \"\\n\" else \" \" endif ++\n    show(rings[ring, client])\n  | ring in 1..r, client in 1..n\n] ++ [\"\\n\"];\n"}}, "square_pack_expert": {"node_ids": ["a8b9b47b-08cd-4c22-ab76-cfed35152b91"], "metadata": {"model_name": "square_pack", "source_code": "int: n; % number of squares\nset of int: SQUARE = 1..n;\nint: maxl = sum(i in SQUARE)(i);\nint: mina = sum(i in SQUARE)(i*i);\n\nvar n..maxl: height;\nvar n..maxl: width;\nvar mina .. n*maxl: area = height * width;\n\narray[SQUARE] of var 0..maxl: x;\narray[SQUARE] of var 0..maxl: y;\n\n% squares fit in the rectangle\nconstraint forall(s in SQUARE)(x[s] + s <= width);\nconstraint forall(s in SQUARE)(y[s] + s <= height);\n\n% non overlap\nconstraint forall(s1, s2 in SQUARE where s1 < s2)\n                 (x[s1] + s1 <= x[s2] \\/\n                  x[s2] + s2 <= x[s1] \\/  \n                  y[s1] + s1 <= y[s2] \\/ \n                  y[s2] + s2 <= y[s1]);\narray[SQUARE] of int: size = [ i | i in SQUARE ];\n\n% non overlap with global diffn\ninclude \"diffn.mzn\";\n%constraint diffn(x,y,size,size);\n\n% redundant cumulative constraints\ninclude \"cumulative.mzn\";\n%constraint cumulative(x,size,size,height);\n%constraint cumulative(y,size,size,width);\n\n% variables ordered in reverse size x[n], y[n], x[n-1], y[n-1], ..., x[1], y[1]\n%array[1..2*n] of var 0..maxl: vs = [ if i mod 2 = 0 then x[n+1 - i div 2] \n%                                     else y[n+1 - i div 2] endif | i in 2..2*n+1 ];\n\nsolve :: seq_search([\n         int_search([area,height,width], input_order, indomain_min, complete) \n         %,int_search(vs, input_order, indomain_min, complete)\n         ])\n      minimize area;\n\noutput [\"area = \",show(area), \"\\n\"] ++\n[\"height = \",show(height), \"\\n\"] ++\n[\"width = \",show(width), \"\\n\"] ++\n[\"x = \", show(x), \"\\n\"] ++\n[\"y = \", show(y), \"\\n\"];\n"}}, "stableroommates_expert": {"node_ids": ["c1852542-f99e-4272-b2fc-8592ff768941"], "metadata": {"model_name": "stableroommates", "source_code": "Model 1 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\nset of int: AGENT0 = 0..n;    % zero indicates no agent\narray[AGENT,1..n-1] of AGENT0: pref; % preference order for each agent\n     % the preference order is padded by zeros\narray[AGENT] of int: npref = [ sum(j in 1..n-1)(bool2int(pref[i,j] > 0))\n                             | i in AGENT ];\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..n-1)\n                               (pref[i,j] != i /\\ \n                                (pref[i,j] = 0 <-> j > npref[i])) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref[i,j1] != pref[i,j2]),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n%% ranking information: rank = 0 means not ranked\narray[AGENT,AGENT] of 0..n-1: rank = \n     array2d(AGENT,AGENT, [ max([bool2int(pref[i1,j] = i2) * j | j in 1..n-1])\n                          | i1, i2 in AGENT ]);\n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] > rank[i,j] -> a[j] < rank[j,i]\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] = rank[i,j] -> a[j] = rank[j,i]\n                 );\n\nsolve satisfy;\n\noutput  [ if i < fix(pref[i,a[i]]) then \"(\" ++ show(i) ++ \",\" ++ show(pref[i,a[i]]) ++ \")\\n\"\n          else \"\" endif\n        | i in AGENT ]\n       ++ [show(rank),\"\\n\"] \n %      ++ [show(npref),\"\\n\"] \n %      ++ [show(a),\"\\n\"]\n        ;\n       \n\n\nModel 2 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\n\narray[AGENT] of int: npref; % number of preferences of each agent\narray[AGENT] of int: cum_npref = [ sum(j in 1..i-1)(npref[j]) | i in AGENT];\narray[1..sum(npref)] of int: preferences;  % all preferences in one list\n\nfunction AGENT: pref(AGENT: i, 1..n-1: j) = \n         assert(j in 1..npref[i], \"Called pref(\" ++ show(i) ++ \",\" ++ show(j) ++ \") too large preference\\n\",\n         preferences[cum_npref[i] + j]);\n\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..npref[i])\n                               (pref(i,j) != i) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref(i,j1) != pref(i,j2)),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n\n\n%% ranking information: rank = 0 means not ranked but shoulnt occur!\nfunction 0..n-1: rank(AGENT: i1, AGENT: i2) = \n                 max([bool2int(pref(i1,j) = i2) * j | j in 1..npref[i1]]); \n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] > rank(i,j) -> a[j] < rank(j,i)\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] = rank(i,j) -> a[j] = rank(j,i)\n                 );\n\nsolve satisfy;\n\n   output  [ if fix(a[i]) < npref[i] /\\ i < pref(i,fix(a[i]))\n             then \"(\" ++ show(i) ++ \",\" ++ show(pref(i,fix(a[i]))) ++ \")\\n\"\n             else \"\" endif\n           | i in AGENT ]\n %      ++ [show(rank),\"\\n\"] \n       ++\n       [show(npref),\"\\n\"] \n       ++ [show(a),\"\\n\"]\n        ;\n       \n\n"}}, "steiner_expert": {"node_ids": ["fbdc559a-d050-4322-8f15-1de559c2d56f"], "metadata": {"model_name": "steiner", "source_code": "% The ternary Steiner problem of order n is to find n(n-1)/6 sets of elements in {1,2,...,n}\n% such that each set contains three elements and any two sets have at most one element in common.\n% For example, the following shows a solution for size n=7:\n%\n%      {1,2,3}, {1,4,5}, {1,6,7}, {2,4,6}, {2,5,7}, {3,4,7}, {3,5,6}\n\ninclude \"globals.mzn\";\n\nint: N = 7; \nint: NB = N *(N-1) div 6;\narray[1..NB] of var set of 1..N: Sets;\n\n% solve satisfy;\nsolve::set_search(Sets, first_fail, indomain_min, complete) satisfy;\n\n\n\nconstraint\n   forall(i in index_set(Sets)) (\n      card(Sets[i]) = 3\n   )\n   /\\ \n   forall(i,j in index_set(Sets) where i < j) (\n      card( Sets[i] intersect Sets[j]) <= 1\n   )\n   /\\ % symmetry breaking\n   decreasing(Sets)\n\n;\n\noutput [\n       \"N: \", show(N), \" NB: \", show(NB), \"\\n\",\n       \"Sets: \", show(Sets)\n];\n\n"}}, "stoch_fjsp_expert": {"node_ids": ["fe19315d-e90b-4f06-b8b4-500c32dd0fa8"], "metadata": {"model_name": "stoch_fjsp", "source_code": "% Stochastic General Assignment Problem \n% First stage:\n%    assign task to machines \n% Second stage:\n%    based on observed processign times, schedule taks on respective machines\n% Objective:\n%    minimise expected makespan\n\ninclude \"globals.mzn\";\n\n% Parameters\n\nint: no_mach;   % Number of machines\nint: no_jobs;   % Number of jobs\nint: no_task;   % Number of total tasks\nint: no_optt;   % Number of total optional tasks\n\nset of int: Mach  = 1..no_mach;\nset of int: Jobs  = 1..no_jobs;\nset of int: Tasks = 1..no_task;\nset of int: OptTs = 1..no_optt;\n\narray [Jobs] of set of int: tasks;\narray [Tasks] of set of int: optts;\n\narray [OptTs] of int: optt_mach;\narray [SCENARIOS1,OptTs] of int: optt_dur;\n\n\narray [Jobs] of int: last_task = [ max(tasks[j]) | j in Jobs ];\n%---------implications for multi scenarion solving ---------------\nint: nbScenarios;\nset of int: SCENARIOS1 = 1..nbScenarios;\nint: first_scen;\nint: last_scen;\nset of int: SCENARIOS = first_scen..last_scen;\narray[SCENARIOS1] of int: weights;\n\n%-------end of multi scenario addons ----------------\narray [Tasks] of int: task_job = \n    [ min(j in Jobs where t in tasks[j])(j) | t in Tasks ];\narray [SCENARIOS,Tasks] of int: task_mins =\n    array2d(SCENARIOS,Tasks,[ sum(k in tasks[task_job[t]])(if k < t then task_mind[s,k] else 0 endif)\n    |   s in SCENARIOS, t in Tasks ]);\narray [SCENARIOS,Tasks] of int: task_maxs =\n    array2d(SCENARIOS,Tasks,[ t_max[s] -\n        sum(k in tasks[task_job[t]])(if k < t then 0 else task_mind[s,k] endif)\n    |   s in SCENARIOS,  t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_mind =\n    array2d(SCENARIOS,Tasks,[ min(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS,t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_maxd = \n    array2d(SCENARIOS,Tasks,[ max(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS, t in Tasks ]);\n\n    % Additional deirved parameters for optional tasks\n    %\narray [OptTs] of int: optt_task =\n    [ min(t in Tasks where o in optts[t])(t) | o in OptTs ];\n\narray[SCENARIOS1] of int: min_dur = [ min([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\narray[SCENARIOS1] of int: max_dur = [ max([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\nset of int: Durs = min(min_dur)..max(max_dur);\n\n    % Parameters related to the planning horizon\n    %\narray[SCENARIOS1] of int: t_max = [sum(t in Tasks)(max(o in optts[t])(optt_dur[s,o])) | s in SCENARIOS1];\n\nset of int: Times = 0..max(t_max);\n\n%-----------------------------------------------------------------------------%\n% Variables\n\n    % Start time variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Times: start =\n    array2d(SCENARIOS,Tasks,[ let { var task_mins[s,t]..task_maxs[s,t]: k } in k | s in SCENARIOS, t in Tasks ]);\n\n    % Duration variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Durs: dur =\n    array2d(SCENARIOS,Tasks,[ if task_mind[s,t] = task_maxd[s,t] then task_mind[s,t] else\n        let { var task_mind[s,t]..task_maxd[s,t]: d } in d endif\n    |   s in SCENARIOS,t in Tasks ]);\n\n    % Variables whether an optional task is executed\n    %\narray [OptTs] of var bool: b;\n\narray[SCENARIOS] of var Times: de_objective;\n\nset of int: StochTimes = 0..sum(t_max);\nvar StochTimes: objective;\n%-----------------------------------------------------------------------------%\n% Constraints\n\n    % Precedence relations\n    %\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs, i in tasks[j] where i < last_task[j])(\n            start[s,i] + dur[s,i] <= start[s,i + 1]\n        )    \n    );\n\n    % Duration constraints\n    %\nconstraint\n    forall(o in OptTs,s in SCENARIOS)(\n        let { int: t = optt_task[o] } in (\n            if card(optts[t]) = 1 then\n                b[o] = true\n            else\n                b[o] -> dur[s,t] = optt_dur[s,o]\n            endif\n        )\n    );\n\n    % Optional tasks' constraints\n    %\nconstraint\n    forall(t in Tasks where card(optts[t]) > 1)(\n        ( sum(o in optts[t])(bool2int(b[o])) <= 1     )\n    /\\  ( exists(o in optts[t])(b[o])                 )\n    );\n\nconstraint\n    forall(t in Tasks where card(optts[t]) = 2)(\n        let {\n            int: o1 = min(optts[t]),\n            int: o2 = max(optts[t])\n        } in ( b[o1] <-> not(b[o2]) )\n    );\n\n    % Resource constraints\n    %\nconstraint\n    forall(m in Mach,s in SCENARIOS)(\n        let {\n            set of int: MTasks = { o | o in OptTs where optt_mach[o] = m }\n        } in (\n            cumulative(\n                [ start[s,optt_task[o]] | o in MTasks ],\n                [ optt_dur[s,o]         | o in MTasks ],\n                [ bool2int(b[o])      | o in MTasks ],\n                1\n            )\n        )\n    );\n\n% Objective constraint\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs)(start[s,last_task[j]] + dur[s,last_task[j]] <= de_objective[s])\n    );\nconstraint \n        objective = sum(s in SCENARIOS)(weights[s]*de_objective[s]);\n%-----------------------------------------------------------------------------%\n% Solve item\n\nsolve \n    :: search\n    minimize objective;\n\n%------------------------------------------------------------------------------%\n% Searches\n\nann: s_mindur   = int_search([dur[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_minstart = int_search([start[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_bool     = bool_search(b, input_order, indomain_max, complete);\nann: s_obj      = int_search(de_objective, input_order, indomain_min, complete);\n\nann: search = seq_search([s_mindur, s_bool, s_minstart, s_obj]);\n\n%-----------------------------------------------------------------------------%\n% Output\n\noutput \n[   \"objective = \", show(de_objective), \";\\n\",\n    \"stoch obj = \", show(objective), \";\\n\",\n    \"start = \", show(start), \";\\n\",\n    \"dur = \", show(dur), \";\\n\",\n    \"b = \", show(b), \";\\n\",\n];\n"}}, "submultisetsum_expert": {"node_ids": ["6c154017-4684-4517-834f-7068e5ad220b"], "metadata": {"model_name": "submultisetsum", "source_code": "% subsetsum problem\narray[int] of int: number;\nint: target;\n\nset of int: NUMBER = index_set(number);\nvar set of NUMBER: selected;\n\nconstraint sum(i in selected)\n              (number[i]) = target;\nsolve satisfy;\n\noutput [show(selected)];"}}, "table_seating_expert": {"node_ids": ["3b3c979f-d158-4329-923a-fbc8c642b276"], "metadata": {"model_name": "table_seating", "source_code": "Model 1 :\n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n          forall(t in TABLE)(not ({p1,p2} subset table[t]));\n\nconstraint forall(t in TABLE)(card(table[t]) <= S);\n\nconstraint forall(p in PERSON)(exists(t in TABLE)(p in table[t]));\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))\n                  ( let { var TABLE: tn1 = sum(t in TABLE)(t * bool2int(couples[c,1] in table[t]));\n                          var TABLE: tn2 = sum(t in TABLE)(t * bool2int(couples[c,2] in table[t]));\n                    } in  tn1 + tn2);\n\n\n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n\n\n\nModel 2 : \n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\narray[PERSON] of var TABLE: seat;\n\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n                        seat[p1] != seat[p2];\n\nconstraint global_cardinality_low_up(seat, [t|t in TABLE], [0|t in TABLE], [S|t in TABLE]);\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))(seat[couples[c,1]] + seat[couples[c,2]]);\n\nconstraint forall(t in TABLE, p in PERSON)(p in table[t] <-> seat[p] = t);    \n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n"}}, "teamselect_expert": {"node_ids": ["cf86ef0c-8b0f-41bb-99e9-f503b64a75c0"], "metadata": {"model_name": "teamselect", "source_code": "Model 1 :\n\n\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\narray[CAPTAIN] of var set of PLAYER: team = [Xavier,Yuri,Zena];\n\nset of int: CAPTAIN = 1..3;\narray[CAPTAIN,PLAYER] of int: value;\n \nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |]; \n\nconstraint card(Xavier intersect GOALIE) >= 1;\nconstraint card(Xavier intersect DEFENCE) >= 2;\nconstraint card(Xavier intersect OFFENCE) >= 2;\nconstraint card(Xavier) = 6;\n\n\nconstraint card(Yuri intersect GOALIE) >= 1;\nconstraint card(Yuri intersect DEFENCE) >= 2;\nconstraint card(Yuri intersect OFFENCE) >= 2;\nconstraint card(Yuri) = 6;\n\nconstraint card(Zena intersect GOALIE) >= 1;\nconstraint card(Zena intersect DEFENCE) >= 2;\nconstraint card(Zena intersect OFFENCE) >= 2;\nconstraint card(Zena) = 6;\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nsolve maximize obj;\n\nvar int: obj = sum(c in CAPTAIN)(sum(p in team[c])(value[c,p]));\n\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n\n\nModel 2 :\n\n\n% team select problem\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\nset of int: CAPTAIN = 1..3;\nint: xavier = 1; int: yuri = 2; int: zena = 3;\narray[CAPTAIN,PLAYER] of int: value;\nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |];\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\npredicate correct_team(var set of PLAYER: team) = \n          card(team) = 6 /\\ \n          card(team intersect GOALIE) >= 1 /\\\n          card(team intersect DEFENCE) >= 2 /\\\n          card(team intersect OFFENCE) >= 2;\n\nconstraint correct_team(Xavier) /\\ correct_team(Yuri) /\\ correct_team(Zena);\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nvar int: obj = sum(p in Xavier)(value[xavier,p]) +\n               sum(p in Yuri)(value[yuri,p]) +\n               sum(p in Zena)(value[zena,p]);\n\nsolve maximize obj;\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n"}}, "template_design_expert": {"node_ids": ["117c106b-5043-469c-8a54-a0b261e29310"], "metadata": {"model_name": "template_design", "source_code": "% Template design\ninclude \"globals.mzn\";\n\nint: S;   \t\t% Number of slots per template.\nint: t;   \t\t% Number of templates.\nint: n;   \t\t% Number of variations.\narray[1..n] of int: d; \t% How much of each variation we must print?\n\n% Lower and upper bounds for the total production.\n%\nint: llower = ceil(sum(i in 1..n)(int2float(d[i]))/int2float(S));\nint: lupper = 2*llower; % If t>1, this should be the optimal Production_{t-1}-1.\n\n% # Slots allocated to variation i in template j\narray[1..n,1..t] of var 0..S: p;\n\n% # Pressings of template j.\narray[1..t] of var 1..lupper: R;\n\n% Sum of all Rj.\nvar llower..lupper: Production;\n\n% Production x S - sum(d[i])\nvar 0..lupper-llower: Surplus;\n\n% First, set up Production to be the sum of the Rj\nconstraint\n\tProduction = sum(i in 1..t)(R[i]);\n\n% the limits on production\nconstraint\n\tProduction >= llower /\\ Production <= lupper;\n\n% The number of slots occupied in each template is S.\nconstraint\n\tforall(j in 1..t)\n\t\t (sum(i in 1..n)(p[i,j]) = S);\n\n% Enough of each variation is printed.\nconstraint\n\tforall(i in 1..n)\n\t\t (sum(j in 1..t)(p[i,j]*R[j]) >= d[i]);\n\n% Symmetry constraints.\n% Variations with the same demand are symmetric.\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] == d[i+1] then\n\t\t\tlex_lesseq([p[i,  j] | j in 1..t],\n\t\t\t\t[p[i+1,j] | j in 1..t])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% pseudo symmetry\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] < d[i+1] then\n\t\t       sum (j in 1..t) (p[i,j]*R[j])\n\t\t     <= sum (j in 1..t) (p[i+1,j]*R[j])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% implied constraints on the surplus\n\n% These are presented in the paper as necessary to get good\n% performance for this model, but I think bounds consistency on the\n% sum(R[i]) constraint would produce the same amount of propagation\n\n% Set up surplus, which is bounded as production is bounded.\nconstraint\n\tSurplus = Production*S - sum(i in 1..n)(d[i]);\n\n% The surplus of each variation is also limited by the surplus.\nconstraint\n\tforall(k in 1..n)\n\t\t (sum(j in 1..t)(p[k,j]*R[j]-d[k]) <= Surplus);\n\n% The surplus of the first k variations is limited by the surplus.\nconstraint\n\tforall(k in 2..n-1)\n\t\t (sum(j in 1..t, m in 1..k)( p[m,j]*R[j]-d[m] ) <= Surplus);\n\n% Implied constraints on the run length.\nconstraint\n\tif t=2 then (\n\t\tR[1] <= Production div 2\n\t/\\\tR[2] >= Production div 2\n\t) else true endif;\n\nconstraint\n\tif t=3 then (\n\t\tR[1] <= Production div 3\n\t/\\\tR[2] <= Production div 2\n\t/\\\tR[3] >= Production div 3\n\t) else true endif;\n\n% Minimize the production.\nsolve :: int_search(array1d(1..n*t,p) ++ R, input_order, indomain_min, complete)\n    minimize Production;\n\noutput [\n    if v = 1 then \"template #\" ++ show(i) ++ \": [\" else \"\" endif ++\n    show(p[v, i]) ++\n    if v = n then \"], pressings: \" ++ show(R[i]) ++ \"\\n\" else \", \" endif\n\t| i in 1..t, v in 1..n]\n    ++ [\"Total pressings: \", show(Production), \"\\n%\\n\"];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%\n"}}, "toomany_expert": {"node_ids": ["9c59ce8f-ee1f-442f-9a85-64e809abb3a9"], "metadata": {"model_name": "toomany", "source_code": "%% TooMany.mzn (too many solutions)\nint: n; % number of machines\nset of int: MACHINE = 1..n;\nint: k; % production per day\nint: red = 1; int: white = 2; int: black = 3; int: blue = 4;\nset of int: COLOR = 1..4;\narray[COLOR] of int: l; % lower bound on production\narray[COLOR] of int: u; % upper bound on production\n\narray[MACHINE,COLOR] of var 0..k div 2: produce;\n\nconstraint forall(m in MACHINE)\n                 (sum(c in COLOR)(produce[m,c]) <= k);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) >= l[c]);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) <= u[c]);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] > 0 /\\ produce[m,black] > 0 -> produce[m,blue] = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,blue] <= produce[m,red]);\nconstraint forall(m in MACHINE)\n                 (produce[m,red] mod 4 = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] mod 3 = 0);\n\n\nsolve maximize sum(m in MACHINE, c in COLOR)(produce[m,c]);\n\noutput [ show_int(3,produce[m,c]) ++\n         if c = 4 then \"\\n\" else \" \" endif\n       | m in MACHINE, c in COLOR ];\n\nn = 4;\nk = 11;\nl = [8,7,10,6];\nu = [14,16,12,20];\n\n"}}, "traffic_lights_table_expert": {"node_ids": ["13f2cb95-7177-43ef-bd2e-460a083aca31"], "metadata": {"model_name": "traffic_lights_table", "source_code": "Model 1 :\n\n%Traffic lights problem in MiniZinc.\n% Specification:\n% Consider a four way traffic junction with eight traffic lights. Four of\n% the traffic lights are for the vehicles and can be represented by the\n% variables V1 to V4 with domains\n% {r,ry,g,y} (for red, red-yellow, green and yellow).\n%  The other four traffic lights are for the pedestrians and can be\n%  represented by the variables P1 to P4 with domains {r,g}.\n%\n% The constraints on these variables can be modelled by quaternary\n% constraints on\n% (Vi, Pi, Vj, Pj ) for 1<=i<=4, j=(1+i)mod 4 which allow just the tuples\n% {(r,r,g,g), (ry,r,y,r), (g,g,r,r), (y,r,ry,r)}.\n%\n% It would be interesting to consider other types of junction (e.g. five roads\n% intersecting) as well as modelling the evolution over time of the\n% traffic light sequence.\n\ninclude \"globals.mzn\";\n\nint: n = 4;\nint: r  = 1; % red\nint: ry = 2; % red-yellow\nint: g  = 3; % green\nint: y  = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V;\narray[1..n] of var Pedestrians: P;\n\n\nsolve satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   table([V[i], P[i], V[j], P[j]], allowed)\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\n% output [\n%  \"V: \", show(V), \"\\nP: \", show(P), \"\\n\"\n% ];\noutput [\n show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: n = 4;\nint: r = 1; % red\nint: ry = 2; % red-yellow\nint: g = 3; % green\nint: y = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V; % ;\narray[1..n] of var Pedestrians: P; %;\n\npredicate cp1d(array[int] of var int: x, array[int] of var int: y) =\n  assert(index_set(x) = index_set(y),\n           \"cp1d: x and y have different sizes\",\n     forall(i in index_set(x)) ( x[i] = y[i] ))\n; \n\n% solve satisfy;\nsolve :: int_search(V ++ P, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   exists(a in 1..4) (\n      cp1d([V[i], P[i], V[j], P[j]], [allowed[a,k] | k in 1..4])\n   )\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\noutput [\n  show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n"}}, "TTPPV_expert": {"node_ids": ["a0f58007-0662-48ff-94fe-189f41e7f1d0"], "metadata": {"model_name": "TTPPV", "source_code": "% Traveling Tournament Problem with Predefined Venues\n%\n% Compact single round robin schedule minimizing total travel distance\n% The venue of each game has already been decided\n% Specialized for CIRC instances (circular distances)\n\ninclude \"globals.mzn\";\n\nint: nbTeams;\nint: nbRounds = nbTeams-1;\n\nset of int: Teams = 1..nbTeams;\nset of int: Rounds = 1..nbRounds;\nset of int: Travels = 1..nbRounds+1;\n\n% predefined venue: pv[i][j] = 1 iff i is playing at home against j\narray[Teams,Teams] of 1..2: pv; \n\n% circular distances: for i>=j, distance[i][j]=min{i-j,j-i+nbTeams}\narray[Teams,Teams] of int: distance = \n  array2d(Teams,Teams,[ if i>=j then (if i-j < j-i+nbTeams then i-j else j-i+nbTeams endif) \n                                else (if j-i < i-j+nbTeams then j-i else i-j+nbTeams endif) \n                                endif | i,j in Teams]);\n\n% output related\nint: digs = ceil(log(10.0,int2float(nbTeams)));\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% decision variables: in round k, team i plays against team opponent[i,k]\narray[Teams,Rounds] of var Teams: opponent;\n\n% auxiliary variables: venue[i,k] = 1 iff team i plays at home in round k\narray[Teams,Rounds] of var 1..2: venue;\nconstraint forall (i in Teams, k in Rounds) (venue[i,k] = pv[i,opponent[i,k]]);\n\n% auxiliary variables: travel[i,k] is the distance travelled by team i to go play in round k (includes travelling back home after last round)\narray[Teams,Travels] of var 0..(nbTeams div 2): travel;\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n% a team cannot play against itself\nconstraint forall (i in Teams, k in Rounds) (opponent[i,k] != i);\n\n% in round k, i plays j means j plays i\nconstraint forall (i in Teams, k in Rounds) (opponent[opponent[i,k],k] = i);\n\n% for each team i, all opponents are different\nconstraint forall (i in Teams) (alldifferent([opponent[i,k] | k in Rounds]));\n\n% for each round k, all opponents are different (implied constraint)\nconstraint forall (k in Rounds) (alldifferent([opponent[i,k] | i in Teams]));\n\n% for each team i, there can be at most 3 consecutive home games and at most 3 consecutive away games\nint: nbStates = 7;\nset of int: States = 1..nbStates;\narray[States,1..2] of int: delta = \n  [| 2, 5\n   | 3, 5\n   | 4, 5\n   | 0, 5\n   | 2, 6\n   | 2, 7\n   | 2, 0 |];\nconstraint forall (i in Teams) (regular( [venue[i,k] | k in Rounds], nbStates, 2, delta, 1, States));\n\n% symmetry breaking: distances are symmetric so reversing the rounds yields a schedule of same cost\nconstraint (opponent[1,1] < opponent[1,nbRounds]);\n\n% define travel variables wrt venues of current- and next-round games\nconstraint forall (i in Teams) (\n\t(venue[i,1]=1 -> travel[i,1] = 0) /\\\n\t(venue[i,1]=2 -> travel[i,1] = distance[i,opponent[i,1]]) );\nconstraint forall (i in Teams, k in 1..nbRounds-1) (\n\t((venue[i,k]=1 /\\ venue[i,k+1]=1) -> travel[i,k+1] = 0) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=1) -> travel[i,k+1] = distance[opponent[i,k],i]) /\\\n\t((venue[i,k]=1 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[i,opponent[i,k+1]]) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[opponent[i,k],opponent[i,k+1]]) );\nconstraint forall (i in Teams) (\n\t(venue[i,nbRounds]=1 -> travel[i,nbRounds+1] = 0) /\\\n\t(venue[i,nbRounds]=2 -> travel[i,nbRounds+1] = distance[opponent[i,nbRounds],i]) );\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nvar int: totalTravel;\nconstraint totalTravel = sum (i in Teams, k in Travels) (travel[i,k]);\nsolve minimize totalTravel;\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\noutput [\"SCHEDULE\\n\"] ++ \n       [ if fix(venue[i,k]) == 1 then \" \" else \"@\" endif ++\n\t show_int(digs,opponent[i,k]) ++ \" \" ++ \n         if k == nbRounds /\\ i != nbTeams then \"\\n\" else \"\" endif\n         | i in Teams, k in Rounds ] ++ [\"\\n\"] ++\n       [\"total travel = \"] ++ [show(totalTravel)] ++ [\"\\n\"];\n"}}, "vessel-loading_expert": {"node_ids": ["b84890a9-e170-4c03-a142-6eff1f9f01ec"], "metadata": {"model_name": "vessel-loading", "source_code": "% Vessel Loading\n\nint: deck_width; % width of deck\nint: deck_length; % height of deck\nint: n_containers; % number of containers\nint: n_classes; % number of container classes\n\narray[int] of int: width;\n% width[c] = width of container c\narray[int] of int: length;\n% length[c] = length of container c\narray[int] of int: class;\n% class[c] = class of container c\narray[int, int] of int: separation;\n% separation[a, b] = the minimum allowed separation between\n%                    containers of classes a and b\n\nset of int: Containers = 1..n_containers;\n\narray[Containers] of var 0..deck_width: Left;\n% Left[c] = leftmost point of container c\narray[Containers] of var 0..deck_width: Right;\n% Right[c] = rightmost point of container c\narray[Containers] of var 0..deck_length: Bottom;\n% Bottom[c] = bottommost point of container c\narray[Containers] of var 0..deck_length: Top;\n% Top[c] = topmost point of container c\n\narray[Containers] of var 1..2: orientation;\n% orientation[c] = 2 if container c is turned 90 degrees, else 1.\n\nconstraint\n  forall (c in Containers) (\n    let {\n      array[1..2] of int: ElemWidth = [width[c], length[c]];\n      array[1..2] of int: ElemLength = [length[c], width[c]]\n    }\n    in \n      Right[c] = Left[c] + ElemWidth[orientation[c]] /\\\n      Top[c] = Bottom[c] + ElemLength[orientation[c]]\n  )\n;\n\nconstraint\n  forall(c, k in Containers where c < k) (\n    Left[c] >= Right[k] + separation[class[c], class[k]] \\/\n    Right[c] + separation[class[c], class[k]] <= Left[k] \\/\n    Bottom[c] >= Top[k] + separation[class[c], class[k]] \\/\n    Top[c] + separation[class[c], class[k]] <= Bottom[k]\n  )\n;\n\n% Excessive (pretty) output\noutput [\"\u250c\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2510\\n\"] ++\n       [if x == 0 then \"\u2502\" else \"\" endif ++\n        let {\n          bool: l = exists([fix(Left[c])   = x | c in Containers]);\n          bool: r = exists([fix(Right[c])  = x | c in Containers]);\n          bool: b = exists([fix(Bottom[c]) = y | c in Containers]);\n          bool: t = exists([fix(Top[c])    = y | c in Containers])\n        } in\n          if     l /\\ r /\\ b /\\ t then \"\u253c\"\n          elseif l /\\ r /\\ b      then \"\u252c\"\n          elseif l /\\ r /\\      t then \"\u2534\"\n          elseif l /\\      b /\\ t then \"\u251c\"\n          elseif      r /\\ b /\\ t then \"\u2524\"\n          elseif l /\\      b      then \"\u250c\"\n          elseif l /\\           t then \"\u2514\"\n          elseif      r /\\ b      then \"\u2510\"\n          elseif      r /\\      t then \"\u2518\"\n          elseif l \\/ r           then \"\u2502\"\n          elseif           b \\/ t then \"\u2500\" \n          else \" \" endif ++\n        if x == deck_width then \"\u2502\\n\" else \"\" endif\n        | y in 0..deck_length, x in 0..deck_width] ++\n        [\"\u2514\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2518\"];\n"}}, "warehouses_expert": {"node_ids": ["4f9fc22c-c7d1-488f-8a71-15b9b7e6f5c5"], "metadata": {"model_name": "warehouses", "source_code": "% Warehouse allocation\n\n% vim: ft=zinc ts=2 sw=2 et tw=0\n\n% A company needs to construct warehouses to supply stores with goods.  Each\n% warehouse possibly to be constructed has a certain capacity defining how many\n% stores it can supply.  Constructing a warehouse incurs a fixed cost.  Costs\n% for transportation from warehouses to stores depend on the locations of\n% warehouses and stores.\n%\n% Determine which warehouses should be constructed and which warehouse should\n% supply which store such that overall cost (transportation cost plus\n% construction cost) is smallest.\n%-----------------------------------------------------------------------------\n\ninclude \"globals.mzn\";\n\n%-----------------------------------------------------------------------------\n% Instance\n\nn_suppliers = 5;\nn_stores = 10;\nbuilding_cost = 30;\n\ncapacity = [1,4,2,1,3];\n\ncost_matrix =\n [|20, 24, 11, 25, 30\n  |28, 27, 82, 83, 74\n  |74, 97, 71, 96, 70\n  | 2, 55, 73, 69, 61\n  |46, 96, 59, 83,  4\n  |42, 22, 29, 67, 59\n  | 1,  5, 73, 59, 56\n  |10, 73, 13, 43, 96\n  |93, 35, 63, 85, 46\n  |47, 65, 55, 71, 95|]; \n\n%-----------------------------------------------------------------------------\n% Model\n\nint: n_suppliers;\nint: n_stores;\nint: building_cost;\narray[1..n_suppliers] of int: capacity;\narray[1..n_stores,1..n_suppliers] of int: cost_matrix;\n\nint: MaxCost = max(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]);\nint: MaxTotal =   (n_suppliers * building_cost) \n                + sum(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]); \n\narray[1..n_stores] of var 1..n_suppliers: supplier;\narray[1..n_suppliers] of var bool: open;\narray[1..n_stores] of var 1..MaxCost: cost;\nvar 1..MaxTotal: tot;\n\nconstraint\n  sum (i in 1..n_suppliers) (building_cost * bool2int(open[i])) +\n  sum (i in 1..n_stores) (cost[i])\n  = tot;\n\nconstraint\n  forall (i in 1..n_stores) (\n    cost_matrix[i,supplier[i]] = cost[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    let {\n      var int: use\n     } in\n    count(supplier,i,use) /\\ use <= capacity[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    (exists (j in 1..n_stores) (supplier[j] == i)) == open[i]\n  );\n\nsolve\n  :: int_search(\n    supplier ++ cost ++ [bool2int(open[i]) | i in 1..n_suppliers],\n    first_fail,\n    indomain_split,\n    complete\n  )\n  minimize tot;\n\noutput\n  [ \"warehouses:\" ]\n  ++\n  [ \"\\ntot = \", show(tot) ]\n  ++\n  [ \"\\nsupplier = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(supplier[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\ncost = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(cost[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\nopen = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(open[i]) ++\n    if i = n_suppliers then \"\\n]\\n\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_suppliers\n  ]\n\n%-----------------------------------------------------------------------------\n%-----------------------------------------------------------------------------\n"}}, "water_buckets1_expert": {"node_ids": ["dec65d8f-faba-42ea-b8a7-1bd526517378"], "metadata": {"model_name": "water_buckets1", "source_code": "Model 1 :\n\n% Water buckets problem in Minizinc\n% \"\"\"\n% Problem description\n% This is a generalization of the CSPLib specification, which is as follows: Given an 8 pint bucket of water, and two empty buckets which can contain 5 and 3 pints respectively, the problem requires to divide the water into two by pouring water between buckets (that is, to end up with 4 pints in the 8 pint bucket, and 4 pints in the 5 pint bucket) in the smallest number of transfers.\n%\n% The generalization consists in making the specification parametric with respect to the start and goal configurations, which are now inputs to the problem.\n%\n% Problem input\n%\n% * Function start, assigning an initial amount of water to each bucket\n% * Function goal, assigning the goal amount of water to each bucket \n%\n% Search space\n% The set of all possibile sequences of configurations (states), where a configuration is a triple encoding the amount of water in each bucket at a given time-step\n%\n% Constraints\n%\n% * C1: At beginning, buckets contain the amount of water specified by function start\n% * C2: At the end, buckets contain the amount of water specified by function goal\n% * C3: The configuration at each step differs from that of the next one in that the amount of water of exactly 2 buckets changes (that in the others remain the same)\n% * C4: The overall amount of water is the same at each time step\n% * C5: After each transition (involving buckets b1 and b2), either the source bucket becomes empty, or the target becomes full\n% \"\"\"\n\n\nint: nb_buckets = 3;\nint: max_step = 10; % 8 for satisfy\nset of int: buckets = 1..nb_buckets;\nset of int: steps = 1..max_step;\narray[buckets] of int: capacity = [8,5,3];\narray[buckets] of int: start = [8,0,0];\narray[buckets] of int: goal = [4,4,0];\n\n% Search space: The set of all possibile sequences of configurations (states), \n% where a configuration is a triple encoding the amount of water in each \n% bucket at a given time-step\narray[steps, buckets] of var int: state;\nvar 1..max_step: goal_step;\n\n% Objective function\nsolve minimize goal_step;\n% solve :: int_search( [ state[i,j] | i in steps, j in buckets ] , \"first_fail\", \"indomain\", \"complete\")  minimize goal_step;\n\nconstraint\n%   goal_step <= 8 % for solve satisfy\n%   /\\\n   % assertions\n   forall(b in buckets) (\n      (start[b] <= capacity[b]) /\\ (goal[b] <= capacity[b])\n   )\n   /\\\n   sum(b in buckets)(start[b]) = sum(b in buckets)(goal[b])\n   /\\\n   forall(s in steps, b in buckets) (\n      state[s,b] >= 0 /\\\n      state[s,b] <= capacity[b]\n   )\n   /\\\n   forall(b in buckets) (\n      % C1: At beginning, buckets contain the amount of water specified by function start\n      state[1,b]=start[b]\n      /\\\n      % C2: At the end, buckets contain the amount of water specified by function goal\n      state[goal_step,b] = goal[b]\n   )\n   /\\\n   forall(step in 1..max_step-1) (\n      % C3: The configuration at each step differs from that of the next one in that the amount of\n      % water of exactly 2 buckets changes (that in the others remain the same)\n      sum(b in buckets)( bool2int(state[step,b] != state[step+1, b])) = 2\n      /\\\n      % C4: The overall amount of water is the same at each time step\n      sum(b in buckets)(state[step,b]) = sum(b in buckets)(state[step+1,b])\n      /\\\n\n      % C5: After each transition (involving buckets b1 and b2), either the source\n      % bucket becomes empty, or the target becomes full\n      forall(b1, b2 in buckets where b1 != b2) (\n         ((state[step, b1] != state[step+1, b1]) /\\ (state[step, b2] != state[step+1, b2])) ->\n            (state[step+1,b1] = 0 \\/ state[step+1,b1] = capacity[b1] \\/\n             state[step+1,b2] = 0 \\/ state[step+1,b2] = capacity[b2])\n     )\n   )\n;\n\n\noutput [\n  if s = 1 /\\ b = 1 then \n    \"goal_step: \" ++ show(goal_step)\n  else \"\" endif ++\n  if b = 1 then \"\\n\" else \" \" endif ++\n  show(state[s, b])\n  | s in steps, b in buckets\n\n] \n++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\n\ninclude \"globals.mzn\";\n\nint: n_states = 15;\nint: input_max = 15;\nint: initial_state = 1;\nset of int: accepting_states = {15};\n\n\n% distance\narray[1..n_states, 1..n_states] of 0..input_max: transition_fn =\narray2d(1..n_states, 1..n_states,\n[%1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n  0, 2, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 1\n  0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 2 \n  0, 0, 0, 4, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 3\n  0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 4\n  0, 0, 0, 0, 0, 6, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 5\n  0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, % 6\n  0, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 0, 0, 0, 0, % 7\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, % 8 \n  0, 0, 0, 0, 0, 0, 0, 0, 0,10, 0, 0, 0, 0, 0, % 9\n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0,11, 0, 0, 0, 0, %10\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,12, 0, 0, 0, %11 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,13, 0, 0, %12\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,14, 0, %13 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %14\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %15\n]);\n\n\narray[1..n_states] of string:  nodes = [\n        \"8,0,0\", % 1 start\n        \"5,0,3\", % 2\n        \"5,3,0\", % 3 \n        \"2,3,3\", % 4 \n        \"2,5,1\", % 5\n        \"7,0,1\", % 6\n        \"7,1,0\", % 7\n        \"4,1,3\", % 8\n        \"3,5,0\", % 9\n        \"3,2,3\", % 10\n        \"6,2,0\", % 11\n        \"6,0,2\", % 12\n        \"1,5,2\", % 13\n        \"1,4,3\", % 14\n        \"4,4,0\"  % 15 goal\n        ];\n\n\narray[1..input_max] of var 0..input_max: x;\nvar 0..input_max: cost;\n\n% solve satisfy;\nsolve minimize cost;\n\nconstraint\nregular(x, n_states, input_max, transition_fn,\n        initial_state, accepting_states)\n;\n\nconstraint\n   cost = 2+sum([bool2int(x[i-1] != x[i] ) | i in 2..input_max])\n;\n\noutput \n[\"cost: \" ++ show(cost) ++ \"\\n\"] ++\n[show(initial_state) ++ \" \"] ++\n[\n  if fix(x[i]) < input_max then show(x[i]) ++ \" \" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(input_max) ++ \"\\n\"] ++ \n[\"\\n\\n\"] ++\n\n[show(nodes[initial_state]) ++ \"\\n\"] ++\n[\n  if fix(x[i]) < input_max then show(nodes[fix(x[i])]) ++ \"\\n\" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(nodes[input_max]) ++ \"\\n\"] ++ \n[\"\\n\"];"}}}}