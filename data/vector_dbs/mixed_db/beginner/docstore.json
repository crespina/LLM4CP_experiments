{"docstore/metadata": {"all_interval_beginner": {"doc_hash": "c74e9d4b6b31fb3b2fbc17d8de9f5005f72a410aa8b381c3f47bec89126ece21"}, "assign_beginner": {"doc_hash": "710399ef5ffbce1af11f2fd4c22c75a318b99b321d396f6d80e3cfc4681199d3"}, "aust_color_beginner": {"doc_hash": "547527a1d5e19a407c91bf63b4161be0dca833bbd602506eb767aaee84cf3074"}, "bibd_beginner": {"doc_hash": "a29abde4245c122558b027202dcf39f8d04ba87f033258ac92c772c9702ae87d"}, "bus_scheduling_csplib_beginner": {"doc_hash": "42730df4bd22aaee5246f8c173b35dccba729c65391f220253f72aefd8c5b403"}, "car_beginner": {"doc_hash": "90c1a3e1f0ba85fee0788ea5971a1f29a699045d2500245c538ca42ac863d9b5"}, "carpet_cutting_beginner": {"doc_hash": "e1cf2b330922a12af59c6556608737fe0bc466e85f7857d110f3489c7c06dabf"}, "cell_block_beginner": {"doc_hash": "05472dcb0e5d319117e313516f9272674331fbb58286601d34863dd2004ce07c"}, "clique_beginner": {"doc_hash": "b909d139fcff9beec6508929cd63084501e930a5b50956f542968e7900b88b5c"}, "cluster_beginner": {"doc_hash": "0c2accce03c41e2413e1237be8f10b39e374686e449217541ed3227816ce4137"}, "compatible_assignment_beginner": {"doc_hash": "48d78dd4cd484764ce9932075335fa9fa6edc25d777c5e926bec2b8b257e68e9"}, "constrained_connected_beginner": {"doc_hash": "2f47e4431dff861697019fee8f9678835e52a9ee9f1e11f7540eac9320d0673e"}, "crazy_sets_beginner": {"doc_hash": "574231aad85352b7fed64ee754f369a1fad67b501ef58f055e73dff9fe6e2a2e"}, "crossfigure_beginner": {"doc_hash": "4fd617c3465a7ed18bc2d5627177a817db6d9552ed897fe03e078934bd23aa95"}, "curriculum_beginner": {"doc_hash": "15261988b87eb95e39e03f9f0e5783f83b46572be7ad97dca9245506fefeb479"}, "diamond_free_degree_sequence_beginner": {"doc_hash": "2dc8e3138d37fe341628b33ee15d23b726e0d0127bd100fc9214ad37b05e907e"}, "doublechannel_beginner": {"doc_hash": "a9ebc788320f41724b1011a8f262299783df26f843d25fa6293b11ee3ef8949d"}, "fractions_beginner": {"doc_hash": "ec2ce13c98a8f533b70ffc1594a6b41259358a59f900e185d7a55b77eaac933e"}, "golfers_beginner": {"doc_hash": "660f157e27a8d7e4c21868266e2649c132985ab5e93a22ebb40c4ce5d0db0cb4"}, "golomb_beginner": {"doc_hash": "5738679d4e4b0b29a3b9fa5df4fd0fc1929129a5210e13226828b26e1467685c"}, "graph_beginner": {"doc_hash": "452cc7ed90dc10a51f2346e4aa0ba6b5a9a80c7c25ef5b6c45b200f60bcf637b"}, "itemset_mining_beginner": {"doc_hash": "ff50dc27d0a28f9662b58be4ff3eecb22ce0e8c1e645fccc1b3550d1a6c1d588"}, "jobshop_beginner": {"doc_hash": "d36177024292a97bdd269f003f6e3183e299bc63216325abf4f9775d6adcfee1"}, "K4xP2Graceful_beginner": {"doc_hash": "712f6d409009c4025fc67ebda69455a0b9b0b9ba32bd42ad575b07ad444861bd"}, "killer_sudoku_beginner": {"doc_hash": "f35f3e19b785c42a780db10abff89d9b2c8a825681a6ad0fe280e5e26500e513"}, "knapsack_beginner": {"doc_hash": "29dfe7ccd6601e5f68cf0fc3784683e8ea2b57329b9d013d7e693a79866ec2b2"}, "langford_beginner": {"doc_hash": "9da6dc3c1bf3960cab58bd26162336b41460d5efc8d528d98f4e460e42590da4"}, "loan_beginner": {"doc_hash": "c1f114fda1a14446a301f3421b750ebb5d03994a7381dd39c64debe26b3a5fd2"}, "ltsp_beginner": {"doc_hash": "0d603ed5111e378bdedc3b4418351933dc0256722bc8e4c96c796ff535083580"}, "magic_hexagon_beginner": {"doc_hash": "c1cbee22a631590b7384caf8089f6123e4115589b60fddb467bdf01ad6e43f5e"}, "magic_sequence_beginner": {"doc_hash": "502c664e9fb9da7f4779030520fbdbb370797cfcb1e1f2c343e6e7c2e56ca202"}, "maximum_density_still_life_beginner": {"doc_hash": "c5e27d279fad8afc4b04415eb83034f8645fcc2f252cf633b265e20cb277cf52"}, "mip_beginner": {"doc_hash": "4b57bb253bc2d29ec4acf061e122a44b43c02296ed8d334572863cdc1cb4c87d"}, "missing_solution_beginner": {"doc_hash": "c5d7b719366231e4f0c29c4bf35b8d6c6cabec273e0f65604f4f4b410d8f97f6"}, "nonogram_create_automaton2_beginner": {"doc_hash": "fd69e0b3a3166881532611305ace02f5986341fb39d58fb30efa7582c738d811"}, "nurses_beginner": {"doc_hash": "41c93bc1cf29bc51d58f26ef28d1effa5e24c80b1d7ec652d82a0e7ee44f35ea"}, "opd_beginner": {"doc_hash": "c8ad289c9fe940212e050cd21e1910488d342e87a75214647b95428435bb1040"}, "partition_beginner": {"doc_hash": "d1ea9312d390565d0c1fbfd20ee7b98ac92b839978d157fb0f83a719c4ef276e"}, "photo_beginner": {"doc_hash": "1cb4ad495263b48a3409a70f94a704336f13ef89fe2b2007dd31f0be63459999"}, "project_scheduling_beginner": {"doc_hash": "f9f4c70bcdabcfebadb07ffd0654da2bc87b8e91e14c2d8a716ad96fd1c173ff"}, "QuasigroupCompletion_beginner": {"doc_hash": "fe24d9a3d446319d411b54347e288890955122f0b9122a714eaf8e62fa2d4806"}, "QuasiGroupExistence_beginner": {"doc_hash": "95583b92bcf260ced8a0a22075962214ebd72a671c7847f612c88326f1771849"}, "queens_beginner": {"doc_hash": "2fb4aad78234fcaf6077257e66c290408112e4bad4f5edea2bd76812285797e1"}, "rcpsp_beginner": {"doc_hash": "6c42e69bd87baf7407ae99975e9846b8c91a5dd68311d4c605f339605594790b"}, "rehearsal_beginner": {"doc_hash": "811120198ae805787a96a80d0be61c712ab235147f7ffa7c4761733a34785219"}, "restart_beginner": {"doc_hash": "1438a5b185c6032538cd9238ea53b6ba3a872194f7c327c7fde7c21b9b696247"}, "RosteringProblem_beginner": {"doc_hash": "671a0a76a6b0e0cf1162c47986b57bc8cc265a27c7d9696027508a30e719fd67"}, "sb_beginner": {"doc_hash": "014ccd57225cba5dc2b37a9b49534bd86902056b3ae8747d606d4859ddd5a85b"}, "schur_beginner": {"doc_hash": "cce2eb1263c459da0c6ef9cf6f3d207242355147604814e2089be43b76a01a5f"}, "setselect_beginner": {"doc_hash": "64d8e7ef9e6f508632fd48729b9ea9818a944f23ddeec3a3958f4d3495b8cca7"}, "shipping_beginner": {"doc_hash": "efbd57e190623ca55b6fe63b313933ee21d10ef3fb35b669c7fa8d94bc0e3950"}, "simple-prod-planning_beginner": {"doc_hash": "93ec4cf07cc5e4c1c8345b163b475e50582968012d99f5ac23f48bcb9c40f570"}, "sonet_problem_beginner": {"doc_hash": "5de3cf986c477ebb9dc3d6689f52dd29acacfd83c2447c781aa3015860247f56"}, "square_pack_beginner": {"doc_hash": "55d532585c3cc7ab335bfb9c63fd6cc3c00e3c55827c71d7014f8bb4526fa383"}, "stableroommates_beginner": {"doc_hash": "9eb6c16f7472ca78d738ba9a8ffdbc5f41c3c6c103b812d616c8b8b631e593cb"}, "steiner_beginner": {"doc_hash": "7d17fe428c15976ef9776f78fdc47c3284a10ac67693994f05346ac2c907f71c"}, "stoch_fjsp_beginner": {"doc_hash": "16f847737c2542565693e42288f054258f477995b413d0a64e60188425c80a6e"}, "submultisetsum_beginner": {"doc_hash": "56a2ae12a6003d9bb9d50280400ebd968568b9be22c4ff059f1a6be6c70b7acf"}, "table_seating_beginner": {"doc_hash": "8d6d950898668ac13be2b204dbb203b0e8bd32ef0417472b0dd5bc65f877262d"}, "teamselect_beginner": {"doc_hash": "3c02ff8ed0afc5991411847d3f3f02f4816bbef9eb5323320197c48aafbef5af"}, "template_design_beginner": {"doc_hash": "78b0466e0f81ef388da397f78f41e79dac76554f137bb87e174f11a9d7fb584c"}, "toomany_beginner": {"doc_hash": "7157c915b8e4996a9864c198ec583d381e8dc8098c0eba5114d6f1f2e8242308"}, "traffic_lights_table_beginner": {"doc_hash": "1fcd515b594f3166f2fe5bf2b14751565c606fb29b44ed31406a810d38272a99"}, "TTPPV_beginner": {"doc_hash": "d1a4ea2fc524d9ea1718f5f95f1be3e9b9ac4bfe22281f7d7962b9a58e344143"}, "vessel-loading_beginner": {"doc_hash": "56aec32d6a7bcfa3aa49a17af8a0dfb36c30453bcb2cdbbea2722fd3c62d1b18"}, "warehouses_beginner": {"doc_hash": "8981b9678254c75c62a472d364c7a47421c199b357251c2d292e3f1c5e3b95c1"}, "water_buckets1_beginner": {"doc_hash": "806f2cec446b5f75450caac8cce7deacdf2ea0554f8b1f11aec6aa76d86d3060"}, "07ce856f-ec8e-4062-b7df-2af74288b0db": {"doc_hash": "c74e9d4b6b31fb3b2fbc17d8de9f5005f72a410aa8b381c3f47bec89126ece21", "ref_doc_id": "all_interval_beginner"}, "5d95f426-a5a5-4f06-8ab4-255fe1eeb1fe": {"doc_hash": "710399ef5ffbce1af11f2fd4c22c75a318b99b321d396f6d80e3cfc4681199d3", "ref_doc_id": "assign_beginner"}, "98d9e212-d5e9-467e-9c8e-90a6c70c6d5d": {"doc_hash": "547527a1d5e19a407c91bf63b4161be0dca833bbd602506eb767aaee84cf3074", "ref_doc_id": "aust_color_beginner"}, "e1a5974f-61ea-47de-aa8d-e48c423921ad": {"doc_hash": "a29abde4245c122558b027202dcf39f8d04ba87f033258ac92c772c9702ae87d", "ref_doc_id": "bibd_beginner"}, "ab8a6fb2-c585-4732-8a64-889525f035f1": {"doc_hash": "42730df4bd22aaee5246f8c173b35dccba729c65391f220253f72aefd8c5b403", "ref_doc_id": "bus_scheduling_csplib_beginner"}, "168ac6f2-5cf4-457a-96a7-cfcf1da061fc": {"doc_hash": "90c1a3e1f0ba85fee0788ea5971a1f29a699045d2500245c538ca42ac863d9b5", "ref_doc_id": "car_beginner"}, "2683cddb-07e4-4a61-820f-4dd2077534a4": {"doc_hash": "e1cf2b330922a12af59c6556608737fe0bc466e85f7857d110f3489c7c06dabf", "ref_doc_id": "carpet_cutting_beginner"}, "612d5e03-cd42-4f6a-be99-db559ec7c314": {"doc_hash": "05472dcb0e5d319117e313516f9272674331fbb58286601d34863dd2004ce07c", "ref_doc_id": "cell_block_beginner"}, "4caab6d4-59f7-4cd4-a90c-f1cc2d3ebbe7": {"doc_hash": "b909d139fcff9beec6508929cd63084501e930a5b50956f542968e7900b88b5c", "ref_doc_id": "clique_beginner"}, "4d1560ec-39d9-48ca-b09b-5f00c46037be": {"doc_hash": "0c2accce03c41e2413e1237be8f10b39e374686e449217541ed3227816ce4137", "ref_doc_id": "cluster_beginner"}, "e5f75b2b-1799-4a0b-8ffa-1a837980b4c9": {"doc_hash": "48d78dd4cd484764ce9932075335fa9fa6edc25d777c5e926bec2b8b257e68e9", "ref_doc_id": "compatible_assignment_beginner"}, "2f3e9edb-4f51-4ac8-aaa9-d599837711f6": {"doc_hash": "2f47e4431dff861697019fee8f9678835e52a9ee9f1e11f7540eac9320d0673e", "ref_doc_id": "constrained_connected_beginner"}, "1df567da-04ec-4777-8c39-6447dea7e046": {"doc_hash": "574231aad85352b7fed64ee754f369a1fad67b501ef58f055e73dff9fe6e2a2e", "ref_doc_id": "crazy_sets_beginner"}, "451732a6-36c2-4547-b16f-4f7e9b7a476b": {"doc_hash": "4fd617c3465a7ed18bc2d5627177a817db6d9552ed897fe03e078934bd23aa95", "ref_doc_id": "crossfigure_beginner"}, "fa3fefc8-f015-4ef1-8df9-0a73b8b1d0c4": {"doc_hash": "15261988b87eb95e39e03f9f0e5783f83b46572be7ad97dca9245506fefeb479", "ref_doc_id": "curriculum_beginner"}, "f613bb09-30bd-4cca-b97c-7260a229e0e7": {"doc_hash": "2dc8e3138d37fe341628b33ee15d23b726e0d0127bd100fc9214ad37b05e907e", "ref_doc_id": "diamond_free_degree_sequence_beginner"}, "afa53493-8d34-447d-a0a5-ab86de3ac672": {"doc_hash": "a9ebc788320f41724b1011a8f262299783df26f843d25fa6293b11ee3ef8949d", "ref_doc_id": "doublechannel_beginner"}, "fa3f3234-d49d-4df8-8fec-38b029e17108": {"doc_hash": "ec2ce13c98a8f533b70ffc1594a6b41259358a59f900e185d7a55b77eaac933e", "ref_doc_id": "fractions_beginner"}, "9cfcb2d2-a6db-40ad-b990-7d4c995ec9e9": {"doc_hash": "660f157e27a8d7e4c21868266e2649c132985ab5e93a22ebb40c4ce5d0db0cb4", "ref_doc_id": "golfers_beginner"}, "91487107-c324-4504-9301-fd11ec00537d": {"doc_hash": "5738679d4e4b0b29a3b9fa5df4fd0fc1929129a5210e13226828b26e1467685c", "ref_doc_id": "golomb_beginner"}, "288c9b5f-8c31-405c-b63b-1f705f128232": {"doc_hash": "452cc7ed90dc10a51f2346e4aa0ba6b5a9a80c7c25ef5b6c45b200f60bcf637b", "ref_doc_id": "graph_beginner"}, "cd8b2ac4-86d8-45df-8ae9-329945d75a55": {"doc_hash": "ff50dc27d0a28f9662b58be4ff3eecb22ce0e8c1e645fccc1b3550d1a6c1d588", "ref_doc_id": "itemset_mining_beginner"}, "111ae802-6e37-405d-8831-580c2249a74a": {"doc_hash": "d36177024292a97bdd269f003f6e3183e299bc63216325abf4f9775d6adcfee1", "ref_doc_id": "jobshop_beginner"}, "30794ba2-6db1-4dac-ac81-243d0c06cf92": {"doc_hash": "712f6d409009c4025fc67ebda69455a0b9b0b9ba32bd42ad575b07ad444861bd", "ref_doc_id": "K4xP2Graceful_beginner"}, "412f417e-e027-45da-8bf5-fb03bd356fc5": {"doc_hash": "f35f3e19b785c42a780db10abff89d9b2c8a825681a6ad0fe280e5e26500e513", "ref_doc_id": "killer_sudoku_beginner"}, "88664e12-ec17-4c30-8f34-d1a2ba121ca3": {"doc_hash": "29dfe7ccd6601e5f68cf0fc3784683e8ea2b57329b9d013d7e693a79866ec2b2", "ref_doc_id": "knapsack_beginner"}, "01968c9a-c9c4-43ec-ae98-51425df90c05": {"doc_hash": "9da6dc3c1bf3960cab58bd26162336b41460d5efc8d528d98f4e460e42590da4", "ref_doc_id": "langford_beginner"}, "e6cb2e7d-4506-4878-94c2-f6cfb05d664e": {"doc_hash": "c1f114fda1a14446a301f3421b750ebb5d03994a7381dd39c64debe26b3a5fd2", "ref_doc_id": "loan_beginner"}, "2817319e-ed8b-4ef4-8b8b-8e22fa7b82f1": {"doc_hash": "0d603ed5111e378bdedc3b4418351933dc0256722bc8e4c96c796ff535083580", "ref_doc_id": "ltsp_beginner"}, "7d40cf11-47f6-49c2-b647-c2fd7af4debb": {"doc_hash": "c1cbee22a631590b7384caf8089f6123e4115589b60fddb467bdf01ad6e43f5e", "ref_doc_id": "magic_hexagon_beginner"}, "60f5d665-46de-4b90-8714-407a12527d7d": {"doc_hash": "502c664e9fb9da7f4779030520fbdbb370797cfcb1e1f2c343e6e7c2e56ca202", "ref_doc_id": "magic_sequence_beginner"}, "d42b6f50-f418-4478-abd5-c54634fda33d": {"doc_hash": "c5e27d279fad8afc4b04415eb83034f8645fcc2f252cf633b265e20cb277cf52", "ref_doc_id": "maximum_density_still_life_beginner"}, "8fa562d4-da85-4869-95c4-32cc80cd9d5a": {"doc_hash": "4b57bb253bc2d29ec4acf061e122a44b43c02296ed8d334572863cdc1cb4c87d", "ref_doc_id": "mip_beginner"}, "662d0e48-d42a-4ca1-bafe-8e3bf7d12aef": {"doc_hash": "c5d7b719366231e4f0c29c4bf35b8d6c6cabec273e0f65604f4f4b410d8f97f6", "ref_doc_id": "missing_solution_beginner"}, "ab33d604-8159-4123-8f4e-6438492dfbab": {"doc_hash": "fd69e0b3a3166881532611305ace02f5986341fb39d58fb30efa7582c738d811", "ref_doc_id": "nonogram_create_automaton2_beginner"}, "7f3225b0-7c54-4c59-94de-5a432acc2ac6": {"doc_hash": "41c93bc1cf29bc51d58f26ef28d1effa5e24c80b1d7ec652d82a0e7ee44f35ea", "ref_doc_id": "nurses_beginner"}, "ba365d05-5cb0-45a2-b121-580290fcd67a": {"doc_hash": "c8ad289c9fe940212e050cd21e1910488d342e87a75214647b95428435bb1040", "ref_doc_id": "opd_beginner"}, "27ecf388-0cdd-456b-b342-4fd01da8ce95": {"doc_hash": "d1ea9312d390565d0c1fbfd20ee7b98ac92b839978d157fb0f83a719c4ef276e", "ref_doc_id": "partition_beginner"}, "9d7918e4-2e7c-450b-abd5-b43323a7c749": {"doc_hash": "1cb4ad495263b48a3409a70f94a704336f13ef89fe2b2007dd31f0be63459999", "ref_doc_id": "photo_beginner"}, "930acf52-d5f6-4d56-b525-57da3f9ae68b": {"doc_hash": "f9f4c70bcdabcfebadb07ffd0654da2bc87b8e91e14c2d8a716ad96fd1c173ff", "ref_doc_id": "project_scheduling_beginner"}, "c548ea43-90cc-4b09-a679-8aadee6e104c": {"doc_hash": "fe24d9a3d446319d411b54347e288890955122f0b9122a714eaf8e62fa2d4806", "ref_doc_id": "QuasigroupCompletion_beginner"}, "ad0f25bc-8e58-47b5-8185-69fea96ce841": {"doc_hash": "95583b92bcf260ced8a0a22075962214ebd72a671c7847f612c88326f1771849", "ref_doc_id": "QuasiGroupExistence_beginner"}, "eb1e6520-993d-4661-a0b5-d7af06301f6d": {"doc_hash": "2fb4aad78234fcaf6077257e66c290408112e4bad4f5edea2bd76812285797e1", "ref_doc_id": "queens_beginner"}, "b1416728-3b5d-41d5-8d06-90b3d4680ec3": {"doc_hash": "6c42e69bd87baf7407ae99975e9846b8c91a5dd68311d4c605f339605594790b", "ref_doc_id": "rcpsp_beginner"}, "11210b56-7cad-4748-bb19-7f1106bb5297": {"doc_hash": "811120198ae805787a96a80d0be61c712ab235147f7ffa7c4761733a34785219", "ref_doc_id": "rehearsal_beginner"}, "1fa23511-0c82-4a7f-b6d3-ab30be6c6ce5": {"doc_hash": "1438a5b185c6032538cd9238ea53b6ba3a872194f7c327c7fde7c21b9b696247", "ref_doc_id": "restart_beginner"}, "33c0583a-83a0-4e61-b9af-cfec4995b820": {"doc_hash": "671a0a76a6b0e0cf1162c47986b57bc8cc265a27c7d9696027508a30e719fd67", "ref_doc_id": "RosteringProblem_beginner"}, "66065360-9a68-4de1-858a-3771ed922ed0": {"doc_hash": "014ccd57225cba5dc2b37a9b49534bd86902056b3ae8747d606d4859ddd5a85b", "ref_doc_id": "sb_beginner"}, "ecb368d1-bdc9-4943-abd1-98993d615941": {"doc_hash": "cce2eb1263c459da0c6ef9cf6f3d207242355147604814e2089be43b76a01a5f", "ref_doc_id": "schur_beginner"}, "fd722d73-a7df-40ae-acad-097c1f2b071b": {"doc_hash": "64d8e7ef9e6f508632fd48729b9ea9818a944f23ddeec3a3958f4d3495b8cca7", "ref_doc_id": "setselect_beginner"}, "637dda26-d408-49a9-87c8-266900b61ac3": {"doc_hash": "efbd57e190623ca55b6fe63b313933ee21d10ef3fb35b669c7fa8d94bc0e3950", "ref_doc_id": "shipping_beginner"}, "d6cd7afd-542d-432f-b437-8df56bb85bf7": {"doc_hash": "93ec4cf07cc5e4c1c8345b163b475e50582968012d99f5ac23f48bcb9c40f570", "ref_doc_id": "simple-prod-planning_beginner"}, "c87d1b40-6f8d-434a-a974-cfa2650d8420": {"doc_hash": "5de3cf986c477ebb9dc3d6689f52dd29acacfd83c2447c781aa3015860247f56", "ref_doc_id": "sonet_problem_beginner"}, "dfdd2674-dde3-4556-9553-e3509dd84755": {"doc_hash": "55d532585c3cc7ab335bfb9c63fd6cc3c00e3c55827c71d7014f8bb4526fa383", "ref_doc_id": "square_pack_beginner"}, "d776130f-a388-45bf-bd8f-9bf256b783e8": {"doc_hash": "9eb6c16f7472ca78d738ba9a8ffdbc5f41c3c6c103b812d616c8b8b631e593cb", "ref_doc_id": "stableroommates_beginner"}, "b6c0db13-a248-4c8c-a1e5-3cbabe5692a6": {"doc_hash": "7d17fe428c15976ef9776f78fdc47c3284a10ac67693994f05346ac2c907f71c", "ref_doc_id": "steiner_beginner"}, "624ab5e1-1ed9-43bc-b0c4-3ab00a9a2221": {"doc_hash": "16f847737c2542565693e42288f054258f477995b413d0a64e60188425c80a6e", "ref_doc_id": "stoch_fjsp_beginner"}, "171e4a5d-d5ef-47e5-bec1-c0bcde15aa3c": {"doc_hash": "56a2ae12a6003d9bb9d50280400ebd968568b9be22c4ff059f1a6be6c70b7acf", "ref_doc_id": "submultisetsum_beginner"}, "74854336-1114-4f34-847e-8adde1c9d74d": {"doc_hash": "8d6d950898668ac13be2b204dbb203b0e8bd32ef0417472b0dd5bc65f877262d", "ref_doc_id": "table_seating_beginner"}, "7dce60e5-ca00-443f-b4ac-11bc45ba1e2e": {"doc_hash": "3c02ff8ed0afc5991411847d3f3f02f4816bbef9eb5323320197c48aafbef5af", "ref_doc_id": "teamselect_beginner"}, "45493d6e-cfc3-47e2-b2a8-b2c5ba0376ec": {"doc_hash": "78b0466e0f81ef388da397f78f41e79dac76554f137bb87e174f11a9d7fb584c", "ref_doc_id": "template_design_beginner"}, "26b1fe9b-176c-4554-a768-b1d1d6bdbc96": {"doc_hash": "7157c915b8e4996a9864c198ec583d381e8dc8098c0eba5114d6f1f2e8242308", "ref_doc_id": "toomany_beginner"}, "0c8aefc6-af68-4850-872c-fade026076a2": {"doc_hash": "1fcd515b594f3166f2fe5bf2b14751565c606fb29b44ed31406a810d38272a99", "ref_doc_id": "traffic_lights_table_beginner"}, "eae09164-57e4-4de5-8ec0-114d3db83622": {"doc_hash": "d1a4ea2fc524d9ea1718f5f95f1be3e9b9ac4bfe22281f7d7962b9a58e344143", "ref_doc_id": "TTPPV_beginner"}, "e3460b1d-b972-4260-b642-545a44b38645": {"doc_hash": "56aec32d6a7bcfa3aa49a17af8a0dfb36c30453bcb2cdbbea2722fd3c62d1b18", "ref_doc_id": "vessel-loading_beginner"}, "75c261b6-72c3-4f49-9bc6-dfdb2d82c1dc": {"doc_hash": "8981b9678254c75c62a472d364c7a47421c199b357251c2d292e3f1c5e3b95c1", "ref_doc_id": "warehouses_beginner"}, "fe2be0eb-1264-4141-bfbb-49779261a2ed": {"doc_hash": "806f2cec446b5f75450caac8cce7deacdf2ea0554f8b1f11aec6aa76d86d3060", "ref_doc_id": "water_buckets1_beginner"}}, "docstore/data": {"07ce856f-ec8e-4062-b7df-2af74288b0db": {"__data__": {"id_": "07ce856f-ec8e-4062-b7df-2af74288b0db", "embedding": null, "metadata": {"model_name": "all_interval", "source_code": "Model 1 : \n\n\n%\n% All interval problem in MiniZinc\n%\n% \"\"\"\n% Given the twelve standard pitch-classes (c, c%, d, ...), represented by\n% numbers 0,1,...,11, find a series in which each pitch-class occurs exactly\n% once and in which the musical intervals between neighbouring notes cover\n% the full set of intervals from the minor second (1 semitone) to the major\n% seventh (11 semitones). That is, for each of the intervals, there is a\n% pair of neigbhouring pitch-classes in the series, between which this\n% interval appears. The problem of finding such a series can be easily\n% formulated as an instance of a more general arithmetic problem on Z_n,\n% the set of integer residues modulo n. Given n in N, find a vector\n% s = (s_1, ..., s_n), such that (i) s is a permutation of\n% Z_n = {0,1,...,n-1}; and (ii) the interval vector\n% v = (|s_2-s_1|, |s_3-s_2|, ... |s_n-s_{n-1}|) is a permutation of\n% Z_n-{0} = {1,2,...,n-1}. A vector v satisfying these conditions is\n% called an all-interval series of size n; the problem of finding such\n% a series is the all-interval series problem of size n. We may also be\n% interested in finding all possible series of a given size.\n\ninclude \"globals.mzn\";\n\nint: n = 12;\n% array[1..n] of var 1..n: x;\narray[1..n] of var 1..n: x;\narray[1..n-1] of var 1..n-1: diffs;\nint: sum_distinct = ((n+1)*n) div 2;\n\n% max_regret seems to be quite good....\nsolve :: int_search(x, max_regret, indomain_split, complete) satisfy;\n\nconstraint      \n  all_different(diffs) :: domain\n  /\\  \n  all_different(x) :: domain\n  /\\ \n  forall(k in 1..n-1) (\n      diffs[k] = abs(x[k+1] - x[k])\n  )\n  /\\ % symmetry breaking\n  x[1] < x[n-1]\n  /\\\n  diffs[1] < diffs[2]\n;\n\n\noutput [\n       show(x) ++ \",\" % , \" \", show(sum_distinct), \" diffs: \", show(diffs)\n]\n\n\nModel 2 : \n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n%    all_different(series) /\\\n\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i != j)  (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n;\n\noutput\n[  show(series)\n];\n\n\nModel 3 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   %  C1: Each pitch class occurs exactly once\n   forall(i, j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i!=j) (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput\n[ show(series)\n];\n\n\nModel 4 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[differ] of var differ: differences;\n\nsolve satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 1..n-2) (\n       differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in differ where i != j) (\n       differences[i] != differences[j]\n   )\n;\n\noutput [\n  show(series)\n];\n\n\nModel 5 : \n\n\ninclude \"globals.mzn\";\n\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_median, complete) satisfy;\n\nconstraint\n  % C1: Each pitch class occurs exactly once\n  % GCAD: Exploitation of alldifferent() global constraint\n  all_different(series)\n  /\\\n\n  % C2: Differences between neighbouring notes are all different\n  % GCAD: Exploitation of alldifferent() global constraint\n  % alldifferent(all (i in classes: i <> n-1) abs(series[i+1] - series[i]));\n  all_different( \n         [ abs(series[i+1] - series[i]) | i in classes where i != n-1]\n  )\n  \n;\n\noutput [\n  show(series)\n];\n\n\nModel 6 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\n% solve satisfy;\nsolve :: int_search(series, occurrence, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n      differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in 0..n-2 where i != j) (\n      differences[i] != differences[j]\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\noutput [\n  show(series)\n];\n\n\nModel 7 : \n\n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\nsolve ::int_search(series, first_fail, indomain_max, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(series)\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n          differences[i] = abs(series[i+1] - series[i])\n   )\n   /\\\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(differences)\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput [\n   \"series: \" ++ show(series) ++ \"\\n\" ++\n   \"differences: \" ++ show(differences) \n];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "all_interval_beginner", "node_type": "4", "metadata": {"model_name": "all_interval", "source_code": "Model 1 : \n\n\n%\n% All interval problem in MiniZinc\n%\n% \"\"\"\n% Given the twelve standard pitch-classes (c, c%, d, ...), represented by\n% numbers 0,1,...,11, find a series in which each pitch-class occurs exactly\n% once and in which the musical intervals between neighbouring notes cover\n% the full set of intervals from the minor second (1 semitone) to the major\n% seventh (11 semitones). That is, for each of the intervals, there is a\n% pair of neigbhouring pitch-classes in the series, between which this\n% interval appears. The problem of finding such a series can be easily\n% formulated as an instance of a more general arithmetic problem on Z_n,\n% the set of integer residues modulo n. Given n in N, find a vector\n% s = (s_1, ..., s_n), such that (i) s is a permutation of\n% Z_n = {0,1,...,n-1}; and (ii) the interval vector\n% v = (|s_2-s_1|, |s_3-s_2|, ... |s_n-s_{n-1}|) is a permutation of\n% Z_n-{0} = {1,2,...,n-1}. A vector v satisfying these conditions is\n% called an all-interval series of size n; the problem of finding such\n% a series is the all-interval series problem of size n. We may also be\n% interested in finding all possible series of a given size.\n\ninclude \"globals.mzn\";\n\nint: n = 12;\n% array[1..n] of var 1..n: x;\narray[1..n] of var 1..n: x;\narray[1..n-1] of var 1..n-1: diffs;\nint: sum_distinct = ((n+1)*n) div 2;\n\n% max_regret seems to be quite good....\nsolve :: int_search(x, max_regret, indomain_split, complete) satisfy;\n\nconstraint      \n  all_different(diffs) :: domain\n  /\\  \n  all_different(x) :: domain\n  /\\ \n  forall(k in 1..n-1) (\n      diffs[k] = abs(x[k+1] - x[k])\n  )\n  /\\ % symmetry breaking\n  x[1] < x[n-1]\n  /\\\n  diffs[1] < diffs[2]\n;\n\n\noutput [\n       show(x) ++ \",\" % , \" \", show(sum_distinct), \" diffs: \", show(diffs)\n]\n\n\nModel 2 : \n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n%    all_different(series) /\\\n\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i != j)  (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n;\n\noutput\n[  show(series)\n];\n\n\nModel 3 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   %  C1: Each pitch class occurs exactly once\n   forall(i, j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i!=j) (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput\n[ show(series)\n];\n\n\nModel 4 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[differ] of var differ: differences;\n\nsolve satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 1..n-2) (\n       differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in differ where i != j) (\n       differences[i] != differences[j]\n   )\n;\n\noutput [\n  show(series)\n];\n\n\nModel 5 : \n\n\ninclude \"globals.mzn\";\n\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_median, complete) satisfy;\n\nconstraint\n  % C1: Each pitch class occurs exactly once\n  % GCAD: Exploitation of alldifferent() global constraint\n  all_different(series)\n  /\\\n\n  % C2: Differences between neighbouring notes are all different\n  % GCAD: Exploitation of alldifferent() global constraint\n  % alldifferent(all (i in classes: i <> n-1) abs(series[i+1] - series[i]));\n  all_different( \n         [ abs(series[i+1] - series[i]) | i in classes where i != n-1]\n  )\n  \n;\n\noutput [\n  show(series)\n];\n\n\nModel 6 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\n% solve satisfy;\nsolve :: int_search(series, occurrence, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n      differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in 0..n-2 where i != j) (\n      differences[i] != differences[j]\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\noutput [\n  show(series)\n];\n\n\nModel 7 : \n\n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\nsolve ::int_search(series, first_fail, indomain_max, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(series)\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n          differences[i] = abs(series[i+1] - series[i])\n   )\n   /\\\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(differences)\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput [\n   \"series: \" ++ show(series) ++ \"\\n\" ++\n   \"differences: \" ++ show(differences) \n];"}, "hash": "c74e9d4b6b31fb3b2fbc17d8de9f5005f72a410aa8b381c3f47bec89126ece21", "class_name": "RelatedNodeInfo"}}, "text": "Here is the explanation of the problem:\n\n**Name of the problem:** All-Interval Series Problem\n\n**What the problem is about in everyday terms:** Imagine you have 12 different musical notes (like C, C#, D, etc.). You want to arrange these notes in a special order so that each note appears only once, and the distance between each pair of adjacent notes is different from the distance between any other pair of adjacent notes. For example, if the distance between the first two notes is 2 semitones, then there should be no other pair of adjacent notes with a distance of 2 semitones.\n\n**Main variables and what they mean:**\n\n* `x` or `series`: an array of 12 variables, each representing a musical note (0 to 11). This array represents the order in which the notes will be played.\n* `diffs` or `differences`: an array of variables representing the distance between each pair of adjacent notes.\n\n**Basic restrictions or rules of the problem:**\n\n* Each note must appear only once in the series.\n* The distance between each pair of adjacent notes must be different from the distance between any other pair of adjacent notes.\n\n**Goal of the problem:** Find an arrangement of the 12 notes that satisfies the above rules.\n\nNote that the different models provided are different ways of solving the same problem, but the underlying problem remains the same.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1348, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5d95f426-a5a5-4f06-8ab4-255fe1eeb1fe": {"__data__": {"id_": "5d95f426-a5a5-4f06-8ab4-255fe1eeb1fe", "embedding": null, "metadata": {"model_name": "assign", "source_code": "Model 1 :\n\nint: n;\nset of int: WORK = 1..n;\nint: m;\nset of int: TASK = 1..m;\narray[WORK,TASK] of int: profit;\narray[WORK] of var TASK: x;\n% new\narray[WORK] of var int: px =\n     [ profit[w,x[w]] | w in WORK ];\nvar int: obj = sum(w in WORK)(px[w]);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\n\nann: varselect;\nann: valselect;\n\nsolve :: int_search(px, varselect, valselect, complete)\n      maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x);\\n\"];\n\n\nvarselect = largest;\nvalselect = indomain_min;\n\n\nModel 2 : \n\n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[DOM] of var COD: task;\narray[COD] of var DOM: worker;\n\ninclude \"inverse.mzn\";\nconstraint inverse(task,worker);\n\n\nsolve maximize sum(w in COD)\n            (profit[w,task[w]]);\n\noutput [show(task)];\n\n\n\nModel 3 : \n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[COD] of var DOM: worker;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(worker);\n\n\nsolve maximize sum(t in COD)\n            (profit[worker[t],t]);\n\noutput [show(worker)];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "assign_beginner", "node_type": "4", "metadata": {"model_name": "assign", "source_code": "Model 1 :\n\nint: n;\nset of int: WORK = 1..n;\nint: m;\nset of int: TASK = 1..m;\narray[WORK,TASK] of int: profit;\narray[WORK] of var TASK: x;\n% new\narray[WORK] of var int: px =\n     [ profit[w,x[w]] | w in WORK ];\nvar int: obj = sum(w in WORK)(px[w]);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\n\nann: varselect;\nann: valselect;\n\nsolve :: int_search(px, varselect, valselect, complete)\n      maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x);\\n\"];\n\n\nvarselect = largest;\nvalselect = indomain_min;\n\n\nModel 2 : \n\n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[DOM] of var COD: task;\narray[COD] of var DOM: worker;\n\ninclude \"inverse.mzn\";\nconstraint inverse(task,worker);\n\n\nsolve maximize sum(w in COD)\n            (profit[w,task[w]]);\n\noutput [show(task)];\n\n\n\nModel 3 : \n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[COD] of var DOM: worker;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(worker);\n\n\nsolve maximize sum(t in COD)\n            (profit[worker[t],t]);\n\noutput [show(worker)];\n"}, "hash": "710399ef5ffbce1af11f2fd4c22c75a318b99b321d396f6d80e3cfc4681199d3", "class_name": "RelatedNodeInfo"}}, "text": "**The Assignment Problem**\n\n**What is it about?**\nImagine you have a group of workers and a list of tasks that need to be done. Each worker can do one task, and each task can be done by one worker. The problem is to assign each worker to a task in a way that maximizes the total profit or benefit.\n\n**Main variables:**\n\n* `WORK` (or `DOM`): a set of workers\n* `TASK` (or `COD`): a set of tasks\n* `x` (or `task` or `worker`): a variable that represents the assignment of a worker to a task\n* `profit`: a table that shows the profit or benefit of assigning a worker to a task\n* `obj`: the total profit or benefit of the assignment\n\n**Basic restrictions or rules:**\n\n* Each worker can do only one task.\n* Each task can be done by only one worker.\n* The assignment must be done in a way that maximizes the total profit or benefit.\n\n**Goal:**\nThe goal is to find an assignment of workers to tasks that maximizes the total profit or benefit.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 935, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "98d9e212-d5e9-467e-9c8e-90a6c70c6d5d": {"__data__": {"id_": "98d9e212-d5e9-467e-9c8e-90a6c70c6d5d", "embedding": null, "metadata": {"model_name": "aust_color", "source_code": "Model 1 :\n\n% Colouring Australia using 4 colors \nint: nc = 4;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n\n\n Model 2 :\n\n % Colouring Australia using nc colors \nint: nc;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aust_color_beginner", "node_type": "4", "metadata": {"model_name": "aust_color", "source_code": "Model 1 :\n\n% Colouring Australia using 4 colors \nint: nc = 4;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n\n\n Model 2 :\n\n % Colouring Australia using nc colors \nint: nc;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n"}, "hash": "547527a1d5e19a407c91bf63b4161be0dca833bbd602506eb767aaee84cf3074", "class_name": "RelatedNodeInfo"}}, "text": "**The Australian Map Colouring Problem**\n\nThis problem is about colouring a map of Australia with different colours. Imagine you have a map of Australia with six states: Western Australia (WA), Northern Territory (NT), South Australia (SA), Queensland (Q), New South Wales (NSW), and Victoria (V), plus Tasmania (T).\n\n**Main variables:**\n\n* wa, nt, sa, q, nsw, v, and t: These are the colours assigned to each state.\n\n**Basic restrictions or rules:**\n\n* Each state must have a different colour from its neighbouring states.\n\n**Goal:**\n\n* Find a way to colour the map of Australia using a certain number of colours (4 or more) such that no two neighbouring states have the same colour.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 684, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e1a5974f-61ea-47de-aa8d-e48c423921ad": {"__data__": {"id_": "e1a5974f-61ea-47de-aa8d-e48c423921ad", "embedding": null, "metadata": {"model_name": "bibd", "source_code": "% bibd.mzn\n% vim: ft=zinc ts=4 sw=4 et tw=0\n% Ralph Becket <rafe@csse.unimelb.edu.au>\n% Tue Oct 23 11:28:06 EST 2007\n%\n% Balanced incomplete block designs.  See the following:\n% http://mathworld.wolfram.com/BlockDesign.html\n% http://www.dcs.st-and.ac.uk/~ianm/CSPLib/prob/prob028/spec.html\n%\n%\n%\n% A BIBD (v, b, r, k, lambda) problem is to find a binary matrix of v rows\n% of b columns such that each row sums to r, each column sums to k, and\n% the dot product beween any pair of distinct rows is lambda.\n\ninclude \"lex_lesseq.mzn\";\n\nint: v;\nint: k;\nint: lambda;\n\nint: b = (lambda * v * (v - 1)) div (k * (k - 1));\nint: r = (lambda * (v - 1)) div (k - 1);\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\narray [rows, cols] of var bool: m;\n\n    % Every row must sum to r.\n    %\nconstraint forall (i in rows) (sum (j in cols) (bool2int(m[i, j])) = r);\n\n    % Every column must sum to k.\n    %\nconstraint forall (j in cols) (sum (i in rows) (bool2int(m[i, j])) = k);\n\n    % The dot product of every pair of distinct rows must be lambda.\n    %\nconstraint\n    forall (i_a, i_b in rows where i_a < i_b) (\n        sum (j in cols) (bool2int(m[i_a, j] /\\ m[i_b, j])) = lambda\n    );\n\n    % Break row symmetry in the incidence matrix.\n    %\nconstraint forall(i in rows diff {max(rows)})(\n        lex_lesseq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    );\n\n    % Break column symmetry in the incidence matrix.\n    %\nconstraint forall(j in cols diff {max(cols)})(\n        lex_lesseq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    );\n\nsolve :: bool_search([m[i, j] | i in rows, j in cols],\n    input_order, indomain_min, complete)\n    satisfy;\n\noutput  [\"bibd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r),\n        \", k = \", show(k), \", lambda = \", show(lambda), \")\\n\\n\"] ++\n        [ ( if j > b then \"\\n\" else show(bool2int(m[i, j])) endif )\n        | i in rows, j in 1..(b + 1)\n        ];\n\n%----------------------------------------------------------------------------%\n%----------------------------------------------------------------------------%\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bibd_beginner", "node_type": "4", "metadata": {"model_name": "bibd", "source_code": "% bibd.mzn\n% vim: ft=zinc ts=4 sw=4 et tw=0\n% Ralph Becket <rafe@csse.unimelb.edu.au>\n% Tue Oct 23 11:28:06 EST 2007\n%\n% Balanced incomplete block designs.  See the following:\n% http://mathworld.wolfram.com/BlockDesign.html\n% http://www.dcs.st-and.ac.uk/~ianm/CSPLib/prob/prob028/spec.html\n%\n%\n%\n% A BIBD (v, b, r, k, lambda) problem is to find a binary matrix of v rows\n% of b columns such that each row sums to r, each column sums to k, and\n% the dot product beween any pair of distinct rows is lambda.\n\ninclude \"lex_lesseq.mzn\";\n\nint: v;\nint: k;\nint: lambda;\n\nint: b = (lambda * v * (v - 1)) div (k * (k - 1));\nint: r = (lambda * (v - 1)) div (k - 1);\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\narray [rows, cols] of var bool: m;\n\n    % Every row must sum to r.\n    %\nconstraint forall (i in rows) (sum (j in cols) (bool2int(m[i, j])) = r);\n\n    % Every column must sum to k.\n    %\nconstraint forall (j in cols) (sum (i in rows) (bool2int(m[i, j])) = k);\n\n    % The dot product of every pair of distinct rows must be lambda.\n    %\nconstraint\n    forall (i_a, i_b in rows where i_a < i_b) (\n        sum (j in cols) (bool2int(m[i_a, j] /\\ m[i_b, j])) = lambda\n    );\n\n    % Break row symmetry in the incidence matrix.\n    %\nconstraint forall(i in rows diff {max(rows)})(\n        lex_lesseq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    );\n\n    % Break column symmetry in the incidence matrix.\n    %\nconstraint forall(j in cols diff {max(cols)})(\n        lex_lesseq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    );\n\nsolve :: bool_search([m[i, j] | i in rows, j in cols],\n    input_order, indomain_min, complete)\n    satisfy;\n\noutput  [\"bibd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r),\n        \", k = \", show(k), \", lambda = \", show(lambda), \")\\n\\n\"] ++\n        [ ( if j > b then \"\\n\" else show(bool2int(m[i, j])) endif )\n        | i in rows, j in 1..(b + 1)\n        ];\n\n%----------------------------------------------------------------------------%\n%----------------------------------------------------------------------------%\n"}, "hash": "a29abde4245c122558b027202dcf39f8d04ba87f033258ac92c772c9702ae87d", "class_name": "RelatedNodeInfo"}}, "text": "Balanced Incomplete Block Design (BIBD)\n\nThis problem is about creating a special kind of table with certain properties. Imagine you have a bunch of people, and you want to divide them into groups to play games or do activities together. You want to make sure that each person plays with the same number of other people, and each group has the same number of people. Also, you want to make sure that any two people play together in the same group a certain number of times.\n\nThe main variables are:\n\n* v: the number of people\n* k: the number of people in each group\n* lambda: the number of times any two people play together in the same group\n* b: the number of groups (calculated based on v, k, and lambda)\n* r: the number of groups each person is in (calculated based on v, k, and lambda)\n* m: a table that shows which people are in which groups (this is the main thing we're trying to figure out)\n\nThe basic restrictions or rules of the problem are:\n\n* Each person is in the same number of groups (r)\n* Each group has the same number of people (k)\n* Any two people play together in the same group the same number of times (lambda)\n\nThe goal of the problem is to find a table (m) that satisfies all these rules.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1213, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ab8a6fb2-c585-4732-8a64-889525f035f1": {"__data__": {"id_": "ab8a6fb2-c585-4732-8a64-889525f035f1", "embedding": null, "metadata": {"model_name": "bus_scheduling_csplib", "source_code": "%\n% Bus driver scheduling problem (prob022 in CSPLib) in MiniZinc.\n%\n% Specification\n% Bus driver scheduling can be formulated as a set paritioning problem.\n% We propose 12 set partitioning problems derived from small bus driver\n% scheduling problems. These consist of a given set of tasks (pieces of\n% work) to cover and a large set of possible shifts, where each shift\n% covers a subset of the tasks and has an associated cost. We must select\n% a subset of possible shifts that covers each piece of work once and\n% only once: this is called a partition. Further,\n%\n% In the driver scheduling (unlike air crew scheduling) the main aim is\n% to reduce the number of shifts used in the solution partition and the\n% total cost of the partition is secondary. To simplify the problem we have\n% made the cost of each shift the same. This means that the goal is to\n% minimise the number of shifts.\n%\n% The problems come from four different bus companies:\n% Reading (r1 to r5a),\n% CentreWest Ealing area (c1, c1a, c2),\n% the former London Transport (t1 and t2).\n%\n% The problems have differing regulations and features (e.g. urban and\n% short distance rural bus schedules can have very different features). Note\n% that r1 and r1a are the same problem, but have different numbers of\n% generated shifts. Similarly with the problems: c1, c1a and r5, r5a.\n%\n% Problems are presented in the same format as the set partitioning\n% examples in ORLIB. The first line gives the number of rows (pieces of work),\n% columns (shifts) and the minimum number of columns need for a partition.\n% Then each line after that corresponds to one column. It starts with\n% the cost (which is always 1 in our case) then the number of rows it\n% covers, followed by the rows it covers.\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \nint: num_work;\nint: num_shifts;\nint: min_num_shifts;\narray[1..num_shifts] of set of int: shifts;\n\narray[1..num_shifts] of var 0..1: x;\nvar 0..num_shifts: tot_shifts;\n\n% solve minimize tot_shifts;\nsolve :: int_search(\n        x ++ [tot_shifts], \n        first_fail, \n        indomain_min, \n        complete) \n    minimize tot_shifts;\n    % satisfy;\n\nconstraint\n   tot_shifts = sum(x)\n   /\\\n   forall(j in 0..num_work-1) (\n       sum(i in 1..num_shifts) (x[i]*bool2int(j in shifts[i])) = 1\n   )\n   /\\\n   tot_shifts >= min_num_shifts\n\n   % /\\ % for solve satisfy (t1)\n   % tot_shifts = 7\n;\n\n\noutput [\n  \"tot_shifts: \" ++ show(tot_shifts) ++ \"\\n\" ++ \n  \"x: \" ++ show(x) ++ \"\\n\"\n] ++ \n[\n  if fix(x[i]) = 1 then show(shifts[i]) else \"\" endif\n  | i in 1..num_shifts\n] ++ \n[\"\\n\"] ++\n[\n  if fix(x[i]) = 1 then show(i) ++ \" \" else \"\" endif\n  | i in 1..num_shifts\n] ++ [\"\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bus_scheduling_csplib_beginner", "node_type": "4", "metadata": {"model_name": "bus_scheduling_csplib", "source_code": "%\n% Bus driver scheduling problem (prob022 in CSPLib) in MiniZinc.\n%\n% Specification\n% Bus driver scheduling can be formulated as a set paritioning problem.\n% We propose 12 set partitioning problems derived from small bus driver\n% scheduling problems. These consist of a given set of tasks (pieces of\n% work) to cover and a large set of possible shifts, where each shift\n% covers a subset of the tasks and has an associated cost. We must select\n% a subset of possible shifts that covers each piece of work once and\n% only once: this is called a partition. Further,\n%\n% In the driver scheduling (unlike air crew scheduling) the main aim is\n% to reduce the number of shifts used in the solution partition and the\n% total cost of the partition is secondary. To simplify the problem we have\n% made the cost of each shift the same. This means that the goal is to\n% minimise the number of shifts.\n%\n% The problems come from four different bus companies:\n% Reading (r1 to r5a),\n% CentreWest Ealing area (c1, c1a, c2),\n% the former London Transport (t1 and t2).\n%\n% The problems have differing regulations and features (e.g. urban and\n% short distance rural bus schedules can have very different features). Note\n% that r1 and r1a are the same problem, but have different numbers of\n% generated shifts. Similarly with the problems: c1, c1a and r5, r5a.\n%\n% Problems are presented in the same format as the set partitioning\n% examples in ORLIB. The first line gives the number of rows (pieces of work),\n% columns (shifts) and the minimum number of columns need for a partition.\n% Then each line after that corresponds to one column. It starts with\n% the cost (which is always 1 in our case) then the number of rows it\n% covers, followed by the rows it covers.\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \nint: num_work;\nint: num_shifts;\nint: min_num_shifts;\narray[1..num_shifts] of set of int: shifts;\n\narray[1..num_shifts] of var 0..1: x;\nvar 0..num_shifts: tot_shifts;\n\n% solve minimize tot_shifts;\nsolve :: int_search(\n        x ++ [tot_shifts], \n        first_fail, \n        indomain_min, \n        complete) \n    minimize tot_shifts;\n    % satisfy;\n\nconstraint\n   tot_shifts = sum(x)\n   /\\\n   forall(j in 0..num_work-1) (\n       sum(i in 1..num_shifts) (x[i]*bool2int(j in shifts[i])) = 1\n   )\n   /\\\n   tot_shifts >= min_num_shifts\n\n   % /\\ % for solve satisfy (t1)\n   % tot_shifts = 7\n;\n\n\noutput [\n  \"tot_shifts: \" ++ show(tot_shifts) ++ \"\\n\" ++ \n  \"x: \" ++ show(x) ++ \"\\n\"\n] ++ \n[\n  if fix(x[i]) = 1 then show(shifts[i]) else \"\" endif\n  | i in 1..num_shifts\n] ++ \n[\"\\n\"] ++\n[\n  if fix(x[i]) = 1 then show(i) ++ \" \" else \"\" endif\n  | i in 1..num_shifts\n] ++ [\"\\n\"];\n"}, "hash": "42730df4bd22aaee5246f8c173b35dccba729c65391f220253f72aefd8c5b403", "class_name": "RelatedNodeInfo"}}, "text": "Bus Driver Scheduling Problem\n\nThis problem is about creating a schedule for bus drivers to cover all the tasks (like driving routes) with the minimum number of drivers needed.\n\nThe main variables are:\n\n* Tasks (or pieces of work): these are the bus routes or driving jobs that need to be covered.\n* Shifts: these are the possible schedules for the bus drivers, which cover some of the tasks.\n* x: this is a variable that decides which shifts to choose for the drivers.\n* tot_shifts: this is the total number of shifts (or drivers) needed to cover all the tasks.\n\nThe basic restrictions or rules of the problem are:\n\n* Each task must be covered by exactly one shift (or driver).\n* Each shift can cover multiple tasks.\n* We want to use the minimum number of shifts (or drivers) to cover all the tasks.\n\nThe goal of the problem is to minimize the total number of shifts (or drivers) needed to cover all the tasks.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 911, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "168ac6f2-5cf4-457a-96a7-cfcf1da061fc": {"__data__": {"id_": "168ac6f2-5cf4-457a-96a7-cfcf1da061fc", "embedding": null, "metadata": {"model_name": "car", "source_code": "%\n% Car sequencing in MiniZinc.\n% include \"globals.mzn\";\n\nint: numclasses;\nint: numoptions;\nint: numcars;\nset of int: Classes = 1..numclasses;\nset of int: Options = 1..numoptions;\nset of int: Slots = 1..numcars;\n\narray[Classes] of int: numberPerClass;\n\narray[Classes,Options] of int: optionsRequired;\narray[Options] of int: windowSize;\narray[Options] of int: optMax;\n\narray[Options] of int: optionNumberPerClass = [sum(j in Classes) (numberPerClass[j] * optionsRequired[j,i]) | i in Options];\n\n% decision variables\n\narray[Slots] of var Classes: slot;\narray[Options, Slots] of var 0..1: setup;\n\n\nvar int: z = sum(s in Classes) (s*slot[s]);\n\n% solve minimize z;\nsolve :: int_search(slot, input_order, indomain_min, complete)\n  satisfy;\n\nconstraint\n  forall(c in Classes ) (\n    sum(s in Slots ) (bool2int(slot[s] = c)) = numberPerClass[c]\n  )\n  /\\\n  forall(o in Options, s in 1..numcars - windowSize[o] + 1) (\n    sum(j in s..s + windowSize[o]- 1) (setup[o,j]) <= optMax[o]\n  )\n  /\\\n  forall(o in Options, s in Slots ) (\n    setup[o,s] = optionsRequired[slot[s],o]\n  )\n  /\\\n  forall(o in Options, i in 1..optionNumberPerClass[o]) (\n    sum(s in 1..(numcars - i * windowSize[o])) (setup[o,s]) >=\n           (optionNumberPerClass[o] - i * optMax[o])\n  )\n;\n\n% for solve satisfy\n% constraint z = 82;\n\n\noutput [\n \"z: \" ++ show(z) ++ \"\\n\" ++\n \"slot: \" ++ show(slot) ++ \"\\n\"\n] ++\n[\n  if j = 1 then \"\\n\" else \" \" endif ++ \n    show(setup[i,j])\n  | i in Options, j in Slots\n];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "car_beginner", "node_type": "4", "metadata": {"model_name": "car", "source_code": "%\n% Car sequencing in MiniZinc.\n% include \"globals.mzn\";\n\nint: numclasses;\nint: numoptions;\nint: numcars;\nset of int: Classes = 1..numclasses;\nset of int: Options = 1..numoptions;\nset of int: Slots = 1..numcars;\n\narray[Classes] of int: numberPerClass;\n\narray[Classes,Options] of int: optionsRequired;\narray[Options] of int: windowSize;\narray[Options] of int: optMax;\n\narray[Options] of int: optionNumberPerClass = [sum(j in Classes) (numberPerClass[j] * optionsRequired[j,i]) | i in Options];\n\n% decision variables\n\narray[Slots] of var Classes: slot;\narray[Options, Slots] of var 0..1: setup;\n\n\nvar int: z = sum(s in Classes) (s*slot[s]);\n\n% solve minimize z;\nsolve :: int_search(slot, input_order, indomain_min, complete)\n  satisfy;\n\nconstraint\n  forall(c in Classes ) (\n    sum(s in Slots ) (bool2int(slot[s] = c)) = numberPerClass[c]\n  )\n  /\\\n  forall(o in Options, s in 1..numcars - windowSize[o] + 1) (\n    sum(j in s..s + windowSize[o]- 1) (setup[o,j]) <= optMax[o]\n  )\n  /\\\n  forall(o in Options, s in Slots ) (\n    setup[o,s] = optionsRequired[slot[s],o]\n  )\n  /\\\n  forall(o in Options, i in 1..optionNumberPerClass[o]) (\n    sum(s in 1..(numcars - i * windowSize[o])) (setup[o,s]) >=\n           (optionNumberPerClass[o] - i * optMax[o])\n  )\n;\n\n% for solve satisfy\n% constraint z = 82;\n\n\noutput [\n \"z: \" ++ show(z) ++ \"\\n\" ++\n \"slot: \" ++ show(slot) ++ \"\\n\"\n] ++\n[\n  if j = 1 then \"\\n\" else \" \" endif ++ \n    show(setup[i,j])\n  | i in Options, j in Slots\n];\n"}, "hash": "90c1a3e1f0ba85fee0788ea5971a1f29a699045d2500245c538ca42ac863d9b5", "class_name": "RelatedNodeInfo"}}, "text": "**Car Sequencing Problem**\n\nThis problem is about arranging cars on a production line in a specific order. Imagine a factory that produces cars with different features, such as sunroofs, leather seats, or navigation systems. The goal is to sequence the cars in a way that minimizes the total number of changes needed to switch between different features.\n\n**Main Variables:**\n\n* `slot`: represents the type of car (e.g., sedan, SUV, etc.) assigned to each production slot.\n* `setup`: indicates whether a specific feature (e.g., sunroof) is installed on a car in a particular slot.\n\n**Basic Restrictions or Rules:**\n\n* Each type of car has a specific number of units to be produced.\n* Certain features require a minimum number of consecutive cars to be produced together (e.g., a sunroof requires 3 consecutive cars).\n* The production line has a limited capacity for each feature (e.g., only 5 cars with leather seats can be produced in a row).\n\n**Goal:**\n\nThe goal is to minimize the total number of changes needed to switch between different car types and features while satisfying the production requirements and restrictions.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1128, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2683cddb-07e4-4a61-820f-4dd2077534a4": {"__data__": {"id_": "2683cddb-07e4-4a61-820f-4dd2077534a4", "embedding": null, "metadata": {"model_name": "carpet_cutting", "source_code": "Model 1 :\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\narray[ROOM] of var ROT: rot;\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)(shape[i,rot[i]] != {});\n\nconstraint forall(i in ROOM)(forall(r in ROFF)\n  (r in shape[i,rot[i]] -> \n  (x[i] + d[r,1] + d[r,3] <= l /\\\n   y[i] + d[r,2] + d[r,4] <= h)));\n\nconstraint forall(i,j in ROOM where i < j)\n  (forall(r1,r2 in ROFF)\n (r1 in shape[i,rot[i]] /\\ \n  r2 in shape[j,rot[j]] -> \n(x[i] + d[r1,1] + d[r1,3] <= x[j] + d[r2,1]\n                   \\/\n x[j] + d[r2,1] + d[r2,3] <= x[i] + d[r1,1]\n                   \\/\n y[i] + d[r1,2] + d[r1,4] <= y[j] + d[r2,2]\n                   \\/\ny[j] + d[r2,2] + d[r2,4] <= y[i] + d[r1,2])\n   ));\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nrot = \\(rot);\\n\"];\n\n\n\nModel 2 :\n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: DIM = 1..2;\narray[ROFF,DIM] of int: rect_size = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 3..4]);\narray[ROFF,DIM] of int: rect_offset = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 1..2]);\narray[int] of set of ROFF: shapes = [ {1,3,4}, {2,5,6}, {1}, {7} ];\nset of int: SHAPE = index_set(shapes);\n%array[int] of set of RECT: s = sort([shapes[i,j] | i in 1..n, j in 1..4]);\n\narray[ROOM] of var SHAPE: kind;\narray[ROOM,DIM] of var int: coords =\n      array2d(ROOM,DIM, [ if j = 1 then x[i] else y[i] endif\n                         | i in ROOM, j in 1..2 ]);\n\n\n\ninclude \"geost.mzn\";\n\nconstraint geost_bb(2,\n                    rect_size,\n                    rect_offset,\n                    shapes,\n                    coords,\n                    kind,\n                    [0,0],\n                    [l,h]);\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)\n                 (exists(r in ROT where shape[i,r] != {})\n                        (shapes[kind[i]] = shape[i,r]));\n\n\noutput [\"rect_size = \\(rect_size);\\nrect_offset = \\(rect_offset);\\n\"] ++\n       [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];\n\n\n\nModel 3 : \n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: SHAPE = 1..4;\narray[ROOM] of var SHAPE: kind;\n\nconstraint geost_bb(2,\n       [| 3,4 | 4,3 | 1,1 | 1,2 | 1,1 | 2,1 | 4,3 |],\n       [| 0,0 | 0,1 | 1,4 | 3,1 | 4,2 | 1,0 | 0,0 |],\n       [ {1,3,4}, {2,5,6}, {1}, {7} ],\n       [| x[1], y[1] | x[2],y[2] | x[3],y[3] |],\n       kind,\n       [ 0,0 ],\n       [ l, h]);\n\nconstraint kind[1] in {1,2};\nconstraint kind[2] in {1,2};\nconstraint kind[3] in {3,4}; \ninclude \"geost.mzn\";\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "carpet_cutting_beginner", "node_type": "4", "metadata": {"model_name": "carpet_cutting", "source_code": "Model 1 :\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\narray[ROOM] of var ROT: rot;\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)(shape[i,rot[i]] != {});\n\nconstraint forall(i in ROOM)(forall(r in ROFF)\n  (r in shape[i,rot[i]] -> \n  (x[i] + d[r,1] + d[r,3] <= l /\\\n   y[i] + d[r,2] + d[r,4] <= h)));\n\nconstraint forall(i,j in ROOM where i < j)\n  (forall(r1,r2 in ROFF)\n (r1 in shape[i,rot[i]] /\\ \n  r2 in shape[j,rot[j]] -> \n(x[i] + d[r1,1] + d[r1,3] <= x[j] + d[r2,1]\n                   \\/\n x[j] + d[r2,1] + d[r2,3] <= x[i] + d[r1,1]\n                   \\/\n y[i] + d[r1,2] + d[r1,4] <= y[j] + d[r2,2]\n                   \\/\ny[j] + d[r2,2] + d[r2,4] <= y[i] + d[r1,2])\n   ));\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nrot = \\(rot);\\n\"];\n\n\n\nModel 2 :\n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: DIM = 1..2;\narray[ROFF,DIM] of int: rect_size = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 3..4]);\narray[ROFF,DIM] of int: rect_offset = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 1..2]);\narray[int] of set of ROFF: shapes = [ {1,3,4}, {2,5,6}, {1}, {7} ];\nset of int: SHAPE = index_set(shapes);\n%array[int] of set of RECT: s = sort([shapes[i,j] | i in 1..n, j in 1..4]);\n\narray[ROOM] of var SHAPE: kind;\narray[ROOM,DIM] of var int: coords =\n      array2d(ROOM,DIM, [ if j = 1 then x[i] else y[i] endif\n                         | i in ROOM, j in 1..2 ]);\n\n\n\ninclude \"geost.mzn\";\n\nconstraint geost_bb(2,\n                    rect_size,\n                    rect_offset,\n                    shapes,\n                    coords,\n                    kind,\n                    [0,0],\n                    [l,h]);\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)\n                 (exists(r in ROT where shape[i,r] != {})\n                        (shapes[kind[i]] = shape[i,r]));\n\n\noutput [\"rect_size = \\(rect_size);\\nrect_offset = \\(rect_offset);\\n\"] ++\n       [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];\n\n\n\nModel 3 : \n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: SHAPE = 1..4;\narray[ROOM] of var SHAPE: kind;\n\nconstraint geost_bb(2,\n       [| 3,4 | 4,3 | 1,1 | 1,2 | 1,1 | 2,1 | 4,3 |],\n       [| 0,0 | 0,1 | 1,4 | 3,1 | 4,2 | 1,0 | 0,0 |],\n       [ {1,3,4}, {2,5,6}, {1}, {7} ],\n       [| x[1], y[1] | x[2],y[2] | x[3],y[3] |],\n       kind,\n       [ 0,0 ],\n       [ l, h]);\n\nconstraint kind[1] in {1,2};\nconstraint kind[2] in {1,2};\nconstraint kind[3] in {3,4}; \ninclude \"geost.mzn\";\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];"}, "hash": "e1cf2b330922a12af59c6556608737fe0bc466e85f7857d110f3489c7c06dabf", "class_name": "RelatedNodeInfo"}}, "text": "Here is the explanation of the problem:\n\n**Name of the problem:** Carpet Cutting Problem\n\n**What the problem is about in everyday terms:** Imagine you have a roll of carpet and you need to cut it to fit different rooms in a house. Each room has a specific shape and size, and you want to use the minimum amount of carpet possible to cover all the rooms.\n\n**Main variables and what they mean:**\n\n* `n`: The number of rooms in the house.\n* `m`: The number of different rectangle shapes that can be used to cut the carpet.\n* `ROOM`: A set of integers representing the rooms in the house.\n* `ROFF`: A set of integers representing the different rectangle shapes.\n* `d`: An array of integers representing the definitions of the rectangle shapes (x-offset, y-offset, x-size, y-size).\n* `shape`: An array of sets of integers representing the shapes that can be used for each room.\n* `h`: The height of the roll of carpet.\n* `maxl`: The maximum length of the roll of carpet.\n* `x` and `y`: Arrays of variables representing the x and y coordinates of the top-left corner of each room.\n* `rot`: An array of variables representing the rotation of each room (0, 90, 180, or 270 degrees).\n* `l`: A variable representing the length of carpet used.\n\n**Basic restrictions or rules of the problem:**\n\n* Each room must be covered by a single piece of carpet.\n* The carpet must be cut from the roll in a way that minimizes waste.\n* The shapes of the rooms and the carpet pieces must fit together without overlapping.\n\n**Goal of the problem:** The goal is to find the minimum length of carpet needed to cover all the rooms.\n\nIn summary, the Carpet Cutting Problem is about finding the most efficient way to cut a roll of carpet to fit different rooms in a house, using the minimum amount of carpet possible.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1786, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "612d5e03-cd42-4f6a-be99-db559ec7c314": {"__data__": {"id_": "612d5e03-cd42-4f6a-be99-db559ec7c314", "embedding": null, "metadata": {"model_name": "cell_block", "source_code": "Model 1 :\n\n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\n%constraint forall(p1, p2 in PRISONER where p1 < p2)\n%                 (abs(r[p1] - r[p2]) + abs(c[p1] - c[p2]) > 0); \ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nconstraint forall(p in PRISONER, d in danger where p != d)\n                 ( abs(r[p] - r[d]) + abs(c[p] - c[d]) > 1 );\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n\n\n\nModel 2 : \n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nfunction var int: \n     manhattan(var int:x1, var int:y1,\n               var int:x2, var int:y2) =\n     abs(x2 - x1) + abs(y2 - y1);\n\nconstraint forall(p in PRISONER, d in danger where p != d) \n                 (manhattan(r[p],c[p],r[d],c[d]) > 1);\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cell_block_beginner", "node_type": "4", "metadata": {"model_name": "cell_block", "source_code": "Model 1 :\n\n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\n%constraint forall(p1, p2 in PRISONER where p1 < p2)\n%                 (abs(r[p1] - r[p2]) + abs(c[p1] - c[p2]) > 0); \ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nconstraint forall(p in PRISONER, d in danger where p != d)\n                 ( abs(r[p] - r[d]) + abs(c[p] - c[d]) > 1 );\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n\n\n\nModel 2 : \n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nfunction var int: \n     manhattan(var int:x1, var int:y1,\n               var int:x2, var int:y2) =\n     abs(x2 - x1) + abs(y2 - y1);\n\nconstraint forall(p in PRISONER, d in danger where p != d) \n                 (manhattan(r[p],c[p],r[d],c[d]) > 1);\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n"}, "hash": "05472dcb0e5d319117e313516f9272674331fbb58286601d34863dd2004ce07c", "class_name": "RelatedNodeInfo"}}, "text": "Here is the explanation of the problem:\n\n**Prisoner Allocation Problem**\n\nThis problem is about allocating prisoners to cells in a prison. Imagine a prison with a certain number of rows and columns of cells. Each prisoner needs to be assigned to a specific cell.\n\n**Main Variables:**\n\n* `k`: The total number of prisoners.\n* `PRISONER`: A set of prisoners, each identified by a unique number from 1 to `k`.\n* `n` and `m`: The number of rows and columns of cells in the prison, respectively.\n* `r` and `c`: Variables that represent the row and column of each prisoner's cell, respectively.\n* `danger`: A set of prisoners who are considered dangerous.\n* `female` and `male`: Sets of female and male prisoners, respectively.\n* `cost`: A table that shows the cost of assigning each prisoner to each cell.\n\n**Basic Restrictions or Rules:**\n\n* Each prisoner must be assigned to a unique cell.\n* Prisoners who are considered dangerous should not be placed next to each other.\n* Female prisoners should be placed in the top half of the prison, while male prisoners should be placed in the bottom half.\n\n**Goal:**\n\nThe goal is to assign prisoners to cells in a way that minimizes the total cost of the assignments. The cost is calculated by summing up the costs of assigning each prisoner to their assigned cell.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1303, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4caab6d4-59f7-4cd4-a90c-f1cc2d3ebbe7": {"__data__": {"id_": "4caab6d4-59f7-4cd4-a90c-f1cc2d3ebbe7", "embedding": null, "metadata": {"model_name": "clique", "source_code": "% Maximum Clique Problem\n\nint: n = 5;\narray[1..n, 1..n] of int: adj =\n    [| 0, 1, 0, 1, 0\n     | 1, 0, 1, 0, 0\n     | 0, 1, 0, 1, 1\n     | 1, 0, 1, 0, 1\n     | 0, 0, 1, 1, 0 |];\n\n% --- naive model ---\n\n% decision variables: which vertices are in the clique?\narray[1..n] of var bool: c;\nvar int: size;\n\n% how many vertices have we selected?\nconstraint size = sum(c);\n\n% we can only pick one of any non-adjacent pair of vertices\nconstraint forall (i, j in 1..n where i < j /\\ 0 == adj[i,j]) (bool2int(c[i]) + bool2int(c[j]) <= 1);\n\nsolve maximize size;\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "clique_beginner", "node_type": "4", "metadata": {"model_name": "clique", "source_code": "% Maximum Clique Problem\n\nint: n = 5;\narray[1..n, 1..n] of int: adj =\n    [| 0, 1, 0, 1, 0\n     | 1, 0, 1, 0, 0\n     | 0, 1, 0, 1, 1\n     | 1, 0, 1, 0, 1\n     | 0, 0, 1, 1, 0 |];\n\n% --- naive model ---\n\n% decision variables: which vertices are in the clique?\narray[1..n] of var bool: c;\nvar int: size;\n\n% how many vertices have we selected?\nconstraint size = sum(c);\n\n% we can only pick one of any non-adjacent pair of vertices\nconstraint forall (i, j in 1..n where i < j /\\ 0 == adj[i,j]) (bool2int(c[i]) + bool2int(c[j]) <= 1);\n\nsolve maximize size;\n\n"}, "hash": "b909d139fcff9beec6508929cd63084501e930a5b50956f542968e7900b88b5c", "class_name": "RelatedNodeInfo"}}, "text": "Maximum Clique Problem\n\nThis problem is about finding a group of friends in a social network where everyone in the group knows each other.\n\nThe main variables are:\n\n* `c`: an array that says whether each person is in the group or not (true or false)\n* `size`: the total number of people in the group\n\nThe basic restrictions or rules of the problem are:\n\n* If two people don't know each other, they can't both be in the group\n* We want to find the largest possible group of friends\n\nThe goal of the problem is to find the largest group of friends (maximize `size`).", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 564, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4d1560ec-39d9-48ca-b09b-5f00c46037be": {"__data__": {"id_": "4d1560ec-39d9-48ca-b09b-5f00c46037be", "embedding": null, "metadata": {"model_name": "cluster", "source_code": "int: n; % points to be clustered\nset of int: POINT = 1..n;\narray[POINT,POINT] of int: dist; % distance between two points\nint: maxdist = max([ dist[i,j] | i,j in POINT]);\n\n\nint: k; % number of clusters\nset of int: CLUSTER = 1..k;\n\nint: maxdiam;\n\narray[POINT] of var CLUSTER: x;\n\nconstraint forall(i,j in POINT where i < j /\\ x[i] = x[j])\n                 (dist[i,j] <= maxdiam);\n\nconstraint forall(i in 1..k-1)\n                 (  min([ j | j in POINT where x[j] = i])\n                  < min([ j | j in POINT where x[j] = i+1]));\n\nvar 0..maxdist: obj = min( i,j in POINT where i < j )\n                         ( dist[i,j] + maxdist * (x[i] != x[j]) );\n\ninclude \"value_precede_chain.mzn\";\nconstraint value_precede_chain([ i | i in 1..k ],x);\n\nsolve maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x)\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cluster_beginner", "node_type": "4", "metadata": {"model_name": "cluster", "source_code": "int: n; % points to be clustered\nset of int: POINT = 1..n;\narray[POINT,POINT] of int: dist; % distance between two points\nint: maxdist = max([ dist[i,j] | i,j in POINT]);\n\n\nint: k; % number of clusters\nset of int: CLUSTER = 1..k;\n\nint: maxdiam;\n\narray[POINT] of var CLUSTER: x;\n\nconstraint forall(i,j in POINT where i < j /\\ x[i] = x[j])\n                 (dist[i,j] <= maxdiam);\n\nconstraint forall(i in 1..k-1)\n                 (  min([ j | j in POINT where x[j] = i])\n                  < min([ j | j in POINT where x[j] = i+1]));\n\nvar 0..maxdist: obj = min( i,j in POINT where i < j )\n                         ( dist[i,j] + maxdist * (x[i] != x[j]) );\n\ninclude \"value_precede_chain.mzn\";\nconstraint value_precede_chain([ i | i in 1..k ],x);\n\nsolve maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x)\\n\"];\n"}, "hash": "0c2accce03c41e2413e1237be8f10b39e374686e449217541ed3227816ce4137", "class_name": "RelatedNodeInfo"}}, "text": "**Problem Name:** Clustering Problem\n\n**What the problem is about:** Imagine you have a bunch of points on a map, and you want to group them into clusters so that points in the same cluster are close to each other.\n\n**Main Variables:**\n\n* `n`: The number of points on the map.\n* `POINT`: A set of points, each represented by a number from 1 to `n`.\n* `dist`: A table that shows the distance between each pair of points.\n* `k`: The number of clusters you want to create.\n* `CLUSTER`: A set of cluster numbers, from 1 to `k`.\n* `x`: An array that assigns each point to a cluster number.\n* `maxdiam`: The maximum distance between points in the same cluster.\n\n**Basic Restrictions or Rules:**\n\n* Points in the same cluster should be close to each other (within `maxdiam` distance).\n* Each cluster should have at least one point.\n* Clusters should be numbered in a way that points in cluster `i` are all closer to each other than points in cluster `i+1`.\n\n**Goal of the Problem:** The goal is to find a way to cluster the points so that the total distance between points in the same cluster is as small as possible, while also making sure that points in different clusters are far enough apart.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1189, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e5f75b2b-1799-4a0b-8ffa-1a837980b4c9": {"__data__": {"id_": "e5f75b2b-1799-4a0b-8ffa-1a837980b4c9", "embedding": null, "metadata": {"model_name": "compatible_assignment", "source_code": "Model 1 :\n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(task);\nconstraint forall(w1, w2 in W)\n                 (task[w1] != m /\\ task[w2] = task[w1] + 1 ->\n                   compatible[w1,w2]);\n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ \"task = \\(task)\\n\" ] ;\n\n\nModel 2 : \n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\narray[T] of var opt W: worker;\n\nconstraint inverse(task,worker);\nconstraint forall(t in T where t mod m != 0)\n                 (compatible[worker[t],worker[t+1]]);\n           \n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ if fix(occurs(worker[t])) then show(worker[t]) else \" \" endif ++ \" \"\n       | t in T ] \n       ++ [ show(task), \"\\n\" ]\n       ;\n\npredicate inverse(array[int] of var opt int: f, array[int] of var opt int: g) = \n          forall(i in index_set(f), j in index_set(g))\n                (occurs(f[i]) /\\ occurs(g[j]) ->\n                 (deopt(f[i]) = j <-> deopt(g[j]) = i)); \n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "compatible_assignment_beginner", "node_type": "4", "metadata": {"model_name": "compatible_assignment", "source_code": "Model 1 :\n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(task);\nconstraint forall(w1, w2 in W)\n                 (task[w1] != m /\\ task[w2] = task[w1] + 1 ->\n                   compatible[w1,w2]);\n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ \"task = \\(task)\\n\" ] ;\n\n\nModel 2 : \n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\narray[T] of var opt W: worker;\n\nconstraint inverse(task,worker);\nconstraint forall(t in T where t mod m != 0)\n                 (compatible[worker[t],worker[t+1]]);\n           \n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ if fix(occurs(worker[t])) then show(worker[t]) else \" \" endif ++ \" \"\n       | t in T ] \n       ++ [ show(task), \"\\n\" ]\n       ;\n\npredicate inverse(array[int] of var opt int: f, array[int] of var opt int: g) = \n          forall(i in index_set(f), j in index_set(g))\n                (occurs(f[i]) /\\ occurs(g[j]) ->\n                 (deopt(f[i]) = j <-> deopt(g[j]) = i)); \n"}, "hash": "48d78dd4cd484764ce9932075335fa9fa6edc25d777c5e926bec2b8b257e68e9", "class_name": "RelatedNodeInfo"}}, "text": "**Problem Name:** Task Assignment Problem\n\n**What the problem is about:** Imagine you have a set of tasks that need to be done, and a set of workers who can do these tasks. Each task has a certain profit associated with it, and each worker can do a specific set of tasks. The problem is to assign tasks to workers in a way that maximizes the total profit.\n\n**Main variables:**\n\n* `task`: an array that assigns a task to each worker\n* `worker`: an array that assigns a worker to each task\n* `profit`: a 2D array that stores the profit of each task for each worker\n* `compatible`: a 2D array that indicates whether two workers can work together on consecutive tasks\n\n**Basic restrictions or rules:**\n\n* Each task must be assigned to a worker\n* Each worker can only do one task at a time\n* If two workers are assigned to consecutive tasks, they must be compatible with each other\n\n**Goal:** The goal is to maximize the total profit by assigning tasks to workers in a way that satisfies the above rules.\n\nIn simple terms, the problem is about finding the best way to assign tasks to workers to get the most profit, while making sure that workers who need to work together can do so.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1178, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2f3e9edb-4f51-4ac8-aaa9-d599837711f6": {"__data__": {"id_": "2f3e9edb-4f51-4ac8-aaa9-d599837711f6", "embedding": null, "metadata": {"model_name": "constrained_connected", "source_code": "% constrained clustering \n% Pick a maximal subset of edges so that no two nodes\n% given by the pairs (first[i],second[i]) \n% are connected.\n\nint: n;\nset of int: NODE = 1..n;\nint: m;\nset of int: EDGE = 1..m;\narray[EDGE] of NODE: pre;\narray[EDGE] of NODE: suc;\nint: d;\nset of int: DPAIR = 1..d;\narray[DPAIR] of NODE: first;\narray[DPAIR] of NODE: second;\n\nvar set of EDGE: selected;\n% a representative for each cluster\narray[NODE] of var NODE: rep;\n\n%constraint forall(e in selected)\n%                 (rep[pre[e]] = rep[suc[e]]);\nconstraint forall(e in EDGE)\n                 (e in selected -> rep[pre[e]] = rep[suc[e]]);\n\nconstraint forall(d in DPAIR)\n                 (rep[first[d]] != rep[second[d]]);\n\nsolve maximize card(selected);\n\noutput [ \"(\" ++ show(pre[e]) ++ \",\" ++ show(suc[e]) ++ \")\\n\"\n       | e in fix(selected) ]\n       ++ [show(rep),\"\\n\"]\n       ;\n\n\n\n                 \n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "constrained_connected_beginner", "node_type": "4", "metadata": {"model_name": "constrained_connected", "source_code": "% constrained clustering \n% Pick a maximal subset of edges so that no two nodes\n% given by the pairs (first[i],second[i]) \n% are connected.\n\nint: n;\nset of int: NODE = 1..n;\nint: m;\nset of int: EDGE = 1..m;\narray[EDGE] of NODE: pre;\narray[EDGE] of NODE: suc;\nint: d;\nset of int: DPAIR = 1..d;\narray[DPAIR] of NODE: first;\narray[DPAIR] of NODE: second;\n\nvar set of EDGE: selected;\n% a representative for each cluster\narray[NODE] of var NODE: rep;\n\n%constraint forall(e in selected)\n%                 (rep[pre[e]] = rep[suc[e]]);\nconstraint forall(e in EDGE)\n                 (e in selected -> rep[pre[e]] = rep[suc[e]]);\n\nconstraint forall(d in DPAIR)\n                 (rep[first[d]] != rep[second[d]]);\n\nsolve maximize card(selected);\n\noutput [ \"(\" ++ show(pre[e]) ++ \",\" ++ show(suc[e]) ++ \")\\n\"\n       | e in fix(selected) ]\n       ++ [show(rep),\"\\n\"]\n       ;\n\n\n\n                 \n"}, "hash": "2f47e4431dff861697019fee8f9678835e52a9ee9f1e11f7540eac9320d0673e", "class_name": "RelatedNodeInfo"}}, "text": "**Constrained Clustering**\n\nThis problem is about grouping things together in a way that follows certain rules.\n\n**Main Variables:**\n\n* `selected`: a set of connections between things (called edges)\n* `rep`: a way to represent each group (called a cluster)\n\n**Basic Restrictions or Rules:**\n\n* If two things are connected (an edge), they must be in the same group (cluster)\n* Certain pairs of things cannot be in the same group (given by `first` and `second` arrays)\n\n**Goal:**\n\nThe goal is to find the largest number of connections (edges) that can be included while following the rules, and to group the things together in a way that makes sense.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 648, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1df567da-04ec-4777-8c39-6447dea7e046": {"__data__": {"id_": "1df567da-04ec-4777-8c39-6447dea7e046", "embedding": null, "metadata": {"model_name": "crazy_sets", "source_code": "Model 1 :\n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m] of var set of NUMBER: s;\n\nconstraint forall(i,j,k in 1..m where i < j /\\ j < k)\n     ( s[i] intersect s[j] intersect s[k] = {} );\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\nconstraint forall(i in 1..m, o in NUMBER)\n      (o in s[i] \n       -> exists(j in 1..c)(x[i,j] = o));\nconstraint forall(i in 1..m, j in 1..c)(x[i,j] in s[i]);\n\nsolve satisfy;\n\noutput [show(s)];\n\nn = 10;\nc = 4;\nm = 4;\n\n\n\nModel 2 : \n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint global_cardinality_low_up( [ x[i,j] | i in 1..m, j in 1..c ],\n                              [ i | i in 1..n ],\n                              [ 0 | i in 1..n ],\n                              [ 2 | i in 1..n ]);\n\n\nsolve satisfy;\n\n   output [ if j = 1 then \"{\" else \"\" endif ++\n   show(x[i,j])\n   ++ if j = c then \"}\" else \", \" endif\n   ++ if j = c /\\ i < m then \", \" else \"\" endif\n   | i in 1..m, j in 1..c ];\n   \n\nn = 10;\nc = 4;\nm = 4;\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crazy_sets_beginner", "node_type": "4", "metadata": {"model_name": "crazy_sets", "source_code": "Model 1 :\n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m] of var set of NUMBER: s;\n\nconstraint forall(i,j,k in 1..m where i < j /\\ j < k)\n     ( s[i] intersect s[j] intersect s[k] = {} );\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\nconstraint forall(i in 1..m, o in NUMBER)\n      (o in s[i] \n       -> exists(j in 1..c)(x[i,j] = o));\nconstraint forall(i in 1..m, j in 1..c)(x[i,j] in s[i]);\n\nsolve satisfy;\n\noutput [show(s)];\n\nn = 10;\nc = 4;\nm = 4;\n\n\n\nModel 2 : \n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint global_cardinality_low_up( [ x[i,j] | i in 1..m, j in 1..c ],\n                              [ i | i in 1..n ],\n                              [ 0 | i in 1..n ],\n                              [ 2 | i in 1..n ]);\n\n\nsolve satisfy;\n\n   output [ if j = 1 then \"{\" else \"\" endif ++\n   show(x[i,j])\n   ++ if j = c then \"}\" else \", \" endif\n   ++ if j = c /\\ i < m then \", \" else \"\" endif\n   | i in 1..m, j in 1..c ];\n   \n\nn = 10;\nc = 4;\nm = 4;\n"}, "hash": "574231aad85352b7fed64ee754f369a1fad67b501ef58f055e73dff9fe6e2a2e", "class_name": "RelatedNodeInfo"}}, "text": "**Problem Name:** Unknown (no specific name is given)\n\n**What the problem is about in everyday terms:** Imagine you have a set of numbers from 1 to 10, and you want to divide these numbers into 4 groups, each containing 4 numbers. The goal is to create these groups in a way that no three groups have a common number.\n\n**Main variables and what they mean:**\n\n* `n`: the maximum value in the set of numbers (in this case, 10)\n* `c`: the number of elements in each group (in this case, 4)\n* `m`: the number of groups (in this case, 4)\n* `s`: an array of sets, where each set represents a group of numbers\n* `x`: a 2D array of numbers, where each row represents a group and each column represents a position in the group\n\n**Basic restrictions or rules of the problem:**\n\n* Each group must have exactly 4 numbers.\n* No three groups can have a common number.\n* The numbers in each group must be in increasing order.\n* The numbers in each group must be unique.\n\n**Goal of the problem:** The goal is to find a way to divide the numbers into groups that satisfy all the rules and restrictions.\n\nNote: The problem is not trying to minimize or maximize anything, it's just trying to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1233, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "451732a6-36c2-4547-b16f-4f7e9b7a476b": {"__data__": {"id_": "451732a6-36c2-4547-b16f-4f7e9b7a476b", "embedding": null, "metadata": {"model_name": "crossfigure", "source_code": "% Crossfigure problem in MiniZinc.\n% \"\"\"\n% Crossfigures are the numerical equivalent of crosswords. You have a grid and some\n% clues with numerical answers to place on this grid. Clues come in several different\n% forms (for example: Across 1. 25 across times two, 2. five dozen, 5. a square number,\n% 10. prime, 14. 29 across times 21 down ...).\n% \"\"\"\n\n\nint: n = 9;\narray[1..n, 1..n] of var 0..9: M;\n\nset of int: D = 0..9999; % the max length of the numbers in this problem is 4\nvar D: A1;\nvar D: A4;\nvar D: A7;\nvar D: A8;\nvar D: A9;\nvar D: A10;\nvar D: A11;\nvar D: A13;\nvar D: A15;\nvar D: A17;\nvar D: A20;\nvar D: A23;\nvar D: A24;\nvar D: A25;\nvar D: A27;\nvar D: A28;\nvar D: A29;\nvar D: A30;\n\nvar D: D1;\nvar D: D2;\nvar D: D3;\nvar D: D4;\nvar D: D5;\nvar D: D6;\nvar D: D10;\nvar D: D12;\nvar D: D14;\nvar D: D16;\nvar D: D17;\nvar D: D18;\nvar D: D19;\nvar D: D20;\nvar D: D21;\nvar D: D22;\nvar D: D26;\nvar D: D28;\n\n\n%\n% across(Matrix, Across, Len, Row, Col)\n%\tConstrains 'Across' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding across.\n%\npredicate across(array[int, int] of var D: Matrix, var D: Across, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Across)\n   /\\\n   forall(i in 0..Len-1) (\n\n       Matrix[Row,Col+i] = tmp[i+1]\n   )\n;\n\n%\n% down(Matrix, Down, Len, Row, Col):\n%\tConstrains 'Down' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding down.\n%\npredicate down(array[int,int] of var D: Matrix, var D: Down, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Down)\n   /\\\n   forall(i in 0..Len-1) (\n      Matrix[Row+i,Col] = tmp[i+1]\n   )\n;\n\n\n%\n% converts a number <-> array\n%\npredicate toNum10(array[int] of var D: a, var D: n) =\n          let { int: len = length(a) }\n          in\n          n = sum(i in 1..len) (\n            ceil(pow(10.0, int2float(len-i))) * a[i]\n          )\n          /\\ forall(i in 1..len) (a[i] >= 0)\n;\n\n\n%\n% x is a square\n% \npredicate square(var D: x) =\n   exists(y in D) (\n      y*y = x\n   )\n;\n\n\n%\n% very simple primality test\n%\npredicate is_prime(var int: x) =\n   forall(i in 2..ceil(sqrt(9999.0))) ( \n        (i < x) -> (x mod i > 0)\n   )\n;\n\n\nsolve :: int_search(\n         [M[i,j] | i,j in 1..n] ++\n         [A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n         D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28],\n         occurrence,\n         indomain_min,\n         complete\n         ) \n     satisfy;\n\n\nconstraint\n\n   % Set up the constraints between the matrix elements and the\n   % clue numbers.\n   across(M, A1, 4, 1, 1)  /\\ \n   across(M, A4, 4, 1, 6)  /\\ \n   across(M, A7, 2, 2, 1)  /\\ \n   across(M, A8, 3, 2, 4)  /\\ \n   across(M, A9, 2, 2, 8)  /\\ \n   across(M, A10, 2, 3, 3) /\\ \n   across(M, A11, 2, 3, 6) /\\ \n   across(M, A13, 4, 4, 1) /\\ \n   across(M, A15, 4, 4, 6) /\\ \n   across(M, A17, 4, 6, 1) /\\ \n   across(M, A20, 4, 6, 6) /\\ \n   across(M, A23, 2, 7, 3) /\\ \n   across(M, A24, 2, 7, 6) /\\ \n   across(M, A25, 2, 8, 1) /\\ \n   across(M, A27, 3, 8, 4) /\\ \n   across(M, A28, 2, 8, 8) /\\ \n   across(M, A29, 4, 9, 1) /\\ \n   across(M, A30, 4, 9, 6) /\\ \n\n   down(M, D1, 4, 1, 1)  /\\ \n   down(M, D2, 2, 1, 2)  /\\ \n   down(M, D3, 4, 1, 4)  /\\ \n   down(M, D4, 4, 1, 6)  /\\ \n   down(M, D5, 2, 1, 8)  /\\ \n   down(M, D6, 4, 1, 9)  /\\ \n   down(M, D10, 2, 3, 3) /\\ \n   down(M, D12, 2, 3, 7) /\\ \n   down(M, D14, 3, 4, 2) /\\ \n   down(M, D16, 3, 4, 8) /\\ \n   down(M, D17, 4, 6, 1) /\\ \n   down(M, D18, 2, 6, 3) /\\ \n   down(M, D19, 4, 6, 4) /\\ \n   down(M, D20, 4, 6, 6) /\\ \n   down(M, D21, 2, 6, 7) /\\ \n   down(M, D22, 4, 6, 9) /\\ \n   down(M, D26, 2, 8, 2) /\\ \n   down(M, D28, 2, 8, 8) /\\ \n\n\n   % Set up the clue constraints.\n%  Across\n%  1 27 across times two\n%  4 4 down plus seventy-one\n%  7 18 down plus four\n%  8 6 down divided by sixteen\n%  9 2 down minus eighteen\n% 10 Dozen in six gross\n% 11 5 down minus seventy\n% 13 26 down times 23 across\n% 15 6 down minus 350\n% 17 25 across times 23 across\n% 20 A square number\n% 23 A prime number\n% 24 A square number\n% 25 20 across divided by seventeen\n% 27 6 down divided by four\n% 28 Four dozen\n% 29 Seven gross\n% 30 22 down plus 450 \n\n   A1 = 2 * A27         /\\ \n   A4 = D4 + 71         /\\ \n   A7 = D18 + 4         /\\ \n   A8 = D6 div 16       /\\ \n   A9 = D2 - 18         /\\ \n   A10 = 6 * 144 div 12 /\\ \n   A11 = D5 - 70        /\\ \n   A13 = D26 * A23      /\\ \n   A15 = D6 - 350       /\\ \n   A17 = A25 * A23      /\\ \n   square(A20)          /\\ \n   is_prime(A23)        /\\\n   square(A24)          /\\ \n   A25 = A20 div 17     /\\ \n   A27 = D6 div 4       /\\ \n   A28 = 4 * 12         /\\ \n   A29 = 7 * 144        /\\ \n   A30 = D22 + 450      /\\ \n\n   % Down\n   %\n   %  1 1 across plus twenty-seven\n   %  2 Five dozen\n   %  3 30 across plus 888\n   %  4 Two times 17 across\n   %  5 29 across divided by twelve\n   %  6 28 across times 23 across\n   % 10 10 across plus four\n   % 12 Three times 24 across\n   % 14 13 across divided by sixteen\n   % 16 28 down times fifteen\n   % 17 13 across minus 399\n   % 18 29 across divided by eighteen\n   % 19 22 down minus ninety-four\n   % 20 20 across minus nine\n   % 21 25 across minus fifty-two\n   % 22 20 down times six\n   % 26 Five times 24 across\n   % 28 21 down plus twenty-seven \n\n   D1 = A1 + 27     /\\ \n   D2 = 5 * 12      /\\ \n   D3 = A30 + 888   /\\ \n   D4 = 2 * A17     /\\ \n   D5 = A29 div 12  /\\ \n   D6 = A28 * A23   /\\ \n   D10 = A10 + 4    /\\ \n   D12 = A24 * 3    /\\ \n   D14 = A13 div 16 /\\ \n   D16 = 15 * D28   /\\ \n   D17 = A13 - 399  /\\ \n   D18 = A29 div 18 /\\ \n   D19 = D22 - 94   /\\ \n   D20 = A20 - 9    /\\ \n   D21 = A25 - 52   /\\ \n   D22 = 6 * D20    /\\ \n   D26 = 5 * A24    /\\ \n   D28 = D21 + 27\n\n\n   % Fix the blackboxes\n   /\\\n   M[1,5] = 0 /\\\n   M[2,3] = 0 /\\\n   M[2,7] = 0 /\\\n   M[3,2] = 0 /\\\n   M[3,5] = 0 /\\\n   M[3,8] = 0 /\\\n   M[4,5] = 0 /\\\n   M[5,1] = 0 /\\\n   M[5,3] = 0 /\\\n   M[5,4] = 0 /\\\n   M[5,5] = 0 /\\\n   M[5,6] = 0 /\\\n   M[5,7] = 0 /\\\n   M[5,9] = 0 /\\\n   M[6,5] = 0 /\\\n   M[7,2] = 0 /\\\n   M[7,5] = 0 /\\\n   M[7,8] = 0 /\\\n   M[8,3] = 0 /\\\n   M[8,7] = 0 /\\\n   M[9,5] = 0\n;\n\n\noutput [\n show([A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n       D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28]), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(M[i,j])\n  | i,j  in 1..n\n] ++ [\"\\n\"];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crossfigure_beginner", "node_type": "4", "metadata": {"model_name": "crossfigure", "source_code": "% Crossfigure problem in MiniZinc.\n% \"\"\"\n% Crossfigures are the numerical equivalent of crosswords. You have a grid and some\n% clues with numerical answers to place on this grid. Clues come in several different\n% forms (for example: Across 1. 25 across times two, 2. five dozen, 5. a square number,\n% 10. prime, 14. 29 across times 21 down ...).\n% \"\"\"\n\n\nint: n = 9;\narray[1..n, 1..n] of var 0..9: M;\n\nset of int: D = 0..9999; % the max length of the numbers in this problem is 4\nvar D: A1;\nvar D: A4;\nvar D: A7;\nvar D: A8;\nvar D: A9;\nvar D: A10;\nvar D: A11;\nvar D: A13;\nvar D: A15;\nvar D: A17;\nvar D: A20;\nvar D: A23;\nvar D: A24;\nvar D: A25;\nvar D: A27;\nvar D: A28;\nvar D: A29;\nvar D: A30;\n\nvar D: D1;\nvar D: D2;\nvar D: D3;\nvar D: D4;\nvar D: D5;\nvar D: D6;\nvar D: D10;\nvar D: D12;\nvar D: D14;\nvar D: D16;\nvar D: D17;\nvar D: D18;\nvar D: D19;\nvar D: D20;\nvar D: D21;\nvar D: D22;\nvar D: D26;\nvar D: D28;\n\n\n%\n% across(Matrix, Across, Len, Row, Col)\n%\tConstrains 'Across' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding across.\n%\npredicate across(array[int, int] of var D: Matrix, var D: Across, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Across)\n   /\\\n   forall(i in 0..Len-1) (\n\n       Matrix[Row,Col+i] = tmp[i+1]\n   )\n;\n\n%\n% down(Matrix, Down, Len, Row, Col):\n%\tConstrains 'Down' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding down.\n%\npredicate down(array[int,int] of var D: Matrix, var D: Down, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Down)\n   /\\\n   forall(i in 0..Len-1) (\n      Matrix[Row+i,Col] = tmp[i+1]\n   )\n;\n\n\n%\n% converts a number <-> array\n%\npredicate toNum10(array[int] of var D: a, var D: n) =\n          let { int: len = length(a) }\n          in\n          n = sum(i in 1..len) (\n            ceil(pow(10.0, int2float(len-i))) * a[i]\n          )\n          /\\ forall(i in 1..len) (a[i] >= 0)\n;\n\n\n%\n% x is a square\n% \npredicate square(var D: x) =\n   exists(y in D) (\n      y*y = x\n   )\n;\n\n\n%\n% very simple primality test\n%\npredicate is_prime(var int: x) =\n   forall(i in 2..ceil(sqrt(9999.0))) ( \n        (i < x) -> (x mod i > 0)\n   )\n;\n\n\nsolve :: int_search(\n         [M[i,j] | i,j in 1..n] ++\n         [A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n         D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28],\n         occurrence,\n         indomain_min,\n         complete\n         ) \n     satisfy;\n\n\nconstraint\n\n   % Set up the constraints between the matrix elements and the\n   % clue numbers.\n   across(M, A1, 4, 1, 1)  /\\ \n   across(M, A4, 4, 1, 6)  /\\ \n   across(M, A7, 2, 2, 1)  /\\ \n   across(M, A8, 3, 2, 4)  /\\ \n   across(M, A9, 2, 2, 8)  /\\ \n   across(M, A10, 2, 3, 3) /\\ \n   across(M, A11, 2, 3, 6) /\\ \n   across(M, A13, 4, 4, 1) /\\ \n   across(M, A15, 4, 4, 6) /\\ \n   across(M, A17, 4, 6, 1) /\\ \n   across(M, A20, 4, 6, 6) /\\ \n   across(M, A23, 2, 7, 3) /\\ \n   across(M, A24, 2, 7, 6) /\\ \n   across(M, A25, 2, 8, 1) /\\ \n   across(M, A27, 3, 8, 4) /\\ \n   across(M, A28, 2, 8, 8) /\\ \n   across(M, A29, 4, 9, 1) /\\ \n   across(M, A30, 4, 9, 6) /\\ \n\n   down(M, D1, 4, 1, 1)  /\\ \n   down(M, D2, 2, 1, 2)  /\\ \n   down(M, D3, 4, 1, 4)  /\\ \n   down(M, D4, 4, 1, 6)  /\\ \n   down(M, D5, 2, 1, 8)  /\\ \n   down(M, D6, 4, 1, 9)  /\\ \n   down(M, D10, 2, 3, 3) /\\ \n   down(M, D12, 2, 3, 7) /\\ \n   down(M, D14, 3, 4, 2) /\\ \n   down(M, D16, 3, 4, 8) /\\ \n   down(M, D17, 4, 6, 1) /\\ \n   down(M, D18, 2, 6, 3) /\\ \n   down(M, D19, 4, 6, 4) /\\ \n   down(M, D20, 4, 6, 6) /\\ \n   down(M, D21, 2, 6, 7) /\\ \n   down(M, D22, 4, 6, 9) /\\ \n   down(M, D26, 2, 8, 2) /\\ \n   down(M, D28, 2, 8, 8) /\\ \n\n\n   % Set up the clue constraints.\n%  Across\n%  1 27 across times two\n%  4 4 down plus seventy-one\n%  7 18 down plus four\n%  8 6 down divided by sixteen\n%  9 2 down minus eighteen\n% 10 Dozen in six gross\n% 11 5 down minus seventy\n% 13 26 down times 23 across\n% 15 6 down minus 350\n% 17 25 across times 23 across\n% 20 A square number\n% 23 A prime number\n% 24 A square number\n% 25 20 across divided by seventeen\n% 27 6 down divided by four\n% 28 Four dozen\n% 29 Seven gross\n% 30 22 down plus 450 \n\n   A1 = 2 * A27         /\\ \n   A4 = D4 + 71         /\\ \n   A7 = D18 + 4         /\\ \n   A8 = D6 div 16       /\\ \n   A9 = D2 - 18         /\\ \n   A10 = 6 * 144 div 12 /\\ \n   A11 = D5 - 70        /\\ \n   A13 = D26 * A23      /\\ \n   A15 = D6 - 350       /\\ \n   A17 = A25 * A23      /\\ \n   square(A20)          /\\ \n   is_prime(A23)        /\\\n   square(A24)          /\\ \n   A25 = A20 div 17     /\\ \n   A27 = D6 div 4       /\\ \n   A28 = 4 * 12         /\\ \n   A29 = 7 * 144        /\\ \n   A30 = D22 + 450      /\\ \n\n   % Down\n   %\n   %  1 1 across plus twenty-seven\n   %  2 Five dozen\n   %  3 30 across plus 888\n   %  4 Two times 17 across\n   %  5 29 across divided by twelve\n   %  6 28 across times 23 across\n   % 10 10 across plus four\n   % 12 Three times 24 across\n   % 14 13 across divided by sixteen\n   % 16 28 down times fifteen\n   % 17 13 across minus 399\n   % 18 29 across divided by eighteen\n   % 19 22 down minus ninety-four\n   % 20 20 across minus nine\n   % 21 25 across minus fifty-two\n   % 22 20 down times six\n   % 26 Five times 24 across\n   % 28 21 down plus twenty-seven \n\n   D1 = A1 + 27     /\\ \n   D2 = 5 * 12      /\\ \n   D3 = A30 + 888   /\\ \n   D4 = 2 * A17     /\\ \n   D5 = A29 div 12  /\\ \n   D6 = A28 * A23   /\\ \n   D10 = A10 + 4    /\\ \n   D12 = A24 * 3    /\\ \n   D14 = A13 div 16 /\\ \n   D16 = 15 * D28   /\\ \n   D17 = A13 - 399  /\\ \n   D18 = A29 div 18 /\\ \n   D19 = D22 - 94   /\\ \n   D20 = A20 - 9    /\\ \n   D21 = A25 - 52   /\\ \n   D22 = 6 * D20    /\\ \n   D26 = 5 * A24    /\\ \n   D28 = D21 + 27\n\n\n   % Fix the blackboxes\n   /\\\n   M[1,5] = 0 /\\\n   M[2,3] = 0 /\\\n   M[2,7] = 0 /\\\n   M[3,2] = 0 /\\\n   M[3,5] = 0 /\\\n   M[3,8] = 0 /\\\n   M[4,5] = 0 /\\\n   M[5,1] = 0 /\\\n   M[5,3] = 0 /\\\n   M[5,4] = 0 /\\\n   M[5,5] = 0 /\\\n   M[5,6] = 0 /\\\n   M[5,7] = 0 /\\\n   M[5,9] = 0 /\\\n   M[6,5] = 0 /\\\n   M[7,2] = 0 /\\\n   M[7,5] = 0 /\\\n   M[7,8] = 0 /\\\n   M[8,3] = 0 /\\\n   M[8,7] = 0 /\\\n   M[9,5] = 0\n;\n\n\noutput [\n show([A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n       D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28]), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(M[i,j])\n  | i,j  in 1..n\n] ++ [\"\\n\"];"}, "hash": "4fd617c3465a7ed18bc2d5627177a817db6d9552ed897fe03e078934bd23aa95", "class_name": "RelatedNodeInfo"}}, "text": "Here is the explanation of the problem:\n\n**Name of the problem:** Crossfigure problem\n\n**What the problem is about in everyday terms:** Imagine you have a grid of numbers, like a crossword puzzle, but instead of words, you have numerical clues to fill in. The clues are given in the form of mathematical equations, and you need to figure out the correct numbers to put in each box to satisfy all the equations.\n\n**What the main variables are and what they mean:**\n\n* `M` is a 9x9 grid of numbers, where each number is between 0 and 9.\n* `A1`, `A4`, ..., `A30` are variables that represent the answers to the \"across\" clues.\n* `D1`, `D2`, ..., `D28` are variables that represent the answers to the \"down\" clues.\n\n**What the basic restrictions or rules of the problem are:**\n\n* Each number in the grid `M` must be between 0 and 9.\n* The numbers in the grid must satisfy the mathematical equations given in the clues.\n* Some numbers in the grid are fixed to be 0 (these are the \"black boxes\").\n\n**What the goal of the problem is:** The goal is to find a solution that satisfies all the mathematical equations and fills in the entire grid `M` with numbers between 0 and 9.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1168, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fa3fefc8-f015-4ef1-8df9-0a73b8b1d0c4": {"__data__": {"id_": "fa3fefc8-f015-4ef1-8df9-0a73b8b1d0c4", "embedding": null, "metadata": {"model_name": "curriculum", "source_code": "% The balanced academic curriculum problem:\n%\n% A curriculum is a set of courses with prerequisites.\n% Each course must be assigned within a set number of periods.\n% A course cannot be scheduled before its prerequisites.\n% Each course confers a number of academic credits (it's \"load\").\n% Students have lower and upper bounds on the number of credits they can study for in a given period.\n% Students have lower and upper bounds on the number of courses they can study for in a given period.\n% The goal is to assign a period to every course satisfying these criteria, minimising the load for all periods.\n\ninclude \"globals.mzn\";\n\nint: n_courses;\nint: n_periods;\nint: load_per_period_lb;\nint: load_per_period_ub;\nint: courses_per_period_lb;\nint: courses_per_period_ub;\narray [1..n_courses] of int: course_load;\nint: max_course_load = sum(c in courses)(course_load[c]);\n\nset of int: courses = 1..n_courses;\nset of int: periods = 1..n_periods;\n\n% period course is assigned to\narray [courses] of var periods: course_period;\n% whether period i has course j assigned\narray [periods, courses] of var 0..1: x;\n% total load for each period\narray [periods] of var load_per_period_lb..load_per_period_ub: load;\n% optimisation target\nvar load_per_period_lb..load_per_period_ub: objective;\n\nconstraint forall(p in periods) (\n    forall(c in courses) (x[p,c] = bool2int(course_period[c] = p)) /\\\n    sum(i in courses) (x[p,i]) >= courses_per_period_lb /\\\n    sum(i in courses) (x[p,i]) <= courses_per_period_ub /\\\n    load[p] = sum(c in courses) (x[p,c] * course_load[c]) /\\\n    load[p] >= load_per_period_lb /\\\n    load[p] <= objective\n);\n\n% prerequisite(a, b) means \"course a has prerequisite course b\".\n\npredicate prerequisite(courses: a, courses: b) =\n    course_period[b] < course_period[a];\n\n% add some redundant linear constraints\n\nconstraint forall(p in 0..n_periods-1) (\n    let {\n\t\tvar 0..max_course_load: l = sum(c in courses) (bool2int(course_period[c] > p) * course_load[c])\n\t} in \n        l >= (n_periods-p) * load_per_period_lb /\\\n        l <= (n_periods-p) * objective\n    );\n\nsolve :: seq_search([\n      int_search([x[i,j] | i in periods, j in courses], input_order, indomain_max, complete),\n      int_search([objective], input_order, indomain_min, complete)\n    ]) minimize objective;\n\noutput \n    [show(c) ++ \"-\" ++ show(course_period[c]) ++ \"\\t\" | c in courses ] ++ [\"\\n\"] ++\n    [\"objective = \", show(objective)];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "curriculum_beginner", "node_type": "4", "metadata": {"model_name": "curriculum", "source_code": "% The balanced academic curriculum problem:\n%\n% A curriculum is a set of courses with prerequisites.\n% Each course must be assigned within a set number of periods.\n% A course cannot be scheduled before its prerequisites.\n% Each course confers a number of academic credits (it's \"load\").\n% Students have lower and upper bounds on the number of credits they can study for in a given period.\n% Students have lower and upper bounds on the number of courses they can study for in a given period.\n% The goal is to assign a period to every course satisfying these criteria, minimising the load for all periods.\n\ninclude \"globals.mzn\";\n\nint: n_courses;\nint: n_periods;\nint: load_per_period_lb;\nint: load_per_period_ub;\nint: courses_per_period_lb;\nint: courses_per_period_ub;\narray [1..n_courses] of int: course_load;\nint: max_course_load = sum(c in courses)(course_load[c]);\n\nset of int: courses = 1..n_courses;\nset of int: periods = 1..n_periods;\n\n% period course is assigned to\narray [courses] of var periods: course_period;\n% whether period i has course j assigned\narray [periods, courses] of var 0..1: x;\n% total load for each period\narray [periods] of var load_per_period_lb..load_per_period_ub: load;\n% optimisation target\nvar load_per_period_lb..load_per_period_ub: objective;\n\nconstraint forall(p in periods) (\n    forall(c in courses) (x[p,c] = bool2int(course_period[c] = p)) /\\\n    sum(i in courses) (x[p,i]) >= courses_per_period_lb /\\\n    sum(i in courses) (x[p,i]) <= courses_per_period_ub /\\\n    load[p] = sum(c in courses) (x[p,c] * course_load[c]) /\\\n    load[p] >= load_per_period_lb /\\\n    load[p] <= objective\n);\n\n% prerequisite(a, b) means \"course a has prerequisite course b\".\n\npredicate prerequisite(courses: a, courses: b) =\n    course_period[b] < course_period[a];\n\n% add some redundant linear constraints\n\nconstraint forall(p in 0..n_periods-1) (\n    let {\n\t\tvar 0..max_course_load: l = sum(c in courses) (bool2int(course_period[c] > p) * course_load[c])\n\t} in \n        l >= (n_periods-p) * load_per_period_lb /\\\n        l <= (n_periods-p) * objective\n    );\n\nsolve :: seq_search([\n      int_search([x[i,j] | i in periods, j in courses], input_order, indomain_max, complete),\n      int_search([objective], input_order, indomain_min, complete)\n    ]) minimize objective;\n\noutput \n    [show(c) ++ \"-\" ++ show(course_period[c]) ++ \"\\t\" | c in courses ] ++ [\"\\n\"] ++\n    [\"objective = \", show(objective)];\n"}, "hash": "15261988b87eb95e39e03f9f0e5783f83b46572be7ad97dca9245506fefeb479", "class_name": "RelatedNodeInfo"}}, "text": "The Balanced Academic Curriculum Problem.\n\nThis problem is about creating a schedule for a set of university courses. Each course has a certain number of credits, and students can only take a certain number of credits and courses per period. The goal is to assign each course to a period in a way that minimizes the total number of credits per period.\n\nThe main variables are:\n\n* Courses: these are the university courses that need to be scheduled.\n* Periods: these are the time slots when the courses can be taught.\n* Course load: this is the number of credits each course is worth.\n* Course period: this is the period when each course is taught.\n* Load: this is the total number of credits for all courses in a period.\n\nThe basic restrictions or rules of the problem are:\n\n* Each course must be assigned to a period.\n* A course cannot be taught before its prerequisites (i.e., courses that must be taken before it).\n* Students can only take a certain number of credits and courses per period.\n* The total number of credits per period should be within a certain range.\n\nThe goal of the problem is to minimize the total number of credits per period, while satisfying all the above rules.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1187, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f613bb09-30bd-4cca-b97c-7260a229e0e7": {"__data__": {"id_": "f613bb09-30bd-4cca-b97c-7260a229e0e7", "embedding": null, "metadata": {"model_name": "diamond_free_degree_sequence", "source_code": "%\n% Diamond-free Degree Sequence (CSPLib #50) in MiniZinc.\n%\n% Given a simple undirected graph G=(V,E), where V is the set of vertices and E the set of\n% undirected edges, the edge {u,v} is in E if and only if vertex u is adjacent to vertex v\u2208G.\n% The graph is simple in that there are no loop edges, i.e. we have no edges of the form {v,v}.\n% Each vertex v\u2208V has a degree dv i.e. the number of edges incident on that vertex. Consequently\n% a graph has a degree sequence d1,\u2026,dn, where di>=di+1. A diamond is a set of four vertices\n% in V such that there are at least five edges between those vertices. Conversely, a graph is\n% diamond-free if it has no diamond as an induced subgraph, i.e. for every set of four vertices\n% the number of edges between those vertices is at most four.\n%\n% In our problem we have additional properties required of the degree sequences of the graphs,\n% in particular that the degree of each vertex is greater than zero (i.e. isolated vertices\n% are disallowed), the degree of each vertex is modulo 3, and the sum of the degrees is\n% modulo 12 (i.e. |E| is modulo 6).\n%\n% The problem is then for a given value of n, produce all unique degree sequences d1,\u2026,dn such\n% that\n%\n%  * di\u2265di+1\n%  * each degree di>0 and di is modulo 3\n%  * the sum of the degrees is modulo 12\n%  * there exists a simple diamond-free graph with that degree sequence\n\n\ninclude \"globals.mzn\"; \n\nint: n = 11;\n\n% decision variables\narray[1..n,1..n] of var 0..1: x;\narray[1..n] of var 1..n: degrees;\n\n\n% solve satisfy;\nsolve :: int_search(degrees, first_fail, indomain_split, complete) satisfy;\n\nconstraint\n  forall(i,j,k,l in 1..n where i < j /\\ j < k /\\ k < l) (\n     x[i,j] + x[i,k] + x[i,l] + x[j,k] + x[j,l] + x[k,l] <= 4\n  )\n  /\\\n  forall(i in 1..n) (\n     degrees[i] = sum([x[i,j] | j in 1..n])\n     /\\ degrees[i] mod 3 = 0\n     % no loops\n     /\\ x[i,i] = 0\n  ) \n  /\\ % undirected graph\n  forall(i,j in 1..n) (\n    x[i,j] = x[j,i]\n  )\n  /\\ sum(degrees) mod 12 = 0\n\n  % symmetry breaking\n  /\\ decreasing(degrees)\n  /\\ lex2(x)\n;\n\noutput \n[ \"degrees: \", show(degrees), \"\\n\"]\n% ++\n% [\n%   if j = 1 then \"\\n\" else \" \" endif ++\n%     show(x[i,j])\n%   | i,j in 1..n\n% ]\n;\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "diamond_free_degree_sequence_beginner", "node_type": "4", "metadata": {"model_name": "diamond_free_degree_sequence", "source_code": "%\n% Diamond-free Degree Sequence (CSPLib #50) in MiniZinc.\n%\n% Given a simple undirected graph G=(V,E), where V is the set of vertices and E the set of\n% undirected edges, the edge {u,v} is in E if and only if vertex u is adjacent to vertex v\u2208G.\n% The graph is simple in that there are no loop edges, i.e. we have no edges of the form {v,v}.\n% Each vertex v\u2208V has a degree dv i.e. the number of edges incident on that vertex. Consequently\n% a graph has a degree sequence d1,\u2026,dn, where di>=di+1. A diamond is a set of four vertices\n% in V such that there are at least five edges between those vertices. Conversely, a graph is\n% diamond-free if it has no diamond as an induced subgraph, i.e. for every set of four vertices\n% the number of edges between those vertices is at most four.\n%\n% In our problem we have additional properties required of the degree sequences of the graphs,\n% in particular that the degree of each vertex is greater than zero (i.e. isolated vertices\n% are disallowed), the degree of each vertex is modulo 3, and the sum of the degrees is\n% modulo 12 (i.e. |E| is modulo 6).\n%\n% The problem is then for a given value of n, produce all unique degree sequences d1,\u2026,dn such\n% that\n%\n%  * di\u2265di+1\n%  * each degree di>0 and di is modulo 3\n%  * the sum of the degrees is modulo 12\n%  * there exists a simple diamond-free graph with that degree sequence\n\n\ninclude \"globals.mzn\"; \n\nint: n = 11;\n\n% decision variables\narray[1..n,1..n] of var 0..1: x;\narray[1..n] of var 1..n: degrees;\n\n\n% solve satisfy;\nsolve :: int_search(degrees, first_fail, indomain_split, complete) satisfy;\n\nconstraint\n  forall(i,j,k,l in 1..n where i < j /\\ j < k /\\ k < l) (\n     x[i,j] + x[i,k] + x[i,l] + x[j,k] + x[j,l] + x[k,l] <= 4\n  )\n  /\\\n  forall(i in 1..n) (\n     degrees[i] = sum([x[i,j] | j in 1..n])\n     /\\ degrees[i] mod 3 = 0\n     % no loops\n     /\\ x[i,i] = 0\n  ) \n  /\\ % undirected graph\n  forall(i,j in 1..n) (\n    x[i,j] = x[j,i]\n  )\n  /\\ sum(degrees) mod 12 = 0\n\n  % symmetry breaking\n  /\\ decreasing(degrees)\n  /\\ lex2(x)\n;\n\noutput \n[ \"degrees: \", show(degrees), \"\\n\"]\n% ++\n% [\n%   if j = 1 then \"\\n\" else \" \" endif ++\n%     show(x[i,j])\n%   | i,j in 1..n\n% ]\n;\n\n"}, "hash": "2dc8e3138d37fe341628b33ee15d23b726e0d0127bd100fc9214ad37b05e907e", "class_name": "RelatedNodeInfo"}}, "text": "**Diamond-free Degree Sequence**\n\n**What is the problem about?**\nImagine you have a bunch of friends, and some of them are friends with each other. You want to know how many friends each person has, and how those friendships are connected, without having any groups of four friends who are all friends with each other (this is called a \"diamond\").\n\n**Main variables:**\n\n* `x`: a table that shows if two friends are friends with each other (1 if they are, 0 if they're not)\n* `degrees`: a list that shows how many friends each person has\n\n**Basic restrictions or rules:**\n\n* Each person has at least one friend (no one is alone)\n* The number of friends each person has is a multiple of 3 (e.g., 3, 6, 9, etc.)\n* The total number of friendships is a multiple of 6\n* There are no groups of four friends who are all friends with each other (no \"diamonds\")\n\n**Goal:**\nFind all possible ways to assign friends to each person, following the rules above, and without having any \"diamonds\".", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 981, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "afa53493-8d34-447d-a0a5-ab86de3ac672": {"__data__": {"id_": "afa53493-8d34-447d-a0a5-ab86de3ac672", "embedding": null, "metadata": {"model_name": "doublechannel", "source_code": "% scheduling ships entering and leaving a port through k channels\nset of int: TYPE = 1..3;\nint: entering = 1;\nint: leaving  = 2;\nint: dummy = 3;\n\nint: nC; % number of channels\nset of int: CHANNEL = 1..nC;\narray[CHANNEL] of int: len;    % length in 100m units\n\nint: nS; % number of ships\nset of int: SHIP = 1..nS; % ships ENTER then LEAVE\nset of int: SHIPE = 1..nS+nC; % ships ENTER then LEAVE then nC dummy ships\n\narray[SHIP] of int: speed;   % time in minutes to traverse 100m\narray[SHIP] of int: desired; % desired time to start to enter/leave \narray[SHIP] of entering..leaving: dirn;   % entering or leaving\n\nint: leeway;  % leeway between 2 ships in 100m units\nint: maxt;    % maximum time\nset of int: TIME = 0..maxt;\n\narray[SHIPE] of var TYPE: kind = dirn ++ [ dummy | i in 1..nC];\narray[SHIPE] of var TIME:    start; % when ships enter the channel \narray[SHIPE] of var TIME:     end; % when ships leave the channel \narray[SHIPE] of var CHANNEL: channel; % which channel a ship is assigned to\n\narray[SHIP] of var SHIPE:   next;  % the next ship in the same channel (or a dummy)\n\n% dummy ships\nconstraint forall(s in nS + 1 .. nS + nC)(start[s] = maxt /\\ end[s] = maxt);\nconstraint forall(s in nS + 1 .. nS + nC)(channel[s] = s - nS);\n\n% relationships between start and ends\nconstraint forall(s in SHIP)(end[s] = start[s] + len[channel[s]]*speed[s]);\n\n\n% the next ship are all different\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(next);\n\n% no clashes in channel\nconstraint forall(s in SHIP)(if kind[s] + kind[next[s]] = entering+leaving then\n                                end[s] <= start[next[s]]\n                             else\n                                start[s] + speed[s]*leeway <= start[next[s]] /\\\n                                end[s] + speed[s]*leeway <= end[next[s]]\n                             endif);\n\n% next ship is in same channel\nconstraint forall(s in SHIP)(channel[next[s]] = channel[s]);\n\nsolve minimize sum(s in SHIP)(abs(start[s] - desired[s]));\n\noutput [ \"start = \",show(start),\n         \";\\nend = \", show(end),\n         \";\\nchannel = \", show(channel),\n         \";\\nnext = \", show(next),\n         \";\\n\" ];\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "doublechannel_beginner", "node_type": "4", "metadata": {"model_name": "doublechannel", "source_code": "% scheduling ships entering and leaving a port through k channels\nset of int: TYPE = 1..3;\nint: entering = 1;\nint: leaving  = 2;\nint: dummy = 3;\n\nint: nC; % number of channels\nset of int: CHANNEL = 1..nC;\narray[CHANNEL] of int: len;    % length in 100m units\n\nint: nS; % number of ships\nset of int: SHIP = 1..nS; % ships ENTER then LEAVE\nset of int: SHIPE = 1..nS+nC; % ships ENTER then LEAVE then nC dummy ships\n\narray[SHIP] of int: speed;   % time in minutes to traverse 100m\narray[SHIP] of int: desired; % desired time to start to enter/leave \narray[SHIP] of entering..leaving: dirn;   % entering or leaving\n\nint: leeway;  % leeway between 2 ships in 100m units\nint: maxt;    % maximum time\nset of int: TIME = 0..maxt;\n\narray[SHIPE] of var TYPE: kind = dirn ++ [ dummy | i in 1..nC];\narray[SHIPE] of var TIME:    start; % when ships enter the channel \narray[SHIPE] of var TIME:     end; % when ships leave the channel \narray[SHIPE] of var CHANNEL: channel; % which channel a ship is assigned to\n\narray[SHIP] of var SHIPE:   next;  % the next ship in the same channel (or a dummy)\n\n% dummy ships\nconstraint forall(s in nS + 1 .. nS + nC)(start[s] = maxt /\\ end[s] = maxt);\nconstraint forall(s in nS + 1 .. nS + nC)(channel[s] = s - nS);\n\n% relationships between start and ends\nconstraint forall(s in SHIP)(end[s] = start[s] + len[channel[s]]*speed[s]);\n\n\n% the next ship are all different\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(next);\n\n% no clashes in channel\nconstraint forall(s in SHIP)(if kind[s] + kind[next[s]] = entering+leaving then\n                                end[s] <= start[next[s]]\n                             else\n                                start[s] + speed[s]*leeway <= start[next[s]] /\\\n                                end[s] + speed[s]*leeway <= end[next[s]]\n                             endif);\n\n% next ship is in same channel\nconstraint forall(s in SHIP)(channel[next[s]] = channel[s]);\n\nsolve minimize sum(s in SHIP)(abs(start[s] - desired[s]));\n\noutput [ \"start = \",show(start),\n         \";\\nend = \", show(end),\n         \";\\nchannel = \", show(channel),\n         \";\\nnext = \", show(next),\n         \";\\n\" ];\n\n"}, "hash": "a9ebc788320f41724b1011a8f262299783df26f843d25fa6293b11ee3ef8949d", "class_name": "RelatedNodeInfo"}}, "text": "**Problem Name:** Ship Scheduling\n\n**What the problem is about:** Imagine a busy port with multiple channels where ships come and go. We need to schedule when each ship enters and leaves the port through which channel, so that they don't crash into each other.\n\n**Main variables:**\n\n* `SHIP`: Each ship is represented by a number.\n* `CHANNEL`: Each channel in the port is represented by a number.\n* `start`: The time when each ship starts to enter or leave the port.\n* `end`: The time when each ship finishes entering or leaving the port.\n* `channel`: The channel assigned to each ship.\n* `next`: The next ship that will use the same channel.\n\n**Basic restrictions or rules:**\n\n* Each ship must enter and leave the port through one of the channels.\n* Ships must not collide with each other in the same channel.\n* There must be a safe distance (called \"leeway\") between two ships in the same channel.\n* Each channel has a limited length, and ships take different times to traverse it.\n\n**Goal of the problem:** We want to find a schedule that minimizes the total difference between the desired start time and the actual start time for all ships. In other words, we want to make sure that each ship starts entering or leaving the port as close as possible to its desired time.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1274, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fa3f3234-d49d-4df8-8fec-38b029e17108": {"__data__": {"id_": "fa3f3234-d49d-4df8-8fec-38b029e17108", "embedding": null, "metadata": {"model_name": "fractions", "source_code": "%\n% Fractions problem in MiniZinc.\n%\n% Prolog benchmark problem (BProlog)\n% \"\"\"\n% Find distinct non-zero digits such that the following equation holds:\n%        A        D        G\n%     ------  + ----- + ------  = 1\n%       B*C      E*F      H*I\n\ninclude \"globals.mzn\"; \n\nvar 1..9: A;\nvar 1..9: B;\nvar 1..9: C;\nvar 1..9: D;\nvar 1..9: E;\nvar 1..9: F;\nvar 1..9: G;\nvar 1..9: H;\nvar 1..9: I;\narray[1..9] of var 1..9: Vars=[A,B,C,D,E,F,G,H,I];\n\nvar 1..81: D1;\nvar 1..81: D2;\nvar 1..81: D3;\n\n\n\n% solve satisfy;\nsolve :: int_search(Vars ++ [D1,D2,D3], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   all_different(Vars) /\\\n   D1 = 10*B+C /\\\n   D2 = 10*E+F /\\\n   D3 = 10*H+I /\\\n   A*D2*D3 + D*D1*D3 + G*D1*D2 = D1*D2*D3 /\\\n   % break the symmetry\n   A*D2 >= D*D1 /\\\n   D*D3 >= G*D2 /\\\n   %redundant constraints\n   3*A >= D1 /\\\n   3*G <= D2\n\n;\n\noutput [\n  show(Vars), \"\\n\"\n]\n;"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fractions_beginner", "node_type": "4", "metadata": {"model_name": "fractions", "source_code": "%\n% Fractions problem in MiniZinc.\n%\n% Prolog benchmark problem (BProlog)\n% \"\"\"\n% Find distinct non-zero digits such that the following equation holds:\n%        A        D        G\n%     ------  + ----- + ------  = 1\n%       B*C      E*F      H*I\n\ninclude \"globals.mzn\"; \n\nvar 1..9: A;\nvar 1..9: B;\nvar 1..9: C;\nvar 1..9: D;\nvar 1..9: E;\nvar 1..9: F;\nvar 1..9: G;\nvar 1..9: H;\nvar 1..9: I;\narray[1..9] of var 1..9: Vars=[A,B,C,D,E,F,G,H,I];\n\nvar 1..81: D1;\nvar 1..81: D2;\nvar 1..81: D3;\n\n\n\n% solve satisfy;\nsolve :: int_search(Vars ++ [D1,D2,D3], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   all_different(Vars) /\\\n   D1 = 10*B+C /\\\n   D2 = 10*E+F /\\\n   D3 = 10*H+I /\\\n   A*D2*D3 + D*D1*D3 + G*D1*D2 = D1*D2*D3 /\\\n   % break the symmetry\n   A*D2 >= D*D1 /\\\n   D*D3 >= G*D2 /\\\n   %redundant constraints\n   3*A >= D1 /\\\n   3*G <= D2\n\n;\n\noutput [\n  show(Vars), \"\\n\"\n]\n;"}, "hash": "ec2ce13c98a8f533b70ffc1594a6b41259358a59f900e185d7a55b77eaac933e", "class_name": "RelatedNodeInfo"}}, "text": "Here is the explanation of the problem:\n\n**Name of the problem:** Fractions problem\n\n**What the problem is about:** Imagine you have 9 distinct digits (from 1 to 9) that you want to use to create three fractions that add up to 1. The fractions are created by combining the digits in a specific way.\n\n**Main variables and their meanings:**\n\n* A, B, C, D, E, F, G, H, I: These are the 9 distinct digits (from 1 to 9) that we want to use to create the fractions.\n* D1, D2, D3: These are the denominators (the numbers at the bottom) of the three fractions.\n\n**Basic restrictions or rules:**\n\n* Each digit can only be used once.\n* The digits must be combined in a specific way to create the fractions.\n* The three fractions must add up to 1.\n\n**Goal of the problem:** Find a way to combine the 9 digits to create three fractions that add up to 1, while following the rules and restrictions mentioned above.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 901, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9cfcb2d2-a6db-40ad-b990-7d4c995ec9e9": {"__data__": {"id_": "9cfcb2d2-a6db-40ad-b990-7d4c995ec9e9", "embedding": null, "metadata": {"model_name": "golfers", "source_code": "Model 1 :\n\n\n% The social golfers problem\n% A club has a number of golfers that play rounds in groups (the number of\n% golfers is a multiple of the number of groups).  Each round, a golfer\n% plays with a group of different people, such that the same pair of golfers\n% never play together twice.\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\nset of int: places = 1..n_golfers;\n\narray [rounds, places] of var golfers: round_place_golfer;\narray [golfers, golfers] of var 0..n_rounds: golfer_golfer_round;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (p in places) (round_place_golfer[r, p])\n    );\n\n    % Break some symmetry by strictly ordering each group in each round.\n    %\nconstraint\n    forall (r in rounds, p in places) (\n        if p mod n_per_group != 0\n        then round_place_golfer[r, p] < round_place_golfer[r, p + 1]\n        else true\n        endif\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (r in rounds, g in 0..(n_groups - 1), i, j in 1..n_per_group\n            where i < j) (\n        golfer_golfer_round[\n            round_place_golfer[r, n_per_group * g + i],\n            round_place_golfer[r, n_per_group * g + j]\n        ] = r\n    );\n\nsolve\n    :: int_search([round_place_golfer[r, p] | r in rounds, p in places],\n        first_fail, indomain_min, complete)\n    satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if p = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif ) ++\n    ( if p mod n_per_group = 1 then \"   \" else \" \" endif ) ++\n    show_int(2, round_place_golfer[r, p]) | r in rounds, p in places\n];\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups, group] of var golfers: round_group_i_golfer;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (g in groups, i in group) (round_group_i_golfer[r, g, i])\n    );\n\n    % We also break some symmetry\n    % here by strictly ordering each group.\n    %\nconstraint\n    forall (r in rounds, g in groups, i in group where i < n_per_group) (\n        round_group_i_golfer[r, g, i] < round_group_i_golfer[r, g, i + 1]\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups, i, j in group where i < j) (\n            bool2int(\n                round_group_i_golfer[r, g, i] = a\n            /\\  round_group_i_golfer[r, g, j] = b\n            )\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if g = 1 /\\ i = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif) ++\n    ( if i = 1 then \"   \" else \" \" endif) ++\n    show_int(2, round_group_i_golfer[r, g, i]) \n    |  r in rounds, g in groups, i in group\n];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups] of var set of golfers: round_group_golfers;\n\n    % Each group has to have the right size.\n    %\nconstraint\n    forall (r in rounds, g in groups) (\n        card(round_group_golfers[r, g]) = n_per_group\n    );\n\n    % Each group in each round has to be disjoint.\n    %\nconstraint\n    forall (r in rounds) (\n        all_disjoint (g in groups) (round_group_golfers[r, g])\n    );\n\n    % Symmetry breaking.\n    %\n% constraint\n%     forall (r in rounds, g in groups where g < n_groups) (\n%         round_group_golfers[r, g] < round_group_golfers[r, g + 1]\n%     );\n\n    % Each pair may play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups) (\n            bool2int({a, b} subset round_group_golfers[r, g])\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [    ( if   g = 1\n              then \"\\nround \" ++ show(r) ++ \":   \"\n              else \"   \"\n              endif\n            ) ++\n            show(round_group_golfers[r, g])\n       |    r in rounds, g in groups\n       ];\n\n\nModel 4 :\n\n\nint: weeks = 4;\nint: groups = 3;\nint: groupSize = 3;\nint: golfers = groups * groupSize;\n\nset of int: Golfer = 1..golfers;\nset of int: Week = 1..weeks;\nset of int: Group = 1..groups;\n\n% Search space: The set of all possible group assignments to all \n% players in each of the weeks\narray[Golfer, Week] of var Group: assign;\n\n% solve satisfy;\n% solve :: int_search([assign[i,j] | i in Golfer, j in Week ], \"first_fail\", \"indomain\", \"complete\") satisfy;\nsolve :: int_search([assign[i,j] | i in Golfer, j in Week ], \n        first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each group has exactly groupSize players\n   forall (gr in Group, w in Week)( % c1\n     sum (g in Golfer) (bool2int(assign[g,w] = gr)) = groupSize\n   )\n   /\\\n   % C2: Each pair of players only meets at most once\n   forall (g1, g2 in Golfer, w1, w2 in Week  where g1 != g2 /\\ w1 != w2) (\n     (bool2int(assign[g1,w1] = assign[g2,w1]) + bool2int(assign[g1,w2] = assign[g2,w2])) <= 1\n   )\n  /\\\n  % SBSA: Symmetry-breaking by selective assignment\n  % On the first week, the first groupSize golfers play in group 1, the \n  % second groupSize golfers play in group 2, etc. On the second week, \n  % golfer 1 plays in group 1, golfer 2 plays in group 2, etc.\n  forall(g in Golfer) (\n    assign[g,1]=((g-1) div groupSize) + 1 % \n  )\n  /\\\n  forall(g in Golfer where g <= groupSize)(\n    assign[g,2]=g\n  )\n\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n  show(assign[i,j])\n  | i in Golfer, j in Week\n] ++ [\"\\n\"];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golfers_beginner", "node_type": "4", "metadata": {"model_name": "golfers", "source_code": "Model 1 :\n\n\n% The social golfers problem\n% A club has a number of golfers that play rounds in groups (the number of\n% golfers is a multiple of the number of groups).  Each round, a golfer\n% plays with a group of different people, such that the same pair of golfers\n% never play together twice.\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\nset of int: places = 1..n_golfers;\n\narray [rounds, places] of var golfers: round_place_golfer;\narray [golfers, golfers] of var 0..n_rounds: golfer_golfer_round;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (p in places) (round_place_golfer[r, p])\n    );\n\n    % Break some symmetry by strictly ordering each group in each round.\n    %\nconstraint\n    forall (r in rounds, p in places) (\n        if p mod n_per_group != 0\n        then round_place_golfer[r, p] < round_place_golfer[r, p + 1]\n        else true\n        endif\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (r in rounds, g in 0..(n_groups - 1), i, j in 1..n_per_group\n            where i < j) (\n        golfer_golfer_round[\n            round_place_golfer[r, n_per_group * g + i],\n            round_place_golfer[r, n_per_group * g + j]\n        ] = r\n    );\n\nsolve\n    :: int_search([round_place_golfer[r, p] | r in rounds, p in places],\n        first_fail, indomain_min, complete)\n    satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if p = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif ) ++\n    ( if p mod n_per_group = 1 then \"   \" else \" \" endif ) ++\n    show_int(2, round_place_golfer[r, p]) | r in rounds, p in places\n];\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups, group] of var golfers: round_group_i_golfer;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (g in groups, i in group) (round_group_i_golfer[r, g, i])\n    );\n\n    % We also break some symmetry\n    % here by strictly ordering each group.\n    %\nconstraint\n    forall (r in rounds, g in groups, i in group where i < n_per_group) (\n        round_group_i_golfer[r, g, i] < round_group_i_golfer[r, g, i + 1]\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups, i, j in group where i < j) (\n            bool2int(\n                round_group_i_golfer[r, g, i] = a\n            /\\  round_group_i_golfer[r, g, j] = b\n            )\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if g = 1 /\\ i = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif) ++\n    ( if i = 1 then \"   \" else \" \" endif) ++\n    show_int(2, round_group_i_golfer[r, g, i]) \n    |  r in rounds, g in groups, i in group\n];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups] of var set of golfers: round_group_golfers;\n\n    % Each group has to have the right size.\n    %\nconstraint\n    forall (r in rounds, g in groups) (\n        card(round_group_golfers[r, g]) = n_per_group\n    );\n\n    % Each group in each round has to be disjoint.\n    %\nconstraint\n    forall (r in rounds) (\n        all_disjoint (g in groups) (round_group_golfers[r, g])\n    );\n\n    % Symmetry breaking.\n    %\n% constraint\n%     forall (r in rounds, g in groups where g < n_groups) (\n%         round_group_golfers[r, g] < round_group_golfers[r, g + 1]\n%     );\n\n    % Each pair may play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups) (\n            bool2int({a, b} subset round_group_golfers[r, g])\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [    ( if   g = 1\n              then \"\\nround \" ++ show(r) ++ \":   \"\n              else \"   \"\n              endif\n            ) ++\n            show(round_group_golfers[r, g])\n       |    r in rounds, g in groups\n       ];\n\n\nModel 4 :\n\n\nint: weeks = 4;\nint: groups = 3;\nint: groupSize = 3;\nint: golfers = groups * groupSize;\n\nset of int: Golfer = 1..golfers;\nset of int: Week = 1..weeks;\nset of int: Group = 1..groups;\n\n% Search space: The set of all possible group assignments to all \n% players in each of the weeks\narray[Golfer, Week] of var Group: assign;\n\n% solve satisfy;\n% solve :: int_search([assign[i,j] | i in Golfer, j in Week ], \"first_fail\", \"indomain\", \"complete\") satisfy;\nsolve :: int_search([assign[i,j] | i in Golfer, j in Week ], \n        first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each group has exactly groupSize players\n   forall (gr in Group, w in Week)( % c1\n     sum (g in Golfer) (bool2int(assign[g,w] = gr)) = groupSize\n   )\n   /\\\n   % C2: Each pair of players only meets at most once\n   forall (g1, g2 in Golfer, w1, w2 in Week  where g1 != g2 /\\ w1 != w2) (\n     (bool2int(assign[g1,w1] = assign[g2,w1]) + bool2int(assign[g1,w2] = assign[g2,w2])) <= 1\n   )\n  /\\\n  % SBSA: Symmetry-breaking by selective assignment\n  % On the first week, the first groupSize golfers play in group 1, the \n  % second groupSize golfers play in group 2, etc. On the second week, \n  % golfer 1 plays in group 1, golfer 2 plays in group 2, etc.\n  forall(g in Golfer) (\n    assign[g,1]=((g-1) div groupSize) + 1 % \n  )\n  /\\\n  forall(g in Golfer where g <= groupSize)(\n    assign[g,2]=g\n  )\n\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n  show(assign[i,j])\n  | i in Golfer, j in Week\n] ++ [\"\\n\"];"}, "hash": "660f157e27a8d7e4c21868266e2649c132985ab5e93a22ebb40c4ce5d0db0cb4", "class_name": "RelatedNodeInfo"}}, "text": "Here is the explanation of the problem:\n\n**Name of the problem:** Social Golfers Problem\n\n**What the problem is about in everyday terms:** Imagine a group of golfers who want to play golf together in small groups over several rounds. The goal is to arrange the golfers into groups for each round such that each golfer plays with different people in each round, and no two golfers play together more than once.\n\n**Main variables and what they mean:**\n\n* `n_groups`: The number of groups that the golfers will be divided into.\n* `n_per_group`: The number of golfers in each group.\n* `n_rounds`: The number of rounds that the golfers will play.\n* `golfers`: The set of all golfers.\n* `rounds`: The set of all rounds.\n* `places` or `groups`: The set of all possible positions or groups that a golfer can be assigned to.\n\n**Basic restrictions or rules of the problem:**\n\n* Each group must have the same number of golfers.\n* Each golfer must play with different people in each round.\n* No two golfers can play together more than once.\n\n**Goal of the problem:** The goal is to find an arrangement of golfers into groups for each round that satisfies the above rules and restrictions.\n\nNote that the different models provided are different ways of representing the same problem, but the overall problem remains the same.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1312, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "91487107-c324-4504-9301-fd11ec00537d": {"__data__": {"id_": "91487107-c324-4504-9301-fd11ec00537d", "embedding": null, "metadata": {"model_name": "golomb", "source_code": "% Golomb rulers\n% From csplib:\n% A Golomb ruler may be defined as a set of m integers 0 = a_1 < a_2 <\n% ... < a_m such that the m(m-1)/2 differences a_j - a_i, 1 <= i < j\n% <= m are distinct. Such a ruler is said to contain m marks and is of\n% length a_m. The objective is to find optimal (minimum length) or\n% near optimal rulers.\n%\n% This is the \"ternary constraints and an alldifferent\" model\n\ninclude \"globals.mzn\";\n\nint: m;\nint: n = m*m;\n\narray[1..m] of var 0..n: mark;\n\narray[1..(m*(m-1)) div 2] of var 0..n: differences =\n    [ mark[j] - mark[i] | i in 1..m, j in i+1..m];\n\nconstraint mark[1] = 0;\n\nconstraint forall ( i in 1..m-1 ) ( mark[i] < mark[i+1] );\n\nconstraint alldifferent(differences);\n\n    % Symmetry breaking\nconstraint differences[1] < differences[(m*(m-1)) div 2];\n\nsolve :: int_search(mark, input_order, indomain, complete)\n    minimize mark[m];\n\noutput [show(mark)];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golomb_beginner", "node_type": "4", "metadata": {"model_name": "golomb", "source_code": "% Golomb rulers\n% From csplib:\n% A Golomb ruler may be defined as a set of m integers 0 = a_1 < a_2 <\n% ... < a_m such that the m(m-1)/2 differences a_j - a_i, 1 <= i < j\n% <= m are distinct. Such a ruler is said to contain m marks and is of\n% length a_m. The objective is to find optimal (minimum length) or\n% near optimal rulers.\n%\n% This is the \"ternary constraints and an alldifferent\" model\n\ninclude \"globals.mzn\";\n\nint: m;\nint: n = m*m;\n\narray[1..m] of var 0..n: mark;\n\narray[1..(m*(m-1)) div 2] of var 0..n: differences =\n    [ mark[j] - mark[i] | i in 1..m, j in i+1..m];\n\nconstraint mark[1] = 0;\n\nconstraint forall ( i in 1..m-1 ) ( mark[i] < mark[i+1] );\n\nconstraint alldifferent(differences);\n\n    % Symmetry breaking\nconstraint differences[1] < differences[(m*(m-1)) div 2];\n\nsolve :: int_search(mark, input_order, indomain, complete)\n    minimize mark[m];\n\noutput [show(mark)];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%\n"}, "hash": "5738679d4e4b0b29a3b9fa5df4fd0fc1929129a5210e13226828b26e1467685c", "class_name": "RelatedNodeInfo"}}, "text": "Golomb Ruler Problem\n\nThis problem is about creating a special kind of ruler with marks on it. Imagine a ruler with some marks on it, and we want to find the best way to place these marks so that the ruler is as short as possible.\n\nThe main variables are:\n\n* `m`: the number of marks on the ruler\n* `mark`: an array that stores the positions of the marks on the ruler\n* `differences`: an array that stores the differences between the positions of the marks\n\nThe basic restrictions or rules of the problem are:\n\n* The marks must be placed in order from left to right (i.e., the first mark is at position 0, and each subsequent mark is to the right of the previous one)\n* All the differences between the positions of the marks must be unique (i.e., no two differences can be the same)\n\nThe goal of the problem is to find the shortest ruler that satisfies these rules. In other words, we want to minimize the length of the ruler.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 926, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "288c9b5f-8c31-405c-b63b-1f705f128232": {"__data__": {"id_": "288c9b5f-8c31-405c-b63b-1f705f128232", "embedding": null, "metadata": {"model_name": "graph", "source_code": "% a strange graph numbering problem\nvar 1..8: a;\nvar 1..8: b;\nvar 1..8: c;\nvar 1..8: d;\nvar 1..8: e;\nvar 1..8: f;\nvar 1..8: g;\nvar 1..8: h;\n\n% Each number is used exactly once\nconstraint a != b;\nconstraint a != c;\nconstraint a != d;\nconstraint a != e;\nconstraint a != f;\nconstraint a != g;\nconstraint a != h;\nconstraint b != c;\nconstraint b != d;\nconstraint b != e;\nconstraint b != f;\nconstraint b != g;\nconstraint b != h;\nconstraint c != d;\nconstraint c != e;\nconstraint c != f;\nconstraint c != g;\nconstraint c != h;\nconstraint d != e;\nconstraint d != f;\nconstraint d != g;\nconstraint d != h;\nconstraint e != f;\nconstraint e != g;\nconstraint e != h;\nconstraint f != g;\nconstraint f != h;\nconstraint g != h;\n\n% Adjacent vertices differ by at most two\nconstraint abs(a - b) >= 2;\nconstraint abs(a - c) >= 2;\nconstraint abs(a - d) >= 2;\nconstraint abs(b - c) >= 2;\nconstraint abs(b - e) >= 2;\nconstraint abs(b - f) >= 2;\nconstraint abs(c - d) >= 2;\nconstraint abs(c - e) >= 2;\nconstraint abs(c - f) >= 2;\nconstraint abs(c - g) >= 2;\nconstraint abs(d - f) >= 2;\nconstraint abs(d - g) >= 2;\nconstraint abs(e - f) >= 2;\nconstraint abs(e - h) >= 2;\nconstraint abs(f - g) >= 2;\nconstraint abs(f - h) >= 2;\nconstraint abs(g - h) >= 2;\n\nsolve satisfy;\n\noutput [\"  \\(b)-\\(e)\\n\",\n        \" /|*|\\\\\\n\",\n        \"\\(a)-\\(c)-\\(f)-\\(h)\\n\",\n        \" \\\\|*|/\\n\",\n        \"  \\(d)-\\(g)\\n\"] ++\n       [\"\\na = \\(a); b = \\(b); c = \\(c); d = \\(d);\",\n        \" e = \\(e); f = \\(f); g = \\(g); h = \\(h);\\n\"] \n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "graph_beginner", "node_type": "4", "metadata": {"model_name": "graph", "source_code": "% a strange graph numbering problem\nvar 1..8: a;\nvar 1..8: b;\nvar 1..8: c;\nvar 1..8: d;\nvar 1..8: e;\nvar 1..8: f;\nvar 1..8: g;\nvar 1..8: h;\n\n% Each number is used exactly once\nconstraint a != b;\nconstraint a != c;\nconstraint a != d;\nconstraint a != e;\nconstraint a != f;\nconstraint a != g;\nconstraint a != h;\nconstraint b != c;\nconstraint b != d;\nconstraint b != e;\nconstraint b != f;\nconstraint b != g;\nconstraint b != h;\nconstraint c != d;\nconstraint c != e;\nconstraint c != f;\nconstraint c != g;\nconstraint c != h;\nconstraint d != e;\nconstraint d != f;\nconstraint d != g;\nconstraint d != h;\nconstraint e != f;\nconstraint e != g;\nconstraint e != h;\nconstraint f != g;\nconstraint f != h;\nconstraint g != h;\n\n% Adjacent vertices differ by at most two\nconstraint abs(a - b) >= 2;\nconstraint abs(a - c) >= 2;\nconstraint abs(a - d) >= 2;\nconstraint abs(b - c) >= 2;\nconstraint abs(b - e) >= 2;\nconstraint abs(b - f) >= 2;\nconstraint abs(c - d) >= 2;\nconstraint abs(c - e) >= 2;\nconstraint abs(c - f) >= 2;\nconstraint abs(c - g) >= 2;\nconstraint abs(d - f) >= 2;\nconstraint abs(d - g) >= 2;\nconstraint abs(e - f) >= 2;\nconstraint abs(e - h) >= 2;\nconstraint abs(f - g) >= 2;\nconstraint abs(f - h) >= 2;\nconstraint abs(g - h) >= 2;\n\nsolve satisfy;\n\noutput [\"  \\(b)-\\(e)\\n\",\n        \" /|*|\\\\\\n\",\n        \"\\(a)-\\(c)-\\(f)-\\(h)\\n\",\n        \" \\\\|*|/\\n\",\n        \"  \\(d)-\\(g)\\n\"] ++\n       [\"\\na = \\(a); b = \\(b); c = \\(c); d = \\(d);\",\n        \" e = \\(e); f = \\(f); g = \\(g); h = \\(h);\\n\"] \n\n"}, "hash": "452cc7ed90dc10a51f2346e4aa0ba6b5a9a80c7c25ef5b6c45b200f60bcf637b", "class_name": "RelatedNodeInfo"}}, "text": "**Graph Numbering Problem**\n\nThis problem is about labeling the vertices of a graph with numbers from 1 to 8, such that each number is used only once.\n\n**Main Variables:**\n\n* a, b, c, d, e, f, g, h: These are the labels or numbers assigned to the vertices of the graph.\n\n**Basic Restrictions or Rules:**\n\n* Each number from 1 to 8 can only be used once.\n* The numbers assigned to adjacent vertices (connected by an edge) must differ by at least 2.\n\n**Goal:**\n\nThe goal is to find an assignment of numbers to the vertices that satisfies the above rules. There is no specific objective to minimize or maximize, the goal is simply to find a valid solution.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 653, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cd8b2ac4-86d8-45df-8ae9-329945d75a55": {"__data__": {"id_": "cd8b2ac4-86d8-45df-8ae9-329945d75a55", "embedding": null, "metadata": {"model_name": "itemset_mining", "source_code": "int : NrI ; \nint : NrT ; \nint : Freq ;\narray [ 1..NrT ] of set of 1..NrI : TDB;\nvar set of 1..NrI : Items ;\nconstraint card ( cover ( Items ,TDB ) ) >= Freq ;\nsolve satisfy ; \n\nfunction var set of int : cover (\n         var set of int : Items ,\n         array [ int ] of var set of int : D) = \n         let {\n                          var set of index_set (D): Trans ;\n                          constraint forall ( t in index_set (D) )\n                          ( t in Trans <-> Items subset D[ t ] );\n         } in Trans;\n\narray[1.. NrI] of int: itemprice;\nint: minUtility;\n\nconstraint sum(i in Items)(itemprice[i]) >= minUtility;\n\nNrI = 6;\nint: bread = 1;\nint: butter = 2;\nint: cheese = 3;\nint: cocoa = 4;\nint: milk = 5;\nint: vegemite = 6;\narray[1..NrI] of string: name = [\"bread\",\"butter\",\"cheese\",\"cocoa\",\"milk\",\"vegemite\"];\nitemprice = [1,2,1,2,1,1];\n\nNrT = 7;\nTDB = [ { butter, cheese, milk, vegemite },\n        { butter, cocoa, milk, vegemite },\n\t{ bread, cocoa, cheese, milk },\n\t{ bread, butter, cheese, vegemite }, \n\t{ bread, cheese, milk, vegemite },\n\t{ bread, butter, cheese, cocoa, milk },\n\t{ bread, cheese, milk }];\n\nFreq = 4;\nminUtility = 3;\n\noutput [ name[i] ++ \" \" | i in fix(Items) ];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "itemset_mining_beginner", "node_type": "4", "metadata": {"model_name": "itemset_mining", "source_code": "int : NrI ; \nint : NrT ; \nint : Freq ;\narray [ 1..NrT ] of set of 1..NrI : TDB;\nvar set of 1..NrI : Items ;\nconstraint card ( cover ( Items ,TDB ) ) >= Freq ;\nsolve satisfy ; \n\nfunction var set of int : cover (\n         var set of int : Items ,\n         array [ int ] of var set of int : D) = \n         let {\n                          var set of index_set (D): Trans ;\n                          constraint forall ( t in index_set (D) )\n                          ( t in Trans <-> Items subset D[ t ] );\n         } in Trans;\n\narray[1.. NrI] of int: itemprice;\nint: minUtility;\n\nconstraint sum(i in Items)(itemprice[i]) >= minUtility;\n\nNrI = 6;\nint: bread = 1;\nint: butter = 2;\nint: cheese = 3;\nint: cocoa = 4;\nint: milk = 5;\nint: vegemite = 6;\narray[1..NrI] of string: name = [\"bread\",\"butter\",\"cheese\",\"cocoa\",\"milk\",\"vegemite\"];\nitemprice = [1,2,1,2,1,1];\n\nNrT = 7;\nTDB = [ { butter, cheese, milk, vegemite },\n        { butter, cocoa, milk, vegemite },\n\t{ bread, cocoa, cheese, milk },\n\t{ bread, butter, cheese, vegemite }, \n\t{ bread, cheese, milk, vegemite },\n\t{ bread, butter, cheese, cocoa, milk },\n\t{ bread, cheese, milk }];\n\nFreq = 4;\nminUtility = 3;\n\noutput [ name[i] ++ \" \" | i in fix(Items) ];\n"}, "hash": "ff50dc27d0a28f9662b58be4ff3eecb22ce0e8c1e645fccc1b3550d1a6c1d588", "class_name": "RelatedNodeInfo"}}, "text": "**Problem Name:** Item Selection Problem\n\n**What the problem is about:** Imagine you have a list of items (like bread, butter, cheese, etc.) and you want to choose some of them to buy. You also have some bundles of items that are often bought together (like butter, cheese, and milk). You want to choose a set of items that covers most of these bundles and also has a total price above a certain minimum.\n\n**Main variables:**\n\n* `Items`: the set of items you choose to buy\n* `TDB`: the bundles of items that are often bought together\n* `itemprice`: the price of each item\n* `minUtility`: the minimum total price you want to achieve\n\n**Basic restrictions or rules:**\n\n* You want to choose a set of items that covers at least a certain number of bundles (defined by `Freq`)\n* The total price of the chosen items should be at least `minUtility`\n\n**Goal of the problem:** Find a set of items that covers most of the bundles and has a total price above the minimum, while satisfying the rules above.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 994, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "111ae802-6e37-405d-8831-580c2249a74a": {"__data__": {"id_": "111ae802-6e37-405d-8831-580c2249a74a", "embedding": null, "metadata": {"model_name": "jobshop", "source_code": "Model 1 :\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\n% only one task on any machine at one time\n%constraint forall(ma in MACH)\n%                 (forall(j1,j2 in JOB where j1 < j2)\n%                       (forall(t1,t2 in TASK where mc[j1,t1] = ma /\\ mc[j2,t2] = ma)\n%                              (nonoverlap(s[j1,t1],d[j1,t1],s[j2,t2],d[j2,t2]))));\n\nconstraint forall(j1, j2 in JOB, t1, t2 in TASK \n       where j1 < j2 /\\ mc[j1,t1] = mc[j2,t2])\n      (nonoverlap(s[j1,t1],d[j1,t1],\n                  s[j2,t2],d[j2,t2]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve :: int_search([s[j,t] | j in JOB, t in TASK], input_order, indomain_min, complete)\n      minimize makespan;\n\noutput [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 2 : \n\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n   %:: int_search([s[j,t]|j in JOB,t in TASK],input_order,indomain_min,complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],smallest, indomain_min, complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],dom_w_deg, indomain_min, complete)\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 3 : \n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n%      ::\n%      seq_search([ int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete),\n%                  int_search([makespan], input_order, indomain_min, complete)])\n%      seq_search([ int_search([makespan], input_order, indomain_min, complete),\n%                   int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete)])\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "jobshop_beginner", "node_type": "4", "metadata": {"model_name": "jobshop", "source_code": "Model 1 :\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\n% only one task on any machine at one time\n%constraint forall(ma in MACH)\n%                 (forall(j1,j2 in JOB where j1 < j2)\n%                       (forall(t1,t2 in TASK where mc[j1,t1] = ma /\\ mc[j2,t2] = ma)\n%                              (nonoverlap(s[j1,t1],d[j1,t1],s[j2,t2],d[j2,t2]))));\n\nconstraint forall(j1, j2 in JOB, t1, t2 in TASK \n       where j1 < j2 /\\ mc[j1,t1] = mc[j2,t2])\n      (nonoverlap(s[j1,t1],d[j1,t1],\n                  s[j2,t2],d[j2,t2]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve :: int_search([s[j,t] | j in JOB, t in TASK], input_order, indomain_min, complete)\n      minimize makespan;\n\noutput [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 2 : \n\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n   %:: int_search([s[j,t]|j in JOB,t in TASK],input_order,indomain_min,complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],smallest, indomain_min, complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],dom_w_deg, indomain_min, complete)\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 3 : \n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n%      ::\n%      seq_search([ int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete),\n%                  int_search([makespan], input_order, indomain_min, complete)])\n%      seq_search([ int_search([makespan], input_order, indomain_min, complete),\n%                   int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete)])\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n"}, "hash": "d36177024292a97bdd269f003f6e3183e299bc63216325abf4f9775d6adcfee1", "class_name": "RelatedNodeInfo"}}, "text": "Here is the explanation of the problem:\n\n**Name of the problem:** Job Shop Scheduling\n\n**What the problem is about in everyday terms:** Imagine you have a workshop with multiple machines, and you need to perform a series of tasks (or jobs) on these machines. Each task has a specific duration and requires a specific machine. The goal is to schedule these tasks in a way that minimizes the total time it takes to complete all the tasks.\n\n**Main variables and what they mean:**\n\n* `n`: The number of jobs (or tasks) to be performed.\n* `m`: The number of machines in the workshop.\n* `JOB`: A set of integers representing the jobs (1 to `n`).\n* `MACH`: A set of integers representing the machines (1 to `m`).\n* `TASK`: A set of integers representing the tasks (1 to `m`).\n* `d`: An array that stores the duration of each task.\n* `mc`: An array that stores the machine required for each task.\n* `s`: An array of variables that represents the start time of each task.\n* `makespan`: A variable that represents the total time it takes to complete all the tasks.\n\n**Basic restrictions or rules of the problem:**\n\n* Each task must be performed in a specific order (e.g., task 1 must be completed before task 2).\n* Each machine can only perform one task at a time.\n* The start time of each task must be greater than or equal to the completion time of the previous task.\n\n**Goal of the problem:** The goal is to minimize the `makespan`, which is the total time it takes to complete all the tasks.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1485, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "30794ba2-6db1-4dac-ac81-243d0c06cf92": {"__data__": {"id_": "30794ba2-6db1-4dac-ac81-243d0c06cf92", "embedding": null, "metadata": {"model_name": "K4xP2Graceful", "source_code": "% K4P2 Graceful Graph in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: m = 16;\nint: n = 8;\narray[1..n] of var 0..m: nodes;\narray[1..m, 1..2] of var 1..n: graph;\narray[1..m] of var 1..m: edges;\n\n\n\nsolve :: int_search(nodes, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..m) (\n    abs(nodes[graph[i,1]] - nodes[graph[i,2]]) = edges[i]  \n  )\n  /\\\n  all_different(edges) \n  /\\ \n  all_different(nodes)\n;\n\ngraph =\narray2d(1..m, 1..2,\n[1, 2,\n1, 3,\n1, 4,\n2, 3,\n2, 4,\n3, 4,\n\n5, 6,\n5, 7,\n5, 8,\n6, 7,\n6, 8,\n7, 8,\n\n1, 5,\n2, 6,\n3, 7,\n4, 8]);\n\noutput\n[\n  \"nodes: \" ++ show(nodes) ++ \"\\n\" ++\n  \"edges: \" ++ show(edges) ++ \"\\n\"\n];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "K4xP2Graceful_beginner", "node_type": "4", "metadata": {"model_name": "K4xP2Graceful", "source_code": "% K4P2 Graceful Graph in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: m = 16;\nint: n = 8;\narray[1..n] of var 0..m: nodes;\narray[1..m, 1..2] of var 1..n: graph;\narray[1..m] of var 1..m: edges;\n\n\n\nsolve :: int_search(nodes, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..m) (\n    abs(nodes[graph[i,1]] - nodes[graph[i,2]]) = edges[i]  \n  )\n  /\\\n  all_different(edges) \n  /\\ \n  all_different(nodes)\n;\n\ngraph =\narray2d(1..m, 1..2,\n[1, 2,\n1, 3,\n1, 4,\n2, 3,\n2, 4,\n3, 4,\n\n5, 6,\n5, 7,\n5, 8,\n6, 7,\n6, 8,\n7, 8,\n\n1, 5,\n2, 6,\n3, 7,\n4, 8]);\n\noutput\n[\n  \"nodes: \" ++ show(nodes) ++ \"\\n\" ++\n  \"edges: \" ++ show(edges) ++ \"\\n\"\n];"}, "hash": "712f6d409009c4025fc67ebda69455a0b9b0b9ba32bd42ad575b07ad444861bd", "class_name": "RelatedNodeInfo"}}, "text": "**K4P2 Graceful Graph**\n\nThis problem is about creating a special kind of graph, which is like a network of connected points.\n\n**Main variables:**\n\n* **nodes**: These are the points in the graph, and we need to assign a number to each one.\n* **graph**: This is the connection between the points, telling us which points are connected to each other.\n* **edges**: These are the connections between the points, and we need to assign a number to each connection.\n\n**Basic restrictions or rules:**\n\n* The difference between the numbers of two connected points must be equal to the number of the connection between them.\n* All connections must have different numbers.\n* All points must have different numbers.\n\n**Goal:**\n\nThe goal is to find a way to assign numbers to the points and connections so that all the rules are satisfied.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 826, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "412f417e-e027-45da-8bf5-fb03bd356fc5": {"__data__": {"id_": "412f417e-e027-45da-8bf5-fb03bd356fc5", "embedding": null, "metadata": {"model_name": "killer_sudoku", "source_code": "Model 1 :\n\n%\n% Killer Sudoku in MiniZinc.\n\n%   Killer sudoku (also killer su doku, sumdoku, sum doku, addoku, or\n%   samunamupure) is a puzzle that combines elements of sudoku and kakuro.\n%   Despite the name, the simpler killer sudokus can be easier to solve\n%   than regular sudokus, depending on the solver's skill at mental arithmetic;\n%   the hardest ones, however, can take hours to crack.\n \n%   The objective is to fill the grid with numbers from 1 to 9 in a way that\n%   the following conditions are met:\n \n%     * Each row, column, and nonet contains each number exactly once.\n%     * The sum of all numbers in a cage must match the small number printed\n%       in its corner.\n%     * No number appears more than once in a cage. (This is the standard rule\n%       for killer sudokus, and implies that no cage can include more\n%       than 9 cells.)\n \n%   In 'Killer X', an additional rule is that each of the long diagonals\n%   contains each number once.\n%   \"\"\"\n \n\nint: num_p = 29; % number of segments\nint: num_hints = 4;  % number of hints per segments (that's max number of hints)\nint: max_val = 100;\narray[1..num_p, 1..2*num_hints+1] of 0..max_val: P =\n  array2d(1..num_p, 1..2*num_hints+1, [\n    1,1,  1,2, 0,0, 0,0,   3,\n    1,3,  1,4, 1,5, 0,0,  15,\n    1,6,  2,5, 2,6, 3,5,  22,\n    1,7,  2,7, 0,0, 0,0,   4,\n    1,8,  2,8, 0,0, 0,0,  16,\n    1,9,  2,9, 3,9, 4,9,  15,\n    2,1,  2,2, 3,1, 3,2,  25,\n    2,3,  2,4, 0,0, 0,0,  17,\n    3,3,  3,4, 4,4, 0,0,   9,\n    3,6,  4,6, 5,6, 0,0,   8,\n    3,7,  3,8, 4,7, 0,0,  20,\n    4,1,  5,1, 0,0, 0,0,   6,\n    4,2,  4,3, 0,0, 0,0,  14,\n    4,5,  5,5, 6,5, 0,0,  17,\n    4,8,  5,7, 5,8, 0,0,  17,\n    5,2,  5,3, 6,2, 0,0,  13,\n    5,4,  6,4, 7,4, 0,0,  20,\n    5,9,  6,9, 0,0, 0,0,  12,\n    6,1,  7,1, 8,1, 9,1,  27,\n    6,3,  7,2, 7,3, 0,0,   6,\n    6,6,  7,6, 7,7, 0,0,  20,\n    6,7,  6,8, 0,0, 0,0,   6,\n    7,5,  8,4, 8,5, 9,4,  10,\n    7,8,  7,9, 8,8, 8,9,  14,\n    8,2,  9,2, 0,0, 0,0,   8,\n    8,3,  9,3, 0,0, 0,0,  16,\n    8,6,  8,7, 0,0, 0,0,  15,\n    9,5,  9,6, 9,7, 0,0,  13,\n    9,8,  9,9, 0,0, 0,0,  17\n   ]);\n\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n \n  forall(i in 1..n) (\n        all_different([x[i,j] | j in 1..n]) /\\\n        all_different([x[j,i] | j in 1..n])\n  )\n  /\\\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n  /\\ % calculate the hints\n  forall(p in 1..num_p) (\n     sum(i in 1..num_hints where P[p,2*(i-1)+1] > 0) (x[  P[p, 2*(i-1)+1], P[p,2*(i-1)+2]  ]) = P[p, 2*num_hints+1]\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\"; \nint: n = 9;\narray[1..n, 1..n] of var 1..9: x;\n\nint: num_segments = 29; % number of segments\n\narray[1..n, 1..n] of int: segments =\narray2d(1..n, 1..n,\n[\n  1, 1, 2, 2, 2, 3, 4, 5, 6, % 1\n  7, 7, 8, 8, 3, 3, 4, 5, 6, % 2\n  7, 7, 9, 9, 3,10,11,11, 6, % 3\n 13,14,14, 9,15,10,11,12, 6, % 4\n 13,16,16,17,15,10,12,12,18, % 5\n 19,16,20,17,15,21,22,22,18, % 6\n 19,20,20,17,23,21,21,24,24, % 7\n 19,25,26,23,23,27,27,24,24, % 8\n 19,25,26,23,28,28,28,29,29, % 9\n]);\n\narray[1..num_segments] of int: segment_sums =\n[\n   3, % 1\n  15, % 2\n  22, % 3\n   4, % 4\n  16, % 5\n  15, % 6\n  25, % 7\n  17, % 8\n   9, % 9\n   8, % 10\n  20, % 11\n  17, % 12\n   6, % 13\n  14, % 14\n  17, % 15\n  13, % 16\n  20, % 17\n  12, % 18\n  27, % 19\n   6, % 20\n  20, % 21\n   6, % 22\n  10, % 23\n  14, % 24\n   8, % 25\n  16, % 26\n  15, % 27\n  13, % 28\n  17  % 29\n];\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\n% Standard Sudoku constraints\nconstraint\n  % rows and columns\n  forall(i in 1..n) (\n     all_different([x[i,j] | j in 1..n]) /\\\n     all_different([x[j,i] | j in 1..n])\n  )\n  /\\ % blocks\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n;\n\n% Handle the segments\nconstraint\n  forall(p in 1..num_segments) (\n    segment_sums[p] = sum([x[i,j] | i,j in 1..n where segments[i,j] = p])\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "killer_sudoku_beginner", "node_type": "4", "metadata": {"model_name": "killer_sudoku", "source_code": "Model 1 :\n\n%\n% Killer Sudoku in MiniZinc.\n\n%   Killer sudoku (also killer su doku, sumdoku, sum doku, addoku, or\n%   samunamupure) is a puzzle that combines elements of sudoku and kakuro.\n%   Despite the name, the simpler killer sudokus can be easier to solve\n%   than regular sudokus, depending on the solver's skill at mental arithmetic;\n%   the hardest ones, however, can take hours to crack.\n \n%   The objective is to fill the grid with numbers from 1 to 9 in a way that\n%   the following conditions are met:\n \n%     * Each row, column, and nonet contains each number exactly once.\n%     * The sum of all numbers in a cage must match the small number printed\n%       in its corner.\n%     * No number appears more than once in a cage. (This is the standard rule\n%       for killer sudokus, and implies that no cage can include more\n%       than 9 cells.)\n \n%   In 'Killer X', an additional rule is that each of the long diagonals\n%   contains each number once.\n%   \"\"\"\n \n\nint: num_p = 29; % number of segments\nint: num_hints = 4;  % number of hints per segments (that's max number of hints)\nint: max_val = 100;\narray[1..num_p, 1..2*num_hints+1] of 0..max_val: P =\n  array2d(1..num_p, 1..2*num_hints+1, [\n    1,1,  1,2, 0,0, 0,0,   3,\n    1,3,  1,4, 1,5, 0,0,  15,\n    1,6,  2,5, 2,6, 3,5,  22,\n    1,7,  2,7, 0,0, 0,0,   4,\n    1,8,  2,8, 0,0, 0,0,  16,\n    1,9,  2,9, 3,9, 4,9,  15,\n    2,1,  2,2, 3,1, 3,2,  25,\n    2,3,  2,4, 0,0, 0,0,  17,\n    3,3,  3,4, 4,4, 0,0,   9,\n    3,6,  4,6, 5,6, 0,0,   8,\n    3,7,  3,8, 4,7, 0,0,  20,\n    4,1,  5,1, 0,0, 0,0,   6,\n    4,2,  4,3, 0,0, 0,0,  14,\n    4,5,  5,5, 6,5, 0,0,  17,\n    4,8,  5,7, 5,8, 0,0,  17,\n    5,2,  5,3, 6,2, 0,0,  13,\n    5,4,  6,4, 7,4, 0,0,  20,\n    5,9,  6,9, 0,0, 0,0,  12,\n    6,1,  7,1, 8,1, 9,1,  27,\n    6,3,  7,2, 7,3, 0,0,   6,\n    6,6,  7,6, 7,7, 0,0,  20,\n    6,7,  6,8, 0,0, 0,0,   6,\n    7,5,  8,4, 8,5, 9,4,  10,\n    7,8,  7,9, 8,8, 8,9,  14,\n    8,2,  9,2, 0,0, 0,0,   8,\n    8,3,  9,3, 0,0, 0,0,  16,\n    8,6,  8,7, 0,0, 0,0,  15,\n    9,5,  9,6, 9,7, 0,0,  13,\n    9,8,  9,9, 0,0, 0,0,  17\n   ]);\n\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n \n  forall(i in 1..n) (\n        all_different([x[i,j] | j in 1..n]) /\\\n        all_different([x[j,i] | j in 1..n])\n  )\n  /\\\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n  /\\ % calculate the hints\n  forall(p in 1..num_p) (\n     sum(i in 1..num_hints where P[p,2*(i-1)+1] > 0) (x[  P[p, 2*(i-1)+1], P[p,2*(i-1)+2]  ]) = P[p, 2*num_hints+1]\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\"; \nint: n = 9;\narray[1..n, 1..n] of var 1..9: x;\n\nint: num_segments = 29; % number of segments\n\narray[1..n, 1..n] of int: segments =\narray2d(1..n, 1..n,\n[\n  1, 1, 2, 2, 2, 3, 4, 5, 6, % 1\n  7, 7, 8, 8, 3, 3, 4, 5, 6, % 2\n  7, 7, 9, 9, 3,10,11,11, 6, % 3\n 13,14,14, 9,15,10,11,12, 6, % 4\n 13,16,16,17,15,10,12,12,18, % 5\n 19,16,20,17,15,21,22,22,18, % 6\n 19,20,20,17,23,21,21,24,24, % 7\n 19,25,26,23,23,27,27,24,24, % 8\n 19,25,26,23,28,28,28,29,29, % 9\n]);\n\narray[1..num_segments] of int: segment_sums =\n[\n   3, % 1\n  15, % 2\n  22, % 3\n   4, % 4\n  16, % 5\n  15, % 6\n  25, % 7\n  17, % 8\n   9, % 9\n   8, % 10\n  20, % 11\n  17, % 12\n   6, % 13\n  14, % 14\n  17, % 15\n  13, % 16\n  20, % 17\n  12, % 18\n  27, % 19\n   6, % 20\n  20, % 21\n   6, % 22\n  10, % 23\n  14, % 24\n   8, % 25\n  16, % 26\n  15, % 27\n  13, % 28\n  17  % 29\n];\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\n% Standard Sudoku constraints\nconstraint\n  % rows and columns\n  forall(i in 1..n) (\n     all_different([x[i,j] | j in 1..n]) /\\\n     all_different([x[j,i] | j in 1..n])\n  )\n  /\\ % blocks\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n;\n\n% Handle the segments\nconstraint\n  forall(p in 1..num_segments) (\n    segment_sums[p] = sum([x[i,j] | i,j in 1..n where segments[i,j] = p])\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];"}, "hash": "f35f3e19b785c42a780db10abff89d9b2c8a825681a6ad0fe280e5e26500e513", "class_name": "RelatedNodeInfo"}}, "text": "Here is the explanation of the problem:\n\n**Name of the problem:** Killer Sudoku\n\n**What the problem is about in everyday terms:** Killer Sudoku is a puzzle game that combines elements of Sudoku and Kakuro. The goal is to fill a 9x9 grid with numbers from 1 to 9, following certain rules.\n\n**Main variables and what they mean:**\n\n* `x[i, j]`: represents the number in the cell at row `i` and column `j` of the grid.\n* `P` and `segments`: represent the \"cages\" or groups of cells that have specific sum constraints.\n* `num_p` and `num_segments`: represent the number of cages or segments in the puzzle.\n* `num_hints`: represents the maximum number of hints or cells in each cage.\n\n**Basic restrictions or rules of the problem:**\n\n* Each row, column, and 3x3 sub-grid (called a \"nonet\") must contain each number from 1 to 9 exactly once.\n* The sum of the numbers in each cage must match the given sum for that cage.\n* No number can appear more than once in a cage.\n\n**Goal of the problem:** The goal is to find a solution that satisfies all the constraints and rules, filling the entire grid with numbers from 1 to 9.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1114, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "88664e12-ec17-4c30-8f34-d1a2ba121ca3": {"__data__": {"id_": "88664e12-ec17-4c30-8f34-d1a2ba121ca3", "embedding": null, "metadata": {"model_name": "knapsack", "source_code": "Model 1 : \n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\narray[OBJ] of var int: x; % how many of each object\n\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in OBJ)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\nModel 2 : \n\n\nint: n;    set of int: OBJ = 1..n;\narray[OBJ] of int: size;\narray[OBJ] of int: value;\nint: limit;\narray[OBJ] of var int: x;\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i]*x[i])<= limit;\nsolve maximize sum(i in OBJ)(value[i]*x[i]);\nn = 4;\nsize = [5,8,9,12];\nvalue = [3,5,7,8];\nlimit = 29;\n\n\n\nModel 3 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var 0..1: x; \n\nconstraint sum(i in 1..n)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 4 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var bool: x; \n\nconstraint sum(i in 1..n)(size[i] * bool2int(x[i])) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(x[i]));\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 5 : \n\n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\nvar set of OBJ: x; \n\n\nconstraint sum(i in x)(size[i]) <= capacity;\n\nsolve maximize sum(i in x)(profit[i]);\n\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 6 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\nvar set of 1..n: x;\n\nconstraint sum(i in 1..n)(size[i] * bool2int(i in x)) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(i in x));\n\noutput [\"x = \", show(x), \"\\n\"];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "knapsack_beginner", "node_type": "4", "metadata": {"model_name": "knapsack", "source_code": "Model 1 : \n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\narray[OBJ] of var int: x; % how many of each object\n\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in OBJ)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\nModel 2 : \n\n\nint: n;    set of int: OBJ = 1..n;\narray[OBJ] of int: size;\narray[OBJ] of int: value;\nint: limit;\narray[OBJ] of var int: x;\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i]*x[i])<= limit;\nsolve maximize sum(i in OBJ)(value[i]*x[i]);\nn = 4;\nsize = [5,8,9,12];\nvalue = [3,5,7,8];\nlimit = 29;\n\n\n\nModel 3 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var 0..1: x; \n\nconstraint sum(i in 1..n)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 4 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var bool: x; \n\nconstraint sum(i in 1..n)(size[i] * bool2int(x[i])) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(x[i]));\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 5 : \n\n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\nvar set of OBJ: x; \n\n\nconstraint sum(i in x)(size[i]) <= capacity;\n\nsolve maximize sum(i in x)(profit[i]);\n\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 6 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\nvar set of 1..n: x;\n\nconstraint sum(i in 1..n)(size[i] * bool2int(i in x)) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(i in x));\n\noutput [\"x = \", show(x), \"\\n\"];"}, "hash": "29dfe7ccd6601e5f68cf0fc3784683e8ea2b57329b9d013d7e693a79866ec2b2", "class_name": "RelatedNodeInfo"}}, "text": "**Knapsack Problem**\n\nThis problem is about packing objects of different sizes and values into a bag with a limited capacity. Imagine you're going on a trip and you have a small bag that can only hold so much weight. You have several items you want to bring, each with a different weight and importance to you. You want to pack the most important items that fit in the bag without exceeding its weight limit.\n\n**Main variables:**\n\n* `n`: the number of objects\n* `capacity`: the maximum weight the bag can hold\n* `profit` (or `value`): how important each object is to you\n* `size`: how much each object weighs\n* `x`: which objects to pack in the bag (how many of each object to take)\n\n**Basic restrictions or rules:**\n\n* You can't pack more objects than you have.\n* The total weight of the packed objects can't exceed the bag's capacity.\n* You can't pack a fraction of an object (you either take it or leave it).\n\n**Goal:**\n\nThe goal is to pack the objects that give you the most importance (or value) while staying within the bag's weight limit.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1045, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "01968c9a-c9c4-43ec-ae98-51425df90c05": {"__data__": {"id_": "01968c9a-c9c4-43ec-ae98-51425df90c05", "embedding": null, "metadata": {"model_name": "langford", "source_code": "Model 1 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n                 (x[d,c+1] = x[d,c] + d + 1);\n\nsolve satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ if fix(x[d,c]) = p then show(d) ++ \" \" else \"\" endif\n          | p in POS, d in DIG, c in COPY ]\n       ;\n\n\n\nModel 2 : \n\n\n% Langford's number problem in MiniZinc.\n%\n% Arrange 2 sets of positive integers 1..k to a sequence,\n% such that, following the first occurence of an integer i,\n% each subsequent occurrence of i, appears i+1 indices later\n% than the last.\n% For example, for k=4, a solution would be 41312432\n\ninclude \"globals.mzn\";\n\nint: k;\nset of int: positionDomain = 1..2*k;\n\narray[positionDomain] of var positionDomain: position;\n% better presentation:\narray[positionDomain] of var 1..k: solution;\n\nsolve :: int_search(position, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..k) (\n     position[i+k] = position[i] + i+1 /\\\n     % hakank: added this\n     solution[position[i]] = i /\\ \n     solution[position[k+i]] = i\n  )\n  /\\   \n  all_different(position)\n  /\\ % symmetry breaking\n  solution[1] < solution[2*k]\n;\n\n\noutput [\n  show(solution), \"\\n\"\n\n];\n\n%\n% data\n%\nk = 4;\n% k = 7;\n% k = 8;\n% k = 10;\n% k = 20;\n\n\n\nModel 3 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"inverse.mzn\";\nconstraint inverse([x[d,c] | d in DIG, c in COPY], y);\n\n%include \"alldifferent.mzn\";\n%constraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n      (x[d,c+1] = x[d,c] + d + 1);\n\n%constraint forall(d in DIG, c in 1..m-1, p in POS)\n%                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve \n      %:: int_search(y, input_order, indomain_min, complete) \n      %:: int_search([x[d,c] | d in DIG, c in COPY], input_order, indomain_min, complete) \n      satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n\n\nModel 4 :\n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\nconstraint forall(d in DIG, c in 1..m-1, p in POS)\n                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve satisfy;\n\noutput [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "langford_beginner", "node_type": "4", "metadata": {"model_name": "langford", "source_code": "Model 1 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n                 (x[d,c+1] = x[d,c] + d + 1);\n\nsolve satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ if fix(x[d,c]) = p then show(d) ++ \" \" else \"\" endif\n          | p in POS, d in DIG, c in COPY ]\n       ;\n\n\n\nModel 2 : \n\n\n% Langford's number problem in MiniZinc.\n%\n% Arrange 2 sets of positive integers 1..k to a sequence,\n% such that, following the first occurence of an integer i,\n% each subsequent occurrence of i, appears i+1 indices later\n% than the last.\n% For example, for k=4, a solution would be 41312432\n\ninclude \"globals.mzn\";\n\nint: k;\nset of int: positionDomain = 1..2*k;\n\narray[positionDomain] of var positionDomain: position;\n% better presentation:\narray[positionDomain] of var 1..k: solution;\n\nsolve :: int_search(position, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..k) (\n     position[i+k] = position[i] + i+1 /\\\n     % hakank: added this\n     solution[position[i]] = i /\\ \n     solution[position[k+i]] = i\n  )\n  /\\   \n  all_different(position)\n  /\\ % symmetry breaking\n  solution[1] < solution[2*k]\n;\n\n\noutput [\n  show(solution), \"\\n\"\n\n];\n\n%\n% data\n%\nk = 4;\n% k = 7;\n% k = 8;\n% k = 10;\n% k = 20;\n\n\n\nModel 3 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"inverse.mzn\";\nconstraint inverse([x[d,c] | d in DIG, c in COPY], y);\n\n%include \"alldifferent.mzn\";\n%constraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n      (x[d,c+1] = x[d,c] + d + 1);\n\n%constraint forall(d in DIG, c in 1..m-1, p in POS)\n%                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve \n      %:: int_search(y, input_order, indomain_min, complete) \n      %:: int_search([x[d,c] | d in DIG, c in COPY], input_order, indomain_min, complete) \n      satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n\n\nModel 4 :\n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\nconstraint forall(d in DIG, c in 1..m-1, p in POS)\n                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve satisfy;\n\noutput [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n"}, "hash": "9da6dc3c1bf3960cab58bd26162336b41460d5efc8d528d98f4e460e42590da4", "class_name": "RelatedNodeInfo"}}, "text": "Here is the explanation of the problem:\n\n**Name of the problem:** Langford's Problem\n\n**What the problem is about in everyday terms:** Imagine you have a set of numbers from 1 to n, and you want to arrange them in a sequence in a special way. Each number should appear m times in the sequence. The rule is that if a number k appears, the next time it appears, it should be k+1 positions later in the sequence.\n\n**Main variables and what they mean:**\n\n* n: the highest number in the set (e.g., if n=4, the set is {1, 2, 3, 4})\n* m: how many times each number should appear in the sequence\n* x (or y): the sequence of numbers, where each number is a position in the sequence\n\n**Basic restrictions or rules of the problem:**\n\n* Each number from 1 to n should appear m times in the sequence.\n* If a number k appears, the next time it appears, it should be k+1 positions later in the sequence.\n\n**Goal of the problem:** The goal is to find a sequence that satisfies the rules above.\n\nNote that the different models are just different ways of representing the same problem, and the explanation above applies to all of them.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1117, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e6cb2e7d-4506-4878-94c2-f6cfb05d664e": {"__data__": {"id_": "e6cb2e7d-4506-4878-94c2-f6cfb05d664e", "embedding": null, "metadata": {"model_name": "loan", "source_code": "% variables\nvar float: R;        % quarterly repayment\nvar float: P;        % principal initially borrowed\nvar 0.0 .. 10.0: I;  % interest rate\n\n% intermediate variables\nvar float: B1; % balance after one quarter\nvar float: B2; % balance after two quarters\nvar float: B3; % balance after three quarters\nvar float: B4; % balance owing at end\n\nconstraint B1 = P * (1.0 + I) - R;\nconstraint B2 = B1 * (1.0 + I) - R;\nconstraint B3 = B2 * (1.0 + I) - R; \nconstraint B4 = B3 * (1.0 + I) - R;\n\nsolve satisfy;\n\noutput [\n \"Borrowing \", show_float(0, 2, P), \" at \", show(I*100.0), \n \"% interest, and repaying \", show_float(0, 2, R), \n  \"\\nper quarter for 1 year leaves \", show_float(0, 2, B4), \" owing\\n\"\n];\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "loan_beginner", "node_type": "4", "metadata": {"model_name": "loan", "source_code": "% variables\nvar float: R;        % quarterly repayment\nvar float: P;        % principal initially borrowed\nvar 0.0 .. 10.0: I;  % interest rate\n\n% intermediate variables\nvar float: B1; % balance after one quarter\nvar float: B2; % balance after two quarters\nvar float: B3; % balance after three quarters\nvar float: B4; % balance owing at end\n\nconstraint B1 = P * (1.0 + I) - R;\nconstraint B2 = B1 * (1.0 + I) - R;\nconstraint B3 = B2 * (1.0 + I) - R; \nconstraint B4 = B3 * (1.0 + I) - R;\n\nsolve satisfy;\n\noutput [\n \"Borrowing \", show_float(0, 2, P), \" at \", show(I*100.0), \n \"% interest, and repaying \", show_float(0, 2, R), \n  \"\\nper quarter for 1 year leaves \", show_float(0, 2, B4), \" owing\\n\"\n];\n\n"}, "hash": "c1f114fda1a14446a301f3421b750ebb5d03994a7381dd39c64debe26b3a5fd2", "class_name": "RelatedNodeInfo"}}, "text": "Loan Repayment Problem\n\nThis problem is about borrowing money and paying it back with interest over a year.\n\nThe main variables are:\n- R: the amount of money you pay back each quarter (like a monthly payment, but every 3 months)\n- P: the amount of money you borrow initially\n- I: the interest rate, which is like a fee for borrowing money\n- B1, B2, B3, B4: these are like snapshots of how much you still owe after each quarter\n\nThe basic rules are:\n- You borrow some money (P) and promise to pay it back with some extra (I) as interest.\n- Each quarter, you pay back some money (R), and the amount you still owe changes based on the interest rate.\n\nThe goal of the problem is to find a way to pay back the loan over a year, with the given interest rate, and see how much you still owe at the end.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 795, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2817319e-ed8b-4ef4-8b8b-8e22fa7b82f1": {"__data__": {"id_": "2817319e-ed8b-4ef4-8b8b-8e22fa7b82f1", "embedding": null, "metadata": {"model_name": "ltsp", "source_code": "int: n; % number of cities\nset of int: CITY = 1..n;\nset of int: POS = 1..n;\narray[CITY] of int: coord; % coordinate of city \nint: m; % number of precedences\nset of int: PREC = 1..m;\narray[PREC] of CITY: left;\narray[PREC] of CITY: right;\n\narray[CITY] of var POS: order;\narray[POS] of var CITY: city;\n\ninclude \"inverse.mzn\";\nconstraint inverse(order,city);\n\nconstraint forall(i in PREC)(order[left[i]] < order[right[i]]);\n\nsolve minimize sum(i in 1..n-1)(abs(coord[city[i]] - coord[city[i+1]]));\n\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ltsp_beginner", "node_type": "4", "metadata": {"model_name": "ltsp", "source_code": "int: n; % number of cities\nset of int: CITY = 1..n;\nset of int: POS = 1..n;\narray[CITY] of int: coord; % coordinate of city \nint: m; % number of precedences\nset of int: PREC = 1..m;\narray[PREC] of CITY: left;\narray[PREC] of CITY: right;\n\narray[CITY] of var POS: order;\narray[POS] of var CITY: city;\n\ninclude \"inverse.mzn\";\nconstraint inverse(order,city);\n\nconstraint forall(i in PREC)(order[left[i]] < order[right[i]]);\n\nsolve minimize sum(i in 1..n-1)(abs(coord[city[i]] - coord[city[i+1]]));\n\n\n"}, "hash": "0d603ed5111e378bdedc3b4418351933dc0256722bc8e4c96c796ff535083580", "class_name": "RelatedNodeInfo"}}, "text": "**Traveling Salesman Problem**\n\nThis problem is about planning a route for a salesman who needs to visit a certain number of cities and return to the starting point.\n\n**Main variables:**\n\n* `n`: the number of cities\n* `coord`: the coordinates of each city (think of it like the address of each city)\n* `order`: the order in which the salesman visits each city\n* `city`: the city at each position in the order\n\n**Basic restrictions or rules:**\n\n* The salesman must visit each city exactly once\n* The salesman must follow the precedences (rules) that specify which city must be visited before another city\n* The salesman must return to the starting point at the end of the route\n\n**Goal:**\n\nThe goal is to find the shortest possible route that visits all cities and returns to the starting point, while following the precedences and rules. In other words, we want to minimize the total distance traveled by the salesman.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 918, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7d40cf11-47f6-49c2-b647-c2fd7af4debb": {"__data__": {"id_": "7d40cf11-47f6-49c2-b647-c2fd7af4debb", "embedding": null, "metadata": {"model_name": "magic_hexagon", "source_code": "% Magic Hexagon in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nset of int: N = 1..19;\nvar N: a;\nvar N: b;\nvar N: c;\nvar N: d;\nvar N: e;\nvar N: f;\nvar N: g;\nvar N: h;\nvar N: i;\nvar N: j;\nvar N: k;\nvar N: l;\nvar N: m;\nvar N: n;\nvar N: o;\nvar N: p;\nvar N: q;\nvar N: r;\nvar N: s;\n\narray[N] of var N: LD = [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s];\n\nsolve satisfy;\n\nconstraint\n  all_different(LD) /\\\n\n  a + b + c =  38 /\\\n  d + e + f + g =  38 /\\\n  h + i + j + k + l =  38 /\\ \n  m + n + o + p =  38 /\\ \n  q + r + s =  38 /\\ \n  a + d + h =  38 /\\ \n  b + e + i + m =  38 /\\ \n  c + f + j + n + q =  38 /\\ \n  g + k + o + r =  38 /\\ \n  l + p + s =  38 /\\ \n  c + g + l =  38 /\\ \n  b + f + k + p =  38 /\\ \n  a + e + j + o + s =  38 /\\ \n  d + i + n + r =  38 /\\ \n  h + m + q =  38 /\\ \n\n  a < c /\\\n  a < h /\\\n  a < l /\\\n  a < q /\\\n  a < s /\\\n  c < h\n;\n\noutput\n[\n  show(LD)\n];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_hexagon_beginner", "node_type": "4", "metadata": {"model_name": "magic_hexagon", "source_code": "% Magic Hexagon in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nset of int: N = 1..19;\nvar N: a;\nvar N: b;\nvar N: c;\nvar N: d;\nvar N: e;\nvar N: f;\nvar N: g;\nvar N: h;\nvar N: i;\nvar N: j;\nvar N: k;\nvar N: l;\nvar N: m;\nvar N: n;\nvar N: o;\nvar N: p;\nvar N: q;\nvar N: r;\nvar N: s;\n\narray[N] of var N: LD = [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s];\n\nsolve satisfy;\n\nconstraint\n  all_different(LD) /\\\n\n  a + b + c =  38 /\\\n  d + e + f + g =  38 /\\\n  h + i + j + k + l =  38 /\\ \n  m + n + o + p =  38 /\\ \n  q + r + s =  38 /\\ \n  a + d + h =  38 /\\ \n  b + e + i + m =  38 /\\ \n  c + f + j + n + q =  38 /\\ \n  g + k + o + r =  38 /\\ \n  l + p + s =  38 /\\ \n  c + g + l =  38 /\\ \n  b + f + k + p =  38 /\\ \n  a + e + j + o + s =  38 /\\ \n  d + i + n + r =  38 /\\ \n  h + m + q =  38 /\\ \n\n  a < c /\\\n  a < h /\\\n  a < l /\\\n  a < q /\\\n  a < s /\\\n  c < h\n;\n\noutput\n[\n  show(LD)\n];"}, "hash": "c1cbee22a631590b7384caf8089f6123e4115589b60fddb467bdf01ad6e43f5e", "class_name": "RelatedNodeInfo"}}, "text": "Magic Hexagon\n\nThis problem is about creating a special kind of hexagon (a six-sided shape) with numbers inside it. Imagine a hexagon divided into smaller triangles, and each triangle has a number in it.\n\nThe main variables are the numbers that go inside the triangles. There are 19 numbers in total, and they are represented by letters like a, b, c, and so on.\n\nThe basic rules of the problem are:\n\n* Each triangle must have a different number in it.\n* The numbers in each row of triangles must add up to 38.\n* The numbers in each column of triangles must also add up to 38.\n* Some specific triangles have to have smaller numbers than others.\n\nThe goal of the problem is to find a way to arrange the numbers in the triangles so that all the rules are followed.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 761, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "60f5d665-46de-4b90-8714-407a12527d7d": {"__data__": {"id_": "60f5d665-46de-4b90-8714-407a12527d7d", "embedding": null, "metadata": {"model_name": "magic_sequence", "source_code": "Model 1 :\n\n% Magic sequence in MiniZinc.\n% A magic sequence of length n is a sequence of integers x0 . . xn-1 between 0 and n-1, such that for all i in 0 to n-1, the number i occurs exactly xi times in the sequence. For instance, 6,2,1,0,0,0,1,0,0,0 is a magic sequence since 0 occurs 6 times in it, 1 occurs twice, ...\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n  forall(i in 0..n-1) (\n    s[i] = sum(j in 0..n-1) (bool2int(s[j] = i))\n  )\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 2 : \n\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n        forall(i in 0..n-1) (\n                s[i] = sum(j in 0..n-1) (bool2int(s[j]=i))\n        )\n        /\\ \n        sum(i in 0..n-1) (s[i])=n \n        /\\\n        sum(i in 0..n-1) (s[i]*i) =n\n;\n\n\noutput [\n       show(s), \"\\n\",\n];\n\n\n\nModel 3 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  10;\narray[0..n-1] of var 0..n-1: s;\narray[0..n-1] of int: value = array1d(0..n-1, [i | i in 0..n-1]); % helper for distribute\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   distribute(s, value, s)         /\\ \n   sum(i in 0..n-1) (s[i])   = n   /\\\n   sum(i in 0..n-1) (s[i]*i) = n\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 4 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  100;\narray[0..n-1] of var 0..n-1: s;\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   global_cardinality(s,array1d(0..n-1, set2array(index_set(s))), s) :: domain\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\nModel 5 : \n\n\n% Magic squares in MiniZinc\n\ninclude \"globals.mzn\";\n\nint: n = 3;\n\nint: total = ( n * (n*n + 1)) div 2;\narray[1..n,1..n] of var 1..n*n: magic;\n\n\n% solve satisfy;\nsolve :: int_search(\n        [magic[i,j] | i in 1..n, j in 1..n], \n        first_fail,\n        indomain_min,\n        complete) \n    satisfy;\n\n\nconstraint\n\n        all_different([magic[i,j] | i in 1..n, j in 1..n]) :: domain\n        /\\\n        forall(k in 1..n) (\n           sum(i in 1..n) (magic[k,i]) = total % :: domain\n           /\\\n           sum(i in 1..n) (magic[i,k]) = total %:: domain\n        )\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,i]) = total  %:: domain\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,n-i+1]) = total %:: domain\n;\n\n% symmetry breaking\n% Activating all these constraints we get the\n% \"standard\" way of counting the number of solutions:\n%    1, 0, 1, 880, 275305224\n% i.e. this sequence: http://oeis.org/A006052\n%\n% Without the constraints the number of solutions are:\n%  N  #solutions\n%  -------------\n%  1     1\n%  2     0\n%  3     8\n%  4  7040\n%  5  many... \n%\n% constraint\n%    magic[1,1] < magic[1,n]\n%    /\\ magic[1,n] < magic[n,1]\n%    /\\ magic[1,1] < magic[n,n]\n% ;\n\n\noutput [\n  \"Total: \" ++ show(total) ++ \"\\n\"\n] ++\n[\n    %   show(magic)\n  if j = 1 then \"\\n\" else \"\" endif ++\n    if fix(magic[i,j]) < 10 then \" \" else \"\" endif ++\n    show(magic[i,j]) ++ \" \"\n  | i,j in 1..n\n] \n++ \n[\"\\n\"];\n\n\nModel 6 : \n\n\n% Magic square integer programming version in MiniZinc.\n% In recreational mathematics, a magic square of order n is an\n% arrangement of n^2 numbers, usually distinct integers, in a square,\n% such that n numbers in all rows, all columns, and both diagonals sum\n% to the same constant. A normal magic square contains the integers\n% from 1 to n^2.\n\n\n% square order\nint: n = 3; \n\n% integers to be placed\nset of 1..n*n: N = 1..n*n;\n\n% x[i,j,k] = 1 means that cell (i,j) contains integer k\narray[1..n, 1..n, N] of var 0..1: x;\n\narray[1..n, 1..n] of var 1..n*n: square;\n\nvar int: s; % the magic sum\n\nsolve :: int_search(\n        [x[i,j,k] | i,j in 1..n, k in N] ++ \n        [square[i,j] | i,j in 1..n] ++\n        [s],\n        first_fail,\n        indomain_min, \n        complete % \"credit(640, bbs(5))\" % \"complete\"\n      ) \n    satisfy;\n\nconstraint \n  s >= 0 \n  /\\\n  s <= n*n*n\n  /\\\n  % each cell must be assigned exactly one integer\n  forall(i in 1..n, j in 1..n) (\n     sum(k in N) (x[i,j,k]) = 1\n  )\n  /\\\n  % each integer must be assigned exactly to one cell\n  forall(k in N) (\n     sum(i in 1..n, j in 1..n) (x[i,j,k]) = 1\n  )\n\n  /\\\n  % the sum in each row must be the magic sum \n  forall(i in 1..n) (\n     sum(j in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in each column must be the magic sum\n  forall(j in 1..n) (\n     sum(i in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in the diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,i,k]) = s\n\n  /\\\n  % the sum in the co-diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,n-i+1,k]) = s\n\n  /\\\n  % for output\n  forall(i,j in 1..n) ( square[i,j] = sum(k in N) (k * x[i,j,k]))\n;\n\n\noutput [ \n   \"\\ns: \", show(s)\n] ++\n[\n  if  j = 1 then \"\\n\" else \" \" endif ++\n    show(square[i,j]) \n  | i,j in 1..n\n\n] ++ [\"\\n\"];\n\n% printf \"\\n\";\n% printf \"Magic sum is %d\\n\", s;\n% printf \"\\n\";\n% for{i in 1..n}\n% {  printf{j in 1..n} \"%3d\", sum{k in N} k * x[i,j,k];\n%    printf \"\\n\";\n% }\n% printf \"\\n\";"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_sequence_beginner", "node_type": "4", "metadata": {"model_name": "magic_sequence", "source_code": "Model 1 :\n\n% Magic sequence in MiniZinc.\n% A magic sequence of length n is a sequence of integers x0 . . xn-1 between 0 and n-1, such that for all i in 0 to n-1, the number i occurs exactly xi times in the sequence. For instance, 6,2,1,0,0,0,1,0,0,0 is a magic sequence since 0 occurs 6 times in it, 1 occurs twice, ...\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n  forall(i in 0..n-1) (\n    s[i] = sum(j in 0..n-1) (bool2int(s[j] = i))\n  )\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 2 : \n\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n        forall(i in 0..n-1) (\n                s[i] = sum(j in 0..n-1) (bool2int(s[j]=i))\n        )\n        /\\ \n        sum(i in 0..n-1) (s[i])=n \n        /\\\n        sum(i in 0..n-1) (s[i]*i) =n\n;\n\n\noutput [\n       show(s), \"\\n\",\n];\n\n\n\nModel 3 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  10;\narray[0..n-1] of var 0..n-1: s;\narray[0..n-1] of int: value = array1d(0..n-1, [i | i in 0..n-1]); % helper for distribute\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   distribute(s, value, s)         /\\ \n   sum(i in 0..n-1) (s[i])   = n   /\\\n   sum(i in 0..n-1) (s[i]*i) = n\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 4 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  100;\narray[0..n-1] of var 0..n-1: s;\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   global_cardinality(s,array1d(0..n-1, set2array(index_set(s))), s) :: domain\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\nModel 5 : \n\n\n% Magic squares in MiniZinc\n\ninclude \"globals.mzn\";\n\nint: n = 3;\n\nint: total = ( n * (n*n + 1)) div 2;\narray[1..n,1..n] of var 1..n*n: magic;\n\n\n% solve satisfy;\nsolve :: int_search(\n        [magic[i,j] | i in 1..n, j in 1..n], \n        first_fail,\n        indomain_min,\n        complete) \n    satisfy;\n\n\nconstraint\n\n        all_different([magic[i,j] | i in 1..n, j in 1..n]) :: domain\n        /\\\n        forall(k in 1..n) (\n           sum(i in 1..n) (magic[k,i]) = total % :: domain\n           /\\\n           sum(i in 1..n) (magic[i,k]) = total %:: domain\n        )\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,i]) = total  %:: domain\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,n-i+1]) = total %:: domain\n;\n\n% symmetry breaking\n% Activating all these constraints we get the\n% \"standard\" way of counting the number of solutions:\n%    1, 0, 1, 880, 275305224\n% i.e. this sequence: http://oeis.org/A006052\n%\n% Without the constraints the number of solutions are:\n%  N  #solutions\n%  -------------\n%  1     1\n%  2     0\n%  3     8\n%  4  7040\n%  5  many... \n%\n% constraint\n%    magic[1,1] < magic[1,n]\n%    /\\ magic[1,n] < magic[n,1]\n%    /\\ magic[1,1] < magic[n,n]\n% ;\n\n\noutput [\n  \"Total: \" ++ show(total) ++ \"\\n\"\n] ++\n[\n    %   show(magic)\n  if j = 1 then \"\\n\" else \"\" endif ++\n    if fix(magic[i,j]) < 10 then \" \" else \"\" endif ++\n    show(magic[i,j]) ++ \" \"\n  | i,j in 1..n\n] \n++ \n[\"\\n\"];\n\n\nModel 6 : \n\n\n% Magic square integer programming version in MiniZinc.\n% In recreational mathematics, a magic square of order n is an\n% arrangement of n^2 numbers, usually distinct integers, in a square,\n% such that n numbers in all rows, all columns, and both diagonals sum\n% to the same constant. A normal magic square contains the integers\n% from 1 to n^2.\n\n\n% square order\nint: n = 3; \n\n% integers to be placed\nset of 1..n*n: N = 1..n*n;\n\n% x[i,j,k] = 1 means that cell (i,j) contains integer k\narray[1..n, 1..n, N] of var 0..1: x;\n\narray[1..n, 1..n] of var 1..n*n: square;\n\nvar int: s; % the magic sum\n\nsolve :: int_search(\n        [x[i,j,k] | i,j in 1..n, k in N] ++ \n        [square[i,j] | i,j in 1..n] ++\n        [s],\n        first_fail,\n        indomain_min, \n        complete % \"credit(640, bbs(5))\" % \"complete\"\n      ) \n    satisfy;\n\nconstraint \n  s >= 0 \n  /\\\n  s <= n*n*n\n  /\\\n  % each cell must be assigned exactly one integer\n  forall(i in 1..n, j in 1..n) (\n     sum(k in N) (x[i,j,k]) = 1\n  )\n  /\\\n  % each integer must be assigned exactly to one cell\n  forall(k in N) (\n     sum(i in 1..n, j in 1..n) (x[i,j,k]) = 1\n  )\n\n  /\\\n  % the sum in each row must be the magic sum \n  forall(i in 1..n) (\n     sum(j in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in each column must be the magic sum\n  forall(j in 1..n) (\n     sum(i in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in the diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,i,k]) = s\n\n  /\\\n  % the sum in the co-diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,n-i+1,k]) = s\n\n  /\\\n  % for output\n  forall(i,j in 1..n) ( square[i,j] = sum(k in N) (k * x[i,j,k]))\n;\n\n\noutput [ \n   \"\\ns: \", show(s)\n] ++\n[\n  if  j = 1 then \"\\n\" else \" \" endif ++\n    show(square[i,j]) \n  | i,j in 1..n\n\n] ++ [\"\\n\"];\n\n% printf \"\\n\";\n% printf \"Magic sum is %d\\n\", s;\n% printf \"\\n\";\n% for{i in 1..n}\n% {  printf{j in 1..n} \"%3d\", sum{k in N} k * x[i,j,k];\n%    printf \"\\n\";\n% }\n% printf \"\\n\";"}, "hash": "502c664e9fb9da7f4779030520fbdbb370797cfcb1e1f2c343e6e7c2e56ca202", "class_name": "RelatedNodeInfo"}}, "text": "Here is the explanation of the problem:\n\n**Name of the problem:** Magic Sequence and Magic Square\n\n**What the problem is about in everyday terms:** This problem is about finding a special kind of sequence or arrangement of numbers that has certain properties. In the case of the magic sequence, it's a sequence of numbers where each number appears a certain number of times, and that number is equal to the value of the number itself. For example, if the sequence has a 6, it means the number 6 appears 6 times in the sequence. In the case of the magic square, it's an arrangement of numbers in a square grid where each row, column, and diagonal adds up to the same total.\n\n**Main variables and what they mean:**\n\n* `s` or `magic`: an array of variables that represent the magic sequence or square.\n* `n`: the length of the sequence or the size of the square.\n* `total`: the total sum of the numbers in the magic square.\n\n**Basic restrictions or rules of the problem:**\n\n* In the magic sequence, each number appears a certain number of times, and that number is equal to the value of the number itself.\n* In the magic square, each row, column, and diagonal adds up to the same total.\n* Each cell in the magic square can only contain one number.\n\n**Goal of the problem:**\n\n* Find a magic sequence or square that satisfies the rules and restrictions.\n* In some cases, the goal is to find all possible solutions or to count the number of solutions.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1445, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d42b6f50-f418-4478-abd5-c54634fda33d": {"__data__": {"id_": "d42b6f50-f418-4478-abd5-c54634fda33d", "embedding": null, "metadata": {"model_name": "maximum_density_still_life", "source_code": "% Maximum density still life in MiniZinc.\n\n% include \"globals.mzn\"; \nint: size = 7; % to change\n\nset of int: objFunctionBoardCoord      = 2..size+1;\nset of int: checkConstraintsBoardCoord = 1..size+2;\nset of int: augmentedBoardCoord        = 0..size+3;\n\n% Search space: The set of all possible assignments of 0s (dead) and 1s (live) \n% to the cells of the board section. However, to be able to easily express \n% constraints on \"boundary\" cells, we take as search space the set of 0/1 \n% boards of size n+4 by n+4: the actual stable pattern appears in the sub-board \n% defined by ignoring the first/last two rows/columns.\narray[augmentedBoardCoord,augmentedBoardCoord] of var 0..1: grid;\n\nvar int: z = sum(r in objFunctionBoardCoord, c in objFunctionBoardCoord) (grid[r,c]);\n\n% Objective function: Maximize the number of live cells in the sub-board defined \n% by ignoring the first/last two/ rows/columns.\n\n\n% solve maximize z;\nsolve :: int_search(\n        [grid[i,j] | i,j in augmentedBoardCoord], \n        smallest, \n        indomain_max, \n        complete) \n    maximize z;\n\nconstraint\n\n  % C1: Cells in the first/last two rows/columns are all 0 (dead)\n  forall(x in augmentedBoardCoord) (\n    grid[0,x] = 0 /\\\n    grid[1,x] = 0 /\\\n    grid[size+2,x] = 0 /\\  \n    grid[size+3,x] = 0 /\\\n    grid[x,0] == 0 /\\       \n    grid[x,1] == 0 /\\\n    grid[x,size+2] = 0 /\\  \n    grid[x,size+3] = 0 \n  )\n  /\\\n  forall(r in checkConstraintsBoardCoord,c in checkConstraintsBoardCoord) (\n    % C2: Each cell of the board (except those of the first/last row/column) \n    %     that has exactly three live neighbors is alive. \n    %     Together with constraint C1, this implies that cells in the\n    %     second/last-but-one row/column cannot have three live neighbors.\n    (\n      ( ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] + \n          grid[r,c-1] + grid[r,c+1] + \n          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1]\n          ) = 3 \n       ) -> (grid[r,c] = 1)\n    )\n    /\\    \n\n    % C3: Each live cell must have 2 or 3 live neighbors (cells of the first/last \n    % row/column may be ignored by this constraint)\n    (\n       (grid[r,c] = 1) -> \n                      (\n                        2 <= \n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          )\n                        /\\\n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          ) <= 3\n                      )\n    )\n  )\n  \n  /\\\n  % SBSO: Symmetry-breaking by selective ordering\n  % The assignment is forced to respect an ordering on the values that occur in corner entries\n  % of the board. In particular:  \n  % - if the NW-corner cell is dead, the SE-corner cell\n  % must be dead too \n  % - if the NE-corner cell is dead, the SW-corner cell must be dead too\n  % \n  grid[2,2] >= grid[size+1,size+1] /\\\n  grid[2,size+1] >= grid[size+1,2]\n;\n\n\noutput [\n  if j = 0 then \"\\n\" else \" \" endif ++\n    show(grid[i,j])\n  | i,j in augmentedBoardCoord\n];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "maximum_density_still_life_beginner", "node_type": "4", "metadata": {"model_name": "maximum_density_still_life", "source_code": "% Maximum density still life in MiniZinc.\n\n% include \"globals.mzn\"; \nint: size = 7; % to change\n\nset of int: objFunctionBoardCoord      = 2..size+1;\nset of int: checkConstraintsBoardCoord = 1..size+2;\nset of int: augmentedBoardCoord        = 0..size+3;\n\n% Search space: The set of all possible assignments of 0s (dead) and 1s (live) \n% to the cells of the board section. However, to be able to easily express \n% constraints on \"boundary\" cells, we take as search space the set of 0/1 \n% boards of size n+4 by n+4: the actual stable pattern appears in the sub-board \n% defined by ignoring the first/last two rows/columns.\narray[augmentedBoardCoord,augmentedBoardCoord] of var 0..1: grid;\n\nvar int: z = sum(r in objFunctionBoardCoord, c in objFunctionBoardCoord) (grid[r,c]);\n\n% Objective function: Maximize the number of live cells in the sub-board defined \n% by ignoring the first/last two/ rows/columns.\n\n\n% solve maximize z;\nsolve :: int_search(\n        [grid[i,j] | i,j in augmentedBoardCoord], \n        smallest, \n        indomain_max, \n        complete) \n    maximize z;\n\nconstraint\n\n  % C1: Cells in the first/last two rows/columns are all 0 (dead)\n  forall(x in augmentedBoardCoord) (\n    grid[0,x] = 0 /\\\n    grid[1,x] = 0 /\\\n    grid[size+2,x] = 0 /\\  \n    grid[size+3,x] = 0 /\\\n    grid[x,0] == 0 /\\       \n    grid[x,1] == 0 /\\\n    grid[x,size+2] = 0 /\\  \n    grid[x,size+3] = 0 \n  )\n  /\\\n  forall(r in checkConstraintsBoardCoord,c in checkConstraintsBoardCoord) (\n    % C2: Each cell of the board (except those of the first/last row/column) \n    %     that has exactly three live neighbors is alive. \n    %     Together with constraint C1, this implies that cells in the\n    %     second/last-but-one row/column cannot have three live neighbors.\n    (\n      ( ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] + \n          grid[r,c-1] + grid[r,c+1] + \n          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1]\n          ) = 3 \n       ) -> (grid[r,c] = 1)\n    )\n    /\\    \n\n    % C3: Each live cell must have 2 or 3 live neighbors (cells of the first/last \n    % row/column may be ignored by this constraint)\n    (\n       (grid[r,c] = 1) -> \n                      (\n                        2 <= \n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          )\n                        /\\\n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          ) <= 3\n                      )\n    )\n  )\n  \n  /\\\n  % SBSO: Symmetry-breaking by selective ordering\n  % The assignment is forced to respect an ordering on the values that occur in corner entries\n  % of the board. In particular:  \n  % - if the NW-corner cell is dead, the SE-corner cell\n  % must be dead too \n  % - if the NE-corner cell is dead, the SW-corner cell must be dead too\n  % \n  grid[2,2] >= grid[size+1,size+1] /\\\n  grid[2,size+1] >= grid[size+1,2]\n;\n\n\noutput [\n  if j = 0 then \"\\n\" else \" \" endif ++\n    show(grid[i,j])\n  | i,j in augmentedBoardCoord\n];\n"}, "hash": "c5e27d279fad8afc4b04415eb83034f8645fcc2f252cf633b265e20cb277cf52", "class_name": "RelatedNodeInfo"}}, "text": "**Problem Name:** Maximum Density Still Life\n\n**What the problem is about:** Imagine you have a grid of cells that can be either alive (represented by 1) or dead (represented by 0). The goal is to find a pattern of alive and dead cells that follows certain rules and has the maximum number of alive cells.\n\n**Main variables:**\n\n* `grid`: a 2D array that represents the grid of cells, where each cell can be either alive (1) or dead (0).\n* `z`: the total number of alive cells in the grid.\n\n**Basic restrictions or rules:**\n\n* Cells in the outermost rows and columns of the grid must be dead.\n* A cell becomes alive if it has exactly three alive neighbors.\n* An alive cell must have either two or three alive neighbors to stay alive.\n* The pattern of alive and dead cells must be symmetrical in certain ways.\n\n**Goal:** The goal is to maximize the number of alive cells (`z`) in the grid while following the rules above.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 919, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8fa562d4-da85-4869-95c4-32cc80cd9d5a": {"__data__": {"id_": "8fa562d4-da85-4869-95c4-32cc80cd9d5a", "embedding": null, "metadata": {"model_name": "mip", "source_code": "Model 1 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.0*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 2 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\n\nsolve maximize 1.0*B - 1.0*C + 1.0*D;\nconstraint 2.0*B - 1.0*C + 2.0*D <=  4.0;\nconstraint 2.0*B - 3.0*C + 1.0*D <= -5.0;\nconstraint -1.0*B + 1.0*C - 2.0*D <= -1.0;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 3 :\n\n\nvar int: B;\nvar int: C;\nvar int: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.5*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 4 :\n\n\nsolve maximize 21*x + 11*y;\n\nvar int: x;\nvar int: y;\nconstraint 7*x + 4*y <= 13;\nconstraint x >= 0 /\\ y >= 0; \n\n\n\nModel 5 : \n\n\nsolve maximize 8*x + 5*y;\n\nvar int: x;\nvar int: y;\nconstraint x + y <= 6;\nconstraint 9*x + 5*y <= 45;\nconstraint x >= 0 /\\ y >= 0; \n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "mip_beginner", "node_type": "4", "metadata": {"model_name": "mip", "source_code": "Model 1 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.0*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 2 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\n\nsolve maximize 1.0*B - 1.0*C + 1.0*D;\nconstraint 2.0*B - 1.0*C + 2.0*D <=  4.0;\nconstraint 2.0*B - 3.0*C + 1.0*D <= -5.0;\nconstraint -1.0*B + 1.0*C - 2.0*D <= -1.0;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 3 :\n\n\nvar int: B;\nvar int: C;\nvar int: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.5*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 4 :\n\n\nsolve maximize 21*x + 11*y;\n\nvar int: x;\nvar int: y;\nconstraint 7*x + 4*y <= 13;\nconstraint x >= 0 /\\ y >= 0; \n\n\n\nModel 5 : \n\n\nsolve maximize 8*x + 5*y;\n\nvar int: x;\nvar int: y;\nconstraint x + y <= 6;\nconstraint 9*x + 5*y <= 45;\nconstraint x >= 0 /\\ y >= 0; \n"}, "hash": "4b57bb253bc2d29ec4acf061e122a44b43c02296ed8d334572863cdc1cb4c87d", "class_name": "RelatedNodeInfo"}}, "text": "**Problem Name:** Resource Allocation Problem\n\n**What the problem is about in everyday terms:** Imagine you have three types of resources (let's call them B, C, and D) and you want to allocate them in the best way possible to maximize your profit or benefit. You have some limitations on how much of each resource you can use, and you want to find the optimal combination that gives you the highest return.\n\n**Main variables and what they mean:**\n\n* B, C, and D: These are the three types of resources you have. They can be thought of as quantities of something (e.g., money, materials, labor).\n* x and y: In some models, these are used instead of B and C, but they represent the same idea - quantities of resources.\n\n**Basic restrictions or rules of the problem:**\n\n* You can't use more resources than you have available (represented by the \"less than or equal to\" constraints).\n* You can't use a negative amount of resources (represented by the \"greater than or equal to 0\" constraints).\n\n**Goal of the problem:**\n\n* Maximize the total benefit or profit you get from allocating the resources. This is represented by the \"maximize\" objective function, which combines the resources in a specific way to give you a total value.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1226, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "662d0e48-d42a-4ca1-bafe-8e3bf7d12aef": {"__data__": {"id_": "662d0e48-d42a-4ca1-bafe-8e3bf7d12aef", "embedding": null, "metadata": {"model_name": "missing_solution", "source_code": "% Missing Solutions\nint: n; % no of people\nset of int: PERSON = 1..n;\nint: male = 1; int: female = 2;\nset of int: GENDER = male..female;\narray[PERSON] of GENDER: gender;\narray[PERSON] of int: age;\n\narray[1..n] of var PERSON: order;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(order);\n\n% males and females alternate\nconstraint forall(i in 1..n)\n                 (i mod 2 = 0 <-> gender[order[i]] = female);\n\n% age does not grow bu more than 10\nconstraint forall(i in 1..n-1)\n                 (age[order[i+1]] - age[order[i]] <= 10);\n\nsolve satisfy;\n\noutput [ show(order), \"\\n\"] ++\n       [\"[\"] ++ [ show(age[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                | i in 1..n ] ++\n       [\"[\"] ++ [ show(gender[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                 | i in 1..n ];\n\n\n%n = 6;\n%gender = [male,male,male,female,female,female];\n%age = [13, 25, 34, 40, 16, 13];\n\nn = 5;\ngender = [male,male,female,female,female];\nage = [13,25,34,40,16];\n\n%order = [4,2,3,1,5];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "missing_solution_beginner", "node_type": "4", "metadata": {"model_name": "missing_solution", "source_code": "% Missing Solutions\nint: n; % no of people\nset of int: PERSON = 1..n;\nint: male = 1; int: female = 2;\nset of int: GENDER = male..female;\narray[PERSON] of GENDER: gender;\narray[PERSON] of int: age;\n\narray[1..n] of var PERSON: order;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(order);\n\n% males and females alternate\nconstraint forall(i in 1..n)\n                 (i mod 2 = 0 <-> gender[order[i]] = female);\n\n% age does not grow bu more than 10\nconstraint forall(i in 1..n-1)\n                 (age[order[i+1]] - age[order[i]] <= 10);\n\nsolve satisfy;\n\noutput [ show(order), \"\\n\"] ++\n       [\"[\"] ++ [ show(age[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                | i in 1..n ] ++\n       [\"[\"] ++ [ show(gender[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                 | i in 1..n ];\n\n\n%n = 6;\n%gender = [male,male,male,female,female,female];\n%age = [13, 25, 34, 40, 16, 13];\n\nn = 5;\ngender = [male,male,female,female,female];\nage = [13,25,34,40,16];\n\n%order = [4,2,3,1,5];\n"}, "hash": "c5d7b719366231e4f0c29c4bf35b8d6c6cabec273e0f65604f4f4b410d8f97f6", "class_name": "RelatedNodeInfo"}}, "text": "**Seating Arrangement Problem**\n\nThis problem is about arranging people in a line, like in a queue or at a table, in a specific order.\n\n**Main Variables:**\n\n* `n`: The number of people.\n* `gender`: An array that stores the gender of each person (male or female).\n* `age`: An array that stores the age of each person.\n* `order`: An array that stores the order in which the people should be arranged.\n\n**Basic Restrictions or Rules:**\n\n* The people should be arranged in a line, one after the other.\n* Males and females should alternate in the line (i.e., a male should be followed by a female, and vice versa).\n* The age difference between two people sitting next to each other should not be more than 10 years.\n\n**Goal:**\n\nThe goal is to find an arrangement of people that satisfies all the above rules. There is no specific goal to minimize or maximize anything; we just want to find a valid arrangement.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 905, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ab33d604-8159-4123-8f4e-6438492dfbab": {"__data__": {"id_": "ab33d604-8159-4123-8f4e-6438492dfbab", "embedding": null, "metadata": {"model_name": "nonogram_create_automaton2", "source_code": "Model 1 :\n\n% Nonoram solver using regular and is written in all-MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: rows;\nint: row_rule_len;\narray[1..rows, 1..row_rule_len] of int: row_rules;\nint: cols;\nint: col_rule_len;\narray[1..cols, 1..col_rule_len] of int: col_rules;\n\n\narray[1..rows, 1..cols] of var 1..2: x;\n\nsolve :: int_search(\n     [x[i,j] | j in 1..cols, i in 1..rows], \n     first_fail, \n     indomain_min, \n     complete) \nsatisfy;\n\n%\n% The approach is rather simple:\n%  - zero_positions is a set of the positions in the state table where the \n%    state 0 should be, which also correspond to the state of the pattern \"0\"\n%  - when this have been identified everything else comes to rest\n%\n% On the other hand, the calculation of the states is hairy, very hairy.\n%\npredicate make_automaton(array[int] of var int: x, array[int] of int: pattern) =\n    let {\n        int: n = length(pattern),\n        % fix for \"zero clues\"\n        int: len = max(length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern),1),\n        int: leading_zeros = sum(i in 1..n) (bool2int(pattern[i] = 0)),\n        set of int: zero_positions = {sum(j in 1..i) (pattern[j]+1) -leading_zeros | i in 1..n where pattern[i] > 0},\n       array[1..2*len] of 0..len*2: states = \n     if (length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern)) = 0 then \n       [1,1]  % fix for \"zero clues\"\n     else \n    [1, 2] ++\n    [\n       if i div 2 in zero_positions then\n           if i mod 2 = 0 then\n            0\n           else\n            (i div 2) + 1\n           endif\n       elseif (i-1) div 2 in zero_positions then\n           if i mod 2 = 0 then\n            (i div 2)+1\n           else\n            (i div 2)+2\n           endif\n       else\n         if not( (((i-1) div 2) - 1) in zero_positions) then\n            if i mod 2 = 0 then\n               (i div 2) + 1\n            else \n              if (i div 2) + 1 in zero_positions then\n                  (i div 2) + 2\n              else \n                  0\n              endif\n            endif\n          else\n             if i mod 2 = 0 then\n                 (i div 2) + 1\n             else \n                if not((i div 2) + 1 in zero_positions) then\n                   0\n                else \n                   (i div 2) + 2 \n                endif\n             endif\n          endif\n       endif\n    | i in 3..2*(len-1)]\n    ++\n    [len, 0]\n    endif\n    } \n    in\n    regular(\n       x,\n       len, \n       2, \n       array2d(1..len, 1..2, states),\n       1, \n       {len}) % :: domain\n;\n\nconstraint\n\n      forall(j in 1..cols) (\n        make_automaton([x[i,j] | i in 1..rows], [col_rules[j,k] | k in 1..col_rule_len])\n      )\n      /\\\n      forall(i in 1..rows) (\n        make_automaton([x[i,j] | j in 1..cols], [row_rules[i,k] | k in 1..row_rule_len])\n      )\n\n;\n\noutput \n[\n  if j = 1 then \"\\n\" else \"\" endif ++\n     if fix(x[i,j]) = 1 then \" \" else \"#\" endif\n    \n  | i in 1..rows, j in 1..cols\n] \n++ \n[\n  \"\\n\"\n];\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\nint: X;\nint: Y;\n\nint: maxlen;\n\narray [1..Y,1..maxlen] of int: rows;\n\narray [1..X,1..maxlen] of int: cols;\n\narray[1..2, 1..2, 1..2] of 0..1: nonmul = \n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 1, 1,\n         1, 0, 0, 1]\n    );\n\narray[1..2, 1..2, 1..2] of 0..1: nonadd =\n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 0, 1,\n         1, 0, 0, 1]\n    );\n\n% variables\n%\narray[1..Y, 1..X] of var 1..2: A;\n\n% All variables in a region must be different\n% Ordering to ensure each variable is handled exactly once\npredicate nonogram_row(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: row) =\n    nonogram([A[row, v] | v in 1..X], cons);\n\npredicate nonogram_col(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: col) = \n    nonogram([A[v,col] | v in 1..Y], cons);\n\npredicate nonogram(array[int] of var 1..2: A, array [int] of int: cons) = \n    let {\n          int: n = if cons[1] = 0 then 0 else max(index_set(cons)) endif,\n          array [1..n + 1, 1..2] of int: consarr =\n              if cons[1] = 0 then [|1, 0|] \n              else array2d(1..n + 1, 1..2,\n                [1, 2] ++\n                [    i * nonmul[cons[i - 1] + 1, cons[i] + 1, s] + \n                     nonadd[cons[i - 1] + 1, cons[i] + 1, s] \n                     | i in 2..n, s in 1..2 \n                ] ++ \n                [n+1,0]\n              )\n              endif\n     } in (\n         regular(A, n + 1, 2, consarr, 1, {n + 1})\n     );\n\nconstraint forall(i in 1..Y) (\n    nonogram_row(A, [rows[i, j] | j in 1..maxlen where rows[i, j] >= 0], i)\n);\n\nconstraint forall(i in 1..X) (\n    nonogram_col(A, [cols[i, j] | j in 1..maxlen where cols[i, j] >= 0], i)\n);\n\nsolve :: int_search(array1d(1..X*Y,A),input_order,indomain_max,complete) satisfy;\n\noutput [\n    if fix(A[r, c]) = 1 then \" \" else \".\" endif ++ \n    if c = Y then \"\\n\" else \" \" endif\n    | r in 1..X, c in 1..Y\n];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "nonogram_create_automaton2_beginner", "node_type": "4", "metadata": {"model_name": "nonogram_create_automaton2", "source_code": "Model 1 :\n\n% Nonoram solver using regular and is written in all-MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: rows;\nint: row_rule_len;\narray[1..rows, 1..row_rule_len] of int: row_rules;\nint: cols;\nint: col_rule_len;\narray[1..cols, 1..col_rule_len] of int: col_rules;\n\n\narray[1..rows, 1..cols] of var 1..2: x;\n\nsolve :: int_search(\n     [x[i,j] | j in 1..cols, i in 1..rows], \n     first_fail, \n     indomain_min, \n     complete) \nsatisfy;\n\n%\n% The approach is rather simple:\n%  - zero_positions is a set of the positions in the state table where the \n%    state 0 should be, which also correspond to the state of the pattern \"0\"\n%  - when this have been identified everything else comes to rest\n%\n% On the other hand, the calculation of the states is hairy, very hairy.\n%\npredicate make_automaton(array[int] of var int: x, array[int] of int: pattern) =\n    let {\n        int: n = length(pattern),\n        % fix for \"zero clues\"\n        int: len = max(length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern),1),\n        int: leading_zeros = sum(i in 1..n) (bool2int(pattern[i] = 0)),\n        set of int: zero_positions = {sum(j in 1..i) (pattern[j]+1) -leading_zeros | i in 1..n where pattern[i] > 0},\n       array[1..2*len] of 0..len*2: states = \n     if (length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern)) = 0 then \n       [1,1]  % fix for \"zero clues\"\n     else \n    [1, 2] ++\n    [\n       if i div 2 in zero_positions then\n           if i mod 2 = 0 then\n            0\n           else\n            (i div 2) + 1\n           endif\n       elseif (i-1) div 2 in zero_positions then\n           if i mod 2 = 0 then\n            (i div 2)+1\n           else\n            (i div 2)+2\n           endif\n       else\n         if not( (((i-1) div 2) - 1) in zero_positions) then\n            if i mod 2 = 0 then\n               (i div 2) + 1\n            else \n              if (i div 2) + 1 in zero_positions then\n                  (i div 2) + 2\n              else \n                  0\n              endif\n            endif\n          else\n             if i mod 2 = 0 then\n                 (i div 2) + 1\n             else \n                if not((i div 2) + 1 in zero_positions) then\n                   0\n                else \n                   (i div 2) + 2 \n                endif\n             endif\n          endif\n       endif\n    | i in 3..2*(len-1)]\n    ++\n    [len, 0]\n    endif\n    } \n    in\n    regular(\n       x,\n       len, \n       2, \n       array2d(1..len, 1..2, states),\n       1, \n       {len}) % :: domain\n;\n\nconstraint\n\n      forall(j in 1..cols) (\n        make_automaton([x[i,j] | i in 1..rows], [col_rules[j,k] | k in 1..col_rule_len])\n      )\n      /\\\n      forall(i in 1..rows) (\n        make_automaton([x[i,j] | j in 1..cols], [row_rules[i,k] | k in 1..row_rule_len])\n      )\n\n;\n\noutput \n[\n  if j = 1 then \"\\n\" else \"\" endif ++\n     if fix(x[i,j]) = 1 then \" \" else \"#\" endif\n    \n  | i in 1..rows, j in 1..cols\n] \n++ \n[\n  \"\\n\"\n];\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\nint: X;\nint: Y;\n\nint: maxlen;\n\narray [1..Y,1..maxlen] of int: rows;\n\narray [1..X,1..maxlen] of int: cols;\n\narray[1..2, 1..2, 1..2] of 0..1: nonmul = \n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 1, 1,\n         1, 0, 0, 1]\n    );\n\narray[1..2, 1..2, 1..2] of 0..1: nonadd =\n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 0, 1,\n         1, 0, 0, 1]\n    );\n\n% variables\n%\narray[1..Y, 1..X] of var 1..2: A;\n\n% All variables in a region must be different\n% Ordering to ensure each variable is handled exactly once\npredicate nonogram_row(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: row) =\n    nonogram([A[row, v] | v in 1..X], cons);\n\npredicate nonogram_col(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: col) = \n    nonogram([A[v,col] | v in 1..Y], cons);\n\npredicate nonogram(array[int] of var 1..2: A, array [int] of int: cons) = \n    let {\n          int: n = if cons[1] = 0 then 0 else max(index_set(cons)) endif,\n          array [1..n + 1, 1..2] of int: consarr =\n              if cons[1] = 0 then [|1, 0|] \n              else array2d(1..n + 1, 1..2,\n                [1, 2] ++\n                [    i * nonmul[cons[i - 1] + 1, cons[i] + 1, s] + \n                     nonadd[cons[i - 1] + 1, cons[i] + 1, s] \n                     | i in 2..n, s in 1..2 \n                ] ++ \n                [n+1,0]\n              )\n              endif\n     } in (\n         regular(A, n + 1, 2, consarr, 1, {n + 1})\n     );\n\nconstraint forall(i in 1..Y) (\n    nonogram_row(A, [rows[i, j] | j in 1..maxlen where rows[i, j] >= 0], i)\n);\n\nconstraint forall(i in 1..X) (\n    nonogram_col(A, [cols[i, j] | j in 1..maxlen where cols[i, j] >= 0], i)\n);\n\nsolve :: int_search(array1d(1..X*Y,A),input_order,indomain_max,complete) satisfy;\n\noutput [\n    if fix(A[r, c]) = 1 then \" \" else \".\" endif ++ \n    if c = Y then \"\\n\" else \" \" endif\n    | r in 1..X, c in 1..Y\n];"}, "hash": "fd69e0b3a3166881532611305ace02f5986341fb39d58fb30efa7582c738d811", "class_name": "RelatedNodeInfo"}}, "text": "**Nonogram Problem**\n\n**What is it about?**\nThe Nonogram problem is about creating a picture using a set of rules. Imagine you have a grid of squares, and you need to fill some of them with colors (let's say black and white) to create a specific image. The rules tell you how many consecutive squares of each color should be in each row and column.\n\n**Main variables:**\n\n* `x` or `A`: a 2D array that represents the grid of squares, where each square can be either 1 (white) or 2 (black).\n* `rows` and `cols`: 2D arrays that contain the rules for each row and column, respectively.\n* `row_rules` and `col_rules`: 2D arrays that contain the specific rules for each row and column.\n\n**Basic restrictions or rules:**\n\n* Each row and column must follow the rules specified in `rows` and `cols`, respectively.\n* The rules specify how many consecutive squares of each color should be in each row and column.\n\n**Goal:**\nThe goal is to find a valid configuration of the grid that satisfies all the rules, creating a specific image.\n\nIn simpler terms, the problem is about solving a puzzle where you need to fill a grid with black and white squares according to some rules, and the goal is to create a specific picture.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1210, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7f3225b0-7c54-4c59-94de-5a432acc2ac6": {"__data__": {"id_": "7f3225b0-7c54-4c59-94de-5a432acc2ac6", "embedding": null, "metadata": {"model_name": "nurses", "source_code": "Model 1 : \n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint forall(d in DAY)\n                 (global_cardinality_low_up([x[n,d] | n in NURSE ],                                               [ day, night ], [ o, l ], [o, u])); \n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n\n\nModel 2 :\n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\nconstraint forall(d in DAY)\n                 (let {var int: on = sum(n in NURSE)\n                                        (bool2int(x[n,d]=night))        \n                      } in l <= on /\\ on <= u);\n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "nurses_beginner", "node_type": "4", "metadata": {"model_name": "nurses", "source_code": "Model 1 : \n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint forall(d in DAY)\n                 (global_cardinality_low_up([x[n,d] | n in NURSE ],                                               [ day, night ], [ o, l ], [o, u])); \n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n\n\nModel 2 :\n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\nconstraint forall(d in DAY)\n                 (let {var int: on = sum(n in NURSE)\n                                        (bool2int(x[n,d]=night))        \n                      } in l <= on /\\ on <= u);\n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n"}, "hash": "41c93bc1cf29bc51d58f26ef28d1effa5e24c80b1d7ec652d82a0e7ee44f35ea", "class_name": "RelatedNodeInfo"}}, "text": "Nurse Scheduling Problem.\n\nThis problem is about creating a schedule for nurses to work at a hospital. Imagine you are the manager of a hospital and you need to create a schedule for your nurses to work over a certain number of days.\n\nThe main variables are:\n\n* Nurses (represented by numbers 1 to k): These are the people who will be working at the hospital.\n* Days (represented by numbers 1 to m): These are the days of the week/month that the nurses will be working.\n* Shifts (represented by numbers 1 to 3): These are the different types of shifts that the nurses can work, such as day shift, night shift, or a day off.\n\nThe basic restrictions or rules of the problem are:\n\n* If a nurse works a night shift two days in a row, they must have a day off on the third day.\n* If a nurse works a night shift, they cannot work a day shift the next day.\n* There must be a certain number of nurses working the night shift each day (between a lower and upper bound).\n\nThe goal of the problem is to create a schedule that satisfies all these rules and restrictions.\n\nNote that the two models are essentially the same, with the second model being a slightly different implementation of the same problem.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1195, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ba365d05-5cb0-45a2-b121-580290fcd67a": {"__data__": {"id_": "ba365d05-5cb0-45a2-b121-580290fcd67a", "embedding": null, "metadata": {"model_name": "opd", "source_code": "%% Design of Collateralised Debt Obligations Squared (CDO^2) Transactions\n% An OPD (v, b, r) problem is to find a binary matrix of v rows\n% and b columns such that each row sums to r, and\n% the dot product beween any pair of distinct rows is minimal.\n\n%Requires MiniZinc >= 2.0.2 for the symmetry_breaking_constraint predicate\n\ninclude \"lex_greatereq.mzn\";\n\n%instance data\nint: v;\nint: b;\nint: r;\n\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\n\n%computing a lower bound for lambda\nint: rv = r*v;\nint: rvmodb = rv mod b;\nint: floorrv = rv div b;\nint: ceilrv = rv div b + bool2int(rv mod b != 0);\nint: num = (ceilrv*ceilrv*rvmodb+floorrv*floorrv*(b-rvmodb)-rv);\nint: denom = v*(v-1);\nint: lb_lambda = num div denom + bool2int( num mod denom !=0);\n\n% This line is there for debugging purposes, it can be safely removed\nint: tmp = trace(\"Computed lower bound for lambda: \"++show(lb_lambda)++\"\\n\",lb_lambda);\n\n\n% lambda is called objective for the MiniZinc Challenge\nvar lb_lambda..b: objective;\n\n\narray [rows, cols] of var 0..1: m;\n\n\n% Every row must sum to r.\nconstraint forall (i in rows) (sum (j in cols) (m[i, j]) = r);\n\n% The dot product of every pair of distinct rows must be at most lambda for an OPD and a PD, and equal to lambda for a BIBD\nconstraint forall (i_a, i_b in rows where i_a < i_b) (\n    sum (j in cols) (m[i_a, j] * m[i_b, j]) <= objective\n);\n\n\n% Break row symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(i in rows diff {max(rows)})(\n        lex_greatereq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    )\n);\n% Break column symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(j in cols diff {max(cols)})(\n        lex_greatereq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    )\n);\n\n\nsolve \n    :: seq_search([int_search([m[i, j] | i in rows, j in cols], input_order, indomain_max, complete),\n       \t\t   int_search([objective], input_order,indomain_min,complete)])\n    minimize objective; \n\n\n% Disabled the full solution. Printing only the objective value, lower bound, and parameters.\noutput  [\"opd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r), \"). Found lambda = \", show(objective),\"\\tlb: \", show(lb_lambda)]\n%       ++[\"\\n\\n\"] ++ \n%\t[ ( if j > b then \"\\n\" else \n%\t        if fix(m[i,j])=1 then \"*\" else \" \" endif\n%\t    endif )\n%       | i in rows, j in 1..(b + 1) ]\n;"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "opd_beginner", "node_type": "4", "metadata": {"model_name": "opd", "source_code": "%% Design of Collateralised Debt Obligations Squared (CDO^2) Transactions\n% An OPD (v, b, r) problem is to find a binary matrix of v rows\n% and b columns such that each row sums to r, and\n% the dot product beween any pair of distinct rows is minimal.\n\n%Requires MiniZinc >= 2.0.2 for the symmetry_breaking_constraint predicate\n\ninclude \"lex_greatereq.mzn\";\n\n%instance data\nint: v;\nint: b;\nint: r;\n\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\n\n%computing a lower bound for lambda\nint: rv = r*v;\nint: rvmodb = rv mod b;\nint: floorrv = rv div b;\nint: ceilrv = rv div b + bool2int(rv mod b != 0);\nint: num = (ceilrv*ceilrv*rvmodb+floorrv*floorrv*(b-rvmodb)-rv);\nint: denom = v*(v-1);\nint: lb_lambda = num div denom + bool2int( num mod denom !=0);\n\n% This line is there for debugging purposes, it can be safely removed\nint: tmp = trace(\"Computed lower bound for lambda: \"++show(lb_lambda)++\"\\n\",lb_lambda);\n\n\n% lambda is called objective for the MiniZinc Challenge\nvar lb_lambda..b: objective;\n\n\narray [rows, cols] of var 0..1: m;\n\n\n% Every row must sum to r.\nconstraint forall (i in rows) (sum (j in cols) (m[i, j]) = r);\n\n% The dot product of every pair of distinct rows must be at most lambda for an OPD and a PD, and equal to lambda for a BIBD\nconstraint forall (i_a, i_b in rows where i_a < i_b) (\n    sum (j in cols) (m[i_a, j] * m[i_b, j]) <= objective\n);\n\n\n% Break row symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(i in rows diff {max(rows)})(\n        lex_greatereq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    )\n);\n% Break column symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(j in cols diff {max(cols)})(\n        lex_greatereq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    )\n);\n\n\nsolve \n    :: seq_search([int_search([m[i, j] | i in rows, j in cols], input_order, indomain_max, complete),\n       \t\t   int_search([objective], input_order,indomain_min,complete)])\n    minimize objective; \n\n\n% Disabled the full solution. Printing only the objective value, lower bound, and parameters.\noutput  [\"opd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r), \"). Found lambda = \", show(objective),\"\\tlb: \", show(lb_lambda)]\n%       ++[\"\\n\\n\"] ++ \n%\t[ ( if j > b then \"\\n\" else \n%\t        if fix(m[i,j])=1 then \"*\" else \" \" endif\n%\t    endif )\n%       | i in rows, j in 1..(b + 1) ]\n;"}, "hash": "c8ad289c9fe940212e050cd21e1910488d342e87a75214647b95428435bb1040", "class_name": "RelatedNodeInfo"}}, "text": "Here is the explanation of the problem:\n\n**Name of the problem:** Design of Collateralised Debt Obligations Squared (CDO^2) Transactions\n\n**What the problem is about in everyday terms:** Imagine you have a set of boxes (v) and each box can hold a certain number of items (r). You want to put items into the boxes in a way that each box has exactly r items, and the items in each box are distributed in a way that is as different as possible from the items in every other box.\n\n**Main variables and what they mean:**\n\n* v: the number of boxes\n* b: the maximum number of items that can be put into each box\n* r: the exact number of items that each box should have\n* m: a matrix that shows which items are in each box (0 means the item is not in the box, 1 means it is)\n* objective (also called lambda): a measure of how different the items in each box are from the items in every other box\n\n**Basic restrictions or rules of the problem:**\n\n* Each box must have exactly r items\n* The items in each box should be distributed in a way that is as different as possible from the items in every other box\n\n**Goal of the problem:** Find a way to put items into the boxes that minimizes the objective (lambda), which means making the items in each box as different as possible from the items in every other box.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1301, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "27ecf388-0cdd-456b-b342-4fd01da8ce95": {"__data__": {"id_": "27ecf388-0cdd-456b-b342-4fd01da8ce95", "embedding": null, "metadata": {"model_name": "partition", "source_code": "Model 1 : \n\n% Partitioning problem\n% Partition 2*n numbers into two groups, each of size n, such that\n% their sums are equal and the sums of their squares are equal.\n\ninclude \"globals.mzn\";\n\n% Instance\n\nn = 32;\n\n% Model\n\nint: n;\n\narray[1..n] of var 1..2*n: x;\narray[1..n] of var 1..2*n: y;\n\nconstraint true\n    %   Break symmetries by ordering numbers in each group\n    /\\  forall (i in 2..n) (x[i-1] < x[i] /\\ y[i-1] < y[i])\n    %   Break symmetries by ordering the groups\n    /\\  x[1] < y[1]\n    \n    %   Partition the numbers\n    /\\  (alldifferent(x++y)) :: bounds\n    \n    %   The sums are equal\n    /\\  sum (x) = 2*n*(2*n+1) div 4\n    /\\  sum (y) = 2*n*(2*n+1) div 4\n    \n    %   The sums of the squares are equal\n    /\\  let {\n            array[1..n] of var 1..4*n*n: sx,\n            array[1..n] of var 1..4*n*n: sy\n        } in\n        forall (i in 1..n) (sx[i]=x[i]*x[i] /\\ sy[i] = y[i]*y[i])\n    /\\  sum (sx) = 2*n*(2*n+1)*(4*n+1) div 12\n    /\\  sum (sy) = 2*n*(2*n+1)*(4*n+1) div 12\n;\n\nsolve ::int_search(x++y,first_fail,indomain_min,complete) satisfy;\n\noutput\n    [\"x = \",show(x),\"\\n\",\"y = \",show(y),\"\\n\",\n     \"sum = \",show(2*n*(2*n+1) div 4),\"\\n\",\n     \"sum of squares = \", show(2*n*(2*n+1)*(4*n+1) div 12), \"\\n\"\n     ];\n\n\n\nModel 2 :\n\n\n\n%\n% Set partition problem in Minizinc.\n%\n%  This is a partition problem.\n%  Given the set S = {1, 2, ..., n},\n%  it consists in finding two sets A and B such that:\n%  <ul>\n%  <li>A U B = S,</li>\n%  <li>|A| = |B|,</li>\n%  <li>sum(A) = sum(B),</li>\n%  <li>sum_squares(A) = sum_squares(B).</li>\n%  </ul>\n \n%\ninclude \"globals.mzn\";\n \nint: n = 16;\nset of 1..n: S = 1..n;\nint: num_sets = 2;\narray[1..num_sets] of var set of S: a;\narray[1..num_sets] of var 0..n*n: sums;\narray[1..num_sets] of var 0..n*n*n*n: sum_squared;\n \n \n%\n% set_sum\n% sums the elements in the set s\n%\npredicate set_sum(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i)\n;\n \npredicate set_sum_squared(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i*i)\n;\n \n \nsolve :: set_search(a, first_fail, indomain_min, complete) satisfy;\n% solve maximize sums[1];\n \nconstraint\n  assert(n mod 4 == 0, \"n must be a multiple of 4\")\n;\n \nconstraint\n   % use all the elements in S and it should be disjoint sets\n   partition_set(a, S)\n   /\\\n   forall(i in 1..num_sets) (  \n     a[i] `set_sum` sums[i]\n     /\\ a[i] `set_sum_squared` sum_squared[i]\n   )\n   /\\\n   forall(i in 2..num_sets) (\n     card(a[i]) > 0 /\\ % this is needed by eclipse\n     card(a[i]) = card(a[i-1]) /\\\n     sums[i] = sums[i-1]\n     /\\ sum_squared[i] = sum_squared[i-1]\n   )\n \n  % symmetry breaking\n  /\\ 1 in a[1]\n \n;\n \noutput [\n   \"a: \" ++ show(a) ++ \"\\n\" ++\n   \"sums: \" ++ show(sums) ++ \"\\n\" ++\n   \"sum_squared: \" ++ show(sum_squared) ++ \"\\n\"\n];\n \n% For model seeker\n% output [\n%    show(set2array(fix(a[i]))) ++ \",\"\n%   | i in 1..num_sets\n% ];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "partition_beginner", "node_type": "4", "metadata": {"model_name": "partition", "source_code": "Model 1 : \n\n% Partitioning problem\n% Partition 2*n numbers into two groups, each of size n, such that\n% their sums are equal and the sums of their squares are equal.\n\ninclude \"globals.mzn\";\n\n% Instance\n\nn = 32;\n\n% Model\n\nint: n;\n\narray[1..n] of var 1..2*n: x;\narray[1..n] of var 1..2*n: y;\n\nconstraint true\n    %   Break symmetries by ordering numbers in each group\n    /\\  forall (i in 2..n) (x[i-1] < x[i] /\\ y[i-1] < y[i])\n    %   Break symmetries by ordering the groups\n    /\\  x[1] < y[1]\n    \n    %   Partition the numbers\n    /\\  (alldifferent(x++y)) :: bounds\n    \n    %   The sums are equal\n    /\\  sum (x) = 2*n*(2*n+1) div 4\n    /\\  sum (y) = 2*n*(2*n+1) div 4\n    \n    %   The sums of the squares are equal\n    /\\  let {\n            array[1..n] of var 1..4*n*n: sx,\n            array[1..n] of var 1..4*n*n: sy\n        } in\n        forall (i in 1..n) (sx[i]=x[i]*x[i] /\\ sy[i] = y[i]*y[i])\n    /\\  sum (sx) = 2*n*(2*n+1)*(4*n+1) div 12\n    /\\  sum (sy) = 2*n*(2*n+1)*(4*n+1) div 12\n;\n\nsolve ::int_search(x++y,first_fail,indomain_min,complete) satisfy;\n\noutput\n    [\"x = \",show(x),\"\\n\",\"y = \",show(y),\"\\n\",\n     \"sum = \",show(2*n*(2*n+1) div 4),\"\\n\",\n     \"sum of squares = \", show(2*n*(2*n+1)*(4*n+1) div 12), \"\\n\"\n     ];\n\n\n\nModel 2 :\n\n\n\n%\n% Set partition problem in Minizinc.\n%\n%  This is a partition problem.\n%  Given the set S = {1, 2, ..., n},\n%  it consists in finding two sets A and B such that:\n%  <ul>\n%  <li>A U B = S,</li>\n%  <li>|A| = |B|,</li>\n%  <li>sum(A) = sum(B),</li>\n%  <li>sum_squares(A) = sum_squares(B).</li>\n%  </ul>\n \n%\ninclude \"globals.mzn\";\n \nint: n = 16;\nset of 1..n: S = 1..n;\nint: num_sets = 2;\narray[1..num_sets] of var set of S: a;\narray[1..num_sets] of var 0..n*n: sums;\narray[1..num_sets] of var 0..n*n*n*n: sum_squared;\n \n \n%\n% set_sum\n% sums the elements in the set s\n%\npredicate set_sum(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i)\n;\n \npredicate set_sum_squared(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i*i)\n;\n \n \nsolve :: set_search(a, first_fail, indomain_min, complete) satisfy;\n% solve maximize sums[1];\n \nconstraint\n  assert(n mod 4 == 0, \"n must be a multiple of 4\")\n;\n \nconstraint\n   % use all the elements in S and it should be disjoint sets\n   partition_set(a, S)\n   /\\\n   forall(i in 1..num_sets) (  \n     a[i] `set_sum` sums[i]\n     /\\ a[i] `set_sum_squared` sum_squared[i]\n   )\n   /\\\n   forall(i in 2..num_sets) (\n     card(a[i]) > 0 /\\ % this is needed by eclipse\n     card(a[i]) = card(a[i-1]) /\\\n     sums[i] = sums[i-1]\n     /\\ sum_squared[i] = sum_squared[i-1]\n   )\n \n  % symmetry breaking\n  /\\ 1 in a[1]\n \n;\n \noutput [\n   \"a: \" ++ show(a) ++ \"\\n\" ++\n   \"sums: \" ++ show(sums) ++ \"\\n\" ++\n   \"sum_squared: \" ++ show(sum_squared) ++ \"\\n\"\n];\n \n% For model seeker\n% output [\n%    show(set2array(fix(a[i]))) ++ \",\"\n%   | i in 1..num_sets\n% ];"}, "hash": "d1ea9312d390565d0c1fbfd20ee7b98ac92b839978d157fb0f83a719c4ef276e", "class_name": "RelatedNodeInfo"}}, "text": "**Partition Problem**\n\nThis problem is about dividing a set of numbers into two groups, so that the sum of the numbers in each group is equal, and the sum of the squares of the numbers in each group is also equal.\n\n**Main Variables:**\n\n* `x` and `y` are the two groups of numbers.\n* `n` is the number of numbers in each group.\n\n**Basic Restrictions:**\n\n* Each group must have the same number of numbers (`n`).\n* The numbers in each group must be different from each other.\n* The sum of the numbers in each group must be equal.\n* The sum of the squares of the numbers in each group must be equal.\n\n**Goal:**\n\nThe goal is to find two groups of numbers that satisfy all the restrictions above.\n\nIn simpler terms, imagine you have a set of numbers, and you want to divide them into two groups, so that the total value of each group is the same, and the total value of the squares of each group is also the same.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 907, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9d7918e4-2e7c-450b-abd5-b43323a7c749": {"__data__": {"id_": "9d7918e4-2e7c-450b-abd5-b43323a7c749", "embedding": null, "metadata": {"model_name": "photo", "source_code": "int:n ;\nset of int: PERSON = 1..n;\nset of int: POS = 1..n;\narray[PERSON,PERSON] of int: friend;\n\n%array[PERSON] of var POS: x;\narray[POS] of var PERSON: y;\n\n%include \"inverse.mzn\";\n%constraint inverse(x,y);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\n%constraint alldifferent(x);\n\n%y[i] = sum(j in 1..n)(bool2int(x[j] = i) * j);\n\nsolve maximize sum(i in 1..n-1)(friend[y[i],y[i+1]]);\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "photo_beginner", "node_type": "4", "metadata": {"model_name": "photo", "source_code": "int:n ;\nset of int: PERSON = 1..n;\nset of int: POS = 1..n;\narray[PERSON,PERSON] of int: friend;\n\n%array[PERSON] of var POS: x;\narray[POS] of var PERSON: y;\n\n%include \"inverse.mzn\";\n%constraint inverse(x,y);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\n%constraint alldifferent(x);\n\n%y[i] = sum(j in 1..n)(bool2int(x[j] = i) * j);\n\nsolve maximize sum(i in 1..n-1)(friend[y[i],y[i+1]]);\n\n"}, "hash": "1cb4ad495263b48a3409a70f94a704336f13ef89fe2b2007dd31f0be63459999", "class_name": "RelatedNodeInfo"}}, "text": "Social Golfers Problem.\n\nThis problem is about organizing a group of people to play golf together in a way that makes everyone happy. Imagine you have a group of friends who want to play golf together, and you want to arrange them into pairs to play together.\n\nThe main variables are:\n\n* PERSON: This represents each individual person in the group.\n* POS: This represents the position or pair that each person will play in.\n* friend: This is a table that shows how much each person likes to play with each other person.\n* x and y: These are variables that will be used to decide who plays with whom.\n\nThe basic restrictions or rules of the problem are:\n\n* Each person must play with someone.\n* No two people can play in the same position (pair).\n* The goal is to make sure that people play with their friends as much as possible.\n\nThe goal of the problem is to maximize the total happiness of all the golfers, which is measured by how much they like to play with the person they are paired with.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 995, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "930acf52-d5f6-4d56-b525-57da3f9ae68b": {"__data__": {"id_": "930acf52-d5f6-4d56-b525-57da3f9ae68b", "embedding": null, "metadata": {"model_name": "project_scheduling", "source_code": "Model 1 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\nconstraint forall(i in PREC)\n                 (start[pre[i,1]] + duration[pre[i,1]] <= start[pre[i,2]]);\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n\n\n\nModel 2 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\npredicate precedes(var int:s1, var int:d1, var int:s2)=\n          s1 + d1 <= s2; \n\nconstraint forall(i in PREC)\n                 (precedes(start[pre[i,1]],duration[pre[i,1]],start[pre[i,2]]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nset of TASK: CARPENTRY = { interior_walls, exterior_walls, roof };\nconstraint forall(t1, t2 in CARPENTRY where t1 < t2)\n      (nonoverlap(start[t1],duration[t1],start[t2],duration[t2]));\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "project_scheduling_beginner", "node_type": "4", "metadata": {"model_name": "project_scheduling", "source_code": "Model 1 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\nconstraint forall(i in PREC)\n                 (start[pre[i,1]] + duration[pre[i,1]] <= start[pre[i,2]]);\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n\n\n\nModel 2 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\npredicate precedes(var int:s1, var int:d1, var int:s2)=\n          s1 + d1 <= s2; \n\nconstraint forall(i in PREC)\n                 (precedes(start[pre[i,1]],duration[pre[i,1]],start[pre[i,2]]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nset of TASK: CARPENTRY = { interior_walls, exterior_walls, roof };\nconstraint forall(t1, t2 in CARPENTRY where t1 < t2)\n      (nonoverlap(start[t1],duration[t1],start[t2],duration[t2]));\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n"}, "hash": "f9f4c70bcdabcfebadb07ffd0654da2bc87b8e91e14c2d8a716ad96fd1c173ff", "class_name": "RelatedNodeInfo"}}, "text": "**House Building Problem**\n\nThis problem is about building a house. Imagine you have a list of tasks to complete, like laying foundations, building walls, installing doors and windows, and putting on a roof. Each task takes a certain amount of time to finish.\n\n**Main Variables:**\n\n* **Tasks**: These are the individual jobs that need to be done to build the house, like laying foundations or installing doors.\n* **Duration**: This is how long each task takes to complete.\n* **Start time**: This is when each task begins.\n* **Makespan**: This is the total time it takes to complete all the tasks.\n\n**Basic Restrictions or Rules:**\n\n* Some tasks can't start until others are finished. For example, you can't start building walls until the foundations are laid.\n* Some tasks can't happen at the same time. For example, you can't be building the interior walls and exterior walls at the same time.\n\n**Goal:**\n\nThe goal is to find the order and timing of the tasks that will allow you to build the house in the shortest amount of time possible.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1040, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c548ea43-90cc-4b09-a679-8aadee6e104c": {"__data__": {"id_": "c548ea43-90cc-4b09-a679-8aadee6e104c", "embedding": null, "metadata": {"model_name": "QuasigroupCompletion", "source_code": "Model 1 :\n\n% Quasigroup with Holes (aka Latin Square Completion)\n\ninclude \"alldifferent.mzn\";\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n\narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N] of var PuzzleRange: puzzle;\n\n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j] = start[i,j] else true endif );\n\n% All different in rows\nconstraint forall (i in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | j in PuzzleRange ] ) );\n\n% All different in columns.\nconstraint forall (j in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | i in PuzzleRange ] ) );\n\nsolve satisfy;\n\noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n \narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N, 1..N] of var 0..1: puzzle;\n \n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j, start[i,j]] = 1 else true endif );\n \n% All different in rows\nconstraint forall (i,k in PuzzleRange) (\n        sum(j in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% All different in columns\nconstraint forall (j,k in PuzzleRange) (\n        sum(i in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% Each cell must have a number assigned\nconstraint forall (i,j in PuzzleRange) (\n        sum(k in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\nsolve satisfy;\n \noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasigroupCompletion_beginner", "node_type": "4", "metadata": {"model_name": "QuasigroupCompletion", "source_code": "Model 1 :\n\n% Quasigroup with Holes (aka Latin Square Completion)\n\ninclude \"alldifferent.mzn\";\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n\narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N] of var PuzzleRange: puzzle;\n\n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j] = start[i,j] else true endif );\n\n% All different in rows\nconstraint forall (i in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | j in PuzzleRange ] ) );\n\n% All different in columns.\nconstraint forall (j in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | i in PuzzleRange ] ) );\n\nsolve satisfy;\n\noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n \narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N, 1..N] of var 0..1: puzzle;\n \n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j, start[i,j]] = 1 else true endif );\n \n% All different in rows\nconstraint forall (i,k in PuzzleRange) (\n        sum(j in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% All different in columns\nconstraint forall (j,k in PuzzleRange) (\n        sum(i in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% Each cell must have a number assigned\nconstraint forall (i,j in PuzzleRange) (\n        sum(k in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\nsolve satisfy;\n \noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];"}, "hash": "fe24d9a3d446319d411b54347e288890955122f0b9122a714eaf8e62fa2d4806", "class_name": "RelatedNodeInfo"}}, "text": "**Problem Name:** Quasigroup with Holes (also known as Latin Square Completion)\n\n**What the problem is about:** Imagine you have a grid with some numbers already filled in, and some empty cells. Your task is to fill in the empty cells with numbers so that each row, column, and cell has each number only once.\n\n**Main variables:**\n\n* `N`: The size of the grid (e.g., 3x3, 4x4, etc.)\n* `start`: The initial grid with some numbers already filled in and some empty cells (represented by 0)\n* `puzzle`: The grid that we want to fill in with numbers\n\n**Basic restrictions or rules:**\n\n* Each row must have each number only once\n* Each column must have each number only once\n* Each cell can only have one number assigned to it\n* The numbers already filled in the `start` grid cannot be changed\n\n**Goal of the problem:** The goal is to find a way to fill in the empty cells in the grid so that all the rules are satisfied. There is no specific goal to minimize or maximize anything; we just want to find a valid solution that meets all the rules.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1039, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ad0f25bc-8e58-47b5-8185-69fea96ce841": {"__data__": {"id_": "ad0f25bc-8e58-47b5-8185-69fea96ce841", "embedding": null, "metadata": {"model_name": "QuasiGroupExistence", "source_code": "Model 1 :\n\n\n% Quasigroup problem in MiniZinc.\n% The quasiGroup existence problem\n% An m order quasigroup  is an mxm multiplication table of integers 1..m,\n% where each element occurrs exactly once in each row and column and certain\n% multiplication axioms hold (in this case, we want axiom 7 to hold).\n%\n% QG7.m problems are order m quasigroups for which (b*a)*b = a*(b*a).\n\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n% solve satisfy;\n \nconstraint\n      \n     % assign the \"reflected\" quasigroup to qGColumns to access its columns\n     %  forall row,col : nDomain .\n     %    quasiGroupColumns[col,row] = quasiGroup[row,col],\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % all values in the diagonals\n     forall( i in nDomain ) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n \n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row, col] | row in nDomain])\n     )\n     /\\\n \n     % this strange constraint\n     % corresponds to:\n     % quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i], j] \n     forall(i,j in nDomain) (\n              quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i],j]\n     )\n     /\\\n     % some implied? constraint\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n%\n% data\n%\nn = 5;\n\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 9; % solutions for n=5, n=9...\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n \nint: n = 4;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n \n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (i != j) ->\n         (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n \n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n \n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\n\nModel 4 :\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n \n     % Idempotency\n     % forall i : nDomain .\n     %     (quasiGroup[i,i] = i),\n \n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     % allDifferent(qgDiagonal) %,\n \n     % anti-Abelian\n     % forall i : nDomain .\n     %   forall j : nDomain .\n     %     (i != j) =>\n     %     (quasiGroup[i,j] != quasiGroup[j,i]),\n \n     % if (i*i)=j then (j*j) = i\n     % forall i : nDomain .\n     %  forall j : nDomain .\n     %    (quasiGroup[i,i]=j) => (quasiGroup[j,j]=i),\n \n \n     % Symmetry-breaking constraints   \n     % forall i : nDomain .\n     %      quasiGroup[i,n-1] + 2 >= i\n \n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n \n \n%\n% data\n%\nn = 4; % 4 works\n\n\nModel 5 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 6 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 5;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 7 :\n\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasiGroupExistence_beginner", "node_type": "4", "metadata": {"model_name": "QuasiGroupExistence", "source_code": "Model 1 :\n\n\n% Quasigroup problem in MiniZinc.\n% The quasiGroup existence problem\n% An m order quasigroup  is an mxm multiplication table of integers 1..m,\n% where each element occurrs exactly once in each row and column and certain\n% multiplication axioms hold (in this case, we want axiom 7 to hold).\n%\n% QG7.m problems are order m quasigroups for which (b*a)*b = a*(b*a).\n\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n% solve satisfy;\n \nconstraint\n      \n     % assign the \"reflected\" quasigroup to qGColumns to access its columns\n     %  forall row,col : nDomain .\n     %    quasiGroupColumns[col,row] = quasiGroup[row,col],\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % all values in the diagonals\n     forall( i in nDomain ) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n \n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row, col] | row in nDomain])\n     )\n     /\\\n \n     % this strange constraint\n     % corresponds to:\n     % quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i], j] \n     forall(i,j in nDomain) (\n              quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i],j]\n     )\n     /\\\n     % some implied? constraint\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n%\n% data\n%\nn = 5;\n\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 9; % solutions for n=5, n=9...\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n \nint: n = 4;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n \n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (i != j) ->\n         (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n \n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n \n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\n\nModel 4 :\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n \n     % Idempotency\n     % forall i : nDomain .\n     %     (quasiGroup[i,i] = i),\n \n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     % allDifferent(qgDiagonal) %,\n \n     % anti-Abelian\n     % forall i : nDomain .\n     %   forall j : nDomain .\n     %     (i != j) =>\n     %     (quasiGroup[i,j] != quasiGroup[j,i]),\n \n     % if (i*i)=j then (j*j) = i\n     % forall i : nDomain .\n     %  forall j : nDomain .\n     %    (quasiGroup[i,i]=j) => (quasiGroup[j,j]=i),\n \n \n     % Symmetry-breaking constraints   \n     % forall i : nDomain .\n     %      quasiGroup[i,n-1] + 2 >= i\n \n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n \n \n%\n% data\n%\nn = 4; % 4 works\n\n\nModel 5 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 6 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 5;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 7 :\n\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];"}, "hash": "95583b92bcf260ced8a0a22075962214ebd72a671c7847f612c88326f1771849", "class_name": "RelatedNodeInfo"}}, "text": "Here is the explanation of the problem:\n\n**Name of the problem:** Quasigroup existence problem\n\n**What the problem is about:** Imagine you have a table with numbers from 1 to n, where n is a given number. You need to fill this table in a special way, so that each row and each column contains each number exactly once. Additionally, there are some rules about how the numbers in the table should be related to each other.\n\n**Main variables:**\n\n* `quasiGroup`: a table (or matrix) with numbers from 1 to n, where each row and column contains each number exactly once.\n* `qgDiagonal`: a list of numbers that represents the diagonal of the `quasiGroup` table.\n\n**Basic restrictions or rules:**\n\n* Each row and each column of the `quasiGroup` table should contain each number exactly once.\n* There are some specific rules about how the numbers in the table should be related to each other, such as `(b*a)*b = a*(b*a)` or `(j*i)*(i*j) = i`.\n* The diagonal of the `quasiGroup` table should also satisfy some specific rules.\n\n**Goal of the problem:** The goal is to find a `quasiGroup` table that satisfies all the rules and restrictions.\n\nNote that the problem is about finding a specific type of mathematical structure called a quasigroup, which is a set with a binary operation that satisfies certain properties. The problem is to find a quasigroup of a given order (i.e., with a given number of elements).", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1402, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eb1e6520-993d-4661-a0b5-d7af06301f6d": {"__data__": {"id_": "eb1e6520-993d-4661-a0b5-d7af06301f6d", "embedding": null, "metadata": {"model_name": "queens", "source_code": "Model 1 :\n\n% n queens problem in MiniZinc.\n\ninclude \"globals.mzn\";\n\nint: n;\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail, \n        indomain_min, \n        complete) \n    satisfy;\n\n% solve satisfy;\n\nconstraint all_different(queens);\n\nconstraint\n    forall(i, j in 1..n where i < j) (\n         queens[i] != queens[j] /\\\n         queens[i] + i != queens[j] + j /\\\n         queens[i] - i != queens[j] - j\n    ) \n ;\n\noutput [\n  show(queens) ++ \"\\n\"\n\n];\n\n% data\nn = 8;\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n;\n\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail,\n        indomain_median,\n        complete\n       )\n     satisfy;\n\n% solve satisfy;\nconstraint all_different(queens); %  :: domain;\nconstraint all_different([queens[i]+i | i in 1..n]) :: domain;\nconstraint all_different([queens[i]-i | i in 1..n]) :: domain;\n\noutput \n[\n  \"queens: \" ++ show(queens)\n] ++ \n% [\n%   if j = 1 then \"\\n\" else \"\" endif ++\n%      if fix(queens[i]) = j then          \n%         show_int(2,j)\n%      else\n%         \"__\"\n%      endif\n%   | i in 1..n, j in 1..n\n% ] ++\n[\"\\n\"]\n;\n\n% data\nn = 8;\n\n\nModel 3 :\n\n\n\nint: n;                                 % The number of queens.\n\narray [1..n] of var 1..n: q;\n\ninclude \"alldifferent.mzn\";\n\nconstraint alldifferent(q);\nconstraint alldifferent(i in 1..n)(q[i] + i);\nconstraint alldifferent(i in 1..n)(q[i] - i);\n\n\nsolve \n%      :: int_search(q, input_order, indomain_min, complete) \n%      :: int_search(q, first_fail, indomain_min, complete) \n%      :: int_search(q, smallest, indomain_min, complete)\n%      :: int_search(q, largest, indomain_min, complete)\n%      :: int_search(q, input_order, indomain_max, complete) \n%      :: int_search(q, first_fail, indomain_max, complete) \n%      :: int_search(q, smallest, indomain_max, complete)\n%      :: int_search(q, largest, indomain_max, complete)\n%      :: int_search(q, input_order, indomain_median, complete) \n%      :: int_search(q, first_fail, indomain_median, complete) \n%      :: int_search(q, smallest, indomain_median, complete)\n%      :: int_search(q, largest, indomain_median, complete)\n%      :: int_search(q, input_order, indomain_random, complete) \n%      :: int_search(q, first_fail, indomain_random, complete) \n%      :: int_search(q, smallest, indomain_random, complete)\n%      :: int_search(q, largest, indomain_random, complete)\n      satisfy;\n\n%output\t\n%%\t[\tif fix(q[i]) = j then \"Q \" else \". \" endif ++\n%\t \tif j = n then \"\\n\" else \"\" endif\n%\t|\ti, j in 1..n\n%\t];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "queens_beginner", "node_type": "4", "metadata": {"model_name": "queens", "source_code": "Model 1 :\n\n% n queens problem in MiniZinc.\n\ninclude \"globals.mzn\";\n\nint: n;\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail, \n        indomain_min, \n        complete) \n    satisfy;\n\n% solve satisfy;\n\nconstraint all_different(queens);\n\nconstraint\n    forall(i, j in 1..n where i < j) (\n         queens[i] != queens[j] /\\\n         queens[i] + i != queens[j] + j /\\\n         queens[i] - i != queens[j] - j\n    ) \n ;\n\noutput [\n  show(queens) ++ \"\\n\"\n\n];\n\n% data\nn = 8;\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n;\n\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail,\n        indomain_median,\n        complete\n       )\n     satisfy;\n\n% solve satisfy;\nconstraint all_different(queens); %  :: domain;\nconstraint all_different([queens[i]+i | i in 1..n]) :: domain;\nconstraint all_different([queens[i]-i | i in 1..n]) :: domain;\n\noutput \n[\n  \"queens: \" ++ show(queens)\n] ++ \n% [\n%   if j = 1 then \"\\n\" else \"\" endif ++\n%      if fix(queens[i]) = j then          \n%         show_int(2,j)\n%      else\n%         \"__\"\n%      endif\n%   | i in 1..n, j in 1..n\n% ] ++\n[\"\\n\"]\n;\n\n% data\nn = 8;\n\n\nModel 3 :\n\n\n\nint: n;                                 % The number of queens.\n\narray [1..n] of var 1..n: q;\n\ninclude \"alldifferent.mzn\";\n\nconstraint alldifferent(q);\nconstraint alldifferent(i in 1..n)(q[i] + i);\nconstraint alldifferent(i in 1..n)(q[i] - i);\n\n\nsolve \n%      :: int_search(q, input_order, indomain_min, complete) \n%      :: int_search(q, first_fail, indomain_min, complete) \n%      :: int_search(q, smallest, indomain_min, complete)\n%      :: int_search(q, largest, indomain_min, complete)\n%      :: int_search(q, input_order, indomain_max, complete) \n%      :: int_search(q, first_fail, indomain_max, complete) \n%      :: int_search(q, smallest, indomain_max, complete)\n%      :: int_search(q, largest, indomain_max, complete)\n%      :: int_search(q, input_order, indomain_median, complete) \n%      :: int_search(q, first_fail, indomain_median, complete) \n%      :: int_search(q, smallest, indomain_median, complete)\n%      :: int_search(q, largest, indomain_median, complete)\n%      :: int_search(q, input_order, indomain_random, complete) \n%      :: int_search(q, first_fail, indomain_random, complete) \n%      :: int_search(q, smallest, indomain_random, complete)\n%      :: int_search(q, largest, indomain_random, complete)\n      satisfy;\n\n%output\t\n%%\t[\tif fix(q[i]) = j then \"Q \" else \". \" endif ++\n%\t \tif j = n then \"\\n\" else \"\" endif\n%\t|\ti, j in 1..n\n%\t];\n"}, "hash": "2fb4aad78234fcaf6077257e66c290408112e4bad4f5edea2bd76812285797e1", "class_name": "RelatedNodeInfo"}}, "text": "**The N-Queens Problem**\n\n**What is it about?**\nImagine you have a chessboard with `n` rows and `n` columns. You want to place `n` queens on the board in such a way that no queen can attack another queen.\n\n**Main variables:**\n* `n`: the number of queens (and the size of the chessboard)\n* `queens`: an array of `n` variables, each representing the column where a queen is placed in a particular row\n\n**Basic restrictions or rules:**\n* Each queen must be placed in a different column (no two queens can be in the same column)\n* No queen can attack another queen diagonally (i.e., no two queens can be on the same diagonal)\n\n**Goal:**\nThe goal is to find a way to place all `n` queens on the board such that they do not attack each other.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 736, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b1416728-3b5d-41d5-8d06-90b3d4680ec3": {"__data__": {"id_": "b1416728-3b5d-41d5-8d06-90b3d4680ec3", "embedding": null, "metadata": {"model_name": "rcpsp", "source_code": "int: n; % number of tasks\nset of int: TASK = 1..n;\narray[TASK] of int: d; % duration\n\nint: m; % number of resources\nset of int: RESOURCE = 1..m;\narray[RESOURCE] of int: L; % resource limit\narray[RESOURCE,TASK] of int: res; % usage\n\nint: l; % number of precedences\nset of int: PREC = 1..l;\narray[PREC,1..2] of TASK: pre; % predecessor/successor pairs\n\nint: maxt; % maximum time\nset of int: TIME = 0..maxt;\n\narray[TASK] of var TIME: s; % start time\n\nconstraint forall(p in PREC)(s[pre[p,1]]+d[pre[p,1]] <= s[pre[p,2]]);\n\ninclude \"cumulative.mzn\";\nconstraint forall(r in RESOURCE)\n                 (cumulative(s,d,[res[r,t]|t in TASK],L[r]));\n%constraint forall(r in RESOURCE) \n%                 ( let { array[int] of var int: ss = \n%                              [ s[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: dd = \n%                              [ d[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: rr = \n%                              [ res[r,t] | t in TASK where res[r,t] > 0 ]; } in\n%                   cumulative(ss,dd,rr,L[r]));\n\nsolve minimize max(t in TASK)(s[t] + d[t]);\n\noutput [show(s)];\n\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rcpsp_beginner", "node_type": "4", "metadata": {"model_name": "rcpsp", "source_code": "int: n; % number of tasks\nset of int: TASK = 1..n;\narray[TASK] of int: d; % duration\n\nint: m; % number of resources\nset of int: RESOURCE = 1..m;\narray[RESOURCE] of int: L; % resource limit\narray[RESOURCE,TASK] of int: res; % usage\n\nint: l; % number of precedences\nset of int: PREC = 1..l;\narray[PREC,1..2] of TASK: pre; % predecessor/successor pairs\n\nint: maxt; % maximum time\nset of int: TIME = 0..maxt;\n\narray[TASK] of var TIME: s; % start time\n\nconstraint forall(p in PREC)(s[pre[p,1]]+d[pre[p,1]] <= s[pre[p,2]]);\n\ninclude \"cumulative.mzn\";\nconstraint forall(r in RESOURCE)\n                 (cumulative(s,d,[res[r,t]|t in TASK],L[r]));\n%constraint forall(r in RESOURCE) \n%                 ( let { array[int] of var int: ss = \n%                              [ s[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: dd = \n%                              [ d[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: rr = \n%                              [ res[r,t] | t in TASK where res[r,t] > 0 ]; } in\n%                   cumulative(ss,dd,rr,L[r]));\n\nsolve minimize max(t in TASK)(s[t] + d[t]);\n\noutput [show(s)];\n\n\n"}, "hash": "6c42e69bd87baf7407ae99975e9846b8c91a5dd68311d4c605f339605594790b", "class_name": "RelatedNodeInfo"}}, "text": "**Resource-Constrained Project Scheduling Problem**\n\nThis problem is about planning a set of tasks that need to be done, using a limited amount of resources, like machines or workers. Each task takes a certain amount of time to complete and uses a certain amount of resources.\n\n**Main variables:**\n\n* Tasks: These are the individual jobs that need to be done.\n* Resources: These are the machines, workers, or other things needed to complete the tasks.\n* Start time: This is when each task will begin.\n* Duration: This is how long each task will take to complete.\n* Resource usage: This is how much of each resource is needed for each task.\n\n**Basic restrictions or rules:**\n\n* Each task must be done after its predecessors (tasks that need to be finished before it can start).\n* Each resource has a limited capacity, and the total usage of that resource by all tasks cannot exceed that capacity.\n* Each task must start after its predecessors have finished.\n\n**Goal:**\n\nThe goal is to find a schedule that completes all tasks as quickly as possible, while following the rules and restrictions above. In other words, we want to minimize the total time it takes to complete all tasks.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1181, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "11210b56-7cad-4748-bb19-7f1106bb5297": {"__data__": {"id_": "11210b56-7cad-4748-bb19-7f1106bb5297", "embedding": null, "metadata": {"model_name": "rehearsal", "source_code": "%\n% Scheduling a Rehearsal in MiniZinc.\n% A concert is to consist of nine pieces of music of different durations\n% each involving a different combination of the five members of the orchestra.\n% Players can arrive at rehearsals immediately before the first piece in which\n% they are involved and depart immediately after the last piece in which\n% they are involved. The problem is to devise an order in which the pieces\n% can be rehearsed so as to minimize the total time that players are waiting\n% to play, i.e. the total time when players are present but not currently\n% playing. In the table below, 1 means that the player is required for\n% the corresponding piece, 0 otherwise. The duration (i.e. rehearsal time)\n% is in some unspecified time units.\n%\n%    Piece       1    2   3    4    5  6    7   8    9\n%    Player 1    1    1   0    1    0  1    1   0    1\n%    Player 2    1    1   0    1    1  1    0   1    0\n%    Player 3    1    1   0    0    0  0    1   1    0\n%    Player 4    1    0   0    0    1  1    0   0    1\n%    Player 5    0    0   1    0    1  1    1   1    0\n%    Duration    2    4   1    3    3  2    5   7    6\n%\n% For example, if the nine pieces were rehearsed in numerical order as\n% given above, then the total waiting time would be:\n%       Player 1: 1+3+7=11\n%       Player 2: 1+5=6\n%       Player 3: 1+3+3+2=9\n%       Player 4: 4+1+3+5+7=20\n%       Player 5: 3\n% giving a total of 49 units. The optimal sequence, as we shall see,\n% is much better than this.\n%\n% ...\n%\n% The minimum waiting time for the rehearsal problem is 17 time units, and\n% an optimal sequence is 3, 8, 2, 7, 1, 6, 5, 4, 9.\n%\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \n\n\nint: num_pieces;\nint: num_players;\narray[1..num_pieces] of int: duration;\narray[1..num_players, 1..num_pieces] of 0..1: rehearsal;\n\n\n%\n% Decision variables\n%\narray[1..num_pieces] of var 1..num_pieces: rehearsal_order;\narray[1..num_players] of var 0..sum(duration): waiting_time; % waiting time for players\narray[1..num_players] of var 1..num_pieces: p_from; % first rehearsal\narray[1..num_players] of var 1..num_pieces: p_to;   % last rehearsal\nvar 0..sum(duration): total_waiting_time = sum(waiting_time); % objective\n\nsolve :: int_search(\n         rehearsal_order % ++ waiting_time% ++ p_from ++ p_to ++ [total_waiting_time]\n         , \n         first_fail, % occurrence, % max_regret, % first_fail, \n         indomain_max, % indomain_max, \n         complete) \n     minimize total_waiting_time;\n     % satisfy;\n\n% solve :: labelling_ff minimize total_waiting_time;\n\nconstraint\n  all_different(rehearsal_order) :: domain\n  /\\\n\n  % This solution is my own without glancing at Smith's models...\n  forall(p in 1..num_players) (\n     % This versions is much faster than using exists (see below)\n     % fix the range from..to, i.e. don't count all that start with 0 \n     % or ends with 0.\n     % This means that we collect the rehearsals with many 0 at the ends\n     %\n     p_from[p] < p_to[p]\n     /\\\n     % skipping rehearsal at start (don't come yet)\n     forall(i in 1..num_pieces) (\n        i < p_from[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\\n     % skipping rehearsal at end (go home after last rehearsal)\n     forall(i in 1..num_pieces) (\n        i > p_to[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\ % and now: count the waiting time for from..to\n     waiting_time[p] = \n         sum(i in 1..num_pieces) (\n              duration[rehearsal_order[i]] * bool2int(\n                                             i >= p_from[p] /\\ i <= p_to[p] \n                                             /\\\n                                             rehearsal[p,rehearsal_order[i]] = 0\n                                )\n     ) \n\n%      % alternative solution with exists. \n%      %  More elegant (= declarative) in my book but slower.\n%      exists(from, to in 1..num_pieces) ( \n%         % skipping rehearsal at start (don't come yet)\n%         forall(i in 1..from-1) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\\n%         % skipping rehearsal at end (go home after last rehearsal)\n%         forall(i in to+1..num_pieces) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\ % and now: count the waiting time for from..to\n%         waiting_time[p] = \n%             sum(i in from..to) (\n%                  duration[rehearsal_order[i]]*\n%                                  bool2int(\n%                                       rehearsal[p,rehearsal_order[i]] = 0\n%                                   )\n%          ) \n%      )\n\n\n  )\n\n  /\\ % symmetry breaking\n  rehearsal_order[1] < rehearsal_order[num_pieces]\n\n  % for all solutions\n  % /\\ total_waiting_time = 17\n;\n\n\n%\n% data\n%\n%\n% num_pieces = 9;\n% num_players = 5;\n% duration = [2, 4, 1, 3, 3, 2, 5, 7, 6];\n% rehearsal = array2d(1..num_players, 1..num_pieces, \n%     [\n%      1,1,0,1,0,1,1,0,1,\n%      1,1,0,1,1,1,0,1,0,\n%      1,1,0,0,0,0,1,1,0,\n%      1,0,0,0,1,1,0,0,1,\n%      0,0,1,0,1,1,1,1,0\n%   ]);\n\n%\n% This is the problem from the Choco v 2.1 example \n% num_pieces = 5;\n% num_players = 3;\n% duration = [4,6,3,5,7];\n% rehearsal =  array2d(1..num_players, 1..num_pieces, \n%         [\n%         1,1,0,1,0,\n%         0,1,1,0,1,\n%         1,1,0,1,1   \n%   ]);\n\n\noutput[\n  \"order: \" , show(rehearsal_order), \"\\n\",\n  \"waiting_time: \", show(waiting_time), \"\\n\",\n  \"total_waiting_time: \" , show(total_waiting_time), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(rehearsal[p, rehearsal_order[j]]) ++ \" \"\n  | p in 1..num_players, j in 1..num_pieces, \n] ++ \n[\"\\n\"]\n;\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rehearsal_beginner", "node_type": "4", "metadata": {"model_name": "rehearsal", "source_code": "%\n% Scheduling a Rehearsal in MiniZinc.\n% A concert is to consist of nine pieces of music of different durations\n% each involving a different combination of the five members of the orchestra.\n% Players can arrive at rehearsals immediately before the first piece in which\n% they are involved and depart immediately after the last piece in which\n% they are involved. The problem is to devise an order in which the pieces\n% can be rehearsed so as to minimize the total time that players are waiting\n% to play, i.e. the total time when players are present but not currently\n% playing. In the table below, 1 means that the player is required for\n% the corresponding piece, 0 otherwise. The duration (i.e. rehearsal time)\n% is in some unspecified time units.\n%\n%    Piece       1    2   3    4    5  6    7   8    9\n%    Player 1    1    1   0    1    0  1    1   0    1\n%    Player 2    1    1   0    1    1  1    0   1    0\n%    Player 3    1    1   0    0    0  0    1   1    0\n%    Player 4    1    0   0    0    1  1    0   0    1\n%    Player 5    0    0   1    0    1  1    1   1    0\n%    Duration    2    4   1    3    3  2    5   7    6\n%\n% For example, if the nine pieces were rehearsed in numerical order as\n% given above, then the total waiting time would be:\n%       Player 1: 1+3+7=11\n%       Player 2: 1+5=6\n%       Player 3: 1+3+3+2=9\n%       Player 4: 4+1+3+5+7=20\n%       Player 5: 3\n% giving a total of 49 units. The optimal sequence, as we shall see,\n% is much better than this.\n%\n% ...\n%\n% The minimum waiting time for the rehearsal problem is 17 time units, and\n% an optimal sequence is 3, 8, 2, 7, 1, 6, 5, 4, 9.\n%\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \n\n\nint: num_pieces;\nint: num_players;\narray[1..num_pieces] of int: duration;\narray[1..num_players, 1..num_pieces] of 0..1: rehearsal;\n\n\n%\n% Decision variables\n%\narray[1..num_pieces] of var 1..num_pieces: rehearsal_order;\narray[1..num_players] of var 0..sum(duration): waiting_time; % waiting time for players\narray[1..num_players] of var 1..num_pieces: p_from; % first rehearsal\narray[1..num_players] of var 1..num_pieces: p_to;   % last rehearsal\nvar 0..sum(duration): total_waiting_time = sum(waiting_time); % objective\n\nsolve :: int_search(\n         rehearsal_order % ++ waiting_time% ++ p_from ++ p_to ++ [total_waiting_time]\n         , \n         first_fail, % occurrence, % max_regret, % first_fail, \n         indomain_max, % indomain_max, \n         complete) \n     minimize total_waiting_time;\n     % satisfy;\n\n% solve :: labelling_ff minimize total_waiting_time;\n\nconstraint\n  all_different(rehearsal_order) :: domain\n  /\\\n\n  % This solution is my own without glancing at Smith's models...\n  forall(p in 1..num_players) (\n     % This versions is much faster than using exists (see below)\n     % fix the range from..to, i.e. don't count all that start with 0 \n     % or ends with 0.\n     % This means that we collect the rehearsals with many 0 at the ends\n     %\n     p_from[p] < p_to[p]\n     /\\\n     % skipping rehearsal at start (don't come yet)\n     forall(i in 1..num_pieces) (\n        i < p_from[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\\n     % skipping rehearsal at end (go home after last rehearsal)\n     forall(i in 1..num_pieces) (\n        i > p_to[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\ % and now: count the waiting time for from..to\n     waiting_time[p] = \n         sum(i in 1..num_pieces) (\n              duration[rehearsal_order[i]] * bool2int(\n                                             i >= p_from[p] /\\ i <= p_to[p] \n                                             /\\\n                                             rehearsal[p,rehearsal_order[i]] = 0\n                                )\n     ) \n\n%      % alternative solution with exists. \n%      %  More elegant (= declarative) in my book but slower.\n%      exists(from, to in 1..num_pieces) ( \n%         % skipping rehearsal at start (don't come yet)\n%         forall(i in 1..from-1) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\\n%         % skipping rehearsal at end (go home after last rehearsal)\n%         forall(i in to+1..num_pieces) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\ % and now: count the waiting time for from..to\n%         waiting_time[p] = \n%             sum(i in from..to) (\n%                  duration[rehearsal_order[i]]*\n%                                  bool2int(\n%                                       rehearsal[p,rehearsal_order[i]] = 0\n%                                   )\n%          ) \n%      )\n\n\n  )\n\n  /\\ % symmetry breaking\n  rehearsal_order[1] < rehearsal_order[num_pieces]\n\n  % for all solutions\n  % /\\ total_waiting_time = 17\n;\n\n\n%\n% data\n%\n%\n% num_pieces = 9;\n% num_players = 5;\n% duration = [2, 4, 1, 3, 3, 2, 5, 7, 6];\n% rehearsal = array2d(1..num_players, 1..num_pieces, \n%     [\n%      1,1,0,1,0,1,1,0,1,\n%      1,1,0,1,1,1,0,1,0,\n%      1,1,0,0,0,0,1,1,0,\n%      1,0,0,0,1,1,0,0,1,\n%      0,0,1,0,1,1,1,1,0\n%   ]);\n\n%\n% This is the problem from the Choco v 2.1 example \n% num_pieces = 5;\n% num_players = 3;\n% duration = [4,6,3,5,7];\n% rehearsal =  array2d(1..num_players, 1..num_pieces, \n%         [\n%         1,1,0,1,0,\n%         0,1,1,0,1,\n%         1,1,0,1,1   \n%   ]);\n\n\noutput[\n  \"order: \" , show(rehearsal_order), \"\\n\",\n  \"waiting_time: \", show(waiting_time), \"\\n\",\n  \"total_waiting_time: \" , show(total_waiting_time), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(rehearsal[p, rehearsal_order[j]]) ++ \" \"\n  | p in 1..num_players, j in 1..num_pieces, \n] ++ \n[\"\\n\"]\n;\n\n"}, "hash": "811120198ae805787a96a80d0be61c712ab235147f7ffa7c4761733a34785219", "class_name": "RelatedNodeInfo"}}, "text": "Here is the explanation of the problem:\n\n**Name of the problem:** Scheduling a Rehearsal\n\n**What the problem is about in everyday terms:** Imagine you are the conductor of an orchestra, and you need to schedule a rehearsal for a concert. There are 9 pieces of music to be rehearsed, and 5 musicians will be participating. Each musician is required for some pieces, but not all. You want to find the best order to rehearse the pieces so that the musicians don't have to wait too long between their performances.\n\n**Main variables and what they mean:**\n\n* `rehearsal_order`: the order in which the pieces will be rehearsed\n* `waiting_time`: the time each musician spends waiting between their performances\n* `total_waiting_time`: the total time all musicians spend waiting\n\n**Basic restrictions or rules of the problem:**\n\n* Each musician can arrive at the rehearsal just before their first piece and leave just after their last piece.\n* Each piece has a specific duration (length of time it takes to rehearse).\n* The order of the pieces must be determined so that each musician's waiting time is minimized.\n\n**Goal of the problem:** Find the order of the pieces that minimizes the total waiting time for all musicians.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1217, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1fa23511-0c82-4a7f-b6d3-ab30be6c6ce5": {"__data__": {"id_": "1fa23511-0c82-4a7f-b6d3-ab30be6c6ce5", "embedding": null, "metadata": {"model_name": "restart", "source_code": "Model 1 : \n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n\nModel 2 :\n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_max, complete)\n      satisfy;\n\n\nModel 3 : \n\n\narray[1..10] of var 1..10:x;\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "restart_beginner", "node_type": "4", "metadata": {"model_name": "restart", "source_code": "Model 1 : \n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n\nModel 2 :\n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_max, complete)\n      satisfy;\n\n\nModel 3 : \n\n\narray[1..10] of var 1..10:x;\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n"}, "hash": "1438a5b185c6032538cd9238ea53b6ba3a872194f7c327c7fde7c21b9b696247", "class_name": "RelatedNodeInfo"}}, "text": "**The Problem of the Ten Variables**\n\nThis problem is about assigning numbers to ten variables in a special way.\n\n**Main Variables:**\n\nThe problem has ten variables, labeled x[1] to x[10]. Each variable can take a value between 1 and 10.\n\n**Basic Restrictions or Rules:**\n\nThe rules are:\n\n* Each variable must have a different value than the others.\n* The values of variables x[2] to x[10] cannot be more than 9.\n* The value of variable x[1] must be at least 9.\n\n**Goal of the Problem:**\n\nThe goal is to find a way to assign numbers to the variables that satisfy all the rules. In other words, we want to find a solution that makes all the variables happy!\n\nNote that the three models are slightly different, but they all represent the same problem. The differences are in how the problem is solved, not in what the problem is about.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 833, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "33c0583a-83a0-4e61-b9af-cfec4995b820": {"__data__": {"id_": "33c0583a-83a0-4e61-b9af-cfec4995b820", "embedding": null, "metadata": {"model_name": "RosteringProblem", "source_code": "include \"all_equal.mzn\";\ninclude \"global_cardinality.mzn\";\n\n% load parameters\ninclude \"parameters.dzn\";\n\nint: daysPerWeek = 7;\n\n% the number of weeks\nint: numberOfWeeks;\n\nint: numberOfDays = numberOfWeeks * daysPerWeek;\n\n% the minimum number of days in a row with the same shift\nint: s_min;\n\n% the maximum number of days in a row with the same shift\nint: s_max; \n\n% 3 shifts: early = 1, late = 2 and night shift = 3 + day off (rest day) = 0\nint: numberOfShifts = 3;\n\n% the shift requirement matrix, including at M_{i,j} the needed employees for day i and shift j\narray[1..daysPerWeek, 1..numberOfShifts+1] of int: shiftRequirements;\n\n\n% the variables X \narray[1..numberOfWeeks * daysPerWeek] of var 0..numberOfShifts: plan1d;\narray[1..numberOfWeeks,1..daysPerWeek] of var 0..numberOfShifts: plan2d;\narray[1..daysPerWeek,1..numberOfWeeks] of var 0..numberOfShifts: plan2dT;\n\n% helper arrays\narray[1..s_min,1..s_min] of var 0..numberOfShifts: s_min_arrays;\narray[1..s_max,1..s_max] of var 0..numberOfShifts: s_max_arrays;\n\n% convert the 2D plan into 1D\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan1d[(week-1) * daysPerWeek + day]\n           );  \n\n% transpose the 2D plan\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan2dT[day, week]\n           );\n\n% C_equalDays: constrains that weekend days (Saturday and Sunday) always have the same shift\nconstraint forall(week in 1..numberOfWeeks) (\n               plan2d[week, daysPerWeek - 1] == plan2d[week, daysPerWeek]\n           );                        \n\n                                                                                                                                \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_min, j in 1..s_min) (\n                 s_min_arrays[i, j] == plan1d[((numberOfDays - s_min - 1 + i + j) mod numberOfDays) + 1]\n           );                                            \n                                            \n% C_shiftRepetitions:for every shift type a minimum number of consecutive assignments to this shift is given\nconstraint forall(day in 1..numberOfDays - s_min) (\n               plan1d[day] != plan1d[day+1] -> all_equal(plan1d[day+1..day+s_min])\n           );     \n% the constraints over the array bounds           \nconstraint forall(d in 1..s_min) (\n               plan1d[d + numberOfDays - s_min] != plan1d[((d + numberOfDays - s_min) mod numberOfDays) +1] -> all_equal(s_min_arrays[d,1..s_min])\n           );                     \n\n           \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_max, j in 1..s_max) (\n                 s_max_arrays[i, j] == plan1d[((numberOfDays - s_max - 2 + i + j) mod numberOfDays) + 1]\n           );                      \n                                            \n% C_shiftRepetitions:for every shift type a maximum number of consecutive assignments to this shift is given           \nconstraint forall(day in 1..numberOfWeeks * daysPerWeek - s_max) (\n               (all_equal(plan1d[day..day+s_max])) -> (plan1d[day] != plan1d[day + s_max])\n           );               \n% the constraints over the array bounds             \nconstraint forall(d in 1..s_max) (\n               (all_equal(s_max_arrays[d, 1..s_max])) -> (plan1d[d + numberOfDays - s_max] != plan1d[d])\n           );                     \n\n                               \n                                                                                                   \n% C_restDays: at least 2 days must be rest days every 2 weeks.\nconstraint forall(day in 1..(numberOfWeeks - 2) * daysPerWeek) (\n               count(j in plan1d[day..day + daysPerWeek * 2])(j=0) >= 2                   \n           );            \nconstraint forall(i in 1..2 * daysPerWeek-1) (\n               count(j in plan1d[numberOfWeeks * daysPerWeek-i .. numberOfWeeks * daysPerWeek] ++ plan1d[1..2*daysPerWeek-i])(j=0) >= 2    \n           );         \n                                            \n% C_shiftOrder: restricts the order of shifts. There is a forward rotating principle. This means, that after an early shift there can only follow a shift with the same or a higher value, or a rest shift.\nconstraint forall(day in 2..numberOfWeeks * daysPerWeek - 1) (\n               plan1d[day] <= plan1d[day + 1] \\/ plan1d[day+1] == 0\n           );         \nconstraint plan1d[1] >= plan1d[numberOfDays] \\/ plan1d[1] == 0;\n                      \n% C_shiftRequirements: for every weekday for each shift the number of required staff is provided (e.g. usually less staff is required on the weekend) \nconstraint forall(day in 1..daysPerWeek) (\n              (global_cardinality(row(plan2dT,day),[0,1,2,3],row(shiftRequirements,day)))   \n           );    \n           \n% solve the problem           \nsolve :: int_search(plan1d, input_order, indomain_min, complete)\n      satisfy;           \n      \n% print the problem      \noutput [ show(row(plan2d,j)) ++ \"\\n\" | j in 1..numberOfWeeks ] ++ [\"\\n\"];      "}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "RosteringProblem_beginner", "node_type": "4", "metadata": {"model_name": "RosteringProblem", "source_code": "include \"all_equal.mzn\";\ninclude \"global_cardinality.mzn\";\n\n% load parameters\ninclude \"parameters.dzn\";\n\nint: daysPerWeek = 7;\n\n% the number of weeks\nint: numberOfWeeks;\n\nint: numberOfDays = numberOfWeeks * daysPerWeek;\n\n% the minimum number of days in a row with the same shift\nint: s_min;\n\n% the maximum number of days in a row with the same shift\nint: s_max; \n\n% 3 shifts: early = 1, late = 2 and night shift = 3 + day off (rest day) = 0\nint: numberOfShifts = 3;\n\n% the shift requirement matrix, including at M_{i,j} the needed employees for day i and shift j\narray[1..daysPerWeek, 1..numberOfShifts+1] of int: shiftRequirements;\n\n\n% the variables X \narray[1..numberOfWeeks * daysPerWeek] of var 0..numberOfShifts: plan1d;\narray[1..numberOfWeeks,1..daysPerWeek] of var 0..numberOfShifts: plan2d;\narray[1..daysPerWeek,1..numberOfWeeks] of var 0..numberOfShifts: plan2dT;\n\n% helper arrays\narray[1..s_min,1..s_min] of var 0..numberOfShifts: s_min_arrays;\narray[1..s_max,1..s_max] of var 0..numberOfShifts: s_max_arrays;\n\n% convert the 2D plan into 1D\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan1d[(week-1) * daysPerWeek + day]\n           );  \n\n% transpose the 2D plan\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan2dT[day, week]\n           );\n\n% C_equalDays: constrains that weekend days (Saturday and Sunday) always have the same shift\nconstraint forall(week in 1..numberOfWeeks) (\n               plan2d[week, daysPerWeek - 1] == plan2d[week, daysPerWeek]\n           );                        \n\n                                                                                                                                \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_min, j in 1..s_min) (\n                 s_min_arrays[i, j] == plan1d[((numberOfDays - s_min - 1 + i + j) mod numberOfDays) + 1]\n           );                                            \n                                            \n% C_shiftRepetitions:for every shift type a minimum number of consecutive assignments to this shift is given\nconstraint forall(day in 1..numberOfDays - s_min) (\n               plan1d[day] != plan1d[day+1] -> all_equal(plan1d[day+1..day+s_min])\n           );     \n% the constraints over the array bounds           \nconstraint forall(d in 1..s_min) (\n               plan1d[d + numberOfDays - s_min] != plan1d[((d + numberOfDays - s_min) mod numberOfDays) +1] -> all_equal(s_min_arrays[d,1..s_min])\n           );                     \n\n           \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_max, j in 1..s_max) (\n                 s_max_arrays[i, j] == plan1d[((numberOfDays - s_max - 2 + i + j) mod numberOfDays) + 1]\n           );                      \n                                            \n% C_shiftRepetitions:for every shift type a maximum number of consecutive assignments to this shift is given           \nconstraint forall(day in 1..numberOfWeeks * daysPerWeek - s_max) (\n               (all_equal(plan1d[day..day+s_max])) -> (plan1d[day] != plan1d[day + s_max])\n           );               \n% the constraints over the array bounds             \nconstraint forall(d in 1..s_max) (\n               (all_equal(s_max_arrays[d, 1..s_max])) -> (plan1d[d + numberOfDays - s_max] != plan1d[d])\n           );                     \n\n                               \n                                                                                                   \n% C_restDays: at least 2 days must be rest days every 2 weeks.\nconstraint forall(day in 1..(numberOfWeeks - 2) * daysPerWeek) (\n               count(j in plan1d[day..day + daysPerWeek * 2])(j=0) >= 2                   \n           );            \nconstraint forall(i in 1..2 * daysPerWeek-1) (\n               count(j in plan1d[numberOfWeeks * daysPerWeek-i .. numberOfWeeks * daysPerWeek] ++ plan1d[1..2*daysPerWeek-i])(j=0) >= 2    \n           );         \n                                            \n% C_shiftOrder: restricts the order of shifts. There is a forward rotating principle. This means, that after an early shift there can only follow a shift with the same or a higher value, or a rest shift.\nconstraint forall(day in 2..numberOfWeeks * daysPerWeek - 1) (\n               plan1d[day] <= plan1d[day + 1] \\/ plan1d[day+1] == 0\n           );         \nconstraint plan1d[1] >= plan1d[numberOfDays] \\/ plan1d[1] == 0;\n                      \n% C_shiftRequirements: for every weekday for each shift the number of required staff is provided (e.g. usually less staff is required on the weekend) \nconstraint forall(day in 1..daysPerWeek) (\n              (global_cardinality(row(plan2dT,day),[0,1,2,3],row(shiftRequirements,day)))   \n           );    \n           \n% solve the problem           \nsolve :: int_search(plan1d, input_order, indomain_min, complete)\n      satisfy;           \n      \n% print the problem      \noutput [ show(row(plan2d,j)) ++ \"\\n\" | j in 1..numberOfWeeks ] ++ [\"\\n\"];      "}, "hash": "671a0a76a6b0e0cf1162c47986b57bc8cc265a27c7d9696027508a30e719fd67", "class_name": "RelatedNodeInfo"}}, "text": "**Nurse Scheduling Problem**\n\nThis problem is about creating a schedule for nurses to work in a hospital. Imagine you are the person in charge of making sure there are enough nurses working each day to take care of patients.\n\n**Main Variables:**\n\n* `plan1d`, `plan2d`, and `plan2dT`: These are arrays that represent the schedule of nurses. They show which shift each nurse is working on each day (early, late, night, or day off).\n* `shiftRequirements`: This is a matrix that shows how many nurses are needed for each shift on each day of the week.\n* `s_min` and `s_max`: These are the minimum and maximum number of days in a row that a nurse can work the same shift.\n\n**Basic Restrictions or Rules:**\n\n* Nurses need to work a certain number of days in a row with the same shift (between `s_min` and `s_max` days).\n* Weekend days (Saturday and Sunday) must have the same shift.\n* There must be at least 2 rest days every 2 weeks.\n* The order of shifts follows a rotating principle (e.g., after an early shift, the next shift can only be the same or a higher value, or a rest shift).\n* The number of nurses working each shift must meet the required staff numbers for that day.\n\n**Goal:**\n\nThe goal is to create a schedule that satisfies all these rules and restrictions, while also making sure that the hospital has enough nurses working each day to take care of patients.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1370, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "66065360-9a68-4de1-858a-3771ed922ed0": {"__data__": {"id_": "66065360-9a68-4de1-858a-3771ed922ed0", "embedding": null, "metadata": {"model_name": "sb", "source_code": "% Solitaire Battleships is a puzzle where\n% we are given a partially filled in board and the number\n% of ships in each row and column and have to fill it with ships\n \n% \"Improved\" version does not introduce reified set_in\n\nint: width;   % height of board (usually 10)\nint: height;  % width of board (usually 10)\nint: maxship; % maximal length of ship (usually 4)\n\n\nset of int: ROWS = 1..width;\nset of int: COLS = 1..height;\nset of int: XROWS = 0..width+1;    % extended rows\nset of int: XCOLS = 0..height+1;   % extended cols\n\n%% ship types enumerated type\nset of int: SHIPS = 1..maxship;  % different ship types\nint: submarine = 1;\nint: destroyer = 2;\nint: cruiser = 3;\nint: battleship = 4;\n\n\n%% the PIECES enumerated type!\nset of int: PIECES = 1..7;\nint: w = 1; % water\nint: c = 2; % circle (submarine)\nint: l = 3; % left end of ship\nint: r = 4; % right end of ship\nint: t = 5; % top of ship\nint: b = 6; % bottom of ship\nint: m = 7; % middle of ship\narray[PIECES] of string: code = [\".\",\"c\",\"l\",\"r\",\"t\",\"b\",\"m\"];\n\narray[ROWS,COLS] of 0..7: hint; % the initial board configuration\narray[ROWS] of int: rowsum;     % sums for each row\narray[COLS] of int: colsum;     % sums for each col\narray[SHIPS] of int: ship; % the number of each type of ship (usually [4,3,2,1]).\n\n\n\n% variables \narray[XROWS,XCOLS] of var PIECES: board;  % the board\n \narray[XROWS,XCOLS] of var 0..1: fill;     % which pieces are ships\n\narray[PIECES] of var 0..width*height: npiece; % number of pieces of each type\n\n\n% model\n\n% ensure hints are respected\nconstraint forall(i in ROWS, j in COLS)(\n\t\t\t   if hint[i,j] != 0 then\n\t\t\t   \t\tboard[i,j] == hint[i,j]\n\t\t\t   else true endif\n\t       ); \n\n% make extended rows and cols empty\nconstraint forall(i in XROWS)(board[i,0] == w /\\ board[i,width+1] == w);\nconstraint forall(j in COLS)(board[0,j] == w /\\ board[height+1,j] == w);\n\n% ensure that the fill array matches the board\nconstraint forall(i in XROWS, j in XCOLS)(\n\t\t\t   fill[i,j] = bool2int(board[i,j] != w)\n\t       ); \n\n% spacing constraints: gaps betwen ships\nconstraint forall(i in ROWS, j in COLS)(\n\t   (board[i,j] == w \\/ board[i+1,j+1] == w)\n\t/\\ (board[i,j] == w \\/ board[i+1,j-1] == w)   % diagonal constraints\n            /\\ (board[i,j] in {c,l,r,t} -> board[i-1,j] == w)\n            /\\ (board[i,j] in {c,l,r,b} -> board[i+1,j] == w)\n            /\\ (board[i,j] in {c,l,t,b} -> board[i,j-1] == w)\n            /\\ (board[i,j] in {c,r,t,b} -> board[i,j+1] == w)\n           );\n               \t\t\t                       \n% ship shape constraints\nconstraint forall(i in ROWS, j in COLS)(\n               %% a left piece needs a right piece or middle to the right\n\t\t\t   (board[i,j] == l -> (board[i,j+1] == r \\/ board[i,j+1] == m))\n\t\t\t/\\ (board[i,j] == r -> (board[i,j-1] == l \\/ board[i,j-1] == m))\n\t\t\t/\\ (board[i,j] == t -> (board[i+1,j] == b \\/ board[i+1,j] == m))\n\t\t\t/\\ (board[i,j] == b -> (board[i-1,j] == t \\/ board[i-1,j] == m))\n\t\t\t   %% a middle piece has to have two opposite sides filled\n\t\t\t/\\ (board[i,j] == m -> (   fill[i-1,j] == fill[i+1,j]\n\t\t\t                        /\\ fill[i,j-1] == fill[i,j+1]\n\t\t\t                        /\\ fill[i-1,j] + fill[i,j-1] == 1))\n\t\t   );\n\t\t   \n% sum up pieces\nconstraint forall(p in PIECES)(\n\t\t\t   sum(i in ROWS, j in COLS)(bool2int(board[i,j] == p)) == npiece[p]\n\t\t   );\n\n% piece sum constraints\nconstraint npiece[c] == ship[submarine]; % submarines\nconstraint npiece[l] == npiece[r]; % left right (probably redundant)\nconstraint npiece[t] == npiece[b]; % top bottom\nconstraint npiece[l] + npiece[t] == sum(s in destroyer..maxship)(ship[s]); \n                                   % no of ends\nconstraint npiece[m] == sum(s in cruiser..maxship)(ship[s] * (s - 2)); \n                                   % no of middles \t\t   \n\t\t    \n% count number of bigger ships\n% at least for standard battleships you can probably simply\n% enforce this constraint for s in destroyer..destroyer\t\t\n% and still be guaranteed a correct solution    \nconstraint forall(s in destroyer..maxship)(\n\t           sum(i in ROWS,j in COLS)(bool2int(\n\t\t\t       if j + s - 1 <= width then\n\t\t\t          board[i,j] == l /\\ board[i,j+s-1] == r     % ship length s lr\n\t\t\t       /\\ forall(k in j+1..j+s-2)(board[i,k] == m)\n\t\t\t       else false endif\n\t\t\t    \\/\n\t\t\t       if i + s - 1 <= height then\n\t\t\t          board[i,j] == t /\\ board[i+s-1,j] == b     % ship length s tb\n\t\t\t       /\\ forall(k in i+1..i+s-2)(board[k,j] == m)\n\t\t\t       else false endif\n\t\t       )) = ship[s]\n\t\t   );\t\t    \n\t\t    \t\t    \n\n% row sums respected\nconstraint forall(i in ROWS)(\n               sum(j in COLS)(fill[i,j]) == rowsum[i]\n           );\n           \n% column sums respected           \nconstraint forall(j in COLS)(\n               sum(i in ROWS)(fill[i,j]) == colsum[j]\n           );           \n\n\nsolve :: int_search([ fill[i,j] | i in ROWS, j in COLS], \n      \t\t  input_order, indomain_min, complete)\n      satisfy;\n\noutput [ code[fix(board[i,j])] ++ \n\t\t if j == width then \" \" ++ show(rowsum[i]) ++ \"\\n\"\n\t\t else \"\" endif\n\t   | i in ROWS, j in COLS ]  ++\n\t   [ show(colsum[j]) | j in COLS ] ++ [\"\\n\"];\n\t   \n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sb_beginner", "node_type": "4", "metadata": {"model_name": "sb", "source_code": "% Solitaire Battleships is a puzzle where\n% we are given a partially filled in board and the number\n% of ships in each row and column and have to fill it with ships\n \n% \"Improved\" version does not introduce reified set_in\n\nint: width;   % height of board (usually 10)\nint: height;  % width of board (usually 10)\nint: maxship; % maximal length of ship (usually 4)\n\n\nset of int: ROWS = 1..width;\nset of int: COLS = 1..height;\nset of int: XROWS = 0..width+1;    % extended rows\nset of int: XCOLS = 0..height+1;   % extended cols\n\n%% ship types enumerated type\nset of int: SHIPS = 1..maxship;  % different ship types\nint: submarine = 1;\nint: destroyer = 2;\nint: cruiser = 3;\nint: battleship = 4;\n\n\n%% the PIECES enumerated type!\nset of int: PIECES = 1..7;\nint: w = 1; % water\nint: c = 2; % circle (submarine)\nint: l = 3; % left end of ship\nint: r = 4; % right end of ship\nint: t = 5; % top of ship\nint: b = 6; % bottom of ship\nint: m = 7; % middle of ship\narray[PIECES] of string: code = [\".\",\"c\",\"l\",\"r\",\"t\",\"b\",\"m\"];\n\narray[ROWS,COLS] of 0..7: hint; % the initial board configuration\narray[ROWS] of int: rowsum;     % sums for each row\narray[COLS] of int: colsum;     % sums for each col\narray[SHIPS] of int: ship; % the number of each type of ship (usually [4,3,2,1]).\n\n\n\n% variables \narray[XROWS,XCOLS] of var PIECES: board;  % the board\n \narray[XROWS,XCOLS] of var 0..1: fill;     % which pieces are ships\n\narray[PIECES] of var 0..width*height: npiece; % number of pieces of each type\n\n\n% model\n\n% ensure hints are respected\nconstraint forall(i in ROWS, j in COLS)(\n\t\t\t   if hint[i,j] != 0 then\n\t\t\t   \t\tboard[i,j] == hint[i,j]\n\t\t\t   else true endif\n\t       ); \n\n% make extended rows and cols empty\nconstraint forall(i in XROWS)(board[i,0] == w /\\ board[i,width+1] == w);\nconstraint forall(j in COLS)(board[0,j] == w /\\ board[height+1,j] == w);\n\n% ensure that the fill array matches the board\nconstraint forall(i in XROWS, j in XCOLS)(\n\t\t\t   fill[i,j] = bool2int(board[i,j] != w)\n\t       ); \n\n% spacing constraints: gaps betwen ships\nconstraint forall(i in ROWS, j in COLS)(\n\t   (board[i,j] == w \\/ board[i+1,j+1] == w)\n\t/\\ (board[i,j] == w \\/ board[i+1,j-1] == w)   % diagonal constraints\n            /\\ (board[i,j] in {c,l,r,t} -> board[i-1,j] == w)\n            /\\ (board[i,j] in {c,l,r,b} -> board[i+1,j] == w)\n            /\\ (board[i,j] in {c,l,t,b} -> board[i,j-1] == w)\n            /\\ (board[i,j] in {c,r,t,b} -> board[i,j+1] == w)\n           );\n               \t\t\t                       \n% ship shape constraints\nconstraint forall(i in ROWS, j in COLS)(\n               %% a left piece needs a right piece or middle to the right\n\t\t\t   (board[i,j] == l -> (board[i,j+1] == r \\/ board[i,j+1] == m))\n\t\t\t/\\ (board[i,j] == r -> (board[i,j-1] == l \\/ board[i,j-1] == m))\n\t\t\t/\\ (board[i,j] == t -> (board[i+1,j] == b \\/ board[i+1,j] == m))\n\t\t\t/\\ (board[i,j] == b -> (board[i-1,j] == t \\/ board[i-1,j] == m))\n\t\t\t   %% a middle piece has to have two opposite sides filled\n\t\t\t/\\ (board[i,j] == m -> (   fill[i-1,j] == fill[i+1,j]\n\t\t\t                        /\\ fill[i,j-1] == fill[i,j+1]\n\t\t\t                        /\\ fill[i-1,j] + fill[i,j-1] == 1))\n\t\t   );\n\t\t   \n% sum up pieces\nconstraint forall(p in PIECES)(\n\t\t\t   sum(i in ROWS, j in COLS)(bool2int(board[i,j] == p)) == npiece[p]\n\t\t   );\n\n% piece sum constraints\nconstraint npiece[c] == ship[submarine]; % submarines\nconstraint npiece[l] == npiece[r]; % left right (probably redundant)\nconstraint npiece[t] == npiece[b]; % top bottom\nconstraint npiece[l] + npiece[t] == sum(s in destroyer..maxship)(ship[s]); \n                                   % no of ends\nconstraint npiece[m] == sum(s in cruiser..maxship)(ship[s] * (s - 2)); \n                                   % no of middles \t\t   \n\t\t    \n% count number of bigger ships\n% at least for standard battleships you can probably simply\n% enforce this constraint for s in destroyer..destroyer\t\t\n% and still be guaranteed a correct solution    \nconstraint forall(s in destroyer..maxship)(\n\t           sum(i in ROWS,j in COLS)(bool2int(\n\t\t\t       if j + s - 1 <= width then\n\t\t\t          board[i,j] == l /\\ board[i,j+s-1] == r     % ship length s lr\n\t\t\t       /\\ forall(k in j+1..j+s-2)(board[i,k] == m)\n\t\t\t       else false endif\n\t\t\t    \\/\n\t\t\t       if i + s - 1 <= height then\n\t\t\t          board[i,j] == t /\\ board[i+s-1,j] == b     % ship length s tb\n\t\t\t       /\\ forall(k in i+1..i+s-2)(board[k,j] == m)\n\t\t\t       else false endif\n\t\t       )) = ship[s]\n\t\t   );\t\t    \n\t\t    \t\t    \n\n% row sums respected\nconstraint forall(i in ROWS)(\n               sum(j in COLS)(fill[i,j]) == rowsum[i]\n           );\n           \n% column sums respected           \nconstraint forall(j in COLS)(\n               sum(i in ROWS)(fill[i,j]) == colsum[j]\n           );           \n\n\nsolve :: int_search([ fill[i,j] | i in ROWS, j in COLS], \n      \t\t  input_order, indomain_min, complete)\n      satisfy;\n\noutput [ code[fix(board[i,j])] ++ \n\t\t if j == width then \" \" ++ show(rowsum[i]) ++ \"\\n\"\n\t\t else \"\" endif\n\t   | i in ROWS, j in COLS ]  ++\n\t   [ show(colsum[j]) | j in COLS ] ++ [\"\\n\"];\n\t   \n"}, "hash": "014ccd57225cba5dc2b37a9b49534bd86902056b3ae8747d606d4859ddd5a85b", "class_name": "RelatedNodeInfo"}}, "text": "**Solitaire Battleships**\n\n**What is it about?**\nImagine you have a puzzle with a partially filled grid, and you need to fill in the rest of the grid with ships of different lengths. You are given the number of ships of each length and the number of ships in each row and column.\n\n**Main variables:**\n\n* `board`: a grid that represents the puzzle, where each cell can be a ship part (like a submarine, left end, right end, etc.) or water.\n* `fill`: a grid that shows which cells are part of a ship.\n* `npiece`: the number of each type of ship part (like submarines, left ends, etc.).\n\n**Basic restrictions or rules:**\n\n* The puzzle must respect the given hints (initially filled cells).\n* Ships cannot touch each other (there must be water between them).\n* Each ship must have the correct number of parts (like left and right ends, middle parts, etc.).\n* The number of ships in each row and column must match the given sums.\n\n**Goal:**\nThe goal is to find a solution that satisfies all the rules and restrictions, and then output the completed puzzle grid with the ship parts and the row and column sums.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1104, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ecb368d1-bdc9-4943-abd1-98993d615941": {"__data__": {"id_": "ecb368d1-bdc9-4943-abd1-98993d615941", "embedding": null, "metadata": {"model_name": "schur", "source_code": "%% schurs numbers\n%%\n%% determine if n balls labelled 1..n\n%% can be placed in c boxes with no box containing a triple {x,y,z} where x+y=z\n \n\nint: n; %% number of balls\nint: c; %% number of boxes\n\narray[1..n] of var 1..c: box;\n\nconstraint forall(i in 1..n-1, j in i+1 .. n - i)(\n\t   \t    box[i] != box[j] \\/ \n\t\t    box[i] != box[i+j] \\/ \n\t\t    box[j] != box[i+j]);\n\nsolve satisfy;\n\noutput [\"n = \", show(n), \";\\nc = \", show(c), \";\\nbox = \",show(box),\";\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "schur_beginner", "node_type": "4", "metadata": {"model_name": "schur", "source_code": "%% schurs numbers\n%%\n%% determine if n balls labelled 1..n\n%% can be placed in c boxes with no box containing a triple {x,y,z} where x+y=z\n \n\nint: n; %% number of balls\nint: c; %% number of boxes\n\narray[1..n] of var 1..c: box;\n\nconstraint forall(i in 1..n-1, j in i+1 .. n - i)(\n\t   \t    box[i] != box[j] \\/ \n\t\t    box[i] != box[i+j] \\/ \n\t\t    box[j] != box[i+j]);\n\nsolve satisfy;\n\noutput [\"n = \", show(n), \";\\nc = \", show(c), \";\\nbox = \",show(box),\";\\n\"];\n"}, "hash": "cce2eb1263c459da0c6ef9cf6f3d207242355147604814e2089be43b76a01a5f", "class_name": "RelatedNodeInfo"}}, "text": "Schur's Numbers Problem\n\nThis problem is about distributing balls into boxes in a special way. Imagine you have a certain number of balls, each with a unique label from 1 to n, and you want to put them into a certain number of boxes.\n\nThe main variables are:\n- n: the number of balls\n- c: the number of boxes\n- box: an array that shows which box each ball goes into\n\nThe basic restrictions or rules of the problem are:\n- Each ball must go into a box\n- No box can contain three balls with labels that add up to each other (for example, balls 1, 2, and 3 cannot be in the same box because 1+2=3)\n\nThe goal of the problem is to find a way to distribute the balls into the boxes that follows these rules.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 700, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fd722d73-a7df-40ae-acad-097c1f2b071b": {"__data__": {"id_": "fd722d73-a7df-40ae-acad-097c1f2b071b", "embedding": null, "metadata": {"model_name": "setselect", "source_code": "Model 1 :\n\n\n% setselect\nint: n; % number of elements\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 2 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\nconstraint card(x) = u;\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 3 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 1..n: x;\n%constraint forall(i in 1..u-1)(x[i] < x[i+1]);\nconstraint forall(i,j in 1..u where i < j)(x[i] != x[j]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 4 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality bound of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 0..n: x;\nconstraint forall(i in 1..u-1)(x[i] >= (x[i] != 0) + x[i+1]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "setselect_beginner", "node_type": "4", "metadata": {"model_name": "setselect", "source_code": "Model 1 :\n\n\n% setselect\nint: n; % number of elements\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 2 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\nconstraint card(x) = u;\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 3 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 1..n: x;\n%constraint forall(i in 1..u-1)(x[i] < x[i+1]);\nconstraint forall(i,j in 1..u where i < j)(x[i] != x[j]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 4 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality bound of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 0..n: x;\nconstraint forall(i in 1..u-1)(x[i] >= (x[i] != 0) + x[i+1]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n"}, "hash": "64d8e7ef9e6f508632fd48729b9ea9818a944f23ddeec3a3958f4d3495b8cca7", "class_name": "RelatedNodeInfo"}}, "text": "**The Set Selection Problem**\n\n**What is it about?**\nImagine you have a bunch of items, and you want to choose a few of them. These items are grouped into smaller sets, and you have some rules to follow when making your selection.\n\n**Main variables:**\n\n* `n`: The total number of items.\n* `k`: The number of smaller sets that the items are grouped into.\n* `s`: The smaller sets themselves, each containing some of the items.\n* `x`: The selection of items you want to choose.\n\n**Basic restrictions or rules:**\n\n* You can only choose one item from each smaller set.\n* The total number of items you choose is limited (this limit is `u` in some models).\n\n**Goal:**\nThe goal is to choose the items that add up to the largest total value. In other words, you want to maximize the sum of the items you select.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 802, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "637dda26-d408-49a9-87c8-266900b61ac3": {"__data__": {"id_": "637dda26-d408-49a9-87c8-266900b61ac3", "embedding": null, "metadata": {"model_name": "shipping", "source_code": "int: W; % number of Warehousse\nset of int: WARE = 1..W;\nint: F; % number of Factories\nset of int: FACT = 1..F;\n\narray[WARE] of int: demand;\narray[FACT] of int: production;\n\narray[FACT,WARE] of int: cost;\n\narray[FACT,WARE] of var int: ship;\n\n%int: m = max(demand);\n%array[FACT,WARE] of var 0..m: ship;\nconstraint forall(f in FACT, w in WARE)(ship[f,w] >= 0);\n\nconstraint forall(w in WARE)\n                 (sum(f in FACT)(ship[f,w]) >= demand[w]);\n\nconstraint forall(f in FACT)\n                 (sum(w in WARE)(ship[f,w]) <= production[f]);\n\nsolve minimize sum(f in FACT, w in WARE)\n                  (cost[f,w]*ship[f,w]);\n\n\noutput [ show_int(2,ship[f,w]) ++\n         if w == W then \"\\n\" else \" \" endif\n       | f in FACT, w in WARE ];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "shipping_beginner", "node_type": "4", "metadata": {"model_name": "shipping", "source_code": "int: W; % number of Warehousse\nset of int: WARE = 1..W;\nint: F; % number of Factories\nset of int: FACT = 1..F;\n\narray[WARE] of int: demand;\narray[FACT] of int: production;\n\narray[FACT,WARE] of int: cost;\n\narray[FACT,WARE] of var int: ship;\n\n%int: m = max(demand);\n%array[FACT,WARE] of var 0..m: ship;\nconstraint forall(f in FACT, w in WARE)(ship[f,w] >= 0);\n\nconstraint forall(w in WARE)\n                 (sum(f in FACT)(ship[f,w]) >= demand[w]);\n\nconstraint forall(f in FACT)\n                 (sum(w in WARE)(ship[f,w]) <= production[f]);\n\nsolve minimize sum(f in FACT, w in WARE)\n                  (cost[f,w]*ship[f,w]);\n\n\noutput [ show_int(2,ship[f,w]) ++\n         if w == W then \"\\n\" else \" \" endif\n       | f in FACT, w in WARE ];"}, "hash": "efbd57e190623ca55b6fe63b313933ee21d10ef3fb35b669c7fa8d94bc0e3950", "class_name": "RelatedNodeInfo"}}, "text": "**Problem Name:** Warehouse-Factories Shipping Problem\n\n**What the problem is about:** Imagine you have several warehouses that need certain amounts of goods, and several factories that can produce those goods. You need to decide how much of each good to ship from each factory to each warehouse, so that each warehouse gets what it needs, and each factory doesn't produce more than it can. You also want to minimize the total cost of shipping.\n\n**Main variables:**\n\n* `W`: The number of warehouses.\n* `F`: The number of factories.\n* `demand`: An array that says how much of each good each warehouse needs.\n* `production`: An array that says how much of each good each factory can produce.\n* `cost`: An array that says how much it costs to ship one unit of each good from each factory to each warehouse.\n* `ship`: An array that says how much of each good to ship from each factory to each warehouse.\n\n**Basic restrictions or rules:**\n\n* Each warehouse must get at least as much of each good as it needs.\n* Each factory can't produce more than it can.\n* You can't ship a negative amount of goods.\n\n**Goal:** Minimize the total cost of shipping goods from factories to warehouses.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1178, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d6cd7afd-542d-432f-b437-8df56bb85bf7": {"__data__": {"id_": "d6cd7afd-542d-432f-b437-8df56bb85bf7", "embedding": null, "metadata": {"model_name": "simple-prod-planning", "source_code": "% Number of different products\nint: nproducts; \nset of int: Products = 1..nproducts;  \n\n%profit per unit for each product\narray[Products] of int: profit;\narray[Products] of string: pname; \n\n%Number of resources\nint: nresources; \nset of int: Resources = 1..nresources; \n\n%amount of each resource available\narray[Resources] of int: capacity; \narray[Resources] of string: rname;\n\n%units of each resource required to produce 1 unit of product\narray[Products, Resources] of int: consumption; \nconstraint assert(forall (r in Resources, p in Products) \n           (consumption[p,r] >= 0), \"Error: negative consumption\");\n\n% bound on number of Products\nint: mproducts = max (p in Products) \n                     (min (r in Resources where consumption[p,r] > 0) \n                          (capacity[r] div consumption[p,r]));\n\n% Variables: how much should we make of each product\narray[Products] of var 0..mproducts: produce;\narray[Resources] of var 0..max(capacity): used;\n\n% Production cannot use more than the available Resources:\nconstraint forall (r in Resources) (     \n      used[r] = sum (p in Products)(consumption[p, r] * produce[p]) \n      /\\ used[r] <= capacity[r]\n);    \n\n% Maximize profit\nsolve maximize sum (p in Products) (profit[p]*produce[p]);\n\noutput [ show(pname[p]) ++ \" = \" ++ show(produce[p]) ++ \";\\n\" |\n         p in Products ] ++\n       [ show(rname[r]) ++ \" = \" ++ show(used[r]) ++ \";\\n\" |\n         r in Resources ];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "simple-prod-planning_beginner", "node_type": "4", "metadata": {"model_name": "simple-prod-planning", "source_code": "% Number of different products\nint: nproducts; \nset of int: Products = 1..nproducts;  \n\n%profit per unit for each product\narray[Products] of int: profit;\narray[Products] of string: pname; \n\n%Number of resources\nint: nresources; \nset of int: Resources = 1..nresources; \n\n%amount of each resource available\narray[Resources] of int: capacity; \narray[Resources] of string: rname;\n\n%units of each resource required to produce 1 unit of product\narray[Products, Resources] of int: consumption; \nconstraint assert(forall (r in Resources, p in Products) \n           (consumption[p,r] >= 0), \"Error: negative consumption\");\n\n% bound on number of Products\nint: mproducts = max (p in Products) \n                     (min (r in Resources where consumption[p,r] > 0) \n                          (capacity[r] div consumption[p,r]));\n\n% Variables: how much should we make of each product\narray[Products] of var 0..mproducts: produce;\narray[Resources] of var 0..max(capacity): used;\n\n% Production cannot use more than the available Resources:\nconstraint forall (r in Resources) (     \n      used[r] = sum (p in Products)(consumption[p, r] * produce[p]) \n      /\\ used[r] <= capacity[r]\n);    \n\n% Maximize profit\nsolve maximize sum (p in Products) (profit[p]*produce[p]);\n\noutput [ show(pname[p]) ++ \" = \" ++ show(produce[p]) ++ \";\\n\" |\n         p in Products ] ++\n       [ show(rname[r]) ++ \" = \" ++ show(used[r]) ++ \";\\n\" |\n         r in Resources ];"}, "hash": "93ec4cf07cc5e4c1c8345b163b475e50582968012d99f5ac23f48bcb9c40f570", "class_name": "RelatedNodeInfo"}}, "text": "**Problem Name:** Product Production Planning\n\n**What the problem is about:** Imagine you have a factory that produces different products, like toys, clothes, or food. You have limited resources, like machines, workers, and raw materials, to make these products. You want to decide how many units of each product to produce to make the most profit possible.\n\n**Main variables:**\n\n* `produce`: how many units of each product to make\n* `used`: how much of each resource is used to make the products\n\n**Basic restrictions or rules:**\n\n* You can't use more resources than you have available\n* You need a certain amount of each resource to make one unit of each product\n* You can't make a negative amount of any product\n\n**Goal:** Maximize the total profit by deciding how many units of each product to produce, while following the rules and restrictions.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 850, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c87d1b40-6f8d-434a-a974-cfa2650d8420": {"__data__": {"id_": "c87d1b40-6f8d-434a-a974-cfa2650d8420", "embedding": null, "metadata": {"model_name": "sonet_problem", "source_code": "% The SONET problem is a network design problem: set up a network between\n% n nodes, where only certain nodes require a connection.\n% Nodes are connected by putting them on a ring, where all nodes\n% on a ring can communicate. Putting a node on a ring requires a so-called\n% ADM, and each ring has a capacity of nodes, i.e. ADMs. There is a certain\n% amount of rings, r, that is available. The objective is to set up a network\n% by using a minimal amount of ADMs.\n%\n%\n% About the problem model\n%\n% The problem model has the amount of rings ('r'), amount of nodes('n'),\n% the 'demand' (which nodes require communication) and node-capacity of each\n% ring ('capacity_nodes') as parameters.\n% The assignement of nodes to rings is modelled by a 2-dimensional matrix 'rings',\n% indexed by the amnount of rings and nodes. The matrix-domain is boolean:\n% If the node in column j is assigned to the ring in row i, then rings[i,j] = 1\n% and 0 otherwise. So all the '1's in the matrix 'rings' stand for an ADM.\n% Hence the objective is to minimise the sum over all columns and rows of matrix\n% 'rings'.\n% \"\"\"\n\nint: r;  % upper bound for amount of rings\nint: n;  % amount of clients\n\n\n% original comment: \n% we have double entries here because of the symmetric structure!\narray[1..n, 1..n] of 0..1: demand;\narray[1..r] of 1..n: capacity_nodes;\n\narray[1..r, 1..n] of var 0..1: rings;\nvar int: z =  sum(ring in 1..r, client in 1..n) (rings[ring, client]);\n\nsolve minimize z;\n% solve satisfy;\n\n\nconstraint\n%   z <= 7 % for solve satisfy\n%   /\\\n\n   % original comment:\n   % if there is a demand between 2 nodes, then there has to exist \n   % a ring, on which they are both installed\n   forall(client1,client2 in 1..n where client1 < client2) (\n      (demand[client1,client2] = 1) ->\n           exists(ring in 1..r) (\n                 rings[ring,client1] + rings[ring, client2] >= 2\n           )\n   )   \n   /\\\n   % original comment:\n   % capacity of each ring must not be exceeded     \n   forall(ring in 1..r) (\n        sum(client in 1..n) (\n              rings[ring, client]\n              ) <= capacity_nodes[ring] \n   )\n;\n\n\n%\n% data\n% (sonet_problem1nu.param)\n%\nr = 4;\nn = 5;\n\ndemand =\narray2d(1..n, 1..n,\n        [0,1,0,1,0,\n         1,0,1,0,0,\n         0,1,0,0,1,\n         1,0,0,0,0,\n         0,0,1,0,0])\n;\n\ncapacity_nodes = [3,2,2,1];\n\n\noutput \n[\n  \"z: \", show(z)\n] ++\n[\n  if client = 1 then \"\\n\" else \" \" endif ++\n    show(rings[ring, client])\n  | ring in 1..r, client in 1..n\n] ++ [\"\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sonet_problem_beginner", "node_type": "4", "metadata": {"model_name": "sonet_problem", "source_code": "% The SONET problem is a network design problem: set up a network between\n% n nodes, where only certain nodes require a connection.\n% Nodes are connected by putting them on a ring, where all nodes\n% on a ring can communicate. Putting a node on a ring requires a so-called\n% ADM, and each ring has a capacity of nodes, i.e. ADMs. There is a certain\n% amount of rings, r, that is available. The objective is to set up a network\n% by using a minimal amount of ADMs.\n%\n%\n% About the problem model\n%\n% The problem model has the amount of rings ('r'), amount of nodes('n'),\n% the 'demand' (which nodes require communication) and node-capacity of each\n% ring ('capacity_nodes') as parameters.\n% The assignement of nodes to rings is modelled by a 2-dimensional matrix 'rings',\n% indexed by the amnount of rings and nodes. The matrix-domain is boolean:\n% If the node in column j is assigned to the ring in row i, then rings[i,j] = 1\n% and 0 otherwise. So all the '1's in the matrix 'rings' stand for an ADM.\n% Hence the objective is to minimise the sum over all columns and rows of matrix\n% 'rings'.\n% \"\"\"\n\nint: r;  % upper bound for amount of rings\nint: n;  % amount of clients\n\n\n% original comment: \n% we have double entries here because of the symmetric structure!\narray[1..n, 1..n] of 0..1: demand;\narray[1..r] of 1..n: capacity_nodes;\n\narray[1..r, 1..n] of var 0..1: rings;\nvar int: z =  sum(ring in 1..r, client in 1..n) (rings[ring, client]);\n\nsolve minimize z;\n% solve satisfy;\n\n\nconstraint\n%   z <= 7 % for solve satisfy\n%   /\\\n\n   % original comment:\n   % if there is a demand between 2 nodes, then there has to exist \n   % a ring, on which they are both installed\n   forall(client1,client2 in 1..n where client1 < client2) (\n      (demand[client1,client2] = 1) ->\n           exists(ring in 1..r) (\n                 rings[ring,client1] + rings[ring, client2] >= 2\n           )\n   )   \n   /\\\n   % original comment:\n   % capacity of each ring must not be exceeded     \n   forall(ring in 1..r) (\n        sum(client in 1..n) (\n              rings[ring, client]\n              ) <= capacity_nodes[ring] \n   )\n;\n\n\n%\n% data\n% (sonet_problem1nu.param)\n%\nr = 4;\nn = 5;\n\ndemand =\narray2d(1..n, 1..n,\n        [0,1,0,1,0,\n         1,0,1,0,0,\n         0,1,0,0,1,\n         1,0,0,0,0,\n         0,0,1,0,0])\n;\n\ncapacity_nodes = [3,2,2,1];\n\n\noutput \n[\n  \"z: \", show(z)\n] ++\n[\n  if client = 1 then \"\\n\" else \" \" endif ++\n    show(rings[ring, client])\n  | ring in 1..r, client in 1..n\n] ++ [\"\\n\"];\n"}, "hash": "5de3cf986c477ebb9dc3d6689f52dd29acacfd83c2447c781aa3015860247f56", "class_name": "RelatedNodeInfo"}}, "text": "SONET Problem\n\nThe SONET problem is about designing a network that connects certain nodes (think of them as computers or devices) in a way that uses the fewest resources possible.\n\nThe main variables are:\n\n* Rings: These are like circles that connect nodes together. Each ring can hold a certain number of nodes.\n* Nodes: These are the devices that need to be connected.\n* Demand: This is a list of which nodes need to be connected to each other.\n* Capacity nodes: This is the maximum number of nodes that can be on each ring.\n\nThe basic restrictions or rules of the problem are:\n\n* If two nodes need to be connected, they must be on the same ring.\n* Each ring can only hold a certain number of nodes, based on its capacity.\n\nThe goal of the problem is to use the fewest number of rings (and therefore the fewest resources) to connect all the nodes that need to be connected.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 875, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dfdd2674-dde3-4556-9553-e3509dd84755": {"__data__": {"id_": "dfdd2674-dde3-4556-9553-e3509dd84755", "embedding": null, "metadata": {"model_name": "square_pack", "source_code": "int: n; % number of squares\nset of int: SQUARE = 1..n;\nint: maxl = sum(i in SQUARE)(i);\nint: mina = sum(i in SQUARE)(i*i);\n\nvar n..maxl: height;\nvar n..maxl: width;\nvar mina .. n*maxl: area = height * width;\n\narray[SQUARE] of var 0..maxl: x;\narray[SQUARE] of var 0..maxl: y;\n\n% squares fit in the rectangle\nconstraint forall(s in SQUARE)(x[s] + s <= width);\nconstraint forall(s in SQUARE)(y[s] + s <= height);\n\n% non overlap\nconstraint forall(s1, s2 in SQUARE where s1 < s2)\n                 (x[s1] + s1 <= x[s2] \\/\n                  x[s2] + s2 <= x[s1] \\/  \n                  y[s1] + s1 <= y[s2] \\/ \n                  y[s2] + s2 <= y[s1]);\narray[SQUARE] of int: size = [ i | i in SQUARE ];\n\n% non overlap with global diffn\ninclude \"diffn.mzn\";\n%constraint diffn(x,y,size,size);\n\n% redundant cumulative constraints\ninclude \"cumulative.mzn\";\n%constraint cumulative(x,size,size,height);\n%constraint cumulative(y,size,size,width);\n\n% variables ordered in reverse size x[n], y[n], x[n-1], y[n-1], ..., x[1], y[1]\n%array[1..2*n] of var 0..maxl: vs = [ if i mod 2 = 0 then x[n+1 - i div 2] \n%                                     else y[n+1 - i div 2] endif | i in 2..2*n+1 ];\n\nsolve :: seq_search([\n         int_search([area,height,width], input_order, indomain_min, complete) \n         %,int_search(vs, input_order, indomain_min, complete)\n         ])\n      minimize area;\n\noutput [\"area = \",show(area), \"\\n\"] ++\n[\"height = \",show(height), \"\\n\"] ++\n[\"width = \",show(width), \"\\n\"] ++\n[\"x = \", show(x), \"\\n\"] ++\n[\"y = \", show(y), \"\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "square_pack_beginner", "node_type": "4", "metadata": {"model_name": "square_pack", "source_code": "int: n; % number of squares\nset of int: SQUARE = 1..n;\nint: maxl = sum(i in SQUARE)(i);\nint: mina = sum(i in SQUARE)(i*i);\n\nvar n..maxl: height;\nvar n..maxl: width;\nvar mina .. n*maxl: area = height * width;\n\narray[SQUARE] of var 0..maxl: x;\narray[SQUARE] of var 0..maxl: y;\n\n% squares fit in the rectangle\nconstraint forall(s in SQUARE)(x[s] + s <= width);\nconstraint forall(s in SQUARE)(y[s] + s <= height);\n\n% non overlap\nconstraint forall(s1, s2 in SQUARE where s1 < s2)\n                 (x[s1] + s1 <= x[s2] \\/\n                  x[s2] + s2 <= x[s1] \\/  \n                  y[s1] + s1 <= y[s2] \\/ \n                  y[s2] + s2 <= y[s1]);\narray[SQUARE] of int: size = [ i | i in SQUARE ];\n\n% non overlap with global diffn\ninclude \"diffn.mzn\";\n%constraint diffn(x,y,size,size);\n\n% redundant cumulative constraints\ninclude \"cumulative.mzn\";\n%constraint cumulative(x,size,size,height);\n%constraint cumulative(y,size,size,width);\n\n% variables ordered in reverse size x[n], y[n], x[n-1], y[n-1], ..., x[1], y[1]\n%array[1..2*n] of var 0..maxl: vs = [ if i mod 2 = 0 then x[n+1 - i div 2] \n%                                     else y[n+1 - i div 2] endif | i in 2..2*n+1 ];\n\nsolve :: seq_search([\n         int_search([area,height,width], input_order, indomain_min, complete) \n         %,int_search(vs, input_order, indomain_min, complete)\n         ])\n      minimize area;\n\noutput [\"area = \",show(area), \"\\n\"] ++\n[\"height = \",show(height), \"\\n\"] ++\n[\"width = \",show(width), \"\\n\"] ++\n[\"x = \", show(x), \"\\n\"] ++\n[\"y = \", show(y), \"\\n\"];\n"}, "hash": "55d532585c3cc7ab335bfb9c63fd6cc3c00e3c55827c71d7014f8bb4526fa383", "class_name": "RelatedNodeInfo"}}, "text": "**Problem Name:** Square Packing Problem\n\n**What the problem is about:** Imagine you have a set of squares of different sizes, and you want to pack them into a rectangle (a box with a length and a width) in a way that they don't overlap with each other. You want to find the smallest rectangle that can fit all the squares.\n\n**Main variables:**\n\n* `n`: The number of squares.\n* `height` and `width`: The length and width of the rectangle.\n* `x` and `y`: The coordinates (positions) of each square in the rectangle.\n* `area`: The total area of the rectangle.\n\n**Basic restrictions or rules:**\n\n* Each square must fit inside the rectangle.\n* No two squares can overlap with each other.\n* The squares must be packed in a way that they don't stick out of the rectangle.\n\n**Goal of the problem:** Find the smallest rectangle (with the smallest area) that can fit all the squares without any overlaps.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 895, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d776130f-a388-45bf-bd8f-9bf256b783e8": {"__data__": {"id_": "d776130f-a388-45bf-bd8f-9bf256b783e8", "embedding": null, "metadata": {"model_name": "stableroommates", "source_code": "Model 1 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\nset of int: AGENT0 = 0..n;    % zero indicates no agent\narray[AGENT,1..n-1] of AGENT0: pref; % preference order for each agent\n     % the preference order is padded by zeros\narray[AGENT] of int: npref = [ sum(j in 1..n-1)(bool2int(pref[i,j] > 0))\n                             | i in AGENT ];\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..n-1)\n                               (pref[i,j] != i /\\ \n                                (pref[i,j] = 0 <-> j > npref[i])) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref[i,j1] != pref[i,j2]),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n%% ranking information: rank = 0 means not ranked\narray[AGENT,AGENT] of 0..n-1: rank = \n     array2d(AGENT,AGENT, [ max([bool2int(pref[i1,j] = i2) * j | j in 1..n-1])\n                          | i1, i2 in AGENT ]);\n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] > rank[i,j] -> a[j] < rank[j,i]\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] = rank[i,j] -> a[j] = rank[j,i]\n                 );\n\nsolve satisfy;\n\noutput  [ if i < fix(pref[i,a[i]]) then \"(\" ++ show(i) ++ \",\" ++ show(pref[i,a[i]]) ++ \")\\n\"\n          else \"\" endif\n        | i in AGENT ]\n       ++ [show(rank),\"\\n\"] \n %      ++ [show(npref),\"\\n\"] \n %      ++ [show(a),\"\\n\"]\n        ;\n       \n\n\nModel 2 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\n\narray[AGENT] of int: npref; % number of preferences of each agent\narray[AGENT] of int: cum_npref = [ sum(j in 1..i-1)(npref[j]) | i in AGENT];\narray[1..sum(npref)] of int: preferences;  % all preferences in one list\n\nfunction AGENT: pref(AGENT: i, 1..n-1: j) = \n         assert(j in 1..npref[i], \"Called pref(\" ++ show(i) ++ \",\" ++ show(j) ++ \") too large preference\\n\",\n         preferences[cum_npref[i] + j]);\n\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..npref[i])\n                               (pref(i,j) != i) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref(i,j1) != pref(i,j2)),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n\n\n%% ranking information: rank = 0 means not ranked but shoulnt occur!\nfunction 0..n-1: rank(AGENT: i1, AGENT: i2) = \n                 max([bool2int(pref(i1,j) = i2) * j | j in 1..npref[i1]]); \n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] > rank(i,j) -> a[j] < rank(j,i)\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] = rank(i,j) -> a[j] = rank(j,i)\n                 );\n\nsolve satisfy;\n\n   output  [ if fix(a[i]) < npref[i] /\\ i < pref(i,fix(a[i]))\n             then \"(\" ++ show(i) ++ \",\" ++ show(pref(i,fix(a[i]))) ++ \")\\n\"\n             else \"\" endif\n           | i in AGENT ]\n %      ++ [show(rank),\"\\n\"] \n       ++\n       [show(npref),\"\\n\"] \n       ++ [show(a),\"\\n\"]\n        ;\n       \n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "stableroommates_beginner", "node_type": "4", "metadata": {"model_name": "stableroommates", "source_code": "Model 1 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\nset of int: AGENT0 = 0..n;    % zero indicates no agent\narray[AGENT,1..n-1] of AGENT0: pref; % preference order for each agent\n     % the preference order is padded by zeros\narray[AGENT] of int: npref = [ sum(j in 1..n-1)(bool2int(pref[i,j] > 0))\n                             | i in AGENT ];\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..n-1)\n                               (pref[i,j] != i /\\ \n                                (pref[i,j] = 0 <-> j > npref[i])) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref[i,j1] != pref[i,j2]),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n%% ranking information: rank = 0 means not ranked\narray[AGENT,AGENT] of 0..n-1: rank = \n     array2d(AGENT,AGENT, [ max([bool2int(pref[i1,j] = i2) * j | j in 1..n-1])\n                          | i1, i2 in AGENT ]);\n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] > rank[i,j] -> a[j] < rank[j,i]\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] = rank[i,j] -> a[j] = rank[j,i]\n                 );\n\nsolve satisfy;\n\noutput  [ if i < fix(pref[i,a[i]]) then \"(\" ++ show(i) ++ \",\" ++ show(pref[i,a[i]]) ++ \")\\n\"\n          else \"\" endif\n        | i in AGENT ]\n       ++ [show(rank),\"\\n\"] \n %      ++ [show(npref),\"\\n\"] \n %      ++ [show(a),\"\\n\"]\n        ;\n       \n\n\nModel 2 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\n\narray[AGENT] of int: npref; % number of preferences of each agent\narray[AGENT] of int: cum_npref = [ sum(j in 1..i-1)(npref[j]) | i in AGENT];\narray[1..sum(npref)] of int: preferences;  % all preferences in one list\n\nfunction AGENT: pref(AGENT: i, 1..n-1: j) = \n         assert(j in 1..npref[i], \"Called pref(\" ++ show(i) ++ \",\" ++ show(j) ++ \") too large preference\\n\",\n         preferences[cum_npref[i] + j]);\n\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..npref[i])\n                               (pref(i,j) != i) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref(i,j1) != pref(i,j2)),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n\n\n%% ranking information: rank = 0 means not ranked but shoulnt occur!\nfunction 0..n-1: rank(AGENT: i1, AGENT: i2) = \n                 max([bool2int(pref(i1,j) = i2) * j | j in 1..npref[i1]]); \n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] > rank(i,j) -> a[j] < rank(j,i)\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] = rank(i,j) -> a[j] = rank(j,i)\n                 );\n\nsolve satisfy;\n\n   output  [ if fix(a[i]) < npref[i] /\\ i < pref(i,fix(a[i]))\n             then \"(\" ++ show(i) ++ \",\" ++ show(pref(i,fix(a[i]))) ++ \")\\n\"\n             else \"\" endif\n           | i in AGENT ]\n %      ++ [show(rank),\"\\n\"] \n       ++\n       [show(npref),\"\\n\"] \n       ++ [show(a),\"\\n\"]\n        ;\n       \n\n"}, "hash": "9eb6c16f7472ca78d738ba9a8ffdbc5f41c3c6c103b812d616c8b8b631e593cb", "class_name": "RelatedNodeInfo"}}, "text": "**The Stable Roommates Problem**\n\nThis problem is about finding a way to pair up people (called \"agents\") in a way that makes everyone happy.\n\n**Main Variables:**\n\n* `n`: The number of agents (people) involved.\n* `pref`: A list of preferences for each agent, showing who they would like to be paired with.\n* `a`: A list of assignments, showing who each agent is paired with.\n* `rank`: A list showing the ranking of each agent's preferences.\n\n**Basic Restrictions or Rules:**\n\n* Each agent has a list of preferences, and they cannot prefer themselves.\n* Each agent's preferences must be unique (they can't prefer the same person twice).\n* The ranking of each agent's preferences is determined by their list of preferences.\n\n**Goal:**\n\nThe goal is to find a way to pair up the agents in a way that satisfies everyone's preferences as much as possible. This means that if an agent prefers someone, they should be paired with that person if possible. The problem is trying to find a stable solution, where no agent would rather be paired with someone else if they had the chance.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1075, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b6c0db13-a248-4c8c-a1e5-3cbabe5692a6": {"__data__": {"id_": "b6c0db13-a248-4c8c-a1e5-3cbabe5692a6", "embedding": null, "metadata": {"model_name": "steiner", "source_code": "% The ternary Steiner problem of order n is to find n(n-1)/6 sets of elements in {1,2,...,n}\n% such that each set contains three elements and any two sets have at most one element in common.\n% For example, the following shows a solution for size n=7:\n%\n%      {1,2,3}, {1,4,5}, {1,6,7}, {2,4,6}, {2,5,7}, {3,4,7}, {3,5,6}\n\ninclude \"globals.mzn\";\n\nint: N = 7; \nint: NB = N *(N-1) div 6;\narray[1..NB] of var set of 1..N: Sets;\n\n% solve satisfy;\nsolve::set_search(Sets, first_fail, indomain_min, complete) satisfy;\n\n\n\nconstraint\n   forall(i in index_set(Sets)) (\n      card(Sets[i]) = 3\n   )\n   /\\ \n   forall(i,j in index_set(Sets) where i < j) (\n      card( Sets[i] intersect Sets[j]) <= 1\n   )\n   /\\ % symmetry breaking\n   decreasing(Sets)\n\n;\n\noutput [\n       \"N: \", show(N), \" NB: \", show(NB), \"\\n\",\n       \"Sets: \", show(Sets)\n];\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "steiner_beginner", "node_type": "4", "metadata": {"model_name": "steiner", "source_code": "% The ternary Steiner problem of order n is to find n(n-1)/6 sets of elements in {1,2,...,n}\n% such that each set contains three elements and any two sets have at most one element in common.\n% For example, the following shows a solution for size n=7:\n%\n%      {1,2,3}, {1,4,5}, {1,6,7}, {2,4,6}, {2,5,7}, {3,4,7}, {3,5,6}\n\ninclude \"globals.mzn\";\n\nint: N = 7; \nint: NB = N *(N-1) div 6;\narray[1..NB] of var set of 1..N: Sets;\n\n% solve satisfy;\nsolve::set_search(Sets, first_fail, indomain_min, complete) satisfy;\n\n\n\nconstraint\n   forall(i in index_set(Sets)) (\n      card(Sets[i]) = 3\n   )\n   /\\ \n   forall(i,j in index_set(Sets) where i < j) (\n      card( Sets[i] intersect Sets[j]) <= 1\n   )\n   /\\ % symmetry breaking\n   decreasing(Sets)\n\n;\n\noutput [\n       \"N: \", show(N), \" NB: \", show(NB), \"\\n\",\n       \"Sets: \", show(Sets)\n];\n\n"}, "hash": "7d17fe428c15976ef9776f78fdc47c3284a10ac67693994f05346ac2c907f71c", "class_name": "RelatedNodeInfo"}}, "text": "**The Ternary Steiner Problem**\n\n**What is it about?**\nImagine you have a set of items, like toys or balls, and you want to group them into sets of three in a special way.\n\n**Main variables:**\n* `N`: The total number of items (toys or balls).\n* `Sets`: A collection of groups, each containing three items.\n\n**Basic restrictions or rules:**\n* Each group must have exactly three items.\n* Any two groups can share at most one item.\n\n**Goal:**\nThe goal is to find a way to group all the items into sets of three, following the rules above, so that we have the desired number of groups (`NB`).\n\nIn simpler terms, we want to divide a set of items into groups of three, making sure that each group is unique and doesn't share too many items with other groups.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 752, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "624ab5e1-1ed9-43bc-b0c4-3ab00a9a2221": {"__data__": {"id_": "624ab5e1-1ed9-43bc-b0c4-3ab00a9a2221", "embedding": null, "metadata": {"model_name": "stoch_fjsp", "source_code": "% Stochastic General Assignment Problem \n% First stage:\n%    assign task to machines \n% Second stage:\n%    based on observed processign times, schedule taks on respective machines\n% Objective:\n%    minimise expected makespan\n\ninclude \"globals.mzn\";\n\n% Parameters\n\nint: no_mach;   % Number of machines\nint: no_jobs;   % Number of jobs\nint: no_task;   % Number of total tasks\nint: no_optt;   % Number of total optional tasks\n\nset of int: Mach  = 1..no_mach;\nset of int: Jobs  = 1..no_jobs;\nset of int: Tasks = 1..no_task;\nset of int: OptTs = 1..no_optt;\n\narray [Jobs] of set of int: tasks;\narray [Tasks] of set of int: optts;\n\narray [OptTs] of int: optt_mach;\narray [SCENARIOS1,OptTs] of int: optt_dur;\n\n\narray [Jobs] of int: last_task = [ max(tasks[j]) | j in Jobs ];\n%---------implications for multi scenarion solving ---------------\nint: nbScenarios;\nset of int: SCENARIOS1 = 1..nbScenarios;\nint: first_scen;\nint: last_scen;\nset of int: SCENARIOS = first_scen..last_scen;\narray[SCENARIOS1] of int: weights;\n\n%-------end of multi scenario addons ----------------\narray [Tasks] of int: task_job = \n    [ min(j in Jobs where t in tasks[j])(j) | t in Tasks ];\narray [SCENARIOS,Tasks] of int: task_mins =\n    array2d(SCENARIOS,Tasks,[ sum(k in tasks[task_job[t]])(if k < t then task_mind[s,k] else 0 endif)\n    |   s in SCENARIOS, t in Tasks ]);\narray [SCENARIOS,Tasks] of int: task_maxs =\n    array2d(SCENARIOS,Tasks,[ t_max[s] -\n        sum(k in tasks[task_job[t]])(if k < t then 0 else task_mind[s,k] endif)\n    |   s in SCENARIOS,  t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_mind =\n    array2d(SCENARIOS,Tasks,[ min(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS,t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_maxd = \n    array2d(SCENARIOS,Tasks,[ max(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS, t in Tasks ]);\n\n    % Additional deirved parameters for optional tasks\n    %\narray [OptTs] of int: optt_task =\n    [ min(t in Tasks where o in optts[t])(t) | o in OptTs ];\n\narray[SCENARIOS1] of int: min_dur = [ min([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\narray[SCENARIOS1] of int: max_dur = [ max([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\nset of int: Durs = min(min_dur)..max(max_dur);\n\n    % Parameters related to the planning horizon\n    %\narray[SCENARIOS1] of int: t_max = [sum(t in Tasks)(max(o in optts[t])(optt_dur[s,o])) | s in SCENARIOS1];\n\nset of int: Times = 0..max(t_max);\n\n%-----------------------------------------------------------------------------%\n% Variables\n\n    % Start time variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Times: start =\n    array2d(SCENARIOS,Tasks,[ let { var task_mins[s,t]..task_maxs[s,t]: k } in k | s in SCENARIOS, t in Tasks ]);\n\n    % Duration variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Durs: dur =\n    array2d(SCENARIOS,Tasks,[ if task_mind[s,t] = task_maxd[s,t] then task_mind[s,t] else\n        let { var task_mind[s,t]..task_maxd[s,t]: d } in d endif\n    |   s in SCENARIOS,t in Tasks ]);\n\n    % Variables whether an optional task is executed\n    %\narray [OptTs] of var bool: b;\n\narray[SCENARIOS] of var Times: de_objective;\n\nset of int: StochTimes = 0..sum(t_max);\nvar StochTimes: objective;\n%-----------------------------------------------------------------------------%\n% Constraints\n\n    % Precedence relations\n    %\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs, i in tasks[j] where i < last_task[j])(\n            start[s,i] + dur[s,i] <= start[s,i + 1]\n        )    \n    );\n\n    % Duration constraints\n    %\nconstraint\n    forall(o in OptTs,s in SCENARIOS)(\n        let { int: t = optt_task[o] } in (\n            if card(optts[t]) = 1 then\n                b[o] = true\n            else\n                b[o] -> dur[s,t] = optt_dur[s,o]\n            endif\n        )\n    );\n\n    % Optional tasks' constraints\n    %\nconstraint\n    forall(t in Tasks where card(optts[t]) > 1)(\n        ( sum(o in optts[t])(bool2int(b[o])) <= 1     )\n    /\\  ( exists(o in optts[t])(b[o])                 )\n    );\n\nconstraint\n    forall(t in Tasks where card(optts[t]) = 2)(\n        let {\n            int: o1 = min(optts[t]),\n            int: o2 = max(optts[t])\n        } in ( b[o1] <-> not(b[o2]) )\n    );\n\n    % Resource constraints\n    %\nconstraint\n    forall(m in Mach,s in SCENARIOS)(\n        let {\n            set of int: MTasks = { o | o in OptTs where optt_mach[o] = m }\n        } in (\n            cumulative(\n                [ start[s,optt_task[o]] | o in MTasks ],\n                [ optt_dur[s,o]         | o in MTasks ],\n                [ bool2int(b[o])      | o in MTasks ],\n                1\n            )\n        )\n    );\n\n% Objective constraint\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs)(start[s,last_task[j]] + dur[s,last_task[j]] <= de_objective[s])\n    );\nconstraint \n        objective = sum(s in SCENARIOS)(weights[s]*de_objective[s]);\n%-----------------------------------------------------------------------------%\n% Solve item\n\nsolve \n    :: search\n    minimize objective;\n\n%------------------------------------------------------------------------------%\n% Searches\n\nann: s_mindur   = int_search([dur[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_minstart = int_search([start[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_bool     = bool_search(b, input_order, indomain_max, complete);\nann: s_obj      = int_search(de_objective, input_order, indomain_min, complete);\n\nann: search = seq_search([s_mindur, s_bool, s_minstart, s_obj]);\n\n%-----------------------------------------------------------------------------%\n% Output\n\noutput \n[   \"objective = \", show(de_objective), \";\\n\",\n    \"stoch obj = \", show(objective), \";\\n\",\n    \"start = \", show(start), \";\\n\",\n    \"dur = \", show(dur), \";\\n\",\n    \"b = \", show(b), \";\\n\",\n];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "stoch_fjsp_beginner", "node_type": "4", "metadata": {"model_name": "stoch_fjsp", "source_code": "% Stochastic General Assignment Problem \n% First stage:\n%    assign task to machines \n% Second stage:\n%    based on observed processign times, schedule taks on respective machines\n% Objective:\n%    minimise expected makespan\n\ninclude \"globals.mzn\";\n\n% Parameters\n\nint: no_mach;   % Number of machines\nint: no_jobs;   % Number of jobs\nint: no_task;   % Number of total tasks\nint: no_optt;   % Number of total optional tasks\n\nset of int: Mach  = 1..no_mach;\nset of int: Jobs  = 1..no_jobs;\nset of int: Tasks = 1..no_task;\nset of int: OptTs = 1..no_optt;\n\narray [Jobs] of set of int: tasks;\narray [Tasks] of set of int: optts;\n\narray [OptTs] of int: optt_mach;\narray [SCENARIOS1,OptTs] of int: optt_dur;\n\n\narray [Jobs] of int: last_task = [ max(tasks[j]) | j in Jobs ];\n%---------implications for multi scenarion solving ---------------\nint: nbScenarios;\nset of int: SCENARIOS1 = 1..nbScenarios;\nint: first_scen;\nint: last_scen;\nset of int: SCENARIOS = first_scen..last_scen;\narray[SCENARIOS1] of int: weights;\n\n%-------end of multi scenario addons ----------------\narray [Tasks] of int: task_job = \n    [ min(j in Jobs where t in tasks[j])(j) | t in Tasks ];\narray [SCENARIOS,Tasks] of int: task_mins =\n    array2d(SCENARIOS,Tasks,[ sum(k in tasks[task_job[t]])(if k < t then task_mind[s,k] else 0 endif)\n    |   s in SCENARIOS, t in Tasks ]);\narray [SCENARIOS,Tasks] of int: task_maxs =\n    array2d(SCENARIOS,Tasks,[ t_max[s] -\n        sum(k in tasks[task_job[t]])(if k < t then 0 else task_mind[s,k] endif)\n    |   s in SCENARIOS,  t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_mind =\n    array2d(SCENARIOS,Tasks,[ min(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS,t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_maxd = \n    array2d(SCENARIOS,Tasks,[ max(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS, t in Tasks ]);\n\n    % Additional deirved parameters for optional tasks\n    %\narray [OptTs] of int: optt_task =\n    [ min(t in Tasks where o in optts[t])(t) | o in OptTs ];\n\narray[SCENARIOS1] of int: min_dur = [ min([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\narray[SCENARIOS1] of int: max_dur = [ max([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\nset of int: Durs = min(min_dur)..max(max_dur);\n\n    % Parameters related to the planning horizon\n    %\narray[SCENARIOS1] of int: t_max = [sum(t in Tasks)(max(o in optts[t])(optt_dur[s,o])) | s in SCENARIOS1];\n\nset of int: Times = 0..max(t_max);\n\n%-----------------------------------------------------------------------------%\n% Variables\n\n    % Start time variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Times: start =\n    array2d(SCENARIOS,Tasks,[ let { var task_mins[s,t]..task_maxs[s,t]: k } in k | s in SCENARIOS, t in Tasks ]);\n\n    % Duration variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Durs: dur =\n    array2d(SCENARIOS,Tasks,[ if task_mind[s,t] = task_maxd[s,t] then task_mind[s,t] else\n        let { var task_mind[s,t]..task_maxd[s,t]: d } in d endif\n    |   s in SCENARIOS,t in Tasks ]);\n\n    % Variables whether an optional task is executed\n    %\narray [OptTs] of var bool: b;\n\narray[SCENARIOS] of var Times: de_objective;\n\nset of int: StochTimes = 0..sum(t_max);\nvar StochTimes: objective;\n%-----------------------------------------------------------------------------%\n% Constraints\n\n    % Precedence relations\n    %\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs, i in tasks[j] where i < last_task[j])(\n            start[s,i] + dur[s,i] <= start[s,i + 1]\n        )    \n    );\n\n    % Duration constraints\n    %\nconstraint\n    forall(o in OptTs,s in SCENARIOS)(\n        let { int: t = optt_task[o] } in (\n            if card(optts[t]) = 1 then\n                b[o] = true\n            else\n                b[o] -> dur[s,t] = optt_dur[s,o]\n            endif\n        )\n    );\n\n    % Optional tasks' constraints\n    %\nconstraint\n    forall(t in Tasks where card(optts[t]) > 1)(\n        ( sum(o in optts[t])(bool2int(b[o])) <= 1     )\n    /\\  ( exists(o in optts[t])(b[o])                 )\n    );\n\nconstraint\n    forall(t in Tasks where card(optts[t]) = 2)(\n        let {\n            int: o1 = min(optts[t]),\n            int: o2 = max(optts[t])\n        } in ( b[o1] <-> not(b[o2]) )\n    );\n\n    % Resource constraints\n    %\nconstraint\n    forall(m in Mach,s in SCENARIOS)(\n        let {\n            set of int: MTasks = { o | o in OptTs where optt_mach[o] = m }\n        } in (\n            cumulative(\n                [ start[s,optt_task[o]] | o in MTasks ],\n                [ optt_dur[s,o]         | o in MTasks ],\n                [ bool2int(b[o])      | o in MTasks ],\n                1\n            )\n        )\n    );\n\n% Objective constraint\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs)(start[s,last_task[j]] + dur[s,last_task[j]] <= de_objective[s])\n    );\nconstraint \n        objective = sum(s in SCENARIOS)(weights[s]*de_objective[s]);\n%-----------------------------------------------------------------------------%\n% Solve item\n\nsolve \n    :: search\n    minimize objective;\n\n%------------------------------------------------------------------------------%\n% Searches\n\nann: s_mindur   = int_search([dur[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_minstart = int_search([start[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_bool     = bool_search(b, input_order, indomain_max, complete);\nann: s_obj      = int_search(de_objective, input_order, indomain_min, complete);\n\nann: search = seq_search([s_mindur, s_bool, s_minstart, s_obj]);\n\n%-----------------------------------------------------------------------------%\n% Output\n\noutput \n[   \"objective = \", show(de_objective), \";\\n\",\n    \"stoch obj = \", show(objective), \";\\n\",\n    \"start = \", show(start), \";\\n\",\n    \"dur = \", show(dur), \";\\n\",\n    \"b = \", show(b), \";\\n\",\n];\n"}, "hash": "16f847737c2542565693e42288f054258f477995b413d0a64e60188425c80a6e", "class_name": "RelatedNodeInfo"}}, "text": "**Stochastic General Assignment Problem**\n\n**What is the problem about in everyday terms?**\nImagine you have a set of tasks that need to be completed on different machines. Each task has a specific duration, and some tasks are optional. You want to assign these tasks to the machines in a way that minimizes the total time it takes to complete all the tasks.\n\n**What are the main variables and what do they mean?**\n\n* **Machines**: These are the devices that will perform the tasks.\n* **Jobs**: These are groups of tasks that need to be completed.\n* **Tasks**: These are the individual activities that need to be performed.\n* **Optional tasks**: These are tasks that may or may not be completed.\n* **Start time**: This is the time when a task starts.\n* **Duration**: This is the time it takes to complete a task.\n* **b**: This is a variable that indicates whether an optional task is executed or not.\n\n**What are the basic restrictions or rules of the problem?**\n\n* Each task must be assigned to a machine.\n* A task cannot start before the previous task in the same job is completed.\n* The duration of a task must be within a certain range.\n* Optional tasks have specific durations and may or may not be executed.\n* The total time it takes to complete all tasks on a machine cannot exceed a certain limit.\n\n**What is the goal of the problem?**\nThe goal is to minimize the expected total time it takes to complete all tasks, considering the uncertainty in the task durations.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1474, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "171e4a5d-d5ef-47e5-bec1-c0bcde15aa3c": {"__data__": {"id_": "171e4a5d-d5ef-47e5-bec1-c0bcde15aa3c", "embedding": null, "metadata": {"model_name": "submultisetsum", "source_code": "% subsetsum problem\narray[int] of int: number;\nint: target;\n\nset of int: NUMBER = index_set(number);\nvar set of NUMBER: selected;\n\nconstraint sum(i in selected)\n              (number[i]) = target;\nsolve satisfy;\n\noutput [show(selected)];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "submultisetsum_beginner", "node_type": "4", "metadata": {"model_name": "submultisetsum", "source_code": "% subsetsum problem\narray[int] of int: number;\nint: target;\n\nset of int: NUMBER = index_set(number);\nvar set of NUMBER: selected;\n\nconstraint sum(i in selected)\n              (number[i]) = target;\nsolve satisfy;\n\noutput [show(selected)];"}, "hash": "56a2ae12a6003d9bb9d50280400ebd968568b9be22c4ff059f1a6be6c70b7acf", "class_name": "RelatedNodeInfo"}}, "text": "**The Subset Sum Problem**\n\n**What the problem is about in everyday terms:**\nImagine you have a set of items, each with a specific weight or value. You want to select a subset of these items such that their total weight or value adds up to a specific target value.\n\n**Main variables and their meanings:**\n\n* `number`: an array of integers representing the weights or values of the items.\n* `target`: an integer representing the target value we want to reach.\n* `selected`: a set of integers representing the indices of the items we choose to include in our subset.\n\n**Basic restrictions or rules:**\n\n* We can only choose items from the given set.\n* The total weight or value of the selected items must equal the target value.\n\n**Goal of the problem:**\nFind a subset of items such that their total weight or value adds up to the target value.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 841, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "74854336-1114-4f34-847e-8adde1c9d74d": {"__data__": {"id_": "74854336-1114-4f34-847e-8adde1c9d74d", "embedding": null, "metadata": {"model_name": "table_seating", "source_code": "Model 1 :\n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n          forall(t in TABLE)(not ({p1,p2} subset table[t]));\n\nconstraint forall(t in TABLE)(card(table[t]) <= S);\n\nconstraint forall(p in PERSON)(exists(t in TABLE)(p in table[t]));\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))\n                  ( let { var TABLE: tn1 = sum(t in TABLE)(t * bool2int(couples[c,1] in table[t]));\n                          var TABLE: tn2 = sum(t in TABLE)(t * bool2int(couples[c,2] in table[t]));\n                    } in  tn1 + tn2);\n\n\n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n\n\n\nModel 2 : \n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\narray[PERSON] of var TABLE: seat;\n\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n                        seat[p1] != seat[p2];\n\nconstraint global_cardinality_low_up(seat, [t|t in TABLE], [0|t in TABLE], [S|t in TABLE]);\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))(seat[couples[c,1]] + seat[couples[c,2]]);\n\nconstraint forall(t in TABLE, p in PERSON)(p in table[t] <-> seat[p] = t);    \n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "table_seating_beginner", "node_type": "4", "metadata": {"model_name": "table_seating", "source_code": "Model 1 :\n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n          forall(t in TABLE)(not ({p1,p2} subset table[t]));\n\nconstraint forall(t in TABLE)(card(table[t]) <= S);\n\nconstraint forall(p in PERSON)(exists(t in TABLE)(p in table[t]));\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))\n                  ( let { var TABLE: tn1 = sum(t in TABLE)(t * bool2int(couples[c,1] in table[t]));\n                          var TABLE: tn2 = sum(t in TABLE)(t * bool2int(couples[c,2] in table[t]));\n                    } in  tn1 + tn2);\n\n\n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n\n\n\nModel 2 : \n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\narray[PERSON] of var TABLE: seat;\n\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n                        seat[p1] != seat[p2];\n\nconstraint global_cardinality_low_up(seat, [t|t in TABLE], [0|t in TABLE], [S|t in TABLE]);\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))(seat[couples[c,1]] + seat[couples[c,2]]);\n\nconstraint forall(t in TABLE, p in PERSON)(p in table[t] <-> seat[p] = t);    \n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n"}, "hash": "8d6d950898668ac13be2b204dbb203b0e8bd32ef0417472b0dd5bc65f877262d", "class_name": "RelatedNodeInfo"}}, "text": "**The Seating Arrangement Problem**\n\nThis problem is about arranging people at tables for a dinner or a party. Imagine you have a certain number of people and a certain number of tables, and each table can only fit a certain number of people.\n\n**Main Variables:**\n\n* `n`: The total number of people.\n* `T`: The number of tables.\n* `S`: The maximum number of people that can sit at each table.\n* `couples`: Pairs of people who want to sit together.\n* `key`: A set of special people who cannot sit together.\n* `table`: An array that shows which people are sitting at each table.\n* `seat`: An array that shows which table each person is sitting at.\n\n**Basic Restrictions or Rules:**\n\n* Each table can only fit a certain number of people (S).\n* Each person must sit at a table.\n* Couples want to sit together at the same table.\n* Special people in the `key` set cannot sit together.\n\n**Goal:**\n\nThe goal is to find a seating arrangement that minimizes the total table numbers of all couples. In other words, we want to find a way to seat the couples together at tables with the lowest possible table numbers.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1104, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7dce60e5-ca00-443f-b4ac-11bc45ba1e2e": {"__data__": {"id_": "7dce60e5-ca00-443f-b4ac-11bc45ba1e2e", "embedding": null, "metadata": {"model_name": "teamselect", "source_code": "Model 1 :\n\n\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\narray[CAPTAIN] of var set of PLAYER: team = [Xavier,Yuri,Zena];\n\nset of int: CAPTAIN = 1..3;\narray[CAPTAIN,PLAYER] of int: value;\n \nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |]; \n\nconstraint card(Xavier intersect GOALIE) >= 1;\nconstraint card(Xavier intersect DEFENCE) >= 2;\nconstraint card(Xavier intersect OFFENCE) >= 2;\nconstraint card(Xavier) = 6;\n\n\nconstraint card(Yuri intersect GOALIE) >= 1;\nconstraint card(Yuri intersect DEFENCE) >= 2;\nconstraint card(Yuri intersect OFFENCE) >= 2;\nconstraint card(Yuri) = 6;\n\nconstraint card(Zena intersect GOALIE) >= 1;\nconstraint card(Zena intersect DEFENCE) >= 2;\nconstraint card(Zena intersect OFFENCE) >= 2;\nconstraint card(Zena) = 6;\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nsolve maximize obj;\n\nvar int: obj = sum(c in CAPTAIN)(sum(p in team[c])(value[c,p]));\n\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n\n\nModel 2 :\n\n\n% team select problem\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\nset of int: CAPTAIN = 1..3;\nint: xavier = 1; int: yuri = 2; int: zena = 3;\narray[CAPTAIN,PLAYER] of int: value;\nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |];\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\npredicate correct_team(var set of PLAYER: team) = \n          card(team) = 6 /\\ \n          card(team intersect GOALIE) >= 1 /\\\n          card(team intersect DEFENCE) >= 2 /\\\n          card(team intersect OFFENCE) >= 2;\n\nconstraint correct_team(Xavier) /\\ correct_team(Yuri) /\\ correct_team(Zena);\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nvar int: obj = sum(p in Xavier)(value[xavier,p]) +\n               sum(p in Yuri)(value[yuri,p]) +\n               sum(p in Zena)(value[zena,p]);\n\nsolve maximize obj;\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "teamselect_beginner", "node_type": "4", "metadata": {"model_name": "teamselect", "source_code": "Model 1 :\n\n\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\narray[CAPTAIN] of var set of PLAYER: team = [Xavier,Yuri,Zena];\n\nset of int: CAPTAIN = 1..3;\narray[CAPTAIN,PLAYER] of int: value;\n \nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |]; \n\nconstraint card(Xavier intersect GOALIE) >= 1;\nconstraint card(Xavier intersect DEFENCE) >= 2;\nconstraint card(Xavier intersect OFFENCE) >= 2;\nconstraint card(Xavier) = 6;\n\n\nconstraint card(Yuri intersect GOALIE) >= 1;\nconstraint card(Yuri intersect DEFENCE) >= 2;\nconstraint card(Yuri intersect OFFENCE) >= 2;\nconstraint card(Yuri) = 6;\n\nconstraint card(Zena intersect GOALIE) >= 1;\nconstraint card(Zena intersect DEFENCE) >= 2;\nconstraint card(Zena intersect OFFENCE) >= 2;\nconstraint card(Zena) = 6;\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nsolve maximize obj;\n\nvar int: obj = sum(c in CAPTAIN)(sum(p in team[c])(value[c,p]));\n\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n\n\nModel 2 :\n\n\n% team select problem\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\nset of int: CAPTAIN = 1..3;\nint: xavier = 1; int: yuri = 2; int: zena = 3;\narray[CAPTAIN,PLAYER] of int: value;\nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |];\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\npredicate correct_team(var set of PLAYER: team) = \n          card(team) = 6 /\\ \n          card(team intersect GOALIE) >= 1 /\\\n          card(team intersect DEFENCE) >= 2 /\\\n          card(team intersect OFFENCE) >= 2;\n\nconstraint correct_team(Xavier) /\\ correct_team(Yuri) /\\ correct_team(Zena);\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nvar int: obj = sum(p in Xavier)(value[xavier,p]) +\n               sum(p in Yuri)(value[yuri,p]) +\n               sum(p in Zena)(value[zena,p]);\n\nsolve maximize obj;\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n"}, "hash": "3c02ff8ed0afc5991411847d3f3f02f4816bbef9eb5323320197c48aafbef5af", "class_name": "RelatedNodeInfo"}}, "text": "**Team Selection Problem**\n\nThis problem is about selecting three teams of six players each from a pool of 11 players. The teams are named Xavier, Yuri, and Zena.\n\n**Main Variables:**\n\n* Xavier, Yuri, and Zena: These are the three teams, each consisting of six players.\n* PLAYER: This is the set of all 11 players.\n* GOALIE, DEFENCE, and OFFENCE: These are subsets of players with specific roles (goalie, defense, and offense).\n* value: This is a table that shows the value or score of each player.\n\n**Basic Restrictions or Rules:**\n\n* Each team must have exactly six players.\n* Each team must have at least one goalie, two defense players, and two offense players.\n* No more than two players can be shared between any two teams.\n\n**Goal:**\n\nThe goal is to select the teams in a way that maximizes the total value or score of all three teams.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 842, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "45493d6e-cfc3-47e2-b2a8-b2c5ba0376ec": {"__data__": {"id_": "45493d6e-cfc3-47e2-b2a8-b2c5ba0376ec", "embedding": null, "metadata": {"model_name": "template_design", "source_code": "% Template design\ninclude \"globals.mzn\";\n\nint: S;   \t\t% Number of slots per template.\nint: t;   \t\t% Number of templates.\nint: n;   \t\t% Number of variations.\narray[1..n] of int: d; \t% How much of each variation we must print?\n\n% Lower and upper bounds for the total production.\n%\nint: llower = ceil(sum(i in 1..n)(int2float(d[i]))/int2float(S));\nint: lupper = 2*llower; % If t>1, this should be the optimal Production_{t-1}-1.\n\n% # Slots allocated to variation i in template j\narray[1..n,1..t] of var 0..S: p;\n\n% # Pressings of template j.\narray[1..t] of var 1..lupper: R;\n\n% Sum of all Rj.\nvar llower..lupper: Production;\n\n% Production x S - sum(d[i])\nvar 0..lupper-llower: Surplus;\n\n% First, set up Production to be the sum of the Rj\nconstraint\n\tProduction = sum(i in 1..t)(R[i]);\n\n% the limits on production\nconstraint\n\tProduction >= llower /\\ Production <= lupper;\n\n% The number of slots occupied in each template is S.\nconstraint\n\tforall(j in 1..t)\n\t\t (sum(i in 1..n)(p[i,j]) = S);\n\n% Enough of each variation is printed.\nconstraint\n\tforall(i in 1..n)\n\t\t (sum(j in 1..t)(p[i,j]*R[j]) >= d[i]);\n\n% Symmetry constraints.\n% Variations with the same demand are symmetric.\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] == d[i+1] then\n\t\t\tlex_lesseq([p[i,  j] | j in 1..t],\n\t\t\t\t[p[i+1,j] | j in 1..t])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% pseudo symmetry\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] < d[i+1] then\n\t\t       sum (j in 1..t) (p[i,j]*R[j])\n\t\t     <= sum (j in 1..t) (p[i+1,j]*R[j])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% implied constraints on the surplus\n\n% These are presented in the paper as necessary to get good\n% performance for this model, but I think bounds consistency on the\n% sum(R[i]) constraint would produce the same amount of propagation\n\n% Set up surplus, which is bounded as production is bounded.\nconstraint\n\tSurplus = Production*S - sum(i in 1..n)(d[i]);\n\n% The surplus of each variation is also limited by the surplus.\nconstraint\n\tforall(k in 1..n)\n\t\t (sum(j in 1..t)(p[k,j]*R[j]-d[k]) <= Surplus);\n\n% The surplus of the first k variations is limited by the surplus.\nconstraint\n\tforall(k in 2..n-1)\n\t\t (sum(j in 1..t, m in 1..k)( p[m,j]*R[j]-d[m] ) <= Surplus);\n\n% Implied constraints on the run length.\nconstraint\n\tif t=2 then (\n\t\tR[1] <= Production div 2\n\t/\\\tR[2] >= Production div 2\n\t) else true endif;\n\nconstraint\n\tif t=3 then (\n\t\tR[1] <= Production div 3\n\t/\\\tR[2] <= Production div 2\n\t/\\\tR[3] >= Production div 3\n\t) else true endif;\n\n% Minimize the production.\nsolve :: int_search(array1d(1..n*t,p) ++ R, input_order, indomain_min, complete)\n    minimize Production;\n\noutput [\n    if v = 1 then \"template #\" ++ show(i) ++ \": [\" else \"\" endif ++\n    show(p[v, i]) ++\n    if v = n then \"], pressings: \" ++ show(R[i]) ++ \"\\n\" else \", \" endif\n\t| i in 1..t, v in 1..n]\n    ++ [\"Total pressings: \", show(Production), \"\\n%\\n\"];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "template_design_beginner", "node_type": "4", "metadata": {"model_name": "template_design", "source_code": "% Template design\ninclude \"globals.mzn\";\n\nint: S;   \t\t% Number of slots per template.\nint: t;   \t\t% Number of templates.\nint: n;   \t\t% Number of variations.\narray[1..n] of int: d; \t% How much of each variation we must print?\n\n% Lower and upper bounds for the total production.\n%\nint: llower = ceil(sum(i in 1..n)(int2float(d[i]))/int2float(S));\nint: lupper = 2*llower; % If t>1, this should be the optimal Production_{t-1}-1.\n\n% # Slots allocated to variation i in template j\narray[1..n,1..t] of var 0..S: p;\n\n% # Pressings of template j.\narray[1..t] of var 1..lupper: R;\n\n% Sum of all Rj.\nvar llower..lupper: Production;\n\n% Production x S - sum(d[i])\nvar 0..lupper-llower: Surplus;\n\n% First, set up Production to be the sum of the Rj\nconstraint\n\tProduction = sum(i in 1..t)(R[i]);\n\n% the limits on production\nconstraint\n\tProduction >= llower /\\ Production <= lupper;\n\n% The number of slots occupied in each template is S.\nconstraint\n\tforall(j in 1..t)\n\t\t (sum(i in 1..n)(p[i,j]) = S);\n\n% Enough of each variation is printed.\nconstraint\n\tforall(i in 1..n)\n\t\t (sum(j in 1..t)(p[i,j]*R[j]) >= d[i]);\n\n% Symmetry constraints.\n% Variations with the same demand are symmetric.\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] == d[i+1] then\n\t\t\tlex_lesseq([p[i,  j] | j in 1..t],\n\t\t\t\t[p[i+1,j] | j in 1..t])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% pseudo symmetry\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] < d[i+1] then\n\t\t       sum (j in 1..t) (p[i,j]*R[j])\n\t\t     <= sum (j in 1..t) (p[i+1,j]*R[j])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% implied constraints on the surplus\n\n% These are presented in the paper as necessary to get good\n% performance for this model, but I think bounds consistency on the\n% sum(R[i]) constraint would produce the same amount of propagation\n\n% Set up surplus, which is bounded as production is bounded.\nconstraint\n\tSurplus = Production*S - sum(i in 1..n)(d[i]);\n\n% The surplus of each variation is also limited by the surplus.\nconstraint\n\tforall(k in 1..n)\n\t\t (sum(j in 1..t)(p[k,j]*R[j]-d[k]) <= Surplus);\n\n% The surplus of the first k variations is limited by the surplus.\nconstraint\n\tforall(k in 2..n-1)\n\t\t (sum(j in 1..t, m in 1..k)( p[m,j]*R[j]-d[m] ) <= Surplus);\n\n% Implied constraints on the run length.\nconstraint\n\tif t=2 then (\n\t\tR[1] <= Production div 2\n\t/\\\tR[2] >= Production div 2\n\t) else true endif;\n\nconstraint\n\tif t=3 then (\n\t\tR[1] <= Production div 3\n\t/\\\tR[2] <= Production div 2\n\t/\\\tR[3] >= Production div 3\n\t) else true endif;\n\n% Minimize the production.\nsolve :: int_search(array1d(1..n*t,p) ++ R, input_order, indomain_min, complete)\n    minimize Production;\n\noutput [\n    if v = 1 then \"template #\" ++ show(i) ++ \": [\" else \"\" endif ++\n    show(p[v, i]) ++\n    if v = n then \"], pressings: \" ++ show(R[i]) ++ \"\\n\" else \", \" endif\n\t| i in 1..t, v in 1..n]\n    ++ [\"Total pressings: \", show(Production), \"\\n%\\n\"];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%\n"}, "hash": "78b0466e0f81ef388da397f78f41e79dac76554f137bb87e174f11a9d7fb584c", "class_name": "RelatedNodeInfo"}}, "text": "**Template Design Problem**\n\nThis problem is about printing different variations of a product, like different flavors of a snack or different colors of a t-shirt. We need to decide how many of each variation to print and how to organize the printing process to minimize waste.\n\n**Main variables:**\n\n* `S`: The number of slots available on a printing template.\n* `t`: The number of printing templates.\n* `n`: The number of different variations of the product.\n* `d`: An array that tells us how many of each variation we need to print.\n* `p`: A 2D array that tells us how many slots on each template are allocated to each variation.\n* `R`: An array that tells us how many times each template is pressed (i.e., how many copies are made).\n* `Production`: The total number of items printed.\n* `Surplus`: The amount of waste or extra items printed.\n\n**Basic restrictions:**\n\n* Each template has `S` slots, and we need to allocate them to the different variations.\n* We need to print at least `d` items of each variation.\n* The total number of items printed (`Production`) is between `llower` and `lupper`, which are calculated based on the number of slots and the number of variations.\n* The surplus (waste) is limited by the total production.\n\n**Goal:**\n\nThe goal is to minimize the total production (i.e., the number of items printed) while meeting the demands for each variation and following the rules for allocating slots on the templates.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1438, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "26b1fe9b-176c-4554-a768-b1d1d6bdbc96": {"__data__": {"id_": "26b1fe9b-176c-4554-a768-b1d1d6bdbc96", "embedding": null, "metadata": {"model_name": "toomany", "source_code": "%% TooMany.mzn (too many solutions)\nint: n; % number of machines\nset of int: MACHINE = 1..n;\nint: k; % production per day\nint: red = 1; int: white = 2; int: black = 3; int: blue = 4;\nset of int: COLOR = 1..4;\narray[COLOR] of int: l; % lower bound on production\narray[COLOR] of int: u; % upper bound on production\n\narray[MACHINE,COLOR] of var 0..k div 2: produce;\n\nconstraint forall(m in MACHINE)\n                 (sum(c in COLOR)(produce[m,c]) <= k);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) >= l[c]);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) <= u[c]);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] > 0 /\\ produce[m,black] > 0 -> produce[m,blue] = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,blue] <= produce[m,red]);\nconstraint forall(m in MACHINE)\n                 (produce[m,red] mod 4 = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] mod 3 = 0);\n\n\nsolve maximize sum(m in MACHINE, c in COLOR)(produce[m,c]);\n\noutput [ show_int(3,produce[m,c]) ++\n         if c = 4 then \"\\n\" else \" \" endif\n       | m in MACHINE, c in COLOR ];\n\nn = 4;\nk = 11;\nl = [8,7,10,6];\nu = [14,16,12,20];\n\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "toomany_beginner", "node_type": "4", "metadata": {"model_name": "toomany", "source_code": "%% TooMany.mzn (too many solutions)\nint: n; % number of machines\nset of int: MACHINE = 1..n;\nint: k; % production per day\nint: red = 1; int: white = 2; int: black = 3; int: blue = 4;\nset of int: COLOR = 1..4;\narray[COLOR] of int: l; % lower bound on production\narray[COLOR] of int: u; % upper bound on production\n\narray[MACHINE,COLOR] of var 0..k div 2: produce;\n\nconstraint forall(m in MACHINE)\n                 (sum(c in COLOR)(produce[m,c]) <= k);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) >= l[c]);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) <= u[c]);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] > 0 /\\ produce[m,black] > 0 -> produce[m,blue] = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,blue] <= produce[m,red]);\nconstraint forall(m in MACHINE)\n                 (produce[m,red] mod 4 = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] mod 3 = 0);\n\n\nsolve maximize sum(m in MACHINE, c in COLOR)(produce[m,c]);\n\noutput [ show_int(3,produce[m,c]) ++\n         if c = 4 then \"\\n\" else \" \" endif\n       | m in MACHINE, c in COLOR ];\n\nn = 4;\nk = 11;\nl = [8,7,10,6];\nu = [14,16,12,20];\n\n"}, "hash": "7157c915b8e4996a9864c198ec583d381e8dc8098c0eba5114d6f1f2e8242308", "class_name": "RelatedNodeInfo"}}, "text": "**Problem Name:** TooMany\n\n**What the problem is about:** Imagine you have a factory with several machines that can produce different colored products (red, white, black, and blue) every day. Each machine can produce a certain amount of each color, and there are rules about how much of each color can be produced.\n\n**Main variables:**\n\n* `n`: The number of machines in the factory.\n* `k`: The total amount of products that can be produced per day.\n* `produce[m,c]`: The amount of color `c` produced by machine `m`.\n\n**Basic restrictions or rules:**\n\n* Each machine can produce at most `k` products per day.\n* The total amount of each color produced by all machines must be within a certain range (defined by `l` and `u`).\n* If a machine produces white and black products, it cannot produce blue products.\n* The amount of blue products produced by a machine cannot be more than the amount of red products.\n* The amount of red products produced by a machine must be a multiple of 4.\n* The amount of white products produced by a machine must be a multiple of 3.\n\n**Goal of the problem:** The goal is to maximize the total amount of products produced by all machines while following the rules and restrictions.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1207, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0c8aefc6-af68-4850-872c-fade026076a2": {"__data__": {"id_": "0c8aefc6-af68-4850-872c-fade026076a2", "embedding": null, "metadata": {"model_name": "traffic_lights_table", "source_code": "Model 1 :\n\n%Traffic lights problem in MiniZinc.\n% Specification:\n% Consider a four way traffic junction with eight traffic lights. Four of\n% the traffic lights are for the vehicles and can be represented by the\n% variables V1 to V4 with domains\n% {r,ry,g,y} (for red, red-yellow, green and yellow).\n%  The other four traffic lights are for the pedestrians and can be\n%  represented by the variables P1 to P4 with domains {r,g}.\n%\n% The constraints on these variables can be modelled by quaternary\n% constraints on\n% (Vi, Pi, Vj, Pj ) for 1<=i<=4, j=(1+i)mod 4 which allow just the tuples\n% {(r,r,g,g), (ry,r,y,r), (g,g,r,r), (y,r,ry,r)}.\n%\n% It would be interesting to consider other types of junction (e.g. five roads\n% intersecting) as well as modelling the evolution over time of the\n% traffic light sequence.\n\ninclude \"globals.mzn\";\n\nint: n = 4;\nint: r  = 1; % red\nint: ry = 2; % red-yellow\nint: g  = 3; % green\nint: y  = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V;\narray[1..n] of var Pedestrians: P;\n\n\nsolve satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   table([V[i], P[i], V[j], P[j]], allowed)\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\n% output [\n%  \"V: \", show(V), \"\\nP: \", show(P), \"\\n\"\n% ];\noutput [\n show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: n = 4;\nint: r = 1; % red\nint: ry = 2; % red-yellow\nint: g = 3; % green\nint: y = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V; % ;\narray[1..n] of var Pedestrians: P; %;\n\npredicate cp1d(array[int] of var int: x, array[int] of var int: y) =\n  assert(index_set(x) = index_set(y),\n           \"cp1d: x and y have different sizes\",\n     forall(i in index_set(x)) ( x[i] = y[i] ))\n; \n\n% solve satisfy;\nsolve :: int_search(V ++ P, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   exists(a in 1..4) (\n      cp1d([V[i], P[i], V[j], P[j]], [allowed[a,k] | k in 1..4])\n   )\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\noutput [\n  show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "traffic_lights_table_beginner", "node_type": "4", "metadata": {"model_name": "traffic_lights_table", "source_code": "Model 1 :\n\n%Traffic lights problem in MiniZinc.\n% Specification:\n% Consider a four way traffic junction with eight traffic lights. Four of\n% the traffic lights are for the vehicles and can be represented by the\n% variables V1 to V4 with domains\n% {r,ry,g,y} (for red, red-yellow, green and yellow).\n%  The other four traffic lights are for the pedestrians and can be\n%  represented by the variables P1 to P4 with domains {r,g}.\n%\n% The constraints on these variables can be modelled by quaternary\n% constraints on\n% (Vi, Pi, Vj, Pj ) for 1<=i<=4, j=(1+i)mod 4 which allow just the tuples\n% {(r,r,g,g), (ry,r,y,r), (g,g,r,r), (y,r,ry,r)}.\n%\n% It would be interesting to consider other types of junction (e.g. five roads\n% intersecting) as well as modelling the evolution over time of the\n% traffic light sequence.\n\ninclude \"globals.mzn\";\n\nint: n = 4;\nint: r  = 1; % red\nint: ry = 2; % red-yellow\nint: g  = 3; % green\nint: y  = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V;\narray[1..n] of var Pedestrians: P;\n\n\nsolve satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   table([V[i], P[i], V[j], P[j]], allowed)\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\n% output [\n%  \"V: \", show(V), \"\\nP: \", show(P), \"\\n\"\n% ];\noutput [\n show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: n = 4;\nint: r = 1; % red\nint: ry = 2; % red-yellow\nint: g = 3; % green\nint: y = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V; % ;\narray[1..n] of var Pedestrians: P; %;\n\npredicate cp1d(array[int] of var int: x, array[int] of var int: y) =\n  assert(index_set(x) = index_set(y),\n           \"cp1d: x and y have different sizes\",\n     forall(i in index_set(x)) ( x[i] = y[i] ))\n; \n\n% solve satisfy;\nsolve :: int_search(V ++ P, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   exists(a in 1..4) (\n      cp1d([V[i], P[i], V[j], P[j]], [allowed[a,k] | k in 1..4])\n   )\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\noutput [\n  show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n"}, "hash": "1fcd515b594f3166f2fe5bf2b14751565c606fb29b44ed31406a810d38272a99", "class_name": "RelatedNodeInfo"}}, "text": "**Traffic Light Problem**\n\nThis problem is about controlling traffic lights at a four-way junction. Imagine you're standing at a crossroads where four roads meet, and there are traffic lights for both cars and pedestrians.\n\n**Main Variables:**\n\n* `V1` to `V4`: These represent the traffic lights for cars, which can be red, red-yellow, green, or yellow.\n* `P1` to `P4`: These represent the traffic lights for pedestrians, which can be red or green.\n\n**Basic Restrictions or Rules:**\n\n* The traffic lights for cars and pedestrians at each intersection must follow certain rules, such as:\n\t+ When the car light is red, the pedestrian light must be red too.\n\t+ When the car light is green, the pedestrian light must be green too.\n\t+ When the car light is red-yellow, the pedestrian light must be yellow, and so on.\n\n**Goal:**\n\nThe goal is to find a sequence of traffic light settings that satisfy these rules and ensure safe and efficient traffic flow.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 949, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eae09164-57e4-4de5-8ec0-114d3db83622": {"__data__": {"id_": "eae09164-57e4-4de5-8ec0-114d3db83622", "embedding": null, "metadata": {"model_name": "TTPPV", "source_code": "% Traveling Tournament Problem with Predefined Venues\n%\n% Compact single round robin schedule minimizing total travel distance\n% The venue of each game has already been decided\n% Specialized for CIRC instances (circular distances)\n\ninclude \"globals.mzn\";\n\nint: nbTeams;\nint: nbRounds = nbTeams-1;\n\nset of int: Teams = 1..nbTeams;\nset of int: Rounds = 1..nbRounds;\nset of int: Travels = 1..nbRounds+1;\n\n% predefined venue: pv[i][j] = 1 iff i is playing at home against j\narray[Teams,Teams] of 1..2: pv; \n\n% circular distances: for i>=j, distance[i][j]=min{i-j,j-i+nbTeams}\narray[Teams,Teams] of int: distance = \n  array2d(Teams,Teams,[ if i>=j then (if i-j < j-i+nbTeams then i-j else j-i+nbTeams endif) \n                                else (if j-i < i-j+nbTeams then j-i else i-j+nbTeams endif) \n                                endif | i,j in Teams]);\n\n% output related\nint: digs = ceil(log(10.0,int2float(nbTeams)));\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% decision variables: in round k, team i plays against team opponent[i,k]\narray[Teams,Rounds] of var Teams: opponent;\n\n% auxiliary variables: venue[i,k] = 1 iff team i plays at home in round k\narray[Teams,Rounds] of var 1..2: venue;\nconstraint forall (i in Teams, k in Rounds) (venue[i,k] = pv[i,opponent[i,k]]);\n\n% auxiliary variables: travel[i,k] is the distance travelled by team i to go play in round k (includes travelling back home after last round)\narray[Teams,Travels] of var 0..(nbTeams div 2): travel;\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n% a team cannot play against itself\nconstraint forall (i in Teams, k in Rounds) (opponent[i,k] != i);\n\n% in round k, i plays j means j plays i\nconstraint forall (i in Teams, k in Rounds) (opponent[opponent[i,k],k] = i);\n\n% for each team i, all opponents are different\nconstraint forall (i in Teams) (alldifferent([opponent[i,k] | k in Rounds]));\n\n% for each round k, all opponents are different (implied constraint)\nconstraint forall (k in Rounds) (alldifferent([opponent[i,k] | i in Teams]));\n\n% for each team i, there can be at most 3 consecutive home games and at most 3 consecutive away games\nint: nbStates = 7;\nset of int: States = 1..nbStates;\narray[States,1..2] of int: delta = \n  [| 2, 5\n   | 3, 5\n   | 4, 5\n   | 0, 5\n   | 2, 6\n   | 2, 7\n   | 2, 0 |];\nconstraint forall (i in Teams) (regular( [venue[i,k] | k in Rounds], nbStates, 2, delta, 1, States));\n\n% symmetry breaking: distances are symmetric so reversing the rounds yields a schedule of same cost\nconstraint (opponent[1,1] < opponent[1,nbRounds]);\n\n% define travel variables wrt venues of current- and next-round games\nconstraint forall (i in Teams) (\n\t(venue[i,1]=1 -> travel[i,1] = 0) /\\\n\t(venue[i,1]=2 -> travel[i,1] = distance[i,opponent[i,1]]) );\nconstraint forall (i in Teams, k in 1..nbRounds-1) (\n\t((venue[i,k]=1 /\\ venue[i,k+1]=1) -> travel[i,k+1] = 0) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=1) -> travel[i,k+1] = distance[opponent[i,k],i]) /\\\n\t((venue[i,k]=1 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[i,opponent[i,k+1]]) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[opponent[i,k],opponent[i,k+1]]) );\nconstraint forall (i in Teams) (\n\t(venue[i,nbRounds]=1 -> travel[i,nbRounds+1] = 0) /\\\n\t(venue[i,nbRounds]=2 -> travel[i,nbRounds+1] = distance[opponent[i,nbRounds],i]) );\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nvar int: totalTravel;\nconstraint totalTravel = sum (i in Teams, k in Travels) (travel[i,k]);\nsolve minimize totalTravel;\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\noutput [\"SCHEDULE\\n\"] ++ \n       [ if fix(venue[i,k]) == 1 then \" \" else \"@\" endif ++\n\t show_int(digs,opponent[i,k]) ++ \" \" ++ \n         if k == nbRounds /\\ i != nbTeams then \"\\n\" else \"\" endif\n         | i in Teams, k in Rounds ] ++ [\"\\n\"] ++\n       [\"total travel = \"] ++ [show(totalTravel)] ++ [\"\\n\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "TTPPV_beginner", "node_type": "4", "metadata": {"model_name": "TTPPV", "source_code": "% Traveling Tournament Problem with Predefined Venues\n%\n% Compact single round robin schedule minimizing total travel distance\n% The venue of each game has already been decided\n% Specialized for CIRC instances (circular distances)\n\ninclude \"globals.mzn\";\n\nint: nbTeams;\nint: nbRounds = nbTeams-1;\n\nset of int: Teams = 1..nbTeams;\nset of int: Rounds = 1..nbRounds;\nset of int: Travels = 1..nbRounds+1;\n\n% predefined venue: pv[i][j] = 1 iff i is playing at home against j\narray[Teams,Teams] of 1..2: pv; \n\n% circular distances: for i>=j, distance[i][j]=min{i-j,j-i+nbTeams}\narray[Teams,Teams] of int: distance = \n  array2d(Teams,Teams,[ if i>=j then (if i-j < j-i+nbTeams then i-j else j-i+nbTeams endif) \n                                else (if j-i < i-j+nbTeams then j-i else i-j+nbTeams endif) \n                                endif | i,j in Teams]);\n\n% output related\nint: digs = ceil(log(10.0,int2float(nbTeams)));\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% decision variables: in round k, team i plays against team opponent[i,k]\narray[Teams,Rounds] of var Teams: opponent;\n\n% auxiliary variables: venue[i,k] = 1 iff team i plays at home in round k\narray[Teams,Rounds] of var 1..2: venue;\nconstraint forall (i in Teams, k in Rounds) (venue[i,k] = pv[i,opponent[i,k]]);\n\n% auxiliary variables: travel[i,k] is the distance travelled by team i to go play in round k (includes travelling back home after last round)\narray[Teams,Travels] of var 0..(nbTeams div 2): travel;\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n% a team cannot play against itself\nconstraint forall (i in Teams, k in Rounds) (opponent[i,k] != i);\n\n% in round k, i plays j means j plays i\nconstraint forall (i in Teams, k in Rounds) (opponent[opponent[i,k],k] = i);\n\n% for each team i, all opponents are different\nconstraint forall (i in Teams) (alldifferent([opponent[i,k] | k in Rounds]));\n\n% for each round k, all opponents are different (implied constraint)\nconstraint forall (k in Rounds) (alldifferent([opponent[i,k] | i in Teams]));\n\n% for each team i, there can be at most 3 consecutive home games and at most 3 consecutive away games\nint: nbStates = 7;\nset of int: States = 1..nbStates;\narray[States,1..2] of int: delta = \n  [| 2, 5\n   | 3, 5\n   | 4, 5\n   | 0, 5\n   | 2, 6\n   | 2, 7\n   | 2, 0 |];\nconstraint forall (i in Teams) (regular( [venue[i,k] | k in Rounds], nbStates, 2, delta, 1, States));\n\n% symmetry breaking: distances are symmetric so reversing the rounds yields a schedule of same cost\nconstraint (opponent[1,1] < opponent[1,nbRounds]);\n\n% define travel variables wrt venues of current- and next-round games\nconstraint forall (i in Teams) (\n\t(venue[i,1]=1 -> travel[i,1] = 0) /\\\n\t(venue[i,1]=2 -> travel[i,1] = distance[i,opponent[i,1]]) );\nconstraint forall (i in Teams, k in 1..nbRounds-1) (\n\t((venue[i,k]=1 /\\ venue[i,k+1]=1) -> travel[i,k+1] = 0) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=1) -> travel[i,k+1] = distance[opponent[i,k],i]) /\\\n\t((venue[i,k]=1 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[i,opponent[i,k+1]]) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[opponent[i,k],opponent[i,k+1]]) );\nconstraint forall (i in Teams) (\n\t(venue[i,nbRounds]=1 -> travel[i,nbRounds+1] = 0) /\\\n\t(venue[i,nbRounds]=2 -> travel[i,nbRounds+1] = distance[opponent[i,nbRounds],i]) );\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nvar int: totalTravel;\nconstraint totalTravel = sum (i in Teams, k in Travels) (travel[i,k]);\nsolve minimize totalTravel;\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\noutput [\"SCHEDULE\\n\"] ++ \n       [ if fix(venue[i,k]) == 1 then \" \" else \"@\" endif ++\n\t show_int(digs,opponent[i,k]) ++ \" \" ++ \n         if k == nbRounds /\\ i != nbTeams then \"\\n\" else \"\" endif\n         | i in Teams, k in Rounds ] ++ [\"\\n\"] ++\n       [\"total travel = \"] ++ [show(totalTravel)] ++ [\"\\n\"];\n"}, "hash": "d1a4ea2fc524d9ea1718f5f95f1be3e9b9ac4bfe22281f7d7962b9a58e344143", "class_name": "RelatedNodeInfo"}}, "text": "**Traveling Tournament Problem**\n\nThis problem is about scheduling a tournament where multiple teams play each other in a round-robin format, meaning each team plays every other team once. The twist is that each game has already been assigned a specific venue (home or away), and we want to find the schedule that minimizes the total travel distance for all teams.\n\n**Main Variables:**\n\n* `nbTeams`: The number of teams participating in the tournament.\n* `opponent[i,k]`: The team that team `i` plays against in round `k`.\n* `venue[i,k]`: Whether team `i` plays at home (1) or away (2) in round `k`.\n* `travel[i,k]`: The distance team `i` travels to play in round `k` (including the return journey after the last round).\n\n**Basic Restrictions:**\n\n* A team cannot play against itself.\n* If team `i` plays team `j` in round `k`, then team `j` plays team `i` in the same round.\n* Each team plays every other team exactly once.\n* No team can have more than three consecutive home games or away games.\n\n**Goal:**\n\nThe goal is to find a schedule that minimizes the total travel distance for all teams.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1095, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e3460b1d-b972-4260-b642-545a44b38645": {"__data__": {"id_": "e3460b1d-b972-4260-b642-545a44b38645", "embedding": null, "metadata": {"model_name": "vessel-loading", "source_code": "% Vessel Loading\n\nint: deck_width; % width of deck\nint: deck_length; % height of deck\nint: n_containers; % number of containers\nint: n_classes; % number of container classes\n\narray[int] of int: width;\n% width[c] = width of container c\narray[int] of int: length;\n% length[c] = length of container c\narray[int] of int: class;\n% class[c] = class of container c\narray[int, int] of int: separation;\n% separation[a, b] = the minimum allowed separation between\n%                    containers of classes a and b\n\nset of int: Containers = 1..n_containers;\n\narray[Containers] of var 0..deck_width: Left;\n% Left[c] = leftmost point of container c\narray[Containers] of var 0..deck_width: Right;\n% Right[c] = rightmost point of container c\narray[Containers] of var 0..deck_length: Bottom;\n% Bottom[c] = bottommost point of container c\narray[Containers] of var 0..deck_length: Top;\n% Top[c] = topmost point of container c\n\narray[Containers] of var 1..2: orientation;\n% orientation[c] = 2 if container c is turned 90 degrees, else 1.\n\nconstraint\n  forall (c in Containers) (\n    let {\n      array[1..2] of int: ElemWidth = [width[c], length[c]];\n      array[1..2] of int: ElemLength = [length[c], width[c]]\n    }\n    in \n      Right[c] = Left[c] + ElemWidth[orientation[c]] /\\\n      Top[c] = Bottom[c] + ElemLength[orientation[c]]\n  )\n;\n\nconstraint\n  forall(c, k in Containers where c < k) (\n    Left[c] >= Right[k] + separation[class[c], class[k]] \\/\n    Right[c] + separation[class[c], class[k]] <= Left[k] \\/\n    Bottom[c] >= Top[k] + separation[class[c], class[k]] \\/\n    Top[c] + separation[class[c], class[k]] <= Bottom[k]\n  )\n;\n\n% Excessive (pretty) output\noutput [\"\u250c\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2510\\n\"] ++\n       [if x == 0 then \"\u2502\" else \"\" endif ++\n        let {\n          bool: l = exists([fix(Left[c])   = x | c in Containers]);\n          bool: r = exists([fix(Right[c])  = x | c in Containers]);\n          bool: b = exists([fix(Bottom[c]) = y | c in Containers]);\n          bool: t = exists([fix(Top[c])    = y | c in Containers])\n        } in\n          if     l /\\ r /\\ b /\\ t then \"\u253c\"\n          elseif l /\\ r /\\ b      then \"\u252c\"\n          elseif l /\\ r /\\      t then \"\u2534\"\n          elseif l /\\      b /\\ t then \"\u251c\"\n          elseif      r /\\ b /\\ t then \"\u2524\"\n          elseif l /\\      b      then \"\u250c\"\n          elseif l /\\           t then \"\u2514\"\n          elseif      r /\\ b      then \"\u2510\"\n          elseif      r /\\      t then \"\u2518\"\n          elseif l \\/ r           then \"\u2502\"\n          elseif           b \\/ t then \"\u2500\" \n          else \" \" endif ++\n        if x == deck_width then \"\u2502\\n\" else \"\" endif\n        | y in 0..deck_length, x in 0..deck_width] ++\n        [\"\u2514\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2518\"];\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "vessel-loading_beginner", "node_type": "4", "metadata": {"model_name": "vessel-loading", "source_code": "% Vessel Loading\n\nint: deck_width; % width of deck\nint: deck_length; % height of deck\nint: n_containers; % number of containers\nint: n_classes; % number of container classes\n\narray[int] of int: width;\n% width[c] = width of container c\narray[int] of int: length;\n% length[c] = length of container c\narray[int] of int: class;\n% class[c] = class of container c\narray[int, int] of int: separation;\n% separation[a, b] = the minimum allowed separation between\n%                    containers of classes a and b\n\nset of int: Containers = 1..n_containers;\n\narray[Containers] of var 0..deck_width: Left;\n% Left[c] = leftmost point of container c\narray[Containers] of var 0..deck_width: Right;\n% Right[c] = rightmost point of container c\narray[Containers] of var 0..deck_length: Bottom;\n% Bottom[c] = bottommost point of container c\narray[Containers] of var 0..deck_length: Top;\n% Top[c] = topmost point of container c\n\narray[Containers] of var 1..2: orientation;\n% orientation[c] = 2 if container c is turned 90 degrees, else 1.\n\nconstraint\n  forall (c in Containers) (\n    let {\n      array[1..2] of int: ElemWidth = [width[c], length[c]];\n      array[1..2] of int: ElemLength = [length[c], width[c]]\n    }\n    in \n      Right[c] = Left[c] + ElemWidth[orientation[c]] /\\\n      Top[c] = Bottom[c] + ElemLength[orientation[c]]\n  )\n;\n\nconstraint\n  forall(c, k in Containers where c < k) (\n    Left[c] >= Right[k] + separation[class[c], class[k]] \\/\n    Right[c] + separation[class[c], class[k]] <= Left[k] \\/\n    Bottom[c] >= Top[k] + separation[class[c], class[k]] \\/\n    Top[c] + separation[class[c], class[k]] <= Bottom[k]\n  )\n;\n\n% Excessive (pretty) output\noutput [\"\u250c\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2510\\n\"] ++\n       [if x == 0 then \"\u2502\" else \"\" endif ++\n        let {\n          bool: l = exists([fix(Left[c])   = x | c in Containers]);\n          bool: r = exists([fix(Right[c])  = x | c in Containers]);\n          bool: b = exists([fix(Bottom[c]) = y | c in Containers]);\n          bool: t = exists([fix(Top[c])    = y | c in Containers])\n        } in\n          if     l /\\ r /\\ b /\\ t then \"\u253c\"\n          elseif l /\\ r /\\ b      then \"\u252c\"\n          elseif l /\\ r /\\      t then \"\u2534\"\n          elseif l /\\      b /\\ t then \"\u251c\"\n          elseif      r /\\ b /\\ t then \"\u2524\"\n          elseif l /\\      b      then \"\u250c\"\n          elseif l /\\           t then \"\u2514\"\n          elseif      r /\\ b      then \"\u2510\"\n          elseif      r /\\      t then \"\u2518\"\n          elseif l \\/ r           then \"\u2502\"\n          elseif           b \\/ t then \"\u2500\" \n          else \" \" endif ++\n        if x == deck_width then \"\u2502\\n\" else \"\" endif\n        | y in 0..deck_length, x in 0..deck_width] ++\n        [\"\u2514\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2518\"];\n"}, "hash": "56aec32d6a7bcfa3aa49a17af8a0dfb36c30453bcb2cdbbea2722fd3c62d1b18", "class_name": "RelatedNodeInfo"}}, "text": "Vessel Loading\n\nThis problem is about loading containers onto a ship's deck. Imagine you have a bunch of boxes of different sizes and types, and you need to fit them onto a rectangular deck.\n\nThe main variables are:\n\n* The width and length of the deck\n* The number of containers and their classes (types)\n* The width, length, and class of each container\n* The minimum separation required between containers of different classes\n* The position of each container on the deck (left, right, bottom, and top coordinates)\n* The orientation of each container (whether it's turned 90 degrees or not)\n\nThe basic restrictions or rules of the problem are:\n\n* Each container must fit within the deck's boundaries\n* Containers cannot overlap with each other\n* Containers of different classes must be separated by a minimum distance\n\nThe goal of the problem is to find a way to load all the containers onto the deck while following these rules.\n\nNote: The output section of the code is used to print a visual representation of the loaded containers, but it's not essential to understanding the problem itself.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1095, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "75c261b6-72c3-4f49-9bc6-dfdb2d82c1dc": {"__data__": {"id_": "75c261b6-72c3-4f49-9bc6-dfdb2d82c1dc", "embedding": null, "metadata": {"model_name": "warehouses", "source_code": "% Warehouse allocation\n\n% vim: ft=zinc ts=2 sw=2 et tw=0\n\n% A company needs to construct warehouses to supply stores with goods.  Each\n% warehouse possibly to be constructed has a certain capacity defining how many\n% stores it can supply.  Constructing a warehouse incurs a fixed cost.  Costs\n% for transportation from warehouses to stores depend on the locations of\n% warehouses and stores.\n%\n% Determine which warehouses should be constructed and which warehouse should\n% supply which store such that overall cost (transportation cost plus\n% construction cost) is smallest.\n%-----------------------------------------------------------------------------\n\ninclude \"globals.mzn\";\n\n%-----------------------------------------------------------------------------\n% Instance\n\nn_suppliers = 5;\nn_stores = 10;\nbuilding_cost = 30;\n\ncapacity = [1,4,2,1,3];\n\ncost_matrix =\n [|20, 24, 11, 25, 30\n  |28, 27, 82, 83, 74\n  |74, 97, 71, 96, 70\n  | 2, 55, 73, 69, 61\n  |46, 96, 59, 83,  4\n  |42, 22, 29, 67, 59\n  | 1,  5, 73, 59, 56\n  |10, 73, 13, 43, 96\n  |93, 35, 63, 85, 46\n  |47, 65, 55, 71, 95|]; \n\n%-----------------------------------------------------------------------------\n% Model\n\nint: n_suppliers;\nint: n_stores;\nint: building_cost;\narray[1..n_suppliers] of int: capacity;\narray[1..n_stores,1..n_suppliers] of int: cost_matrix;\n\nint: MaxCost = max(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]);\nint: MaxTotal =   (n_suppliers * building_cost) \n                + sum(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]); \n\narray[1..n_stores] of var 1..n_suppliers: supplier;\narray[1..n_suppliers] of var bool: open;\narray[1..n_stores] of var 1..MaxCost: cost;\nvar 1..MaxTotal: tot;\n\nconstraint\n  sum (i in 1..n_suppliers) (building_cost * bool2int(open[i])) +\n  sum (i in 1..n_stores) (cost[i])\n  = tot;\n\nconstraint\n  forall (i in 1..n_stores) (\n    cost_matrix[i,supplier[i]] = cost[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    let {\n      var int: use\n     } in\n    count(supplier,i,use) /\\ use <= capacity[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    (exists (j in 1..n_stores) (supplier[j] == i)) == open[i]\n  );\n\nsolve\n  :: int_search(\n    supplier ++ cost ++ [bool2int(open[i]) | i in 1..n_suppliers],\n    first_fail,\n    indomain_split,\n    complete\n  )\n  minimize tot;\n\noutput\n  [ \"warehouses:\" ]\n  ++\n  [ \"\\ntot = \", show(tot) ]\n  ++\n  [ \"\\nsupplier = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(supplier[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\ncost = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(cost[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\nopen = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(open[i]) ++\n    if i = n_suppliers then \"\\n]\\n\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_suppliers\n  ]\n\n%-----------------------------------------------------------------------------\n%-----------------------------------------------------------------------------\n"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "warehouses_beginner", "node_type": "4", "metadata": {"model_name": "warehouses", "source_code": "% Warehouse allocation\n\n% vim: ft=zinc ts=2 sw=2 et tw=0\n\n% A company needs to construct warehouses to supply stores with goods.  Each\n% warehouse possibly to be constructed has a certain capacity defining how many\n% stores it can supply.  Constructing a warehouse incurs a fixed cost.  Costs\n% for transportation from warehouses to stores depend on the locations of\n% warehouses and stores.\n%\n% Determine which warehouses should be constructed and which warehouse should\n% supply which store such that overall cost (transportation cost plus\n% construction cost) is smallest.\n%-----------------------------------------------------------------------------\n\ninclude \"globals.mzn\";\n\n%-----------------------------------------------------------------------------\n% Instance\n\nn_suppliers = 5;\nn_stores = 10;\nbuilding_cost = 30;\n\ncapacity = [1,4,2,1,3];\n\ncost_matrix =\n [|20, 24, 11, 25, 30\n  |28, 27, 82, 83, 74\n  |74, 97, 71, 96, 70\n  | 2, 55, 73, 69, 61\n  |46, 96, 59, 83,  4\n  |42, 22, 29, 67, 59\n  | 1,  5, 73, 59, 56\n  |10, 73, 13, 43, 96\n  |93, 35, 63, 85, 46\n  |47, 65, 55, 71, 95|]; \n\n%-----------------------------------------------------------------------------\n% Model\n\nint: n_suppliers;\nint: n_stores;\nint: building_cost;\narray[1..n_suppliers] of int: capacity;\narray[1..n_stores,1..n_suppliers] of int: cost_matrix;\n\nint: MaxCost = max(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]);\nint: MaxTotal =   (n_suppliers * building_cost) \n                + sum(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]); \n\narray[1..n_stores] of var 1..n_suppliers: supplier;\narray[1..n_suppliers] of var bool: open;\narray[1..n_stores] of var 1..MaxCost: cost;\nvar 1..MaxTotal: tot;\n\nconstraint\n  sum (i in 1..n_suppliers) (building_cost * bool2int(open[i])) +\n  sum (i in 1..n_stores) (cost[i])\n  = tot;\n\nconstraint\n  forall (i in 1..n_stores) (\n    cost_matrix[i,supplier[i]] = cost[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    let {\n      var int: use\n     } in\n    count(supplier,i,use) /\\ use <= capacity[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    (exists (j in 1..n_stores) (supplier[j] == i)) == open[i]\n  );\n\nsolve\n  :: int_search(\n    supplier ++ cost ++ [bool2int(open[i]) | i in 1..n_suppliers],\n    first_fail,\n    indomain_split,\n    complete\n  )\n  minimize tot;\n\noutput\n  [ \"warehouses:\" ]\n  ++\n  [ \"\\ntot = \", show(tot) ]\n  ++\n  [ \"\\nsupplier = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(supplier[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\ncost = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(cost[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\nopen = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(open[i]) ++\n    if i = n_suppliers then \"\\n]\\n\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_suppliers\n  ]\n\n%-----------------------------------------------------------------------------\n%-----------------------------------------------------------------------------\n"}, "hash": "8981b9678254c75c62a472d364c7a47421c199b357251c2d292e3f1c5e3b95c1", "class_name": "RelatedNodeInfo"}}, "text": "Warehouse Allocation Problem\n\nThis problem is about a company that wants to build warehouses to supply goods to stores. The company needs to decide which warehouses to build and which stores each warehouse should supply to minimize the total cost.\n\nThe main variables are:\n\n* Warehouses: These are the places where the company will store goods.\n* Stores: These are the places where the company will send goods from the warehouses.\n* Capacity: This is the number of stores that each warehouse can supply.\n* Cost: This is the cost of building a warehouse and transporting goods from the warehouse to the stores.\n\nThe basic restrictions or rules of the problem are:\n\n* Each warehouse can only supply a certain number of stores based on its capacity.\n* Each store must be supplied by only one warehouse.\n* The company wants to minimize the total cost, which includes the cost of building warehouses and transporting goods.\n\nThe goal of the problem is to find the best way to allocate warehouses to stores to minimize the total cost.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1028, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fe2be0eb-1264-4141-bfbb-49779261a2ed": {"__data__": {"id_": "fe2be0eb-1264-4141-bfbb-49779261a2ed", "embedding": null, "metadata": {"model_name": "water_buckets1", "source_code": "Model 1 :\n\n% Water buckets problem in Minizinc\n% \"\"\"\n% Problem description\n% This is a generalization of the CSPLib specification, which is as follows: Given an 8 pint bucket of water, and two empty buckets which can contain 5 and 3 pints respectively, the problem requires to divide the water into two by pouring water between buckets (that is, to end up with 4 pints in the 8 pint bucket, and 4 pints in the 5 pint bucket) in the smallest number of transfers.\n%\n% The generalization consists in making the specification parametric with respect to the start and goal configurations, which are now inputs to the problem.\n%\n% Problem input\n%\n% * Function start, assigning an initial amount of water to each bucket\n% * Function goal, assigning the goal amount of water to each bucket \n%\n% Search space\n% The set of all possibile sequences of configurations (states), where a configuration is a triple encoding the amount of water in each bucket at a given time-step\n%\n% Constraints\n%\n% * C1: At beginning, buckets contain the amount of water specified by function start\n% * C2: At the end, buckets contain the amount of water specified by function goal\n% * C3: The configuration at each step differs from that of the next one in that the amount of water of exactly 2 buckets changes (that in the others remain the same)\n% * C4: The overall amount of water is the same at each time step\n% * C5: After each transition (involving buckets b1 and b2), either the source bucket becomes empty, or the target becomes full\n% \"\"\"\n\n\nint: nb_buckets = 3;\nint: max_step = 10; % 8 for satisfy\nset of int: buckets = 1..nb_buckets;\nset of int: steps = 1..max_step;\narray[buckets] of int: capacity = [8,5,3];\narray[buckets] of int: start = [8,0,0];\narray[buckets] of int: goal = [4,4,0];\n\n% Search space: The set of all possibile sequences of configurations (states), \n% where a configuration is a triple encoding the amount of water in each \n% bucket at a given time-step\narray[steps, buckets] of var int: state;\nvar 1..max_step: goal_step;\n\n% Objective function\nsolve minimize goal_step;\n% solve :: int_search( [ state[i,j] | i in steps, j in buckets ] , \"first_fail\", \"indomain\", \"complete\")  minimize goal_step;\n\nconstraint\n%   goal_step <= 8 % for solve satisfy\n%   /\\\n   % assertions\n   forall(b in buckets) (\n      (start[b] <= capacity[b]) /\\ (goal[b] <= capacity[b])\n   )\n   /\\\n   sum(b in buckets)(start[b]) = sum(b in buckets)(goal[b])\n   /\\\n   forall(s in steps, b in buckets) (\n      state[s,b] >= 0 /\\\n      state[s,b] <= capacity[b]\n   )\n   /\\\n   forall(b in buckets) (\n      % C1: At beginning, buckets contain the amount of water specified by function start\n      state[1,b]=start[b]\n      /\\\n      % C2: At the end, buckets contain the amount of water specified by function goal\n      state[goal_step,b] = goal[b]\n   )\n   /\\\n   forall(step in 1..max_step-1) (\n      % C3: The configuration at each step differs from that of the next one in that the amount of\n      % water of exactly 2 buckets changes (that in the others remain the same)\n      sum(b in buckets)( bool2int(state[step,b] != state[step+1, b])) = 2\n      /\\\n      % C4: The overall amount of water is the same at each time step\n      sum(b in buckets)(state[step,b]) = sum(b in buckets)(state[step+1,b])\n      /\\\n\n      % C5: After each transition (involving buckets b1 and b2), either the source\n      % bucket becomes empty, or the target becomes full\n      forall(b1, b2 in buckets where b1 != b2) (\n         ((state[step, b1] != state[step+1, b1]) /\\ (state[step, b2] != state[step+1, b2])) ->\n            (state[step+1,b1] = 0 \\/ state[step+1,b1] = capacity[b1] \\/\n             state[step+1,b2] = 0 \\/ state[step+1,b2] = capacity[b2])\n     )\n   )\n;\n\n\noutput [\n  if s = 1 /\\ b = 1 then \n    \"goal_step: \" ++ show(goal_step)\n  else \"\" endif ++\n  if b = 1 then \"\\n\" else \" \" endif ++\n  show(state[s, b])\n  | s in steps, b in buckets\n\n] \n++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\n\ninclude \"globals.mzn\";\n\nint: n_states = 15;\nint: input_max = 15;\nint: initial_state = 1;\nset of int: accepting_states = {15};\n\n\n% distance\narray[1..n_states, 1..n_states] of 0..input_max: transition_fn =\narray2d(1..n_states, 1..n_states,\n[%1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n  0, 2, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 1\n  0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 2 \n  0, 0, 0, 4, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 3\n  0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 4\n  0, 0, 0, 0, 0, 6, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 5\n  0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, % 6\n  0, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 0, 0, 0, 0, % 7\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, % 8 \n  0, 0, 0, 0, 0, 0, 0, 0, 0,10, 0, 0, 0, 0, 0, % 9\n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0,11, 0, 0, 0, 0, %10\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,12, 0, 0, 0, %11 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,13, 0, 0, %12\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,14, 0, %13 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %14\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %15\n]);\n\n\narray[1..n_states] of string:  nodes = [\n        \"8,0,0\", % 1 start\n        \"5,0,3\", % 2\n        \"5,3,0\", % 3 \n        \"2,3,3\", % 4 \n        \"2,5,1\", % 5\n        \"7,0,1\", % 6\n        \"7,1,0\", % 7\n        \"4,1,3\", % 8\n        \"3,5,0\", % 9\n        \"3,2,3\", % 10\n        \"6,2,0\", % 11\n        \"6,0,2\", % 12\n        \"1,5,2\", % 13\n        \"1,4,3\", % 14\n        \"4,4,0\"  % 15 goal\n        ];\n\n\narray[1..input_max] of var 0..input_max: x;\nvar 0..input_max: cost;\n\n% solve satisfy;\nsolve minimize cost;\n\nconstraint\nregular(x, n_states, input_max, transition_fn,\n        initial_state, accepting_states)\n;\n\nconstraint\n   cost = 2+sum([bool2int(x[i-1] != x[i] ) | i in 2..input_max])\n;\n\noutput \n[\"cost: \" ++ show(cost) ++ \"\\n\"] ++\n[show(initial_state) ++ \" \"] ++\n[\n  if fix(x[i]) < input_max then show(x[i]) ++ \" \" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(input_max) ++ \"\\n\"] ++ \n[\"\\n\\n\"] ++\n\n[show(nodes[initial_state]) ++ \"\\n\"] ++\n[\n  if fix(x[i]) < input_max then show(nodes[fix(x[i])]) ++ \"\\n\" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(nodes[input_max]) ++ \"\\n\"] ++ \n[\"\\n\"];"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "water_buckets1_beginner", "node_type": "4", "metadata": {"model_name": "water_buckets1", "source_code": "Model 1 :\n\n% Water buckets problem in Minizinc\n% \"\"\"\n% Problem description\n% This is a generalization of the CSPLib specification, which is as follows: Given an 8 pint bucket of water, and two empty buckets which can contain 5 and 3 pints respectively, the problem requires to divide the water into two by pouring water between buckets (that is, to end up with 4 pints in the 8 pint bucket, and 4 pints in the 5 pint bucket) in the smallest number of transfers.\n%\n% The generalization consists in making the specification parametric with respect to the start and goal configurations, which are now inputs to the problem.\n%\n% Problem input\n%\n% * Function start, assigning an initial amount of water to each bucket\n% * Function goal, assigning the goal amount of water to each bucket \n%\n% Search space\n% The set of all possibile sequences of configurations (states), where a configuration is a triple encoding the amount of water in each bucket at a given time-step\n%\n% Constraints\n%\n% * C1: At beginning, buckets contain the amount of water specified by function start\n% * C2: At the end, buckets contain the amount of water specified by function goal\n% * C3: The configuration at each step differs from that of the next one in that the amount of water of exactly 2 buckets changes (that in the others remain the same)\n% * C4: The overall amount of water is the same at each time step\n% * C5: After each transition (involving buckets b1 and b2), either the source bucket becomes empty, or the target becomes full\n% \"\"\"\n\n\nint: nb_buckets = 3;\nint: max_step = 10; % 8 for satisfy\nset of int: buckets = 1..nb_buckets;\nset of int: steps = 1..max_step;\narray[buckets] of int: capacity = [8,5,3];\narray[buckets] of int: start = [8,0,0];\narray[buckets] of int: goal = [4,4,0];\n\n% Search space: The set of all possibile sequences of configurations (states), \n% where a configuration is a triple encoding the amount of water in each \n% bucket at a given time-step\narray[steps, buckets] of var int: state;\nvar 1..max_step: goal_step;\n\n% Objective function\nsolve minimize goal_step;\n% solve :: int_search( [ state[i,j] | i in steps, j in buckets ] , \"first_fail\", \"indomain\", \"complete\")  minimize goal_step;\n\nconstraint\n%   goal_step <= 8 % for solve satisfy\n%   /\\\n   % assertions\n   forall(b in buckets) (\n      (start[b] <= capacity[b]) /\\ (goal[b] <= capacity[b])\n   )\n   /\\\n   sum(b in buckets)(start[b]) = sum(b in buckets)(goal[b])\n   /\\\n   forall(s in steps, b in buckets) (\n      state[s,b] >= 0 /\\\n      state[s,b] <= capacity[b]\n   )\n   /\\\n   forall(b in buckets) (\n      % C1: At beginning, buckets contain the amount of water specified by function start\n      state[1,b]=start[b]\n      /\\\n      % C2: At the end, buckets contain the amount of water specified by function goal\n      state[goal_step,b] = goal[b]\n   )\n   /\\\n   forall(step in 1..max_step-1) (\n      % C3: The configuration at each step differs from that of the next one in that the amount of\n      % water of exactly 2 buckets changes (that in the others remain the same)\n      sum(b in buckets)( bool2int(state[step,b] != state[step+1, b])) = 2\n      /\\\n      % C4: The overall amount of water is the same at each time step\n      sum(b in buckets)(state[step,b]) = sum(b in buckets)(state[step+1,b])\n      /\\\n\n      % C5: After each transition (involving buckets b1 and b2), either the source\n      % bucket becomes empty, or the target becomes full\n      forall(b1, b2 in buckets where b1 != b2) (\n         ((state[step, b1] != state[step+1, b1]) /\\ (state[step, b2] != state[step+1, b2])) ->\n            (state[step+1,b1] = 0 \\/ state[step+1,b1] = capacity[b1] \\/\n             state[step+1,b2] = 0 \\/ state[step+1,b2] = capacity[b2])\n     )\n   )\n;\n\n\noutput [\n  if s = 1 /\\ b = 1 then \n    \"goal_step: \" ++ show(goal_step)\n  else \"\" endif ++\n  if b = 1 then \"\\n\" else \" \" endif ++\n  show(state[s, b])\n  | s in steps, b in buckets\n\n] \n++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\n\ninclude \"globals.mzn\";\n\nint: n_states = 15;\nint: input_max = 15;\nint: initial_state = 1;\nset of int: accepting_states = {15};\n\n\n% distance\narray[1..n_states, 1..n_states] of 0..input_max: transition_fn =\narray2d(1..n_states, 1..n_states,\n[%1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n  0, 2, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 1\n  0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 2 \n  0, 0, 0, 4, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 3\n  0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 4\n  0, 0, 0, 0, 0, 6, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 5\n  0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, % 6\n  0, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 0, 0, 0, 0, % 7\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, % 8 \n  0, 0, 0, 0, 0, 0, 0, 0, 0,10, 0, 0, 0, 0, 0, % 9\n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0,11, 0, 0, 0, 0, %10\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,12, 0, 0, 0, %11 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,13, 0, 0, %12\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,14, 0, %13 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %14\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %15\n]);\n\n\narray[1..n_states] of string:  nodes = [\n        \"8,0,0\", % 1 start\n        \"5,0,3\", % 2\n        \"5,3,0\", % 3 \n        \"2,3,3\", % 4 \n        \"2,5,1\", % 5\n        \"7,0,1\", % 6\n        \"7,1,0\", % 7\n        \"4,1,3\", % 8\n        \"3,5,0\", % 9\n        \"3,2,3\", % 10\n        \"6,2,0\", % 11\n        \"6,0,2\", % 12\n        \"1,5,2\", % 13\n        \"1,4,3\", % 14\n        \"4,4,0\"  % 15 goal\n        ];\n\n\narray[1..input_max] of var 0..input_max: x;\nvar 0..input_max: cost;\n\n% solve satisfy;\nsolve minimize cost;\n\nconstraint\nregular(x, n_states, input_max, transition_fn,\n        initial_state, accepting_states)\n;\n\nconstraint\n   cost = 2+sum([bool2int(x[i-1] != x[i] ) | i in 2..input_max])\n;\n\noutput \n[\"cost: \" ++ show(cost) ++ \"\\n\"] ++\n[show(initial_state) ++ \" \"] ++\n[\n  if fix(x[i]) < input_max then show(x[i]) ++ \" \" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(input_max) ++ \"\\n\"] ++ \n[\"\\n\\n\"] ++\n\n[show(nodes[initial_state]) ++ \"\\n\"] ++\n[\n  if fix(x[i]) < input_max then show(nodes[fix(x[i])]) ++ \"\\n\" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(nodes[input_max]) ++ \"\\n\"] ++ \n[\"\\n\"];"}, "hash": "806f2cec446b5f75450caac8cce7deacdf2ea0554f8b1f11aec6aa76d86d3060", "class_name": "RelatedNodeInfo"}}, "text": "Here is the explanation of the problem:\n\n**Name of the problem:** Water Buckets Problem\n\n**What the problem is about in everyday terms:** Imagine you have three buckets of different sizes (8, 5, and 3 pints) and you want to divide a certain amount of water between them in a specific way. You can pour water from one bucket to another, but you want to do it in the fewest number of steps possible.\n\n**Main variables and what they mean:**\n\n* `state`: an array that represents the amount of water in each bucket at each step\n* `goal_step`: the number of steps it takes to reach the desired goal\n* `buckets`: the three buckets of different sizes\n* `capacity`: the maximum amount of water each bucket can hold\n* `start` and `goal`: the initial and desired amounts of water in each bucket\n\n**Basic restrictions or rules of the problem:**\n\n* The total amount of water remains the same at each step\n* The amount of water in each bucket can only change by pouring water from one bucket to another\n* After each step, either the source bucket becomes empty or the target bucket becomes full\n* The goal is to reach the desired amounts of water in each bucket in the fewest number of steps possible\n\n**Goal of the problem:** Minimize the number of steps (`goal_step`) it takes to reach the desired goal.\n\nNote that Model 2 appears to be a different problem, but it's actually a reformulation of the same Water Buckets Problem using a different modeling approach.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1450, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"all_interval_beginner": {"node_ids": ["07ce856f-ec8e-4062-b7df-2af74288b0db"], "metadata": {"model_name": "all_interval", "source_code": "Model 1 : \n\n\n%\n% All interval problem in MiniZinc\n%\n% \"\"\"\n% Given the twelve standard pitch-classes (c, c%, d, ...), represented by\n% numbers 0,1,...,11, find a series in which each pitch-class occurs exactly\n% once and in which the musical intervals between neighbouring notes cover\n% the full set of intervals from the minor second (1 semitone) to the major\n% seventh (11 semitones). That is, for each of the intervals, there is a\n% pair of neigbhouring pitch-classes in the series, between which this\n% interval appears. The problem of finding such a series can be easily\n% formulated as an instance of a more general arithmetic problem on Z_n,\n% the set of integer residues modulo n. Given n in N, find a vector\n% s = (s_1, ..., s_n), such that (i) s is a permutation of\n% Z_n = {0,1,...,n-1}; and (ii) the interval vector\n% v = (|s_2-s_1|, |s_3-s_2|, ... |s_n-s_{n-1}|) is a permutation of\n% Z_n-{0} = {1,2,...,n-1}. A vector v satisfying these conditions is\n% called an all-interval series of size n; the problem of finding such\n% a series is the all-interval series problem of size n. We may also be\n% interested in finding all possible series of a given size.\n\ninclude \"globals.mzn\";\n\nint: n = 12;\n% array[1..n] of var 1..n: x;\narray[1..n] of var 1..n: x;\narray[1..n-1] of var 1..n-1: diffs;\nint: sum_distinct = ((n+1)*n) div 2;\n\n% max_regret seems to be quite good....\nsolve :: int_search(x, max_regret, indomain_split, complete) satisfy;\n\nconstraint      \n  all_different(diffs) :: domain\n  /\\  \n  all_different(x) :: domain\n  /\\ \n  forall(k in 1..n-1) (\n      diffs[k] = abs(x[k+1] - x[k])\n  )\n  /\\ % symmetry breaking\n  x[1] < x[n-1]\n  /\\\n  diffs[1] < diffs[2]\n;\n\n\noutput [\n       show(x) ++ \",\" % , \" \", show(sum_distinct), \" diffs: \", show(diffs)\n]\n\n\nModel 2 : \n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n%    all_different(series) /\\\n\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i != j)  (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n;\n\noutput\n[  show(series)\n];\n\n\nModel 3 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   %  C1: Each pitch class occurs exactly once\n   forall(i, j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i!=j) (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput\n[ show(series)\n];\n\n\nModel 4 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[differ] of var differ: differences;\n\nsolve satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 1..n-2) (\n       differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in differ where i != j) (\n       differences[i] != differences[j]\n   )\n;\n\noutput [\n  show(series)\n];\n\n\nModel 5 : \n\n\ninclude \"globals.mzn\";\n\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_median, complete) satisfy;\n\nconstraint\n  % C1: Each pitch class occurs exactly once\n  % GCAD: Exploitation of alldifferent() global constraint\n  all_different(series)\n  /\\\n\n  % C2: Differences between neighbouring notes are all different\n  % GCAD: Exploitation of alldifferent() global constraint\n  % alldifferent(all (i in classes: i <> n-1) abs(series[i+1] - series[i]));\n  all_different( \n         [ abs(series[i+1] - series[i]) | i in classes where i != n-1]\n  )\n  \n;\n\noutput [\n  show(series)\n];\n\n\nModel 6 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\n% solve satisfy;\nsolve :: int_search(series, occurrence, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n      differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in 0..n-2 where i != j) (\n      differences[i] != differences[j]\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\noutput [\n  show(series)\n];\n\n\nModel 7 : \n\n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\nsolve ::int_search(series, first_fail, indomain_max, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(series)\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n          differences[i] = abs(series[i+1] - series[i])\n   )\n   /\\\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(differences)\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput [\n   \"series: \" ++ show(series) ++ \"\\n\" ++\n   \"differences: \" ++ show(differences) \n];"}}, "assign_beginner": {"node_ids": ["5d95f426-a5a5-4f06-8ab4-255fe1eeb1fe"], "metadata": {"model_name": "assign", "source_code": "Model 1 :\n\nint: n;\nset of int: WORK = 1..n;\nint: m;\nset of int: TASK = 1..m;\narray[WORK,TASK] of int: profit;\narray[WORK] of var TASK: x;\n% new\narray[WORK] of var int: px =\n     [ profit[w,x[w]] | w in WORK ];\nvar int: obj = sum(w in WORK)(px[w]);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\n\nann: varselect;\nann: valselect;\n\nsolve :: int_search(px, varselect, valselect, complete)\n      maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x);\\n\"];\n\n\nvarselect = largest;\nvalselect = indomain_min;\n\n\nModel 2 : \n\n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[DOM] of var COD: task;\narray[COD] of var DOM: worker;\n\ninclude \"inverse.mzn\";\nconstraint inverse(task,worker);\n\n\nsolve maximize sum(w in COD)\n            (profit[w,task[w]]);\n\noutput [show(task)];\n\n\n\nModel 3 : \n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[COD] of var DOM: worker;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(worker);\n\n\nsolve maximize sum(t in COD)\n            (profit[worker[t],t]);\n\noutput [show(worker)];\n"}}, "aust_color_beginner": {"node_ids": ["98d9e212-d5e9-467e-9c8e-90a6c70c6d5d"], "metadata": {"model_name": "aust_color", "source_code": "Model 1 :\n\n% Colouring Australia using 4 colors \nint: nc = 4;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n\n\n Model 2 :\n\n % Colouring Australia using nc colors \nint: nc;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n"}}, "bibd_beginner": {"node_ids": ["e1a5974f-61ea-47de-aa8d-e48c423921ad"], "metadata": {"model_name": "bibd", "source_code": "% bibd.mzn\n% vim: ft=zinc ts=4 sw=4 et tw=0\n% Ralph Becket <rafe@csse.unimelb.edu.au>\n% Tue Oct 23 11:28:06 EST 2007\n%\n% Balanced incomplete block designs.  See the following:\n% http://mathworld.wolfram.com/BlockDesign.html\n% http://www.dcs.st-and.ac.uk/~ianm/CSPLib/prob/prob028/spec.html\n%\n%\n%\n% A BIBD (v, b, r, k, lambda) problem is to find a binary matrix of v rows\n% of b columns such that each row sums to r, each column sums to k, and\n% the dot product beween any pair of distinct rows is lambda.\n\ninclude \"lex_lesseq.mzn\";\n\nint: v;\nint: k;\nint: lambda;\n\nint: b = (lambda * v * (v - 1)) div (k * (k - 1));\nint: r = (lambda * (v - 1)) div (k - 1);\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\narray [rows, cols] of var bool: m;\n\n    % Every row must sum to r.\n    %\nconstraint forall (i in rows) (sum (j in cols) (bool2int(m[i, j])) = r);\n\n    % Every column must sum to k.\n    %\nconstraint forall (j in cols) (sum (i in rows) (bool2int(m[i, j])) = k);\n\n    % The dot product of every pair of distinct rows must be lambda.\n    %\nconstraint\n    forall (i_a, i_b in rows where i_a < i_b) (\n        sum (j in cols) (bool2int(m[i_a, j] /\\ m[i_b, j])) = lambda\n    );\n\n    % Break row symmetry in the incidence matrix.\n    %\nconstraint forall(i in rows diff {max(rows)})(\n        lex_lesseq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    );\n\n    % Break column symmetry in the incidence matrix.\n    %\nconstraint forall(j in cols diff {max(cols)})(\n        lex_lesseq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    );\n\nsolve :: bool_search([m[i, j] | i in rows, j in cols],\n    input_order, indomain_min, complete)\n    satisfy;\n\noutput  [\"bibd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r),\n        \", k = \", show(k), \", lambda = \", show(lambda), \")\\n\\n\"] ++\n        [ ( if j > b then \"\\n\" else show(bool2int(m[i, j])) endif )\n        | i in rows, j in 1..(b + 1)\n        ];\n\n%----------------------------------------------------------------------------%\n%----------------------------------------------------------------------------%\n"}}, "bus_scheduling_csplib_beginner": {"node_ids": ["ab8a6fb2-c585-4732-8a64-889525f035f1"], "metadata": {"model_name": "bus_scheduling_csplib", "source_code": "%\n% Bus driver scheduling problem (prob022 in CSPLib) in MiniZinc.\n%\n% Specification\n% Bus driver scheduling can be formulated as a set paritioning problem.\n% We propose 12 set partitioning problems derived from small bus driver\n% scheduling problems. These consist of a given set of tasks (pieces of\n% work) to cover and a large set of possible shifts, where each shift\n% covers a subset of the tasks and has an associated cost. We must select\n% a subset of possible shifts that covers each piece of work once and\n% only once: this is called a partition. Further,\n%\n% In the driver scheduling (unlike air crew scheduling) the main aim is\n% to reduce the number of shifts used in the solution partition and the\n% total cost of the partition is secondary. To simplify the problem we have\n% made the cost of each shift the same. This means that the goal is to\n% minimise the number of shifts.\n%\n% The problems come from four different bus companies:\n% Reading (r1 to r5a),\n% CentreWest Ealing area (c1, c1a, c2),\n% the former London Transport (t1 and t2).\n%\n% The problems have differing regulations and features (e.g. urban and\n% short distance rural bus schedules can have very different features). Note\n% that r1 and r1a are the same problem, but have different numbers of\n% generated shifts. Similarly with the problems: c1, c1a and r5, r5a.\n%\n% Problems are presented in the same format as the set partitioning\n% examples in ORLIB. The first line gives the number of rows (pieces of work),\n% columns (shifts) and the minimum number of columns need for a partition.\n% Then each line after that corresponds to one column. It starts with\n% the cost (which is always 1 in our case) then the number of rows it\n% covers, followed by the rows it covers.\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \nint: num_work;\nint: num_shifts;\nint: min_num_shifts;\narray[1..num_shifts] of set of int: shifts;\n\narray[1..num_shifts] of var 0..1: x;\nvar 0..num_shifts: tot_shifts;\n\n% solve minimize tot_shifts;\nsolve :: int_search(\n        x ++ [tot_shifts], \n        first_fail, \n        indomain_min, \n        complete) \n    minimize tot_shifts;\n    % satisfy;\n\nconstraint\n   tot_shifts = sum(x)\n   /\\\n   forall(j in 0..num_work-1) (\n       sum(i in 1..num_shifts) (x[i]*bool2int(j in shifts[i])) = 1\n   )\n   /\\\n   tot_shifts >= min_num_shifts\n\n   % /\\ % for solve satisfy (t1)\n   % tot_shifts = 7\n;\n\n\noutput [\n  \"tot_shifts: \" ++ show(tot_shifts) ++ \"\\n\" ++ \n  \"x: \" ++ show(x) ++ \"\\n\"\n] ++ \n[\n  if fix(x[i]) = 1 then show(shifts[i]) else \"\" endif\n  | i in 1..num_shifts\n] ++ \n[\"\\n\"] ++\n[\n  if fix(x[i]) = 1 then show(i) ++ \" \" else \"\" endif\n  | i in 1..num_shifts\n] ++ [\"\\n\"];\n"}}, "car_beginner": {"node_ids": ["168ac6f2-5cf4-457a-96a7-cfcf1da061fc"], "metadata": {"model_name": "car", "source_code": "%\n% Car sequencing in MiniZinc.\n% include \"globals.mzn\";\n\nint: numclasses;\nint: numoptions;\nint: numcars;\nset of int: Classes = 1..numclasses;\nset of int: Options = 1..numoptions;\nset of int: Slots = 1..numcars;\n\narray[Classes] of int: numberPerClass;\n\narray[Classes,Options] of int: optionsRequired;\narray[Options] of int: windowSize;\narray[Options] of int: optMax;\n\narray[Options] of int: optionNumberPerClass = [sum(j in Classes) (numberPerClass[j] * optionsRequired[j,i]) | i in Options];\n\n% decision variables\n\narray[Slots] of var Classes: slot;\narray[Options, Slots] of var 0..1: setup;\n\n\nvar int: z = sum(s in Classes) (s*slot[s]);\n\n% solve minimize z;\nsolve :: int_search(slot, input_order, indomain_min, complete)\n  satisfy;\n\nconstraint\n  forall(c in Classes ) (\n    sum(s in Slots ) (bool2int(slot[s] = c)) = numberPerClass[c]\n  )\n  /\\\n  forall(o in Options, s in 1..numcars - windowSize[o] + 1) (\n    sum(j in s..s + windowSize[o]- 1) (setup[o,j]) <= optMax[o]\n  )\n  /\\\n  forall(o in Options, s in Slots ) (\n    setup[o,s] = optionsRequired[slot[s],o]\n  )\n  /\\\n  forall(o in Options, i in 1..optionNumberPerClass[o]) (\n    sum(s in 1..(numcars - i * windowSize[o])) (setup[o,s]) >=\n           (optionNumberPerClass[o] - i * optMax[o])\n  )\n;\n\n% for solve satisfy\n% constraint z = 82;\n\n\noutput [\n \"z: \" ++ show(z) ++ \"\\n\" ++\n \"slot: \" ++ show(slot) ++ \"\\n\"\n] ++\n[\n  if j = 1 then \"\\n\" else \" \" endif ++ \n    show(setup[i,j])\n  | i in Options, j in Slots\n];\n"}}, "carpet_cutting_beginner": {"node_ids": ["2683cddb-07e4-4a61-820f-4dd2077534a4"], "metadata": {"model_name": "carpet_cutting", "source_code": "Model 1 :\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\narray[ROOM] of var ROT: rot;\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)(shape[i,rot[i]] != {});\n\nconstraint forall(i in ROOM)(forall(r in ROFF)\n  (r in shape[i,rot[i]] -> \n  (x[i] + d[r,1] + d[r,3] <= l /\\\n   y[i] + d[r,2] + d[r,4] <= h)));\n\nconstraint forall(i,j in ROOM where i < j)\n  (forall(r1,r2 in ROFF)\n (r1 in shape[i,rot[i]] /\\ \n  r2 in shape[j,rot[j]] -> \n(x[i] + d[r1,1] + d[r1,3] <= x[j] + d[r2,1]\n                   \\/\n x[j] + d[r2,1] + d[r2,3] <= x[i] + d[r1,1]\n                   \\/\n y[i] + d[r1,2] + d[r1,4] <= y[j] + d[r2,2]\n                   \\/\ny[j] + d[r2,2] + d[r2,4] <= y[i] + d[r1,2])\n   ));\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nrot = \\(rot);\\n\"];\n\n\n\nModel 2 :\n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: DIM = 1..2;\narray[ROFF,DIM] of int: rect_size = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 3..4]);\narray[ROFF,DIM] of int: rect_offset = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 1..2]);\narray[int] of set of ROFF: shapes = [ {1,3,4}, {2,5,6}, {1}, {7} ];\nset of int: SHAPE = index_set(shapes);\n%array[int] of set of RECT: s = sort([shapes[i,j] | i in 1..n, j in 1..4]);\n\narray[ROOM] of var SHAPE: kind;\narray[ROOM,DIM] of var int: coords =\n      array2d(ROOM,DIM, [ if j = 1 then x[i] else y[i] endif\n                         | i in ROOM, j in 1..2 ]);\n\n\n\ninclude \"geost.mzn\";\n\nconstraint geost_bb(2,\n                    rect_size,\n                    rect_offset,\n                    shapes,\n                    coords,\n                    kind,\n                    [0,0],\n                    [l,h]);\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)\n                 (exists(r in ROT where shape[i,r] != {})\n                        (shapes[kind[i]] = shape[i,r]));\n\n\noutput [\"rect_size = \\(rect_size);\\nrect_offset = \\(rect_offset);\\n\"] ++\n       [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];\n\n\n\nModel 3 : \n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: SHAPE = 1..4;\narray[ROOM] of var SHAPE: kind;\n\nconstraint geost_bb(2,\n       [| 3,4 | 4,3 | 1,1 | 1,2 | 1,1 | 2,1 | 4,3 |],\n       [| 0,0 | 0,1 | 1,4 | 3,1 | 4,2 | 1,0 | 0,0 |],\n       [ {1,3,4}, {2,5,6}, {1}, {7} ],\n       [| x[1], y[1] | x[2],y[2] | x[3],y[3] |],\n       kind,\n       [ 0,0 ],\n       [ l, h]);\n\nconstraint kind[1] in {1,2};\nconstraint kind[2] in {1,2};\nconstraint kind[3] in {3,4}; \ninclude \"geost.mzn\";\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];"}}, "cell_block_beginner": {"node_ids": ["612d5e03-cd42-4f6a-be99-db559ec7c314"], "metadata": {"model_name": "cell_block", "source_code": "Model 1 :\n\n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\n%constraint forall(p1, p2 in PRISONER where p1 < p2)\n%                 (abs(r[p1] - r[p2]) + abs(c[p1] - c[p2]) > 0); \ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nconstraint forall(p in PRISONER, d in danger where p != d)\n                 ( abs(r[p] - r[d]) + abs(c[p] - c[d]) > 1 );\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n\n\n\nModel 2 : \n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nfunction var int: \n     manhattan(var int:x1, var int:y1,\n               var int:x2, var int:y2) =\n     abs(x2 - x1) + abs(y2 - y1);\n\nconstraint forall(p in PRISONER, d in danger where p != d) \n                 (manhattan(r[p],c[p],r[d],c[d]) > 1);\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n"}}, "clique_beginner": {"node_ids": ["4caab6d4-59f7-4cd4-a90c-f1cc2d3ebbe7"], "metadata": {"model_name": "clique", "source_code": "% Maximum Clique Problem\n\nint: n = 5;\narray[1..n, 1..n] of int: adj =\n    [| 0, 1, 0, 1, 0\n     | 1, 0, 1, 0, 0\n     | 0, 1, 0, 1, 1\n     | 1, 0, 1, 0, 1\n     | 0, 0, 1, 1, 0 |];\n\n% --- naive model ---\n\n% decision variables: which vertices are in the clique?\narray[1..n] of var bool: c;\nvar int: size;\n\n% how many vertices have we selected?\nconstraint size = sum(c);\n\n% we can only pick one of any non-adjacent pair of vertices\nconstraint forall (i, j in 1..n where i < j /\\ 0 == adj[i,j]) (bool2int(c[i]) + bool2int(c[j]) <= 1);\n\nsolve maximize size;\n\n"}}, "cluster_beginner": {"node_ids": ["4d1560ec-39d9-48ca-b09b-5f00c46037be"], "metadata": {"model_name": "cluster", "source_code": "int: n; % points to be clustered\nset of int: POINT = 1..n;\narray[POINT,POINT] of int: dist; % distance between two points\nint: maxdist = max([ dist[i,j] | i,j in POINT]);\n\n\nint: k; % number of clusters\nset of int: CLUSTER = 1..k;\n\nint: maxdiam;\n\narray[POINT] of var CLUSTER: x;\n\nconstraint forall(i,j in POINT where i < j /\\ x[i] = x[j])\n                 (dist[i,j] <= maxdiam);\n\nconstraint forall(i in 1..k-1)\n                 (  min([ j | j in POINT where x[j] = i])\n                  < min([ j | j in POINT where x[j] = i+1]));\n\nvar 0..maxdist: obj = min( i,j in POINT where i < j )\n                         ( dist[i,j] + maxdist * (x[i] != x[j]) );\n\ninclude \"value_precede_chain.mzn\";\nconstraint value_precede_chain([ i | i in 1..k ],x);\n\nsolve maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x)\\n\"];\n"}}, "compatible_assignment_beginner": {"node_ids": ["e5f75b2b-1799-4a0b-8ffa-1a837980b4c9"], "metadata": {"model_name": "compatible_assignment", "source_code": "Model 1 :\n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(task);\nconstraint forall(w1, w2 in W)\n                 (task[w1] != m /\\ task[w2] = task[w1] + 1 ->\n                   compatible[w1,w2]);\n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ \"task = \\(task)\\n\" ] ;\n\n\nModel 2 : \n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\narray[T] of var opt W: worker;\n\nconstraint inverse(task,worker);\nconstraint forall(t in T where t mod m != 0)\n                 (compatible[worker[t],worker[t+1]]);\n           \n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ if fix(occurs(worker[t])) then show(worker[t]) else \" \" endif ++ \" \"\n       | t in T ] \n       ++ [ show(task), \"\\n\" ]\n       ;\n\npredicate inverse(array[int] of var opt int: f, array[int] of var opt int: g) = \n          forall(i in index_set(f), j in index_set(g))\n                (occurs(f[i]) /\\ occurs(g[j]) ->\n                 (deopt(f[i]) = j <-> deopt(g[j]) = i)); \n"}}, "constrained_connected_beginner": {"node_ids": ["2f3e9edb-4f51-4ac8-aaa9-d599837711f6"], "metadata": {"model_name": "constrained_connected", "source_code": "% constrained clustering \n% Pick a maximal subset of edges so that no two nodes\n% given by the pairs (first[i],second[i]) \n% are connected.\n\nint: n;\nset of int: NODE = 1..n;\nint: m;\nset of int: EDGE = 1..m;\narray[EDGE] of NODE: pre;\narray[EDGE] of NODE: suc;\nint: d;\nset of int: DPAIR = 1..d;\narray[DPAIR] of NODE: first;\narray[DPAIR] of NODE: second;\n\nvar set of EDGE: selected;\n% a representative for each cluster\narray[NODE] of var NODE: rep;\n\n%constraint forall(e in selected)\n%                 (rep[pre[e]] = rep[suc[e]]);\nconstraint forall(e in EDGE)\n                 (e in selected -> rep[pre[e]] = rep[suc[e]]);\n\nconstraint forall(d in DPAIR)\n                 (rep[first[d]] != rep[second[d]]);\n\nsolve maximize card(selected);\n\noutput [ \"(\" ++ show(pre[e]) ++ \",\" ++ show(suc[e]) ++ \")\\n\"\n       | e in fix(selected) ]\n       ++ [show(rep),\"\\n\"]\n       ;\n\n\n\n                 \n"}}, "crazy_sets_beginner": {"node_ids": ["1df567da-04ec-4777-8c39-6447dea7e046"], "metadata": {"model_name": "crazy_sets", "source_code": "Model 1 :\n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m] of var set of NUMBER: s;\n\nconstraint forall(i,j,k in 1..m where i < j /\\ j < k)\n     ( s[i] intersect s[j] intersect s[k] = {} );\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\nconstraint forall(i in 1..m, o in NUMBER)\n      (o in s[i] \n       -> exists(j in 1..c)(x[i,j] = o));\nconstraint forall(i in 1..m, j in 1..c)(x[i,j] in s[i]);\n\nsolve satisfy;\n\noutput [show(s)];\n\nn = 10;\nc = 4;\nm = 4;\n\n\n\nModel 2 : \n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint global_cardinality_low_up( [ x[i,j] | i in 1..m, j in 1..c ],\n                              [ i | i in 1..n ],\n                              [ 0 | i in 1..n ],\n                              [ 2 | i in 1..n ]);\n\n\nsolve satisfy;\n\n   output [ if j = 1 then \"{\" else \"\" endif ++\n   show(x[i,j])\n   ++ if j = c then \"}\" else \", \" endif\n   ++ if j = c /\\ i < m then \", \" else \"\" endif\n   | i in 1..m, j in 1..c ];\n   \n\nn = 10;\nc = 4;\nm = 4;\n"}}, "crossfigure_beginner": {"node_ids": ["451732a6-36c2-4547-b16f-4f7e9b7a476b"], "metadata": {"model_name": "crossfigure", "source_code": "% Crossfigure problem in MiniZinc.\n% \"\"\"\n% Crossfigures are the numerical equivalent of crosswords. You have a grid and some\n% clues with numerical answers to place on this grid. Clues come in several different\n% forms (for example: Across 1. 25 across times two, 2. five dozen, 5. a square number,\n% 10. prime, 14. 29 across times 21 down ...).\n% \"\"\"\n\n\nint: n = 9;\narray[1..n, 1..n] of var 0..9: M;\n\nset of int: D = 0..9999; % the max length of the numbers in this problem is 4\nvar D: A1;\nvar D: A4;\nvar D: A7;\nvar D: A8;\nvar D: A9;\nvar D: A10;\nvar D: A11;\nvar D: A13;\nvar D: A15;\nvar D: A17;\nvar D: A20;\nvar D: A23;\nvar D: A24;\nvar D: A25;\nvar D: A27;\nvar D: A28;\nvar D: A29;\nvar D: A30;\n\nvar D: D1;\nvar D: D2;\nvar D: D3;\nvar D: D4;\nvar D: D5;\nvar D: D6;\nvar D: D10;\nvar D: D12;\nvar D: D14;\nvar D: D16;\nvar D: D17;\nvar D: D18;\nvar D: D19;\nvar D: D20;\nvar D: D21;\nvar D: D22;\nvar D: D26;\nvar D: D28;\n\n\n%\n% across(Matrix, Across, Len, Row, Col)\n%\tConstrains 'Across' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding across.\n%\npredicate across(array[int, int] of var D: Matrix, var D: Across, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Across)\n   /\\\n   forall(i in 0..Len-1) (\n\n       Matrix[Row,Col+i] = tmp[i+1]\n   )\n;\n\n%\n% down(Matrix, Down, Len, Row, Col):\n%\tConstrains 'Down' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding down.\n%\npredicate down(array[int,int] of var D: Matrix, var D: Down, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Down)\n   /\\\n   forall(i in 0..Len-1) (\n      Matrix[Row+i,Col] = tmp[i+1]\n   )\n;\n\n\n%\n% converts a number <-> array\n%\npredicate toNum10(array[int] of var D: a, var D: n) =\n          let { int: len = length(a) }\n          in\n          n = sum(i in 1..len) (\n            ceil(pow(10.0, int2float(len-i))) * a[i]\n          )\n          /\\ forall(i in 1..len) (a[i] >= 0)\n;\n\n\n%\n% x is a square\n% \npredicate square(var D: x) =\n   exists(y in D) (\n      y*y = x\n   )\n;\n\n\n%\n% very simple primality test\n%\npredicate is_prime(var int: x) =\n   forall(i in 2..ceil(sqrt(9999.0))) ( \n        (i < x) -> (x mod i > 0)\n   )\n;\n\n\nsolve :: int_search(\n         [M[i,j] | i,j in 1..n] ++\n         [A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n         D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28],\n         occurrence,\n         indomain_min,\n         complete\n         ) \n     satisfy;\n\n\nconstraint\n\n   % Set up the constraints between the matrix elements and the\n   % clue numbers.\n   across(M, A1, 4, 1, 1)  /\\ \n   across(M, A4, 4, 1, 6)  /\\ \n   across(M, A7, 2, 2, 1)  /\\ \n   across(M, A8, 3, 2, 4)  /\\ \n   across(M, A9, 2, 2, 8)  /\\ \n   across(M, A10, 2, 3, 3) /\\ \n   across(M, A11, 2, 3, 6) /\\ \n   across(M, A13, 4, 4, 1) /\\ \n   across(M, A15, 4, 4, 6) /\\ \n   across(M, A17, 4, 6, 1) /\\ \n   across(M, A20, 4, 6, 6) /\\ \n   across(M, A23, 2, 7, 3) /\\ \n   across(M, A24, 2, 7, 6) /\\ \n   across(M, A25, 2, 8, 1) /\\ \n   across(M, A27, 3, 8, 4) /\\ \n   across(M, A28, 2, 8, 8) /\\ \n   across(M, A29, 4, 9, 1) /\\ \n   across(M, A30, 4, 9, 6) /\\ \n\n   down(M, D1, 4, 1, 1)  /\\ \n   down(M, D2, 2, 1, 2)  /\\ \n   down(M, D3, 4, 1, 4)  /\\ \n   down(M, D4, 4, 1, 6)  /\\ \n   down(M, D5, 2, 1, 8)  /\\ \n   down(M, D6, 4, 1, 9)  /\\ \n   down(M, D10, 2, 3, 3) /\\ \n   down(M, D12, 2, 3, 7) /\\ \n   down(M, D14, 3, 4, 2) /\\ \n   down(M, D16, 3, 4, 8) /\\ \n   down(M, D17, 4, 6, 1) /\\ \n   down(M, D18, 2, 6, 3) /\\ \n   down(M, D19, 4, 6, 4) /\\ \n   down(M, D20, 4, 6, 6) /\\ \n   down(M, D21, 2, 6, 7) /\\ \n   down(M, D22, 4, 6, 9) /\\ \n   down(M, D26, 2, 8, 2) /\\ \n   down(M, D28, 2, 8, 8) /\\ \n\n\n   % Set up the clue constraints.\n%  Across\n%  1 27 across times two\n%  4 4 down plus seventy-one\n%  7 18 down plus four\n%  8 6 down divided by sixteen\n%  9 2 down minus eighteen\n% 10 Dozen in six gross\n% 11 5 down minus seventy\n% 13 26 down times 23 across\n% 15 6 down minus 350\n% 17 25 across times 23 across\n% 20 A square number\n% 23 A prime number\n% 24 A square number\n% 25 20 across divided by seventeen\n% 27 6 down divided by four\n% 28 Four dozen\n% 29 Seven gross\n% 30 22 down plus 450 \n\n   A1 = 2 * A27         /\\ \n   A4 = D4 + 71         /\\ \n   A7 = D18 + 4         /\\ \n   A8 = D6 div 16       /\\ \n   A9 = D2 - 18         /\\ \n   A10 = 6 * 144 div 12 /\\ \n   A11 = D5 - 70        /\\ \n   A13 = D26 * A23      /\\ \n   A15 = D6 - 350       /\\ \n   A17 = A25 * A23      /\\ \n   square(A20)          /\\ \n   is_prime(A23)        /\\\n   square(A24)          /\\ \n   A25 = A20 div 17     /\\ \n   A27 = D6 div 4       /\\ \n   A28 = 4 * 12         /\\ \n   A29 = 7 * 144        /\\ \n   A30 = D22 + 450      /\\ \n\n   % Down\n   %\n   %  1 1 across plus twenty-seven\n   %  2 Five dozen\n   %  3 30 across plus 888\n   %  4 Two times 17 across\n   %  5 29 across divided by twelve\n   %  6 28 across times 23 across\n   % 10 10 across plus four\n   % 12 Three times 24 across\n   % 14 13 across divided by sixteen\n   % 16 28 down times fifteen\n   % 17 13 across minus 399\n   % 18 29 across divided by eighteen\n   % 19 22 down minus ninety-four\n   % 20 20 across minus nine\n   % 21 25 across minus fifty-two\n   % 22 20 down times six\n   % 26 Five times 24 across\n   % 28 21 down plus twenty-seven \n\n   D1 = A1 + 27     /\\ \n   D2 = 5 * 12      /\\ \n   D3 = A30 + 888   /\\ \n   D4 = 2 * A17     /\\ \n   D5 = A29 div 12  /\\ \n   D6 = A28 * A23   /\\ \n   D10 = A10 + 4    /\\ \n   D12 = A24 * 3    /\\ \n   D14 = A13 div 16 /\\ \n   D16 = 15 * D28   /\\ \n   D17 = A13 - 399  /\\ \n   D18 = A29 div 18 /\\ \n   D19 = D22 - 94   /\\ \n   D20 = A20 - 9    /\\ \n   D21 = A25 - 52   /\\ \n   D22 = 6 * D20    /\\ \n   D26 = 5 * A24    /\\ \n   D28 = D21 + 27\n\n\n   % Fix the blackboxes\n   /\\\n   M[1,5] = 0 /\\\n   M[2,3] = 0 /\\\n   M[2,7] = 0 /\\\n   M[3,2] = 0 /\\\n   M[3,5] = 0 /\\\n   M[3,8] = 0 /\\\n   M[4,5] = 0 /\\\n   M[5,1] = 0 /\\\n   M[5,3] = 0 /\\\n   M[5,4] = 0 /\\\n   M[5,5] = 0 /\\\n   M[5,6] = 0 /\\\n   M[5,7] = 0 /\\\n   M[5,9] = 0 /\\\n   M[6,5] = 0 /\\\n   M[7,2] = 0 /\\\n   M[7,5] = 0 /\\\n   M[7,8] = 0 /\\\n   M[8,3] = 0 /\\\n   M[8,7] = 0 /\\\n   M[9,5] = 0\n;\n\n\noutput [\n show([A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n       D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28]), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(M[i,j])\n  | i,j  in 1..n\n] ++ [\"\\n\"];"}}, "curriculum_beginner": {"node_ids": ["fa3fefc8-f015-4ef1-8df9-0a73b8b1d0c4"], "metadata": {"model_name": "curriculum", "source_code": "% The balanced academic curriculum problem:\n%\n% A curriculum is a set of courses with prerequisites.\n% Each course must be assigned within a set number of periods.\n% A course cannot be scheduled before its prerequisites.\n% Each course confers a number of academic credits (it's \"load\").\n% Students have lower and upper bounds on the number of credits they can study for in a given period.\n% Students have lower and upper bounds on the number of courses they can study for in a given period.\n% The goal is to assign a period to every course satisfying these criteria, minimising the load for all periods.\n\ninclude \"globals.mzn\";\n\nint: n_courses;\nint: n_periods;\nint: load_per_period_lb;\nint: load_per_period_ub;\nint: courses_per_period_lb;\nint: courses_per_period_ub;\narray [1..n_courses] of int: course_load;\nint: max_course_load = sum(c in courses)(course_load[c]);\n\nset of int: courses = 1..n_courses;\nset of int: periods = 1..n_periods;\n\n% period course is assigned to\narray [courses] of var periods: course_period;\n% whether period i has course j assigned\narray [periods, courses] of var 0..1: x;\n% total load for each period\narray [periods] of var load_per_period_lb..load_per_period_ub: load;\n% optimisation target\nvar load_per_period_lb..load_per_period_ub: objective;\n\nconstraint forall(p in periods) (\n    forall(c in courses) (x[p,c] = bool2int(course_period[c] = p)) /\\\n    sum(i in courses) (x[p,i]) >= courses_per_period_lb /\\\n    sum(i in courses) (x[p,i]) <= courses_per_period_ub /\\\n    load[p] = sum(c in courses) (x[p,c] * course_load[c]) /\\\n    load[p] >= load_per_period_lb /\\\n    load[p] <= objective\n);\n\n% prerequisite(a, b) means \"course a has prerequisite course b\".\n\npredicate prerequisite(courses: a, courses: b) =\n    course_period[b] < course_period[a];\n\n% add some redundant linear constraints\n\nconstraint forall(p in 0..n_periods-1) (\n    let {\n\t\tvar 0..max_course_load: l = sum(c in courses) (bool2int(course_period[c] > p) * course_load[c])\n\t} in \n        l >= (n_periods-p) * load_per_period_lb /\\\n        l <= (n_periods-p) * objective\n    );\n\nsolve :: seq_search([\n      int_search([x[i,j] | i in periods, j in courses], input_order, indomain_max, complete),\n      int_search([objective], input_order, indomain_min, complete)\n    ]) minimize objective;\n\noutput \n    [show(c) ++ \"-\" ++ show(course_period[c]) ++ \"\\t\" | c in courses ] ++ [\"\\n\"] ++\n    [\"objective = \", show(objective)];\n"}}, "diamond_free_degree_sequence_beginner": {"node_ids": ["f613bb09-30bd-4cca-b97c-7260a229e0e7"], "metadata": {"model_name": "diamond_free_degree_sequence", "source_code": "%\n% Diamond-free Degree Sequence (CSPLib #50) in MiniZinc.\n%\n% Given a simple undirected graph G=(V,E), where V is the set of vertices and E the set of\n% undirected edges, the edge {u,v} is in E if and only if vertex u is adjacent to vertex v\u2208G.\n% The graph is simple in that there are no loop edges, i.e. we have no edges of the form {v,v}.\n% Each vertex v\u2208V has a degree dv i.e. the number of edges incident on that vertex. Consequently\n% a graph has a degree sequence d1,\u2026,dn, where di>=di+1. A diamond is a set of four vertices\n% in V such that there are at least five edges between those vertices. Conversely, a graph is\n% diamond-free if it has no diamond as an induced subgraph, i.e. for every set of four vertices\n% the number of edges between those vertices is at most four.\n%\n% In our problem we have additional properties required of the degree sequences of the graphs,\n% in particular that the degree of each vertex is greater than zero (i.e. isolated vertices\n% are disallowed), the degree of each vertex is modulo 3, and the sum of the degrees is\n% modulo 12 (i.e. |E| is modulo 6).\n%\n% The problem is then for a given value of n, produce all unique degree sequences d1,\u2026,dn such\n% that\n%\n%  * di\u2265di+1\n%  * each degree di>0 and di is modulo 3\n%  * the sum of the degrees is modulo 12\n%  * there exists a simple diamond-free graph with that degree sequence\n\n\ninclude \"globals.mzn\"; \n\nint: n = 11;\n\n% decision variables\narray[1..n,1..n] of var 0..1: x;\narray[1..n] of var 1..n: degrees;\n\n\n% solve satisfy;\nsolve :: int_search(degrees, first_fail, indomain_split, complete) satisfy;\n\nconstraint\n  forall(i,j,k,l in 1..n where i < j /\\ j < k /\\ k < l) (\n     x[i,j] + x[i,k] + x[i,l] + x[j,k] + x[j,l] + x[k,l] <= 4\n  )\n  /\\\n  forall(i in 1..n) (\n     degrees[i] = sum([x[i,j] | j in 1..n])\n     /\\ degrees[i] mod 3 = 0\n     % no loops\n     /\\ x[i,i] = 0\n  ) \n  /\\ % undirected graph\n  forall(i,j in 1..n) (\n    x[i,j] = x[j,i]\n  )\n  /\\ sum(degrees) mod 12 = 0\n\n  % symmetry breaking\n  /\\ decreasing(degrees)\n  /\\ lex2(x)\n;\n\noutput \n[ \"degrees: \", show(degrees), \"\\n\"]\n% ++\n% [\n%   if j = 1 then \"\\n\" else \" \" endif ++\n%     show(x[i,j])\n%   | i,j in 1..n\n% ]\n;\n\n"}}, "doublechannel_beginner": {"node_ids": ["afa53493-8d34-447d-a0a5-ab86de3ac672"], "metadata": {"model_name": "doublechannel", "source_code": "% scheduling ships entering and leaving a port through k channels\nset of int: TYPE = 1..3;\nint: entering = 1;\nint: leaving  = 2;\nint: dummy = 3;\n\nint: nC; % number of channels\nset of int: CHANNEL = 1..nC;\narray[CHANNEL] of int: len;    % length in 100m units\n\nint: nS; % number of ships\nset of int: SHIP = 1..nS; % ships ENTER then LEAVE\nset of int: SHIPE = 1..nS+nC; % ships ENTER then LEAVE then nC dummy ships\n\narray[SHIP] of int: speed;   % time in minutes to traverse 100m\narray[SHIP] of int: desired; % desired time to start to enter/leave \narray[SHIP] of entering..leaving: dirn;   % entering or leaving\n\nint: leeway;  % leeway between 2 ships in 100m units\nint: maxt;    % maximum time\nset of int: TIME = 0..maxt;\n\narray[SHIPE] of var TYPE: kind = dirn ++ [ dummy | i in 1..nC];\narray[SHIPE] of var TIME:    start; % when ships enter the channel \narray[SHIPE] of var TIME:     end; % when ships leave the channel \narray[SHIPE] of var CHANNEL: channel; % which channel a ship is assigned to\n\narray[SHIP] of var SHIPE:   next;  % the next ship in the same channel (or a dummy)\n\n% dummy ships\nconstraint forall(s in nS + 1 .. nS + nC)(start[s] = maxt /\\ end[s] = maxt);\nconstraint forall(s in nS + 1 .. nS + nC)(channel[s] = s - nS);\n\n% relationships between start and ends\nconstraint forall(s in SHIP)(end[s] = start[s] + len[channel[s]]*speed[s]);\n\n\n% the next ship are all different\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(next);\n\n% no clashes in channel\nconstraint forall(s in SHIP)(if kind[s] + kind[next[s]] = entering+leaving then\n                                end[s] <= start[next[s]]\n                             else\n                                start[s] + speed[s]*leeway <= start[next[s]] /\\\n                                end[s] + speed[s]*leeway <= end[next[s]]\n                             endif);\n\n% next ship is in same channel\nconstraint forall(s in SHIP)(channel[next[s]] = channel[s]);\n\nsolve minimize sum(s in SHIP)(abs(start[s] - desired[s]));\n\noutput [ \"start = \",show(start),\n         \";\\nend = \", show(end),\n         \";\\nchannel = \", show(channel),\n         \";\\nnext = \", show(next),\n         \";\\n\" ];\n\n"}}, "fractions_beginner": {"node_ids": ["fa3f3234-d49d-4df8-8fec-38b029e17108"], "metadata": {"model_name": "fractions", "source_code": "%\n% Fractions problem in MiniZinc.\n%\n% Prolog benchmark problem (BProlog)\n% \"\"\"\n% Find distinct non-zero digits such that the following equation holds:\n%        A        D        G\n%     ------  + ----- + ------  = 1\n%       B*C      E*F      H*I\n\ninclude \"globals.mzn\"; \n\nvar 1..9: A;\nvar 1..9: B;\nvar 1..9: C;\nvar 1..9: D;\nvar 1..9: E;\nvar 1..9: F;\nvar 1..9: G;\nvar 1..9: H;\nvar 1..9: I;\narray[1..9] of var 1..9: Vars=[A,B,C,D,E,F,G,H,I];\n\nvar 1..81: D1;\nvar 1..81: D2;\nvar 1..81: D3;\n\n\n\n% solve satisfy;\nsolve :: int_search(Vars ++ [D1,D2,D3], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   all_different(Vars) /\\\n   D1 = 10*B+C /\\\n   D2 = 10*E+F /\\\n   D3 = 10*H+I /\\\n   A*D2*D3 + D*D1*D3 + G*D1*D2 = D1*D2*D3 /\\\n   % break the symmetry\n   A*D2 >= D*D1 /\\\n   D*D3 >= G*D2 /\\\n   %redundant constraints\n   3*A >= D1 /\\\n   3*G <= D2\n\n;\n\noutput [\n  show(Vars), \"\\n\"\n]\n;"}}, "golfers_beginner": {"node_ids": ["9cfcb2d2-a6db-40ad-b990-7d4c995ec9e9"], "metadata": {"model_name": "golfers", "source_code": "Model 1 :\n\n\n% The social golfers problem\n% A club has a number of golfers that play rounds in groups (the number of\n% golfers is a multiple of the number of groups).  Each round, a golfer\n% plays with a group of different people, such that the same pair of golfers\n% never play together twice.\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\nset of int: places = 1..n_golfers;\n\narray [rounds, places] of var golfers: round_place_golfer;\narray [golfers, golfers] of var 0..n_rounds: golfer_golfer_round;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (p in places) (round_place_golfer[r, p])\n    );\n\n    % Break some symmetry by strictly ordering each group in each round.\n    %\nconstraint\n    forall (r in rounds, p in places) (\n        if p mod n_per_group != 0\n        then round_place_golfer[r, p] < round_place_golfer[r, p + 1]\n        else true\n        endif\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (r in rounds, g in 0..(n_groups - 1), i, j in 1..n_per_group\n            where i < j) (\n        golfer_golfer_round[\n            round_place_golfer[r, n_per_group * g + i],\n            round_place_golfer[r, n_per_group * g + j]\n        ] = r\n    );\n\nsolve\n    :: int_search([round_place_golfer[r, p] | r in rounds, p in places],\n        first_fail, indomain_min, complete)\n    satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if p = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif ) ++\n    ( if p mod n_per_group = 1 then \"   \" else \" \" endif ) ++\n    show_int(2, round_place_golfer[r, p]) | r in rounds, p in places\n];\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups, group] of var golfers: round_group_i_golfer;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (g in groups, i in group) (round_group_i_golfer[r, g, i])\n    );\n\n    % We also break some symmetry\n    % here by strictly ordering each group.\n    %\nconstraint\n    forall (r in rounds, g in groups, i in group where i < n_per_group) (\n        round_group_i_golfer[r, g, i] < round_group_i_golfer[r, g, i + 1]\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups, i, j in group where i < j) (\n            bool2int(\n                round_group_i_golfer[r, g, i] = a\n            /\\  round_group_i_golfer[r, g, j] = b\n            )\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if g = 1 /\\ i = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif) ++\n    ( if i = 1 then \"   \" else \" \" endif) ++\n    show_int(2, round_group_i_golfer[r, g, i]) \n    |  r in rounds, g in groups, i in group\n];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups] of var set of golfers: round_group_golfers;\n\n    % Each group has to have the right size.\n    %\nconstraint\n    forall (r in rounds, g in groups) (\n        card(round_group_golfers[r, g]) = n_per_group\n    );\n\n    % Each group in each round has to be disjoint.\n    %\nconstraint\n    forall (r in rounds) (\n        all_disjoint (g in groups) (round_group_golfers[r, g])\n    );\n\n    % Symmetry breaking.\n    %\n% constraint\n%     forall (r in rounds, g in groups where g < n_groups) (\n%         round_group_golfers[r, g] < round_group_golfers[r, g + 1]\n%     );\n\n    % Each pair may play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups) (\n            bool2int({a, b} subset round_group_golfers[r, g])\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [    ( if   g = 1\n              then \"\\nround \" ++ show(r) ++ \":   \"\n              else \"   \"\n              endif\n            ) ++\n            show(round_group_golfers[r, g])\n       |    r in rounds, g in groups\n       ];\n\n\nModel 4 :\n\n\nint: weeks = 4;\nint: groups = 3;\nint: groupSize = 3;\nint: golfers = groups * groupSize;\n\nset of int: Golfer = 1..golfers;\nset of int: Week = 1..weeks;\nset of int: Group = 1..groups;\n\n% Search space: The set of all possible group assignments to all \n% players in each of the weeks\narray[Golfer, Week] of var Group: assign;\n\n% solve satisfy;\n% solve :: int_search([assign[i,j] | i in Golfer, j in Week ], \"first_fail\", \"indomain\", \"complete\") satisfy;\nsolve :: int_search([assign[i,j] | i in Golfer, j in Week ], \n        first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each group has exactly groupSize players\n   forall (gr in Group, w in Week)( % c1\n     sum (g in Golfer) (bool2int(assign[g,w] = gr)) = groupSize\n   )\n   /\\\n   % C2: Each pair of players only meets at most once\n   forall (g1, g2 in Golfer, w1, w2 in Week  where g1 != g2 /\\ w1 != w2) (\n     (bool2int(assign[g1,w1] = assign[g2,w1]) + bool2int(assign[g1,w2] = assign[g2,w2])) <= 1\n   )\n  /\\\n  % SBSA: Symmetry-breaking by selective assignment\n  % On the first week, the first groupSize golfers play in group 1, the \n  % second groupSize golfers play in group 2, etc. On the second week, \n  % golfer 1 plays in group 1, golfer 2 plays in group 2, etc.\n  forall(g in Golfer) (\n    assign[g,1]=((g-1) div groupSize) + 1 % \n  )\n  /\\\n  forall(g in Golfer where g <= groupSize)(\n    assign[g,2]=g\n  )\n\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n  show(assign[i,j])\n  | i in Golfer, j in Week\n] ++ [\"\\n\"];"}}, "golomb_beginner": {"node_ids": ["91487107-c324-4504-9301-fd11ec00537d"], "metadata": {"model_name": "golomb", "source_code": "% Golomb rulers\n% From csplib:\n% A Golomb ruler may be defined as a set of m integers 0 = a_1 < a_2 <\n% ... < a_m such that the m(m-1)/2 differences a_j - a_i, 1 <= i < j\n% <= m are distinct. Such a ruler is said to contain m marks and is of\n% length a_m. The objective is to find optimal (minimum length) or\n% near optimal rulers.\n%\n% This is the \"ternary constraints and an alldifferent\" model\n\ninclude \"globals.mzn\";\n\nint: m;\nint: n = m*m;\n\narray[1..m] of var 0..n: mark;\n\narray[1..(m*(m-1)) div 2] of var 0..n: differences =\n    [ mark[j] - mark[i] | i in 1..m, j in i+1..m];\n\nconstraint mark[1] = 0;\n\nconstraint forall ( i in 1..m-1 ) ( mark[i] < mark[i+1] );\n\nconstraint alldifferent(differences);\n\n    % Symmetry breaking\nconstraint differences[1] < differences[(m*(m-1)) div 2];\n\nsolve :: int_search(mark, input_order, indomain, complete)\n    minimize mark[m];\n\noutput [show(mark)];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%\n"}}, "graph_beginner": {"node_ids": ["288c9b5f-8c31-405c-b63b-1f705f128232"], "metadata": {"model_name": "graph", "source_code": "% a strange graph numbering problem\nvar 1..8: a;\nvar 1..8: b;\nvar 1..8: c;\nvar 1..8: d;\nvar 1..8: e;\nvar 1..8: f;\nvar 1..8: g;\nvar 1..8: h;\n\n% Each number is used exactly once\nconstraint a != b;\nconstraint a != c;\nconstraint a != d;\nconstraint a != e;\nconstraint a != f;\nconstraint a != g;\nconstraint a != h;\nconstraint b != c;\nconstraint b != d;\nconstraint b != e;\nconstraint b != f;\nconstraint b != g;\nconstraint b != h;\nconstraint c != d;\nconstraint c != e;\nconstraint c != f;\nconstraint c != g;\nconstraint c != h;\nconstraint d != e;\nconstraint d != f;\nconstraint d != g;\nconstraint d != h;\nconstraint e != f;\nconstraint e != g;\nconstraint e != h;\nconstraint f != g;\nconstraint f != h;\nconstraint g != h;\n\n% Adjacent vertices differ by at most two\nconstraint abs(a - b) >= 2;\nconstraint abs(a - c) >= 2;\nconstraint abs(a - d) >= 2;\nconstraint abs(b - c) >= 2;\nconstraint abs(b - e) >= 2;\nconstraint abs(b - f) >= 2;\nconstraint abs(c - d) >= 2;\nconstraint abs(c - e) >= 2;\nconstraint abs(c - f) >= 2;\nconstraint abs(c - g) >= 2;\nconstraint abs(d - f) >= 2;\nconstraint abs(d - g) >= 2;\nconstraint abs(e - f) >= 2;\nconstraint abs(e - h) >= 2;\nconstraint abs(f - g) >= 2;\nconstraint abs(f - h) >= 2;\nconstraint abs(g - h) >= 2;\n\nsolve satisfy;\n\noutput [\"  \\(b)-\\(e)\\n\",\n        \" /|*|\\\\\\n\",\n        \"\\(a)-\\(c)-\\(f)-\\(h)\\n\",\n        \" \\\\|*|/\\n\",\n        \"  \\(d)-\\(g)\\n\"] ++\n       [\"\\na = \\(a); b = \\(b); c = \\(c); d = \\(d);\",\n        \" e = \\(e); f = \\(f); g = \\(g); h = \\(h);\\n\"] \n\n"}}, "itemset_mining_beginner": {"node_ids": ["cd8b2ac4-86d8-45df-8ae9-329945d75a55"], "metadata": {"model_name": "itemset_mining", "source_code": "int : NrI ; \nint : NrT ; \nint : Freq ;\narray [ 1..NrT ] of set of 1..NrI : TDB;\nvar set of 1..NrI : Items ;\nconstraint card ( cover ( Items ,TDB ) ) >= Freq ;\nsolve satisfy ; \n\nfunction var set of int : cover (\n         var set of int : Items ,\n         array [ int ] of var set of int : D) = \n         let {\n                          var set of index_set (D): Trans ;\n                          constraint forall ( t in index_set (D) )\n                          ( t in Trans <-> Items subset D[ t ] );\n         } in Trans;\n\narray[1.. NrI] of int: itemprice;\nint: minUtility;\n\nconstraint sum(i in Items)(itemprice[i]) >= minUtility;\n\nNrI = 6;\nint: bread = 1;\nint: butter = 2;\nint: cheese = 3;\nint: cocoa = 4;\nint: milk = 5;\nint: vegemite = 6;\narray[1..NrI] of string: name = [\"bread\",\"butter\",\"cheese\",\"cocoa\",\"milk\",\"vegemite\"];\nitemprice = [1,2,1,2,1,1];\n\nNrT = 7;\nTDB = [ { butter, cheese, milk, vegemite },\n        { butter, cocoa, milk, vegemite },\n\t{ bread, cocoa, cheese, milk },\n\t{ bread, butter, cheese, vegemite }, \n\t{ bread, cheese, milk, vegemite },\n\t{ bread, butter, cheese, cocoa, milk },\n\t{ bread, cheese, milk }];\n\nFreq = 4;\nminUtility = 3;\n\noutput [ name[i] ++ \" \" | i in fix(Items) ];\n"}}, "jobshop_beginner": {"node_ids": ["111ae802-6e37-405d-8831-580c2249a74a"], "metadata": {"model_name": "jobshop", "source_code": "Model 1 :\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\n% only one task on any machine at one time\n%constraint forall(ma in MACH)\n%                 (forall(j1,j2 in JOB where j1 < j2)\n%                       (forall(t1,t2 in TASK where mc[j1,t1] = ma /\\ mc[j2,t2] = ma)\n%                              (nonoverlap(s[j1,t1],d[j1,t1],s[j2,t2],d[j2,t2]))));\n\nconstraint forall(j1, j2 in JOB, t1, t2 in TASK \n       where j1 < j2 /\\ mc[j1,t1] = mc[j2,t2])\n      (nonoverlap(s[j1,t1],d[j1,t1],\n                  s[j2,t2],d[j2,t2]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve :: int_search([s[j,t] | j in JOB, t in TASK], input_order, indomain_min, complete)\n      minimize makespan;\n\noutput [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 2 : \n\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n   %:: int_search([s[j,t]|j in JOB,t in TASK],input_order,indomain_min,complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],smallest, indomain_min, complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],dom_w_deg, indomain_min, complete)\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 3 : \n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n%      ::\n%      seq_search([ int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete),\n%                  int_search([makespan], input_order, indomain_min, complete)])\n%      seq_search([ int_search([makespan], input_order, indomain_min, complete),\n%                   int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete)])\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n"}}, "K4xP2Graceful_beginner": {"node_ids": ["30794ba2-6db1-4dac-ac81-243d0c06cf92"], "metadata": {"model_name": "K4xP2Graceful", "source_code": "% K4P2 Graceful Graph in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: m = 16;\nint: n = 8;\narray[1..n] of var 0..m: nodes;\narray[1..m, 1..2] of var 1..n: graph;\narray[1..m] of var 1..m: edges;\n\n\n\nsolve :: int_search(nodes, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..m) (\n    abs(nodes[graph[i,1]] - nodes[graph[i,2]]) = edges[i]  \n  )\n  /\\\n  all_different(edges) \n  /\\ \n  all_different(nodes)\n;\n\ngraph =\narray2d(1..m, 1..2,\n[1, 2,\n1, 3,\n1, 4,\n2, 3,\n2, 4,\n3, 4,\n\n5, 6,\n5, 7,\n5, 8,\n6, 7,\n6, 8,\n7, 8,\n\n1, 5,\n2, 6,\n3, 7,\n4, 8]);\n\noutput\n[\n  \"nodes: \" ++ show(nodes) ++ \"\\n\" ++\n  \"edges: \" ++ show(edges) ++ \"\\n\"\n];"}}, "killer_sudoku_beginner": {"node_ids": ["412f417e-e027-45da-8bf5-fb03bd356fc5"], "metadata": {"model_name": "killer_sudoku", "source_code": "Model 1 :\n\n%\n% Killer Sudoku in MiniZinc.\n\n%   Killer sudoku (also killer su doku, sumdoku, sum doku, addoku, or\n%   samunamupure) is a puzzle that combines elements of sudoku and kakuro.\n%   Despite the name, the simpler killer sudokus can be easier to solve\n%   than regular sudokus, depending on the solver's skill at mental arithmetic;\n%   the hardest ones, however, can take hours to crack.\n \n%   The objective is to fill the grid with numbers from 1 to 9 in a way that\n%   the following conditions are met:\n \n%     * Each row, column, and nonet contains each number exactly once.\n%     * The sum of all numbers in a cage must match the small number printed\n%       in its corner.\n%     * No number appears more than once in a cage. (This is the standard rule\n%       for killer sudokus, and implies that no cage can include more\n%       than 9 cells.)\n \n%   In 'Killer X', an additional rule is that each of the long diagonals\n%   contains each number once.\n%   \"\"\"\n \n\nint: num_p = 29; % number of segments\nint: num_hints = 4;  % number of hints per segments (that's max number of hints)\nint: max_val = 100;\narray[1..num_p, 1..2*num_hints+1] of 0..max_val: P =\n  array2d(1..num_p, 1..2*num_hints+1, [\n    1,1,  1,2, 0,0, 0,0,   3,\n    1,3,  1,4, 1,5, 0,0,  15,\n    1,6,  2,5, 2,6, 3,5,  22,\n    1,7,  2,7, 0,0, 0,0,   4,\n    1,8,  2,8, 0,0, 0,0,  16,\n    1,9,  2,9, 3,9, 4,9,  15,\n    2,1,  2,2, 3,1, 3,2,  25,\n    2,3,  2,4, 0,0, 0,0,  17,\n    3,3,  3,4, 4,4, 0,0,   9,\n    3,6,  4,6, 5,6, 0,0,   8,\n    3,7,  3,8, 4,7, 0,0,  20,\n    4,1,  5,1, 0,0, 0,0,   6,\n    4,2,  4,3, 0,0, 0,0,  14,\n    4,5,  5,5, 6,5, 0,0,  17,\n    4,8,  5,7, 5,8, 0,0,  17,\n    5,2,  5,3, 6,2, 0,0,  13,\n    5,4,  6,4, 7,4, 0,0,  20,\n    5,9,  6,9, 0,0, 0,0,  12,\n    6,1,  7,1, 8,1, 9,1,  27,\n    6,3,  7,2, 7,3, 0,0,   6,\n    6,6,  7,6, 7,7, 0,0,  20,\n    6,7,  6,8, 0,0, 0,0,   6,\n    7,5,  8,4, 8,5, 9,4,  10,\n    7,8,  7,9, 8,8, 8,9,  14,\n    8,2,  9,2, 0,0, 0,0,   8,\n    8,3,  9,3, 0,0, 0,0,  16,\n    8,6,  8,7, 0,0, 0,0,  15,\n    9,5,  9,6, 9,7, 0,0,  13,\n    9,8,  9,9, 0,0, 0,0,  17\n   ]);\n\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n \n  forall(i in 1..n) (\n        all_different([x[i,j] | j in 1..n]) /\\\n        all_different([x[j,i] | j in 1..n])\n  )\n  /\\\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n  /\\ % calculate the hints\n  forall(p in 1..num_p) (\n     sum(i in 1..num_hints where P[p,2*(i-1)+1] > 0) (x[  P[p, 2*(i-1)+1], P[p,2*(i-1)+2]  ]) = P[p, 2*num_hints+1]\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\"; \nint: n = 9;\narray[1..n, 1..n] of var 1..9: x;\n\nint: num_segments = 29; % number of segments\n\narray[1..n, 1..n] of int: segments =\narray2d(1..n, 1..n,\n[\n  1, 1, 2, 2, 2, 3, 4, 5, 6, % 1\n  7, 7, 8, 8, 3, 3, 4, 5, 6, % 2\n  7, 7, 9, 9, 3,10,11,11, 6, % 3\n 13,14,14, 9,15,10,11,12, 6, % 4\n 13,16,16,17,15,10,12,12,18, % 5\n 19,16,20,17,15,21,22,22,18, % 6\n 19,20,20,17,23,21,21,24,24, % 7\n 19,25,26,23,23,27,27,24,24, % 8\n 19,25,26,23,28,28,28,29,29, % 9\n]);\n\narray[1..num_segments] of int: segment_sums =\n[\n   3, % 1\n  15, % 2\n  22, % 3\n   4, % 4\n  16, % 5\n  15, % 6\n  25, % 7\n  17, % 8\n   9, % 9\n   8, % 10\n  20, % 11\n  17, % 12\n   6, % 13\n  14, % 14\n  17, % 15\n  13, % 16\n  20, % 17\n  12, % 18\n  27, % 19\n   6, % 20\n  20, % 21\n   6, % 22\n  10, % 23\n  14, % 24\n   8, % 25\n  16, % 26\n  15, % 27\n  13, % 28\n  17  % 29\n];\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\n% Standard Sudoku constraints\nconstraint\n  % rows and columns\n  forall(i in 1..n) (\n     all_different([x[i,j] | j in 1..n]) /\\\n     all_different([x[j,i] | j in 1..n])\n  )\n  /\\ % blocks\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n;\n\n% Handle the segments\nconstraint\n  forall(p in 1..num_segments) (\n    segment_sums[p] = sum([x[i,j] | i,j in 1..n where segments[i,j] = p])\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];"}}, "knapsack_beginner": {"node_ids": ["88664e12-ec17-4c30-8f34-d1a2ba121ca3"], "metadata": {"model_name": "knapsack", "source_code": "Model 1 : \n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\narray[OBJ] of var int: x; % how many of each object\n\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in OBJ)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\nModel 2 : \n\n\nint: n;    set of int: OBJ = 1..n;\narray[OBJ] of int: size;\narray[OBJ] of int: value;\nint: limit;\narray[OBJ] of var int: x;\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i]*x[i])<= limit;\nsolve maximize sum(i in OBJ)(value[i]*x[i]);\nn = 4;\nsize = [5,8,9,12];\nvalue = [3,5,7,8];\nlimit = 29;\n\n\n\nModel 3 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var 0..1: x; \n\nconstraint sum(i in 1..n)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 4 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var bool: x; \n\nconstraint sum(i in 1..n)(size[i] * bool2int(x[i])) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(x[i]));\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 5 : \n\n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\nvar set of OBJ: x; \n\n\nconstraint sum(i in x)(size[i]) <= capacity;\n\nsolve maximize sum(i in x)(profit[i]);\n\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 6 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\nvar set of 1..n: x;\n\nconstraint sum(i in 1..n)(size[i] * bool2int(i in x)) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(i in x));\n\noutput [\"x = \", show(x), \"\\n\"];"}}, "langford_beginner": {"node_ids": ["01968c9a-c9c4-43ec-ae98-51425df90c05"], "metadata": {"model_name": "langford", "source_code": "Model 1 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n                 (x[d,c+1] = x[d,c] + d + 1);\n\nsolve satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ if fix(x[d,c]) = p then show(d) ++ \" \" else \"\" endif\n          | p in POS, d in DIG, c in COPY ]\n       ;\n\n\n\nModel 2 : \n\n\n% Langford's number problem in MiniZinc.\n%\n% Arrange 2 sets of positive integers 1..k to a sequence,\n% such that, following the first occurence of an integer i,\n% each subsequent occurrence of i, appears i+1 indices later\n% than the last.\n% For example, for k=4, a solution would be 41312432\n\ninclude \"globals.mzn\";\n\nint: k;\nset of int: positionDomain = 1..2*k;\n\narray[positionDomain] of var positionDomain: position;\n% better presentation:\narray[positionDomain] of var 1..k: solution;\n\nsolve :: int_search(position, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..k) (\n     position[i+k] = position[i] + i+1 /\\\n     % hakank: added this\n     solution[position[i]] = i /\\ \n     solution[position[k+i]] = i\n  )\n  /\\   \n  all_different(position)\n  /\\ % symmetry breaking\n  solution[1] < solution[2*k]\n;\n\n\noutput [\n  show(solution), \"\\n\"\n\n];\n\n%\n% data\n%\nk = 4;\n% k = 7;\n% k = 8;\n% k = 10;\n% k = 20;\n\n\n\nModel 3 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"inverse.mzn\";\nconstraint inverse([x[d,c] | d in DIG, c in COPY], y);\n\n%include \"alldifferent.mzn\";\n%constraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n      (x[d,c+1] = x[d,c] + d + 1);\n\n%constraint forall(d in DIG, c in 1..m-1, p in POS)\n%                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve \n      %:: int_search(y, input_order, indomain_min, complete) \n      %:: int_search([x[d,c] | d in DIG, c in COPY], input_order, indomain_min, complete) \n      satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n\n\nModel 4 :\n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\nconstraint forall(d in DIG, c in 1..m-1, p in POS)\n                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve satisfy;\n\noutput [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n"}}, "loan_beginner": {"node_ids": ["e6cb2e7d-4506-4878-94c2-f6cfb05d664e"], "metadata": {"model_name": "loan", "source_code": "% variables\nvar float: R;        % quarterly repayment\nvar float: P;        % principal initially borrowed\nvar 0.0 .. 10.0: I;  % interest rate\n\n% intermediate variables\nvar float: B1; % balance after one quarter\nvar float: B2; % balance after two quarters\nvar float: B3; % balance after three quarters\nvar float: B4; % balance owing at end\n\nconstraint B1 = P * (1.0 + I) - R;\nconstraint B2 = B1 * (1.0 + I) - R;\nconstraint B3 = B2 * (1.0 + I) - R; \nconstraint B4 = B3 * (1.0 + I) - R;\n\nsolve satisfy;\n\noutput [\n \"Borrowing \", show_float(0, 2, P), \" at \", show(I*100.0), \n \"% interest, and repaying \", show_float(0, 2, R), \n  \"\\nper quarter for 1 year leaves \", show_float(0, 2, B4), \" owing\\n\"\n];\n\n"}}, "ltsp_beginner": {"node_ids": ["2817319e-ed8b-4ef4-8b8b-8e22fa7b82f1"], "metadata": {"model_name": "ltsp", "source_code": "int: n; % number of cities\nset of int: CITY = 1..n;\nset of int: POS = 1..n;\narray[CITY] of int: coord; % coordinate of city \nint: m; % number of precedences\nset of int: PREC = 1..m;\narray[PREC] of CITY: left;\narray[PREC] of CITY: right;\n\narray[CITY] of var POS: order;\narray[POS] of var CITY: city;\n\ninclude \"inverse.mzn\";\nconstraint inverse(order,city);\n\nconstraint forall(i in PREC)(order[left[i]] < order[right[i]]);\n\nsolve minimize sum(i in 1..n-1)(abs(coord[city[i]] - coord[city[i+1]]));\n\n\n"}}, "magic_hexagon_beginner": {"node_ids": ["7d40cf11-47f6-49c2-b647-c2fd7af4debb"], "metadata": {"model_name": "magic_hexagon", "source_code": "% Magic Hexagon in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nset of int: N = 1..19;\nvar N: a;\nvar N: b;\nvar N: c;\nvar N: d;\nvar N: e;\nvar N: f;\nvar N: g;\nvar N: h;\nvar N: i;\nvar N: j;\nvar N: k;\nvar N: l;\nvar N: m;\nvar N: n;\nvar N: o;\nvar N: p;\nvar N: q;\nvar N: r;\nvar N: s;\n\narray[N] of var N: LD = [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s];\n\nsolve satisfy;\n\nconstraint\n  all_different(LD) /\\\n\n  a + b + c =  38 /\\\n  d + e + f + g =  38 /\\\n  h + i + j + k + l =  38 /\\ \n  m + n + o + p =  38 /\\ \n  q + r + s =  38 /\\ \n  a + d + h =  38 /\\ \n  b + e + i + m =  38 /\\ \n  c + f + j + n + q =  38 /\\ \n  g + k + o + r =  38 /\\ \n  l + p + s =  38 /\\ \n  c + g + l =  38 /\\ \n  b + f + k + p =  38 /\\ \n  a + e + j + o + s =  38 /\\ \n  d + i + n + r =  38 /\\ \n  h + m + q =  38 /\\ \n\n  a < c /\\\n  a < h /\\\n  a < l /\\\n  a < q /\\\n  a < s /\\\n  c < h\n;\n\noutput\n[\n  show(LD)\n];"}}, "magic_sequence_beginner": {"node_ids": ["60f5d665-46de-4b90-8714-407a12527d7d"], "metadata": {"model_name": "magic_sequence", "source_code": "Model 1 :\n\n% Magic sequence in MiniZinc.\n% A magic sequence of length n is a sequence of integers x0 . . xn-1 between 0 and n-1, such that for all i in 0 to n-1, the number i occurs exactly xi times in the sequence. For instance, 6,2,1,0,0,0,1,0,0,0 is a magic sequence since 0 occurs 6 times in it, 1 occurs twice, ...\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n  forall(i in 0..n-1) (\n    s[i] = sum(j in 0..n-1) (bool2int(s[j] = i))\n  )\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 2 : \n\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n        forall(i in 0..n-1) (\n                s[i] = sum(j in 0..n-1) (bool2int(s[j]=i))\n        )\n        /\\ \n        sum(i in 0..n-1) (s[i])=n \n        /\\\n        sum(i in 0..n-1) (s[i]*i) =n\n;\n\n\noutput [\n       show(s), \"\\n\",\n];\n\n\n\nModel 3 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  10;\narray[0..n-1] of var 0..n-1: s;\narray[0..n-1] of int: value = array1d(0..n-1, [i | i in 0..n-1]); % helper for distribute\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   distribute(s, value, s)         /\\ \n   sum(i in 0..n-1) (s[i])   = n   /\\\n   sum(i in 0..n-1) (s[i]*i) = n\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 4 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  100;\narray[0..n-1] of var 0..n-1: s;\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   global_cardinality(s,array1d(0..n-1, set2array(index_set(s))), s) :: domain\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\nModel 5 : \n\n\n% Magic squares in MiniZinc\n\ninclude \"globals.mzn\";\n\nint: n = 3;\n\nint: total = ( n * (n*n + 1)) div 2;\narray[1..n,1..n] of var 1..n*n: magic;\n\n\n% solve satisfy;\nsolve :: int_search(\n        [magic[i,j] | i in 1..n, j in 1..n], \n        first_fail,\n        indomain_min,\n        complete) \n    satisfy;\n\n\nconstraint\n\n        all_different([magic[i,j] | i in 1..n, j in 1..n]) :: domain\n        /\\\n        forall(k in 1..n) (\n           sum(i in 1..n) (magic[k,i]) = total % :: domain\n           /\\\n           sum(i in 1..n) (magic[i,k]) = total %:: domain\n        )\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,i]) = total  %:: domain\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,n-i+1]) = total %:: domain\n;\n\n% symmetry breaking\n% Activating all these constraints we get the\n% \"standard\" way of counting the number of solutions:\n%    1, 0, 1, 880, 275305224\n% i.e. this sequence: http://oeis.org/A006052\n%\n% Without the constraints the number of solutions are:\n%  N  #solutions\n%  -------------\n%  1     1\n%  2     0\n%  3     8\n%  4  7040\n%  5  many... \n%\n% constraint\n%    magic[1,1] < magic[1,n]\n%    /\\ magic[1,n] < magic[n,1]\n%    /\\ magic[1,1] < magic[n,n]\n% ;\n\n\noutput [\n  \"Total: \" ++ show(total) ++ \"\\n\"\n] ++\n[\n    %   show(magic)\n  if j = 1 then \"\\n\" else \"\" endif ++\n    if fix(magic[i,j]) < 10 then \" \" else \"\" endif ++\n    show(magic[i,j]) ++ \" \"\n  | i,j in 1..n\n] \n++ \n[\"\\n\"];\n\n\nModel 6 : \n\n\n% Magic square integer programming version in MiniZinc.\n% In recreational mathematics, a magic square of order n is an\n% arrangement of n^2 numbers, usually distinct integers, in a square,\n% such that n numbers in all rows, all columns, and both diagonals sum\n% to the same constant. A normal magic square contains the integers\n% from 1 to n^2.\n\n\n% square order\nint: n = 3; \n\n% integers to be placed\nset of 1..n*n: N = 1..n*n;\n\n% x[i,j,k] = 1 means that cell (i,j) contains integer k\narray[1..n, 1..n, N] of var 0..1: x;\n\narray[1..n, 1..n] of var 1..n*n: square;\n\nvar int: s; % the magic sum\n\nsolve :: int_search(\n        [x[i,j,k] | i,j in 1..n, k in N] ++ \n        [square[i,j] | i,j in 1..n] ++\n        [s],\n        first_fail,\n        indomain_min, \n        complete % \"credit(640, bbs(5))\" % \"complete\"\n      ) \n    satisfy;\n\nconstraint \n  s >= 0 \n  /\\\n  s <= n*n*n\n  /\\\n  % each cell must be assigned exactly one integer\n  forall(i in 1..n, j in 1..n) (\n     sum(k in N) (x[i,j,k]) = 1\n  )\n  /\\\n  % each integer must be assigned exactly to one cell\n  forall(k in N) (\n     sum(i in 1..n, j in 1..n) (x[i,j,k]) = 1\n  )\n\n  /\\\n  % the sum in each row must be the magic sum \n  forall(i in 1..n) (\n     sum(j in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in each column must be the magic sum\n  forall(j in 1..n) (\n     sum(i in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in the diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,i,k]) = s\n\n  /\\\n  % the sum in the co-diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,n-i+1,k]) = s\n\n  /\\\n  % for output\n  forall(i,j in 1..n) ( square[i,j] = sum(k in N) (k * x[i,j,k]))\n;\n\n\noutput [ \n   \"\\ns: \", show(s)\n] ++\n[\n  if  j = 1 then \"\\n\" else \" \" endif ++\n    show(square[i,j]) \n  | i,j in 1..n\n\n] ++ [\"\\n\"];\n\n% printf \"\\n\";\n% printf \"Magic sum is %d\\n\", s;\n% printf \"\\n\";\n% for{i in 1..n}\n% {  printf{j in 1..n} \"%3d\", sum{k in N} k * x[i,j,k];\n%    printf \"\\n\";\n% }\n% printf \"\\n\";"}}, "maximum_density_still_life_beginner": {"node_ids": ["d42b6f50-f418-4478-abd5-c54634fda33d"], "metadata": {"model_name": "maximum_density_still_life", "source_code": "% Maximum density still life in MiniZinc.\n\n% include \"globals.mzn\"; \nint: size = 7; % to change\n\nset of int: objFunctionBoardCoord      = 2..size+1;\nset of int: checkConstraintsBoardCoord = 1..size+2;\nset of int: augmentedBoardCoord        = 0..size+3;\n\n% Search space: The set of all possible assignments of 0s (dead) and 1s (live) \n% to the cells of the board section. However, to be able to easily express \n% constraints on \"boundary\" cells, we take as search space the set of 0/1 \n% boards of size n+4 by n+4: the actual stable pattern appears in the sub-board \n% defined by ignoring the first/last two rows/columns.\narray[augmentedBoardCoord,augmentedBoardCoord] of var 0..1: grid;\n\nvar int: z = sum(r in objFunctionBoardCoord, c in objFunctionBoardCoord) (grid[r,c]);\n\n% Objective function: Maximize the number of live cells in the sub-board defined \n% by ignoring the first/last two/ rows/columns.\n\n\n% solve maximize z;\nsolve :: int_search(\n        [grid[i,j] | i,j in augmentedBoardCoord], \n        smallest, \n        indomain_max, \n        complete) \n    maximize z;\n\nconstraint\n\n  % C1: Cells in the first/last two rows/columns are all 0 (dead)\n  forall(x in augmentedBoardCoord) (\n    grid[0,x] = 0 /\\\n    grid[1,x] = 0 /\\\n    grid[size+2,x] = 0 /\\  \n    grid[size+3,x] = 0 /\\\n    grid[x,0] == 0 /\\       \n    grid[x,1] == 0 /\\\n    grid[x,size+2] = 0 /\\  \n    grid[x,size+3] = 0 \n  )\n  /\\\n  forall(r in checkConstraintsBoardCoord,c in checkConstraintsBoardCoord) (\n    % C2: Each cell of the board (except those of the first/last row/column) \n    %     that has exactly three live neighbors is alive. \n    %     Together with constraint C1, this implies that cells in the\n    %     second/last-but-one row/column cannot have three live neighbors.\n    (\n      ( ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] + \n          grid[r,c-1] + grid[r,c+1] + \n          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1]\n          ) = 3 \n       ) -> (grid[r,c] = 1)\n    )\n    /\\    \n\n    % C3: Each live cell must have 2 or 3 live neighbors (cells of the first/last \n    % row/column may be ignored by this constraint)\n    (\n       (grid[r,c] = 1) -> \n                      (\n                        2 <= \n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          )\n                        /\\\n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          ) <= 3\n                      )\n    )\n  )\n  \n  /\\\n  % SBSO: Symmetry-breaking by selective ordering\n  % The assignment is forced to respect an ordering on the values that occur in corner entries\n  % of the board. In particular:  \n  % - if the NW-corner cell is dead, the SE-corner cell\n  % must be dead too \n  % - if the NE-corner cell is dead, the SW-corner cell must be dead too\n  % \n  grid[2,2] >= grid[size+1,size+1] /\\\n  grid[2,size+1] >= grid[size+1,2]\n;\n\n\noutput [\n  if j = 0 then \"\\n\" else \" \" endif ++\n    show(grid[i,j])\n  | i,j in augmentedBoardCoord\n];\n"}}, "mip_beginner": {"node_ids": ["8fa562d4-da85-4869-95c4-32cc80cd9d5a"], "metadata": {"model_name": "mip", "source_code": "Model 1 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.0*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 2 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\n\nsolve maximize 1.0*B - 1.0*C + 1.0*D;\nconstraint 2.0*B - 1.0*C + 2.0*D <=  4.0;\nconstraint 2.0*B - 3.0*C + 1.0*D <= -5.0;\nconstraint -1.0*B + 1.0*C - 2.0*D <= -1.0;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 3 :\n\n\nvar int: B;\nvar int: C;\nvar int: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.5*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 4 :\n\n\nsolve maximize 21*x + 11*y;\n\nvar int: x;\nvar int: y;\nconstraint 7*x + 4*y <= 13;\nconstraint x >= 0 /\\ y >= 0; \n\n\n\nModel 5 : \n\n\nsolve maximize 8*x + 5*y;\n\nvar int: x;\nvar int: y;\nconstraint x + y <= 6;\nconstraint 9*x + 5*y <= 45;\nconstraint x >= 0 /\\ y >= 0; \n"}}, "missing_solution_beginner": {"node_ids": ["662d0e48-d42a-4ca1-bafe-8e3bf7d12aef"], "metadata": {"model_name": "missing_solution", "source_code": "% Missing Solutions\nint: n; % no of people\nset of int: PERSON = 1..n;\nint: male = 1; int: female = 2;\nset of int: GENDER = male..female;\narray[PERSON] of GENDER: gender;\narray[PERSON] of int: age;\n\narray[1..n] of var PERSON: order;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(order);\n\n% males and females alternate\nconstraint forall(i in 1..n)\n                 (i mod 2 = 0 <-> gender[order[i]] = female);\n\n% age does not grow bu more than 10\nconstraint forall(i in 1..n-1)\n                 (age[order[i+1]] - age[order[i]] <= 10);\n\nsolve satisfy;\n\noutput [ show(order), \"\\n\"] ++\n       [\"[\"] ++ [ show(age[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                | i in 1..n ] ++\n       [\"[\"] ++ [ show(gender[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                 | i in 1..n ];\n\n\n%n = 6;\n%gender = [male,male,male,female,female,female];\n%age = [13, 25, 34, 40, 16, 13];\n\nn = 5;\ngender = [male,male,female,female,female];\nage = [13,25,34,40,16];\n\n%order = [4,2,3,1,5];\n"}}, "nonogram_create_automaton2_beginner": {"node_ids": ["ab33d604-8159-4123-8f4e-6438492dfbab"], "metadata": {"model_name": "nonogram_create_automaton2", "source_code": "Model 1 :\n\n% Nonoram solver using regular and is written in all-MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: rows;\nint: row_rule_len;\narray[1..rows, 1..row_rule_len] of int: row_rules;\nint: cols;\nint: col_rule_len;\narray[1..cols, 1..col_rule_len] of int: col_rules;\n\n\narray[1..rows, 1..cols] of var 1..2: x;\n\nsolve :: int_search(\n     [x[i,j] | j in 1..cols, i in 1..rows], \n     first_fail, \n     indomain_min, \n     complete) \nsatisfy;\n\n%\n% The approach is rather simple:\n%  - zero_positions is a set of the positions in the state table where the \n%    state 0 should be, which also correspond to the state of the pattern \"0\"\n%  - when this have been identified everything else comes to rest\n%\n% On the other hand, the calculation of the states is hairy, very hairy.\n%\npredicate make_automaton(array[int] of var int: x, array[int] of int: pattern) =\n    let {\n        int: n = length(pattern),\n        % fix for \"zero clues\"\n        int: len = max(length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern),1),\n        int: leading_zeros = sum(i in 1..n) (bool2int(pattern[i] = 0)),\n        set of int: zero_positions = {sum(j in 1..i) (pattern[j]+1) -leading_zeros | i in 1..n where pattern[i] > 0},\n       array[1..2*len] of 0..len*2: states = \n     if (length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern)) = 0 then \n       [1,1]  % fix for \"zero clues\"\n     else \n    [1, 2] ++\n    [\n       if i div 2 in zero_positions then\n           if i mod 2 = 0 then\n            0\n           else\n            (i div 2) + 1\n           endif\n       elseif (i-1) div 2 in zero_positions then\n           if i mod 2 = 0 then\n            (i div 2)+1\n           else\n            (i div 2)+2\n           endif\n       else\n         if not( (((i-1) div 2) - 1) in zero_positions) then\n            if i mod 2 = 0 then\n               (i div 2) + 1\n            else \n              if (i div 2) + 1 in zero_positions then\n                  (i div 2) + 2\n              else \n                  0\n              endif\n            endif\n          else\n             if i mod 2 = 0 then\n                 (i div 2) + 1\n             else \n                if not((i div 2) + 1 in zero_positions) then\n                   0\n                else \n                   (i div 2) + 2 \n                endif\n             endif\n          endif\n       endif\n    | i in 3..2*(len-1)]\n    ++\n    [len, 0]\n    endif\n    } \n    in\n    regular(\n       x,\n       len, \n       2, \n       array2d(1..len, 1..2, states),\n       1, \n       {len}) % :: domain\n;\n\nconstraint\n\n      forall(j in 1..cols) (\n        make_automaton([x[i,j] | i in 1..rows], [col_rules[j,k] | k in 1..col_rule_len])\n      )\n      /\\\n      forall(i in 1..rows) (\n        make_automaton([x[i,j] | j in 1..cols], [row_rules[i,k] | k in 1..row_rule_len])\n      )\n\n;\n\noutput \n[\n  if j = 1 then \"\\n\" else \"\" endif ++\n     if fix(x[i,j]) = 1 then \" \" else \"#\" endif\n    \n  | i in 1..rows, j in 1..cols\n] \n++ \n[\n  \"\\n\"\n];\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\nint: X;\nint: Y;\n\nint: maxlen;\n\narray [1..Y,1..maxlen] of int: rows;\n\narray [1..X,1..maxlen] of int: cols;\n\narray[1..2, 1..2, 1..2] of 0..1: nonmul = \n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 1, 1,\n         1, 0, 0, 1]\n    );\n\narray[1..2, 1..2, 1..2] of 0..1: nonadd =\n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 0, 1,\n         1, 0, 0, 1]\n    );\n\n% variables\n%\narray[1..Y, 1..X] of var 1..2: A;\n\n% All variables in a region must be different\n% Ordering to ensure each variable is handled exactly once\npredicate nonogram_row(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: row) =\n    nonogram([A[row, v] | v in 1..X], cons);\n\npredicate nonogram_col(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: col) = \n    nonogram([A[v,col] | v in 1..Y], cons);\n\npredicate nonogram(array[int] of var 1..2: A, array [int] of int: cons) = \n    let {\n          int: n = if cons[1] = 0 then 0 else max(index_set(cons)) endif,\n          array [1..n + 1, 1..2] of int: consarr =\n              if cons[1] = 0 then [|1, 0|] \n              else array2d(1..n + 1, 1..2,\n                [1, 2] ++\n                [    i * nonmul[cons[i - 1] + 1, cons[i] + 1, s] + \n                     nonadd[cons[i - 1] + 1, cons[i] + 1, s] \n                     | i in 2..n, s in 1..2 \n                ] ++ \n                [n+1,0]\n              )\n              endif\n     } in (\n         regular(A, n + 1, 2, consarr, 1, {n + 1})\n     );\n\nconstraint forall(i in 1..Y) (\n    nonogram_row(A, [rows[i, j] | j in 1..maxlen where rows[i, j] >= 0], i)\n);\n\nconstraint forall(i in 1..X) (\n    nonogram_col(A, [cols[i, j] | j in 1..maxlen where cols[i, j] >= 0], i)\n);\n\nsolve :: int_search(array1d(1..X*Y,A),input_order,indomain_max,complete) satisfy;\n\noutput [\n    if fix(A[r, c]) = 1 then \" \" else \".\" endif ++ \n    if c = Y then \"\\n\" else \" \" endif\n    | r in 1..X, c in 1..Y\n];"}}, "nurses_beginner": {"node_ids": ["7f3225b0-7c54-4c59-94de-5a432acc2ac6"], "metadata": {"model_name": "nurses", "source_code": "Model 1 : \n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint forall(d in DAY)\n                 (global_cardinality_low_up([x[n,d] | n in NURSE ],                                               [ day, night ], [ o, l ], [o, u])); \n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n\n\nModel 2 :\n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\nconstraint forall(d in DAY)\n                 (let {var int: on = sum(n in NURSE)\n                                        (bool2int(x[n,d]=night))        \n                      } in l <= on /\\ on <= u);\n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n"}}, "opd_beginner": {"node_ids": ["ba365d05-5cb0-45a2-b121-580290fcd67a"], "metadata": {"model_name": "opd", "source_code": "%% Design of Collateralised Debt Obligations Squared (CDO^2) Transactions\n% An OPD (v, b, r) problem is to find a binary matrix of v rows\n% and b columns such that each row sums to r, and\n% the dot product beween any pair of distinct rows is minimal.\n\n%Requires MiniZinc >= 2.0.2 for the symmetry_breaking_constraint predicate\n\ninclude \"lex_greatereq.mzn\";\n\n%instance data\nint: v;\nint: b;\nint: r;\n\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\n\n%computing a lower bound for lambda\nint: rv = r*v;\nint: rvmodb = rv mod b;\nint: floorrv = rv div b;\nint: ceilrv = rv div b + bool2int(rv mod b != 0);\nint: num = (ceilrv*ceilrv*rvmodb+floorrv*floorrv*(b-rvmodb)-rv);\nint: denom = v*(v-1);\nint: lb_lambda = num div denom + bool2int( num mod denom !=0);\n\n% This line is there for debugging purposes, it can be safely removed\nint: tmp = trace(\"Computed lower bound for lambda: \"++show(lb_lambda)++\"\\n\",lb_lambda);\n\n\n% lambda is called objective for the MiniZinc Challenge\nvar lb_lambda..b: objective;\n\n\narray [rows, cols] of var 0..1: m;\n\n\n% Every row must sum to r.\nconstraint forall (i in rows) (sum (j in cols) (m[i, j]) = r);\n\n% The dot product of every pair of distinct rows must be at most lambda for an OPD and a PD, and equal to lambda for a BIBD\nconstraint forall (i_a, i_b in rows where i_a < i_b) (\n    sum (j in cols) (m[i_a, j] * m[i_b, j]) <= objective\n);\n\n\n% Break row symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(i in rows diff {max(rows)})(\n        lex_greatereq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    )\n);\n% Break column symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(j in cols diff {max(cols)})(\n        lex_greatereq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    )\n);\n\n\nsolve \n    :: seq_search([int_search([m[i, j] | i in rows, j in cols], input_order, indomain_max, complete),\n       \t\t   int_search([objective], input_order,indomain_min,complete)])\n    minimize objective; \n\n\n% Disabled the full solution. Printing only the objective value, lower bound, and parameters.\noutput  [\"opd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r), \"). Found lambda = \", show(objective),\"\\tlb: \", show(lb_lambda)]\n%       ++[\"\\n\\n\"] ++ \n%\t[ ( if j > b then \"\\n\" else \n%\t        if fix(m[i,j])=1 then \"*\" else \" \" endif\n%\t    endif )\n%       | i in rows, j in 1..(b + 1) ]\n;"}}, "partition_beginner": {"node_ids": ["27ecf388-0cdd-456b-b342-4fd01da8ce95"], "metadata": {"model_name": "partition", "source_code": "Model 1 : \n\n% Partitioning problem\n% Partition 2*n numbers into two groups, each of size n, such that\n% their sums are equal and the sums of their squares are equal.\n\ninclude \"globals.mzn\";\n\n% Instance\n\nn = 32;\n\n% Model\n\nint: n;\n\narray[1..n] of var 1..2*n: x;\narray[1..n] of var 1..2*n: y;\n\nconstraint true\n    %   Break symmetries by ordering numbers in each group\n    /\\  forall (i in 2..n) (x[i-1] < x[i] /\\ y[i-1] < y[i])\n    %   Break symmetries by ordering the groups\n    /\\  x[1] < y[1]\n    \n    %   Partition the numbers\n    /\\  (alldifferent(x++y)) :: bounds\n    \n    %   The sums are equal\n    /\\  sum (x) = 2*n*(2*n+1) div 4\n    /\\  sum (y) = 2*n*(2*n+1) div 4\n    \n    %   The sums of the squares are equal\n    /\\  let {\n            array[1..n] of var 1..4*n*n: sx,\n            array[1..n] of var 1..4*n*n: sy\n        } in\n        forall (i in 1..n) (sx[i]=x[i]*x[i] /\\ sy[i] = y[i]*y[i])\n    /\\  sum (sx) = 2*n*(2*n+1)*(4*n+1) div 12\n    /\\  sum (sy) = 2*n*(2*n+1)*(4*n+1) div 12\n;\n\nsolve ::int_search(x++y,first_fail,indomain_min,complete) satisfy;\n\noutput\n    [\"x = \",show(x),\"\\n\",\"y = \",show(y),\"\\n\",\n     \"sum = \",show(2*n*(2*n+1) div 4),\"\\n\",\n     \"sum of squares = \", show(2*n*(2*n+1)*(4*n+1) div 12), \"\\n\"\n     ];\n\n\n\nModel 2 :\n\n\n\n%\n% Set partition problem in Minizinc.\n%\n%  This is a partition problem.\n%  Given the set S = {1, 2, ..., n},\n%  it consists in finding two sets A and B such that:\n%  <ul>\n%  <li>A U B = S,</li>\n%  <li>|A| = |B|,</li>\n%  <li>sum(A) = sum(B),</li>\n%  <li>sum_squares(A) = sum_squares(B).</li>\n%  </ul>\n \n%\ninclude \"globals.mzn\";\n \nint: n = 16;\nset of 1..n: S = 1..n;\nint: num_sets = 2;\narray[1..num_sets] of var set of S: a;\narray[1..num_sets] of var 0..n*n: sums;\narray[1..num_sets] of var 0..n*n*n*n: sum_squared;\n \n \n%\n% set_sum\n% sums the elements in the set s\n%\npredicate set_sum(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i)\n;\n \npredicate set_sum_squared(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i*i)\n;\n \n \nsolve :: set_search(a, first_fail, indomain_min, complete) satisfy;\n% solve maximize sums[1];\n \nconstraint\n  assert(n mod 4 == 0, \"n must be a multiple of 4\")\n;\n \nconstraint\n   % use all the elements in S and it should be disjoint sets\n   partition_set(a, S)\n   /\\\n   forall(i in 1..num_sets) (  \n     a[i] `set_sum` sums[i]\n     /\\ a[i] `set_sum_squared` sum_squared[i]\n   )\n   /\\\n   forall(i in 2..num_sets) (\n     card(a[i]) > 0 /\\ % this is needed by eclipse\n     card(a[i]) = card(a[i-1]) /\\\n     sums[i] = sums[i-1]\n     /\\ sum_squared[i] = sum_squared[i-1]\n   )\n \n  % symmetry breaking\n  /\\ 1 in a[1]\n \n;\n \noutput [\n   \"a: \" ++ show(a) ++ \"\\n\" ++\n   \"sums: \" ++ show(sums) ++ \"\\n\" ++\n   \"sum_squared: \" ++ show(sum_squared) ++ \"\\n\"\n];\n \n% For model seeker\n% output [\n%    show(set2array(fix(a[i]))) ++ \",\"\n%   | i in 1..num_sets\n% ];"}}, "photo_beginner": {"node_ids": ["9d7918e4-2e7c-450b-abd5-b43323a7c749"], "metadata": {"model_name": "photo", "source_code": "int:n ;\nset of int: PERSON = 1..n;\nset of int: POS = 1..n;\narray[PERSON,PERSON] of int: friend;\n\n%array[PERSON] of var POS: x;\narray[POS] of var PERSON: y;\n\n%include \"inverse.mzn\";\n%constraint inverse(x,y);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\n%constraint alldifferent(x);\n\n%y[i] = sum(j in 1..n)(bool2int(x[j] = i) * j);\n\nsolve maximize sum(i in 1..n-1)(friend[y[i],y[i+1]]);\n\n"}}, "project_scheduling_beginner": {"node_ids": ["930acf52-d5f6-4d56-b525-57da3f9ae68b"], "metadata": {"model_name": "project_scheduling", "source_code": "Model 1 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\nconstraint forall(i in PREC)\n                 (start[pre[i,1]] + duration[pre[i,1]] <= start[pre[i,2]]);\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n\n\n\nModel 2 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\npredicate precedes(var int:s1, var int:d1, var int:s2)=\n          s1 + d1 <= s2; \n\nconstraint forall(i in PREC)\n                 (precedes(start[pre[i,1]],duration[pre[i,1]],start[pre[i,2]]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nset of TASK: CARPENTRY = { interior_walls, exterior_walls, roof };\nconstraint forall(t1, t2 in CARPENTRY where t1 < t2)\n      (nonoverlap(start[t1],duration[t1],start[t2],duration[t2]));\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n"}}, "QuasigroupCompletion_beginner": {"node_ids": ["c548ea43-90cc-4b09-a679-8aadee6e104c"], "metadata": {"model_name": "QuasigroupCompletion", "source_code": "Model 1 :\n\n% Quasigroup with Holes (aka Latin Square Completion)\n\ninclude \"alldifferent.mzn\";\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n\narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N] of var PuzzleRange: puzzle;\n\n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j] = start[i,j] else true endif );\n\n% All different in rows\nconstraint forall (i in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | j in PuzzleRange ] ) );\n\n% All different in columns.\nconstraint forall (j in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | i in PuzzleRange ] ) );\n\nsolve satisfy;\n\noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n \narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N, 1..N] of var 0..1: puzzle;\n \n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j, start[i,j]] = 1 else true endif );\n \n% All different in rows\nconstraint forall (i,k in PuzzleRange) (\n        sum(j in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% All different in columns\nconstraint forall (j,k in PuzzleRange) (\n        sum(i in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% Each cell must have a number assigned\nconstraint forall (i,j in PuzzleRange) (\n        sum(k in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\nsolve satisfy;\n \noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];"}}, "QuasiGroupExistence_beginner": {"node_ids": ["ad0f25bc-8e58-47b5-8185-69fea96ce841"], "metadata": {"model_name": "QuasiGroupExistence", "source_code": "Model 1 :\n\n\n% Quasigroup problem in MiniZinc.\n% The quasiGroup existence problem\n% An m order quasigroup  is an mxm multiplication table of integers 1..m,\n% where each element occurrs exactly once in each row and column and certain\n% multiplication axioms hold (in this case, we want axiom 7 to hold).\n%\n% QG7.m problems are order m quasigroups for which (b*a)*b = a*(b*a).\n\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n% solve satisfy;\n \nconstraint\n      \n     % assign the \"reflected\" quasigroup to qGColumns to access its columns\n     %  forall row,col : nDomain .\n     %    quasiGroupColumns[col,row] = quasiGroup[row,col],\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % all values in the diagonals\n     forall( i in nDomain ) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n \n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row, col] | row in nDomain])\n     )\n     /\\\n \n     % this strange constraint\n     % corresponds to:\n     % quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i], j] \n     forall(i,j in nDomain) (\n              quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i],j]\n     )\n     /\\\n     % some implied? constraint\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n%\n% data\n%\nn = 5;\n\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 9; % solutions for n=5, n=9...\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n \nint: n = 4;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n \n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (i != j) ->\n         (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n \n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n \n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\n\nModel 4 :\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n \n     % Idempotency\n     % forall i : nDomain .\n     %     (quasiGroup[i,i] = i),\n \n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     % allDifferent(qgDiagonal) %,\n \n     % anti-Abelian\n     % forall i : nDomain .\n     %   forall j : nDomain .\n     %     (i != j) =>\n     %     (quasiGroup[i,j] != quasiGroup[j,i]),\n \n     % if (i*i)=j then (j*j) = i\n     % forall i : nDomain .\n     %  forall j : nDomain .\n     %    (quasiGroup[i,i]=j) => (quasiGroup[j,j]=i),\n \n \n     % Symmetry-breaking constraints   \n     % forall i : nDomain .\n     %      quasiGroup[i,n-1] + 2 >= i\n \n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n \n \n%\n% data\n%\nn = 4; % 4 works\n\n\nModel 5 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 6 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 5;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 7 :\n\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];"}}, "queens_beginner": {"node_ids": ["eb1e6520-993d-4661-a0b5-d7af06301f6d"], "metadata": {"model_name": "queens", "source_code": "Model 1 :\n\n% n queens problem in MiniZinc.\n\ninclude \"globals.mzn\";\n\nint: n;\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail, \n        indomain_min, \n        complete) \n    satisfy;\n\n% solve satisfy;\n\nconstraint all_different(queens);\n\nconstraint\n    forall(i, j in 1..n where i < j) (\n         queens[i] != queens[j] /\\\n         queens[i] + i != queens[j] + j /\\\n         queens[i] - i != queens[j] - j\n    ) \n ;\n\noutput [\n  show(queens) ++ \"\\n\"\n\n];\n\n% data\nn = 8;\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n;\n\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail,\n        indomain_median,\n        complete\n       )\n     satisfy;\n\n% solve satisfy;\nconstraint all_different(queens); %  :: domain;\nconstraint all_different([queens[i]+i | i in 1..n]) :: domain;\nconstraint all_different([queens[i]-i | i in 1..n]) :: domain;\n\noutput \n[\n  \"queens: \" ++ show(queens)\n] ++ \n% [\n%   if j = 1 then \"\\n\" else \"\" endif ++\n%      if fix(queens[i]) = j then          \n%         show_int(2,j)\n%      else\n%         \"__\"\n%      endif\n%   | i in 1..n, j in 1..n\n% ] ++\n[\"\\n\"]\n;\n\n% data\nn = 8;\n\n\nModel 3 :\n\n\n\nint: n;                                 % The number of queens.\n\narray [1..n] of var 1..n: q;\n\ninclude \"alldifferent.mzn\";\n\nconstraint alldifferent(q);\nconstraint alldifferent(i in 1..n)(q[i] + i);\nconstraint alldifferent(i in 1..n)(q[i] - i);\n\n\nsolve \n%      :: int_search(q, input_order, indomain_min, complete) \n%      :: int_search(q, first_fail, indomain_min, complete) \n%      :: int_search(q, smallest, indomain_min, complete)\n%      :: int_search(q, largest, indomain_min, complete)\n%      :: int_search(q, input_order, indomain_max, complete) \n%      :: int_search(q, first_fail, indomain_max, complete) \n%      :: int_search(q, smallest, indomain_max, complete)\n%      :: int_search(q, largest, indomain_max, complete)\n%      :: int_search(q, input_order, indomain_median, complete) \n%      :: int_search(q, first_fail, indomain_median, complete) \n%      :: int_search(q, smallest, indomain_median, complete)\n%      :: int_search(q, largest, indomain_median, complete)\n%      :: int_search(q, input_order, indomain_random, complete) \n%      :: int_search(q, first_fail, indomain_random, complete) \n%      :: int_search(q, smallest, indomain_random, complete)\n%      :: int_search(q, largest, indomain_random, complete)\n      satisfy;\n\n%output\t\n%%\t[\tif fix(q[i]) = j then \"Q \" else \". \" endif ++\n%\t \tif j = n then \"\\n\" else \"\" endif\n%\t|\ti, j in 1..n\n%\t];\n"}}, "rcpsp_beginner": {"node_ids": ["b1416728-3b5d-41d5-8d06-90b3d4680ec3"], "metadata": {"model_name": "rcpsp", "source_code": "int: n; % number of tasks\nset of int: TASK = 1..n;\narray[TASK] of int: d; % duration\n\nint: m; % number of resources\nset of int: RESOURCE = 1..m;\narray[RESOURCE] of int: L; % resource limit\narray[RESOURCE,TASK] of int: res; % usage\n\nint: l; % number of precedences\nset of int: PREC = 1..l;\narray[PREC,1..2] of TASK: pre; % predecessor/successor pairs\n\nint: maxt; % maximum time\nset of int: TIME = 0..maxt;\n\narray[TASK] of var TIME: s; % start time\n\nconstraint forall(p in PREC)(s[pre[p,1]]+d[pre[p,1]] <= s[pre[p,2]]);\n\ninclude \"cumulative.mzn\";\nconstraint forall(r in RESOURCE)\n                 (cumulative(s,d,[res[r,t]|t in TASK],L[r]));\n%constraint forall(r in RESOURCE) \n%                 ( let { array[int] of var int: ss = \n%                              [ s[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: dd = \n%                              [ d[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: rr = \n%                              [ res[r,t] | t in TASK where res[r,t] > 0 ]; } in\n%                   cumulative(ss,dd,rr,L[r]));\n\nsolve minimize max(t in TASK)(s[t] + d[t]);\n\noutput [show(s)];\n\n\n"}}, "rehearsal_beginner": {"node_ids": ["11210b56-7cad-4748-bb19-7f1106bb5297"], "metadata": {"model_name": "rehearsal", "source_code": "%\n% Scheduling a Rehearsal in MiniZinc.\n% A concert is to consist of nine pieces of music of different durations\n% each involving a different combination of the five members of the orchestra.\n% Players can arrive at rehearsals immediately before the first piece in which\n% they are involved and depart immediately after the last piece in which\n% they are involved. The problem is to devise an order in which the pieces\n% can be rehearsed so as to minimize the total time that players are waiting\n% to play, i.e. the total time when players are present but not currently\n% playing. In the table below, 1 means that the player is required for\n% the corresponding piece, 0 otherwise. The duration (i.e. rehearsal time)\n% is in some unspecified time units.\n%\n%    Piece       1    2   3    4    5  6    7   8    9\n%    Player 1    1    1   0    1    0  1    1   0    1\n%    Player 2    1    1   0    1    1  1    0   1    0\n%    Player 3    1    1   0    0    0  0    1   1    0\n%    Player 4    1    0   0    0    1  1    0   0    1\n%    Player 5    0    0   1    0    1  1    1   1    0\n%    Duration    2    4   1    3    3  2    5   7    6\n%\n% For example, if the nine pieces were rehearsed in numerical order as\n% given above, then the total waiting time would be:\n%       Player 1: 1+3+7=11\n%       Player 2: 1+5=6\n%       Player 3: 1+3+3+2=9\n%       Player 4: 4+1+3+5+7=20\n%       Player 5: 3\n% giving a total of 49 units. The optimal sequence, as we shall see,\n% is much better than this.\n%\n% ...\n%\n% The minimum waiting time for the rehearsal problem is 17 time units, and\n% an optimal sequence is 3, 8, 2, 7, 1, 6, 5, 4, 9.\n%\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \n\n\nint: num_pieces;\nint: num_players;\narray[1..num_pieces] of int: duration;\narray[1..num_players, 1..num_pieces] of 0..1: rehearsal;\n\n\n%\n% Decision variables\n%\narray[1..num_pieces] of var 1..num_pieces: rehearsal_order;\narray[1..num_players] of var 0..sum(duration): waiting_time; % waiting time for players\narray[1..num_players] of var 1..num_pieces: p_from; % first rehearsal\narray[1..num_players] of var 1..num_pieces: p_to;   % last rehearsal\nvar 0..sum(duration): total_waiting_time = sum(waiting_time); % objective\n\nsolve :: int_search(\n         rehearsal_order % ++ waiting_time% ++ p_from ++ p_to ++ [total_waiting_time]\n         , \n         first_fail, % occurrence, % max_regret, % first_fail, \n         indomain_max, % indomain_max, \n         complete) \n     minimize total_waiting_time;\n     % satisfy;\n\n% solve :: labelling_ff minimize total_waiting_time;\n\nconstraint\n  all_different(rehearsal_order) :: domain\n  /\\\n\n  % This solution is my own without glancing at Smith's models...\n  forall(p in 1..num_players) (\n     % This versions is much faster than using exists (see below)\n     % fix the range from..to, i.e. don't count all that start with 0 \n     % or ends with 0.\n     % This means that we collect the rehearsals with many 0 at the ends\n     %\n     p_from[p] < p_to[p]\n     /\\\n     % skipping rehearsal at start (don't come yet)\n     forall(i in 1..num_pieces) (\n        i < p_from[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\\n     % skipping rehearsal at end (go home after last rehearsal)\n     forall(i in 1..num_pieces) (\n        i > p_to[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\ % and now: count the waiting time for from..to\n     waiting_time[p] = \n         sum(i in 1..num_pieces) (\n              duration[rehearsal_order[i]] * bool2int(\n                                             i >= p_from[p] /\\ i <= p_to[p] \n                                             /\\\n                                             rehearsal[p,rehearsal_order[i]] = 0\n                                )\n     ) \n\n%      % alternative solution with exists. \n%      %  More elegant (= declarative) in my book but slower.\n%      exists(from, to in 1..num_pieces) ( \n%         % skipping rehearsal at start (don't come yet)\n%         forall(i in 1..from-1) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\\n%         % skipping rehearsal at end (go home after last rehearsal)\n%         forall(i in to+1..num_pieces) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\ % and now: count the waiting time for from..to\n%         waiting_time[p] = \n%             sum(i in from..to) (\n%                  duration[rehearsal_order[i]]*\n%                                  bool2int(\n%                                       rehearsal[p,rehearsal_order[i]] = 0\n%                                   )\n%          ) \n%      )\n\n\n  )\n\n  /\\ % symmetry breaking\n  rehearsal_order[1] < rehearsal_order[num_pieces]\n\n  % for all solutions\n  % /\\ total_waiting_time = 17\n;\n\n\n%\n% data\n%\n%\n% num_pieces = 9;\n% num_players = 5;\n% duration = [2, 4, 1, 3, 3, 2, 5, 7, 6];\n% rehearsal = array2d(1..num_players, 1..num_pieces, \n%     [\n%      1,1,0,1,0,1,1,0,1,\n%      1,1,0,1,1,1,0,1,0,\n%      1,1,0,0,0,0,1,1,0,\n%      1,0,0,0,1,1,0,0,1,\n%      0,0,1,0,1,1,1,1,0\n%   ]);\n\n%\n% This is the problem from the Choco v 2.1 example \n% num_pieces = 5;\n% num_players = 3;\n% duration = [4,6,3,5,7];\n% rehearsal =  array2d(1..num_players, 1..num_pieces, \n%         [\n%         1,1,0,1,0,\n%         0,1,1,0,1,\n%         1,1,0,1,1   \n%   ]);\n\n\noutput[\n  \"order: \" , show(rehearsal_order), \"\\n\",\n  \"waiting_time: \", show(waiting_time), \"\\n\",\n  \"total_waiting_time: \" , show(total_waiting_time), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(rehearsal[p, rehearsal_order[j]]) ++ \" \"\n  | p in 1..num_players, j in 1..num_pieces, \n] ++ \n[\"\\n\"]\n;\n\n"}}, "restart_beginner": {"node_ids": ["1fa23511-0c82-4a7f-b6d3-ab30be6c6ce5"], "metadata": {"model_name": "restart", "source_code": "Model 1 : \n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n\nModel 2 :\n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_max, complete)\n      satisfy;\n\n\nModel 3 : \n\n\narray[1..10] of var 1..10:x;\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n"}}, "RosteringProblem_beginner": {"node_ids": ["33c0583a-83a0-4e61-b9af-cfec4995b820"], "metadata": {"model_name": "RosteringProblem", "source_code": "include \"all_equal.mzn\";\ninclude \"global_cardinality.mzn\";\n\n% load parameters\ninclude \"parameters.dzn\";\n\nint: daysPerWeek = 7;\n\n% the number of weeks\nint: numberOfWeeks;\n\nint: numberOfDays = numberOfWeeks * daysPerWeek;\n\n% the minimum number of days in a row with the same shift\nint: s_min;\n\n% the maximum number of days in a row with the same shift\nint: s_max; \n\n% 3 shifts: early = 1, late = 2 and night shift = 3 + day off (rest day) = 0\nint: numberOfShifts = 3;\n\n% the shift requirement matrix, including at M_{i,j} the needed employees for day i and shift j\narray[1..daysPerWeek, 1..numberOfShifts+1] of int: shiftRequirements;\n\n\n% the variables X \narray[1..numberOfWeeks * daysPerWeek] of var 0..numberOfShifts: plan1d;\narray[1..numberOfWeeks,1..daysPerWeek] of var 0..numberOfShifts: plan2d;\narray[1..daysPerWeek,1..numberOfWeeks] of var 0..numberOfShifts: plan2dT;\n\n% helper arrays\narray[1..s_min,1..s_min] of var 0..numberOfShifts: s_min_arrays;\narray[1..s_max,1..s_max] of var 0..numberOfShifts: s_max_arrays;\n\n% convert the 2D plan into 1D\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan1d[(week-1) * daysPerWeek + day]\n           );  \n\n% transpose the 2D plan\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan2dT[day, week]\n           );\n\n% C_equalDays: constrains that weekend days (Saturday and Sunday) always have the same shift\nconstraint forall(week in 1..numberOfWeeks) (\n               plan2d[week, daysPerWeek - 1] == plan2d[week, daysPerWeek]\n           );                        \n\n                                                                                                                                \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_min, j in 1..s_min) (\n                 s_min_arrays[i, j] == plan1d[((numberOfDays - s_min - 1 + i + j) mod numberOfDays) + 1]\n           );                                            \n                                            \n% C_shiftRepetitions:for every shift type a minimum number of consecutive assignments to this shift is given\nconstraint forall(day in 1..numberOfDays - s_min) (\n               plan1d[day] != plan1d[day+1] -> all_equal(plan1d[day+1..day+s_min])\n           );     \n% the constraints over the array bounds           \nconstraint forall(d in 1..s_min) (\n               plan1d[d + numberOfDays - s_min] != plan1d[((d + numberOfDays - s_min) mod numberOfDays) +1] -> all_equal(s_min_arrays[d,1..s_min])\n           );                     \n\n           \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_max, j in 1..s_max) (\n                 s_max_arrays[i, j] == plan1d[((numberOfDays - s_max - 2 + i + j) mod numberOfDays) + 1]\n           );                      \n                                            \n% C_shiftRepetitions:for every shift type a maximum number of consecutive assignments to this shift is given           \nconstraint forall(day in 1..numberOfWeeks * daysPerWeek - s_max) (\n               (all_equal(plan1d[day..day+s_max])) -> (plan1d[day] != plan1d[day + s_max])\n           );               \n% the constraints over the array bounds             \nconstraint forall(d in 1..s_max) (\n               (all_equal(s_max_arrays[d, 1..s_max])) -> (plan1d[d + numberOfDays - s_max] != plan1d[d])\n           );                     \n\n                               \n                                                                                                   \n% C_restDays: at least 2 days must be rest days every 2 weeks.\nconstraint forall(day in 1..(numberOfWeeks - 2) * daysPerWeek) (\n               count(j in plan1d[day..day + daysPerWeek * 2])(j=0) >= 2                   \n           );            \nconstraint forall(i in 1..2 * daysPerWeek-1) (\n               count(j in plan1d[numberOfWeeks * daysPerWeek-i .. numberOfWeeks * daysPerWeek] ++ plan1d[1..2*daysPerWeek-i])(j=0) >= 2    \n           );         \n                                            \n% C_shiftOrder: restricts the order of shifts. There is a forward rotating principle. This means, that after an early shift there can only follow a shift with the same or a higher value, or a rest shift.\nconstraint forall(day in 2..numberOfWeeks * daysPerWeek - 1) (\n               plan1d[day] <= plan1d[day + 1] \\/ plan1d[day+1] == 0\n           );         \nconstraint plan1d[1] >= plan1d[numberOfDays] \\/ plan1d[1] == 0;\n                      \n% C_shiftRequirements: for every weekday for each shift the number of required staff is provided (e.g. usually less staff is required on the weekend) \nconstraint forall(day in 1..daysPerWeek) (\n              (global_cardinality(row(plan2dT,day),[0,1,2,3],row(shiftRequirements,day)))   \n           );    \n           \n% solve the problem           \nsolve :: int_search(plan1d, input_order, indomain_min, complete)\n      satisfy;           \n      \n% print the problem      \noutput [ show(row(plan2d,j)) ++ \"\\n\" | j in 1..numberOfWeeks ] ++ [\"\\n\"];      "}}, "sb_beginner": {"node_ids": ["66065360-9a68-4de1-858a-3771ed922ed0"], "metadata": {"model_name": "sb", "source_code": "% Solitaire Battleships is a puzzle where\n% we are given a partially filled in board and the number\n% of ships in each row and column and have to fill it with ships\n \n% \"Improved\" version does not introduce reified set_in\n\nint: width;   % height of board (usually 10)\nint: height;  % width of board (usually 10)\nint: maxship; % maximal length of ship (usually 4)\n\n\nset of int: ROWS = 1..width;\nset of int: COLS = 1..height;\nset of int: XROWS = 0..width+1;    % extended rows\nset of int: XCOLS = 0..height+1;   % extended cols\n\n%% ship types enumerated type\nset of int: SHIPS = 1..maxship;  % different ship types\nint: submarine = 1;\nint: destroyer = 2;\nint: cruiser = 3;\nint: battleship = 4;\n\n\n%% the PIECES enumerated type!\nset of int: PIECES = 1..7;\nint: w = 1; % water\nint: c = 2; % circle (submarine)\nint: l = 3; % left end of ship\nint: r = 4; % right end of ship\nint: t = 5; % top of ship\nint: b = 6; % bottom of ship\nint: m = 7; % middle of ship\narray[PIECES] of string: code = [\".\",\"c\",\"l\",\"r\",\"t\",\"b\",\"m\"];\n\narray[ROWS,COLS] of 0..7: hint; % the initial board configuration\narray[ROWS] of int: rowsum;     % sums for each row\narray[COLS] of int: colsum;     % sums for each col\narray[SHIPS] of int: ship; % the number of each type of ship (usually [4,3,2,1]).\n\n\n\n% variables \narray[XROWS,XCOLS] of var PIECES: board;  % the board\n \narray[XROWS,XCOLS] of var 0..1: fill;     % which pieces are ships\n\narray[PIECES] of var 0..width*height: npiece; % number of pieces of each type\n\n\n% model\n\n% ensure hints are respected\nconstraint forall(i in ROWS, j in COLS)(\n\t\t\t   if hint[i,j] != 0 then\n\t\t\t   \t\tboard[i,j] == hint[i,j]\n\t\t\t   else true endif\n\t       ); \n\n% make extended rows and cols empty\nconstraint forall(i in XROWS)(board[i,0] == w /\\ board[i,width+1] == w);\nconstraint forall(j in COLS)(board[0,j] == w /\\ board[height+1,j] == w);\n\n% ensure that the fill array matches the board\nconstraint forall(i in XROWS, j in XCOLS)(\n\t\t\t   fill[i,j] = bool2int(board[i,j] != w)\n\t       ); \n\n% spacing constraints: gaps betwen ships\nconstraint forall(i in ROWS, j in COLS)(\n\t   (board[i,j] == w \\/ board[i+1,j+1] == w)\n\t/\\ (board[i,j] == w \\/ board[i+1,j-1] == w)   % diagonal constraints\n            /\\ (board[i,j] in {c,l,r,t} -> board[i-1,j] == w)\n            /\\ (board[i,j] in {c,l,r,b} -> board[i+1,j] == w)\n            /\\ (board[i,j] in {c,l,t,b} -> board[i,j-1] == w)\n            /\\ (board[i,j] in {c,r,t,b} -> board[i,j+1] == w)\n           );\n               \t\t\t                       \n% ship shape constraints\nconstraint forall(i in ROWS, j in COLS)(\n               %% a left piece needs a right piece or middle to the right\n\t\t\t   (board[i,j] == l -> (board[i,j+1] == r \\/ board[i,j+1] == m))\n\t\t\t/\\ (board[i,j] == r -> (board[i,j-1] == l \\/ board[i,j-1] == m))\n\t\t\t/\\ (board[i,j] == t -> (board[i+1,j] == b \\/ board[i+1,j] == m))\n\t\t\t/\\ (board[i,j] == b -> (board[i-1,j] == t \\/ board[i-1,j] == m))\n\t\t\t   %% a middle piece has to have two opposite sides filled\n\t\t\t/\\ (board[i,j] == m -> (   fill[i-1,j] == fill[i+1,j]\n\t\t\t                        /\\ fill[i,j-1] == fill[i,j+1]\n\t\t\t                        /\\ fill[i-1,j] + fill[i,j-1] == 1))\n\t\t   );\n\t\t   \n% sum up pieces\nconstraint forall(p in PIECES)(\n\t\t\t   sum(i in ROWS, j in COLS)(bool2int(board[i,j] == p)) == npiece[p]\n\t\t   );\n\n% piece sum constraints\nconstraint npiece[c] == ship[submarine]; % submarines\nconstraint npiece[l] == npiece[r]; % left right (probably redundant)\nconstraint npiece[t] == npiece[b]; % top bottom\nconstraint npiece[l] + npiece[t] == sum(s in destroyer..maxship)(ship[s]); \n                                   % no of ends\nconstraint npiece[m] == sum(s in cruiser..maxship)(ship[s] * (s - 2)); \n                                   % no of middles \t\t   \n\t\t    \n% count number of bigger ships\n% at least for standard battleships you can probably simply\n% enforce this constraint for s in destroyer..destroyer\t\t\n% and still be guaranteed a correct solution    \nconstraint forall(s in destroyer..maxship)(\n\t           sum(i in ROWS,j in COLS)(bool2int(\n\t\t\t       if j + s - 1 <= width then\n\t\t\t          board[i,j] == l /\\ board[i,j+s-1] == r     % ship length s lr\n\t\t\t       /\\ forall(k in j+1..j+s-2)(board[i,k] == m)\n\t\t\t       else false endif\n\t\t\t    \\/\n\t\t\t       if i + s - 1 <= height then\n\t\t\t          board[i,j] == t /\\ board[i+s-1,j] == b     % ship length s tb\n\t\t\t       /\\ forall(k in i+1..i+s-2)(board[k,j] == m)\n\t\t\t       else false endif\n\t\t       )) = ship[s]\n\t\t   );\t\t    \n\t\t    \t\t    \n\n% row sums respected\nconstraint forall(i in ROWS)(\n               sum(j in COLS)(fill[i,j]) == rowsum[i]\n           );\n           \n% column sums respected           \nconstraint forall(j in COLS)(\n               sum(i in ROWS)(fill[i,j]) == colsum[j]\n           );           \n\n\nsolve :: int_search([ fill[i,j] | i in ROWS, j in COLS], \n      \t\t  input_order, indomain_min, complete)\n      satisfy;\n\noutput [ code[fix(board[i,j])] ++ \n\t\t if j == width then \" \" ++ show(rowsum[i]) ++ \"\\n\"\n\t\t else \"\" endif\n\t   | i in ROWS, j in COLS ]  ++\n\t   [ show(colsum[j]) | j in COLS ] ++ [\"\\n\"];\n\t   \n"}}, "schur_beginner": {"node_ids": ["ecb368d1-bdc9-4943-abd1-98993d615941"], "metadata": {"model_name": "schur", "source_code": "%% schurs numbers\n%%\n%% determine if n balls labelled 1..n\n%% can be placed in c boxes with no box containing a triple {x,y,z} where x+y=z\n \n\nint: n; %% number of balls\nint: c; %% number of boxes\n\narray[1..n] of var 1..c: box;\n\nconstraint forall(i in 1..n-1, j in i+1 .. n - i)(\n\t   \t    box[i] != box[j] \\/ \n\t\t    box[i] != box[i+j] \\/ \n\t\t    box[j] != box[i+j]);\n\nsolve satisfy;\n\noutput [\"n = \", show(n), \";\\nc = \", show(c), \";\\nbox = \",show(box),\";\\n\"];\n"}}, "setselect_beginner": {"node_ids": ["fd722d73-a7df-40ae-acad-097c1f2b071b"], "metadata": {"model_name": "setselect", "source_code": "Model 1 :\n\n\n% setselect\nint: n; % number of elements\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 2 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\nconstraint card(x) = u;\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 3 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 1..n: x;\n%constraint forall(i in 1..u-1)(x[i] < x[i+1]);\nconstraint forall(i,j in 1..u where i < j)(x[i] != x[j]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 4 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality bound of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 0..n: x;\nconstraint forall(i in 1..u-1)(x[i] >= (x[i] != 0) + x[i+1]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n"}}, "shipping_beginner": {"node_ids": ["637dda26-d408-49a9-87c8-266900b61ac3"], "metadata": {"model_name": "shipping", "source_code": "int: W; % number of Warehousse\nset of int: WARE = 1..W;\nint: F; % number of Factories\nset of int: FACT = 1..F;\n\narray[WARE] of int: demand;\narray[FACT] of int: production;\n\narray[FACT,WARE] of int: cost;\n\narray[FACT,WARE] of var int: ship;\n\n%int: m = max(demand);\n%array[FACT,WARE] of var 0..m: ship;\nconstraint forall(f in FACT, w in WARE)(ship[f,w] >= 0);\n\nconstraint forall(w in WARE)\n                 (sum(f in FACT)(ship[f,w]) >= demand[w]);\n\nconstraint forall(f in FACT)\n                 (sum(w in WARE)(ship[f,w]) <= production[f]);\n\nsolve minimize sum(f in FACT, w in WARE)\n                  (cost[f,w]*ship[f,w]);\n\n\noutput [ show_int(2,ship[f,w]) ++\n         if w == W then \"\\n\" else \" \" endif\n       | f in FACT, w in WARE ];"}}, "simple-prod-planning_beginner": {"node_ids": ["d6cd7afd-542d-432f-b437-8df56bb85bf7"], "metadata": {"model_name": "simple-prod-planning", "source_code": "% Number of different products\nint: nproducts; \nset of int: Products = 1..nproducts;  \n\n%profit per unit for each product\narray[Products] of int: profit;\narray[Products] of string: pname; \n\n%Number of resources\nint: nresources; \nset of int: Resources = 1..nresources; \n\n%amount of each resource available\narray[Resources] of int: capacity; \narray[Resources] of string: rname;\n\n%units of each resource required to produce 1 unit of product\narray[Products, Resources] of int: consumption; \nconstraint assert(forall (r in Resources, p in Products) \n           (consumption[p,r] >= 0), \"Error: negative consumption\");\n\n% bound on number of Products\nint: mproducts = max (p in Products) \n                     (min (r in Resources where consumption[p,r] > 0) \n                          (capacity[r] div consumption[p,r]));\n\n% Variables: how much should we make of each product\narray[Products] of var 0..mproducts: produce;\narray[Resources] of var 0..max(capacity): used;\n\n% Production cannot use more than the available Resources:\nconstraint forall (r in Resources) (     \n      used[r] = sum (p in Products)(consumption[p, r] * produce[p]) \n      /\\ used[r] <= capacity[r]\n);    \n\n% Maximize profit\nsolve maximize sum (p in Products) (profit[p]*produce[p]);\n\noutput [ show(pname[p]) ++ \" = \" ++ show(produce[p]) ++ \";\\n\" |\n         p in Products ] ++\n       [ show(rname[r]) ++ \" = \" ++ show(used[r]) ++ \";\\n\" |\n         r in Resources ];"}}, "sonet_problem_beginner": {"node_ids": ["c87d1b40-6f8d-434a-a974-cfa2650d8420"], "metadata": {"model_name": "sonet_problem", "source_code": "% The SONET problem is a network design problem: set up a network between\n% n nodes, where only certain nodes require a connection.\n% Nodes are connected by putting them on a ring, where all nodes\n% on a ring can communicate. Putting a node on a ring requires a so-called\n% ADM, and each ring has a capacity of nodes, i.e. ADMs. There is a certain\n% amount of rings, r, that is available. The objective is to set up a network\n% by using a minimal amount of ADMs.\n%\n%\n% About the problem model\n%\n% The problem model has the amount of rings ('r'), amount of nodes('n'),\n% the 'demand' (which nodes require communication) and node-capacity of each\n% ring ('capacity_nodes') as parameters.\n% The assignement of nodes to rings is modelled by a 2-dimensional matrix 'rings',\n% indexed by the amnount of rings and nodes. The matrix-domain is boolean:\n% If the node in column j is assigned to the ring in row i, then rings[i,j] = 1\n% and 0 otherwise. So all the '1's in the matrix 'rings' stand for an ADM.\n% Hence the objective is to minimise the sum over all columns and rows of matrix\n% 'rings'.\n% \"\"\"\n\nint: r;  % upper bound for amount of rings\nint: n;  % amount of clients\n\n\n% original comment: \n% we have double entries here because of the symmetric structure!\narray[1..n, 1..n] of 0..1: demand;\narray[1..r] of 1..n: capacity_nodes;\n\narray[1..r, 1..n] of var 0..1: rings;\nvar int: z =  sum(ring in 1..r, client in 1..n) (rings[ring, client]);\n\nsolve minimize z;\n% solve satisfy;\n\n\nconstraint\n%   z <= 7 % for solve satisfy\n%   /\\\n\n   % original comment:\n   % if there is a demand between 2 nodes, then there has to exist \n   % a ring, on which they are both installed\n   forall(client1,client2 in 1..n where client1 < client2) (\n      (demand[client1,client2] = 1) ->\n           exists(ring in 1..r) (\n                 rings[ring,client1] + rings[ring, client2] >= 2\n           )\n   )   \n   /\\\n   % original comment:\n   % capacity of each ring must not be exceeded     \n   forall(ring in 1..r) (\n        sum(client in 1..n) (\n              rings[ring, client]\n              ) <= capacity_nodes[ring] \n   )\n;\n\n\n%\n% data\n% (sonet_problem1nu.param)\n%\nr = 4;\nn = 5;\n\ndemand =\narray2d(1..n, 1..n,\n        [0,1,0,1,0,\n         1,0,1,0,0,\n         0,1,0,0,1,\n         1,0,0,0,0,\n         0,0,1,0,0])\n;\n\ncapacity_nodes = [3,2,2,1];\n\n\noutput \n[\n  \"z: \", show(z)\n] ++\n[\n  if client = 1 then \"\\n\" else \" \" endif ++\n    show(rings[ring, client])\n  | ring in 1..r, client in 1..n\n] ++ [\"\\n\"];\n"}}, "square_pack_beginner": {"node_ids": ["dfdd2674-dde3-4556-9553-e3509dd84755"], "metadata": {"model_name": "square_pack", "source_code": "int: n; % number of squares\nset of int: SQUARE = 1..n;\nint: maxl = sum(i in SQUARE)(i);\nint: mina = sum(i in SQUARE)(i*i);\n\nvar n..maxl: height;\nvar n..maxl: width;\nvar mina .. n*maxl: area = height * width;\n\narray[SQUARE] of var 0..maxl: x;\narray[SQUARE] of var 0..maxl: y;\n\n% squares fit in the rectangle\nconstraint forall(s in SQUARE)(x[s] + s <= width);\nconstraint forall(s in SQUARE)(y[s] + s <= height);\n\n% non overlap\nconstraint forall(s1, s2 in SQUARE where s1 < s2)\n                 (x[s1] + s1 <= x[s2] \\/\n                  x[s2] + s2 <= x[s1] \\/  \n                  y[s1] + s1 <= y[s2] \\/ \n                  y[s2] + s2 <= y[s1]);\narray[SQUARE] of int: size = [ i | i in SQUARE ];\n\n% non overlap with global diffn\ninclude \"diffn.mzn\";\n%constraint diffn(x,y,size,size);\n\n% redundant cumulative constraints\ninclude \"cumulative.mzn\";\n%constraint cumulative(x,size,size,height);\n%constraint cumulative(y,size,size,width);\n\n% variables ordered in reverse size x[n], y[n], x[n-1], y[n-1], ..., x[1], y[1]\n%array[1..2*n] of var 0..maxl: vs = [ if i mod 2 = 0 then x[n+1 - i div 2] \n%                                     else y[n+1 - i div 2] endif | i in 2..2*n+1 ];\n\nsolve :: seq_search([\n         int_search([area,height,width], input_order, indomain_min, complete) \n         %,int_search(vs, input_order, indomain_min, complete)\n         ])\n      minimize area;\n\noutput [\"area = \",show(area), \"\\n\"] ++\n[\"height = \",show(height), \"\\n\"] ++\n[\"width = \",show(width), \"\\n\"] ++\n[\"x = \", show(x), \"\\n\"] ++\n[\"y = \", show(y), \"\\n\"];\n"}}, "stableroommates_beginner": {"node_ids": ["d776130f-a388-45bf-bd8f-9bf256b783e8"], "metadata": {"model_name": "stableroommates", "source_code": "Model 1 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\nset of int: AGENT0 = 0..n;    % zero indicates no agent\narray[AGENT,1..n-1] of AGENT0: pref; % preference order for each agent\n     % the preference order is padded by zeros\narray[AGENT] of int: npref = [ sum(j in 1..n-1)(bool2int(pref[i,j] > 0))\n                             | i in AGENT ];\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..n-1)\n                               (pref[i,j] != i /\\ \n                                (pref[i,j] = 0 <-> j > npref[i])) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref[i,j1] != pref[i,j2]),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n%% ranking information: rank = 0 means not ranked\narray[AGENT,AGENT] of 0..n-1: rank = \n     array2d(AGENT,AGENT, [ max([bool2int(pref[i1,j] = i2) * j | j in 1..n-1])\n                          | i1, i2 in AGENT ]);\n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] > rank[i,j] -> a[j] < rank[j,i]\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] = rank[i,j] -> a[j] = rank[j,i]\n                 );\n\nsolve satisfy;\n\noutput  [ if i < fix(pref[i,a[i]]) then \"(\" ++ show(i) ++ \",\" ++ show(pref[i,a[i]]) ++ \")\\n\"\n          else \"\" endif\n        | i in AGENT ]\n       ++ [show(rank),\"\\n\"] \n %      ++ [show(npref),\"\\n\"] \n %      ++ [show(a),\"\\n\"]\n        ;\n       \n\n\nModel 2 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\n\narray[AGENT] of int: npref; % number of preferences of each agent\narray[AGENT] of int: cum_npref = [ sum(j in 1..i-1)(npref[j]) | i in AGENT];\narray[1..sum(npref)] of int: preferences;  % all preferences in one list\n\nfunction AGENT: pref(AGENT: i, 1..n-1: j) = \n         assert(j in 1..npref[i], \"Called pref(\" ++ show(i) ++ \",\" ++ show(j) ++ \") too large preference\\n\",\n         preferences[cum_npref[i] + j]);\n\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..npref[i])\n                               (pref(i,j) != i) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref(i,j1) != pref(i,j2)),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n\n\n%% ranking information: rank = 0 means not ranked but shoulnt occur!\nfunction 0..n-1: rank(AGENT: i1, AGENT: i2) = \n                 max([bool2int(pref(i1,j) = i2) * j | j in 1..npref[i1]]); \n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] > rank(i,j) -> a[j] < rank(j,i)\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] = rank(i,j) -> a[j] = rank(j,i)\n                 );\n\nsolve satisfy;\n\n   output  [ if fix(a[i]) < npref[i] /\\ i < pref(i,fix(a[i]))\n             then \"(\" ++ show(i) ++ \",\" ++ show(pref(i,fix(a[i]))) ++ \")\\n\"\n             else \"\" endif\n           | i in AGENT ]\n %      ++ [show(rank),\"\\n\"] \n       ++\n       [show(npref),\"\\n\"] \n       ++ [show(a),\"\\n\"]\n        ;\n       \n\n"}}, "steiner_beginner": {"node_ids": ["b6c0db13-a248-4c8c-a1e5-3cbabe5692a6"], "metadata": {"model_name": "steiner", "source_code": "% The ternary Steiner problem of order n is to find n(n-1)/6 sets of elements in {1,2,...,n}\n% such that each set contains three elements and any two sets have at most one element in common.\n% For example, the following shows a solution for size n=7:\n%\n%      {1,2,3}, {1,4,5}, {1,6,7}, {2,4,6}, {2,5,7}, {3,4,7}, {3,5,6}\n\ninclude \"globals.mzn\";\n\nint: N = 7; \nint: NB = N *(N-1) div 6;\narray[1..NB] of var set of 1..N: Sets;\n\n% solve satisfy;\nsolve::set_search(Sets, first_fail, indomain_min, complete) satisfy;\n\n\n\nconstraint\n   forall(i in index_set(Sets)) (\n      card(Sets[i]) = 3\n   )\n   /\\ \n   forall(i,j in index_set(Sets) where i < j) (\n      card( Sets[i] intersect Sets[j]) <= 1\n   )\n   /\\ % symmetry breaking\n   decreasing(Sets)\n\n;\n\noutput [\n       \"N: \", show(N), \" NB: \", show(NB), \"\\n\",\n       \"Sets: \", show(Sets)\n];\n\n"}}, "stoch_fjsp_beginner": {"node_ids": ["624ab5e1-1ed9-43bc-b0c4-3ab00a9a2221"], "metadata": {"model_name": "stoch_fjsp", "source_code": "% Stochastic General Assignment Problem \n% First stage:\n%    assign task to machines \n% Second stage:\n%    based on observed processign times, schedule taks on respective machines\n% Objective:\n%    minimise expected makespan\n\ninclude \"globals.mzn\";\n\n% Parameters\n\nint: no_mach;   % Number of machines\nint: no_jobs;   % Number of jobs\nint: no_task;   % Number of total tasks\nint: no_optt;   % Number of total optional tasks\n\nset of int: Mach  = 1..no_mach;\nset of int: Jobs  = 1..no_jobs;\nset of int: Tasks = 1..no_task;\nset of int: OptTs = 1..no_optt;\n\narray [Jobs] of set of int: tasks;\narray [Tasks] of set of int: optts;\n\narray [OptTs] of int: optt_mach;\narray [SCENARIOS1,OptTs] of int: optt_dur;\n\n\narray [Jobs] of int: last_task = [ max(tasks[j]) | j in Jobs ];\n%---------implications for multi scenarion solving ---------------\nint: nbScenarios;\nset of int: SCENARIOS1 = 1..nbScenarios;\nint: first_scen;\nint: last_scen;\nset of int: SCENARIOS = first_scen..last_scen;\narray[SCENARIOS1] of int: weights;\n\n%-------end of multi scenario addons ----------------\narray [Tasks] of int: task_job = \n    [ min(j in Jobs where t in tasks[j])(j) | t in Tasks ];\narray [SCENARIOS,Tasks] of int: task_mins =\n    array2d(SCENARIOS,Tasks,[ sum(k in tasks[task_job[t]])(if k < t then task_mind[s,k] else 0 endif)\n    |   s in SCENARIOS, t in Tasks ]);\narray [SCENARIOS,Tasks] of int: task_maxs =\n    array2d(SCENARIOS,Tasks,[ t_max[s] -\n        sum(k in tasks[task_job[t]])(if k < t then 0 else task_mind[s,k] endif)\n    |   s in SCENARIOS,  t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_mind =\n    array2d(SCENARIOS,Tasks,[ min(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS,t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_maxd = \n    array2d(SCENARIOS,Tasks,[ max(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS, t in Tasks ]);\n\n    % Additional deirved parameters for optional tasks\n    %\narray [OptTs] of int: optt_task =\n    [ min(t in Tasks where o in optts[t])(t) | o in OptTs ];\n\narray[SCENARIOS1] of int: min_dur = [ min([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\narray[SCENARIOS1] of int: max_dur = [ max([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\nset of int: Durs = min(min_dur)..max(max_dur);\n\n    % Parameters related to the planning horizon\n    %\narray[SCENARIOS1] of int: t_max = [sum(t in Tasks)(max(o in optts[t])(optt_dur[s,o])) | s in SCENARIOS1];\n\nset of int: Times = 0..max(t_max);\n\n%-----------------------------------------------------------------------------%\n% Variables\n\n    % Start time variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Times: start =\n    array2d(SCENARIOS,Tasks,[ let { var task_mins[s,t]..task_maxs[s,t]: k } in k | s in SCENARIOS, t in Tasks ]);\n\n    % Duration variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Durs: dur =\n    array2d(SCENARIOS,Tasks,[ if task_mind[s,t] = task_maxd[s,t] then task_mind[s,t] else\n        let { var task_mind[s,t]..task_maxd[s,t]: d } in d endif\n    |   s in SCENARIOS,t in Tasks ]);\n\n    % Variables whether an optional task is executed\n    %\narray [OptTs] of var bool: b;\n\narray[SCENARIOS] of var Times: de_objective;\n\nset of int: StochTimes = 0..sum(t_max);\nvar StochTimes: objective;\n%-----------------------------------------------------------------------------%\n% Constraints\n\n    % Precedence relations\n    %\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs, i in tasks[j] where i < last_task[j])(\n            start[s,i] + dur[s,i] <= start[s,i + 1]\n        )    \n    );\n\n    % Duration constraints\n    %\nconstraint\n    forall(o in OptTs,s in SCENARIOS)(\n        let { int: t = optt_task[o] } in (\n            if card(optts[t]) = 1 then\n                b[o] = true\n            else\n                b[o] -> dur[s,t] = optt_dur[s,o]\n            endif\n        )\n    );\n\n    % Optional tasks' constraints\n    %\nconstraint\n    forall(t in Tasks where card(optts[t]) > 1)(\n        ( sum(o in optts[t])(bool2int(b[o])) <= 1     )\n    /\\  ( exists(o in optts[t])(b[o])                 )\n    );\n\nconstraint\n    forall(t in Tasks where card(optts[t]) = 2)(\n        let {\n            int: o1 = min(optts[t]),\n            int: o2 = max(optts[t])\n        } in ( b[o1] <-> not(b[o2]) )\n    );\n\n    % Resource constraints\n    %\nconstraint\n    forall(m in Mach,s in SCENARIOS)(\n        let {\n            set of int: MTasks = { o | o in OptTs where optt_mach[o] = m }\n        } in (\n            cumulative(\n                [ start[s,optt_task[o]] | o in MTasks ],\n                [ optt_dur[s,o]         | o in MTasks ],\n                [ bool2int(b[o])      | o in MTasks ],\n                1\n            )\n        )\n    );\n\n% Objective constraint\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs)(start[s,last_task[j]] + dur[s,last_task[j]] <= de_objective[s])\n    );\nconstraint \n        objective = sum(s in SCENARIOS)(weights[s]*de_objective[s]);\n%-----------------------------------------------------------------------------%\n% Solve item\n\nsolve \n    :: search\n    minimize objective;\n\n%------------------------------------------------------------------------------%\n% Searches\n\nann: s_mindur   = int_search([dur[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_minstart = int_search([start[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_bool     = bool_search(b, input_order, indomain_max, complete);\nann: s_obj      = int_search(de_objective, input_order, indomain_min, complete);\n\nann: search = seq_search([s_mindur, s_bool, s_minstart, s_obj]);\n\n%-----------------------------------------------------------------------------%\n% Output\n\noutput \n[   \"objective = \", show(de_objective), \";\\n\",\n    \"stoch obj = \", show(objective), \";\\n\",\n    \"start = \", show(start), \";\\n\",\n    \"dur = \", show(dur), \";\\n\",\n    \"b = \", show(b), \";\\n\",\n];\n"}}, "submultisetsum_beginner": {"node_ids": ["171e4a5d-d5ef-47e5-bec1-c0bcde15aa3c"], "metadata": {"model_name": "submultisetsum", "source_code": "% subsetsum problem\narray[int] of int: number;\nint: target;\n\nset of int: NUMBER = index_set(number);\nvar set of NUMBER: selected;\n\nconstraint sum(i in selected)\n              (number[i]) = target;\nsolve satisfy;\n\noutput [show(selected)];"}}, "table_seating_beginner": {"node_ids": ["74854336-1114-4f34-847e-8adde1c9d74d"], "metadata": {"model_name": "table_seating", "source_code": "Model 1 :\n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n          forall(t in TABLE)(not ({p1,p2} subset table[t]));\n\nconstraint forall(t in TABLE)(card(table[t]) <= S);\n\nconstraint forall(p in PERSON)(exists(t in TABLE)(p in table[t]));\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))\n                  ( let { var TABLE: tn1 = sum(t in TABLE)(t * bool2int(couples[c,1] in table[t]));\n                          var TABLE: tn2 = sum(t in TABLE)(t * bool2int(couples[c,2] in table[t]));\n                    } in  tn1 + tn2);\n\n\n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n\n\n\nModel 2 : \n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\narray[PERSON] of var TABLE: seat;\n\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n                        seat[p1] != seat[p2];\n\nconstraint global_cardinality_low_up(seat, [t|t in TABLE], [0|t in TABLE], [S|t in TABLE]);\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))(seat[couples[c,1]] + seat[couples[c,2]]);\n\nconstraint forall(t in TABLE, p in PERSON)(p in table[t] <-> seat[p] = t);    \n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n"}}, "teamselect_beginner": {"node_ids": ["7dce60e5-ca00-443f-b4ac-11bc45ba1e2e"], "metadata": {"model_name": "teamselect", "source_code": "Model 1 :\n\n\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\narray[CAPTAIN] of var set of PLAYER: team = [Xavier,Yuri,Zena];\n\nset of int: CAPTAIN = 1..3;\narray[CAPTAIN,PLAYER] of int: value;\n \nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |]; \n\nconstraint card(Xavier intersect GOALIE) >= 1;\nconstraint card(Xavier intersect DEFENCE) >= 2;\nconstraint card(Xavier intersect OFFENCE) >= 2;\nconstraint card(Xavier) = 6;\n\n\nconstraint card(Yuri intersect GOALIE) >= 1;\nconstraint card(Yuri intersect DEFENCE) >= 2;\nconstraint card(Yuri intersect OFFENCE) >= 2;\nconstraint card(Yuri) = 6;\n\nconstraint card(Zena intersect GOALIE) >= 1;\nconstraint card(Zena intersect DEFENCE) >= 2;\nconstraint card(Zena intersect OFFENCE) >= 2;\nconstraint card(Zena) = 6;\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nsolve maximize obj;\n\nvar int: obj = sum(c in CAPTAIN)(sum(p in team[c])(value[c,p]));\n\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n\n\nModel 2 :\n\n\n% team select problem\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\nset of int: CAPTAIN = 1..3;\nint: xavier = 1; int: yuri = 2; int: zena = 3;\narray[CAPTAIN,PLAYER] of int: value;\nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |];\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\npredicate correct_team(var set of PLAYER: team) = \n          card(team) = 6 /\\ \n          card(team intersect GOALIE) >= 1 /\\\n          card(team intersect DEFENCE) >= 2 /\\\n          card(team intersect OFFENCE) >= 2;\n\nconstraint correct_team(Xavier) /\\ correct_team(Yuri) /\\ correct_team(Zena);\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nvar int: obj = sum(p in Xavier)(value[xavier,p]) +\n               sum(p in Yuri)(value[yuri,p]) +\n               sum(p in Zena)(value[zena,p]);\n\nsolve maximize obj;\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n"}}, "template_design_beginner": {"node_ids": ["45493d6e-cfc3-47e2-b2a8-b2c5ba0376ec"], "metadata": {"model_name": "template_design", "source_code": "% Template design\ninclude \"globals.mzn\";\n\nint: S;   \t\t% Number of slots per template.\nint: t;   \t\t% Number of templates.\nint: n;   \t\t% Number of variations.\narray[1..n] of int: d; \t% How much of each variation we must print?\n\n% Lower and upper bounds for the total production.\n%\nint: llower = ceil(sum(i in 1..n)(int2float(d[i]))/int2float(S));\nint: lupper = 2*llower; % If t>1, this should be the optimal Production_{t-1}-1.\n\n% # Slots allocated to variation i in template j\narray[1..n,1..t] of var 0..S: p;\n\n% # Pressings of template j.\narray[1..t] of var 1..lupper: R;\n\n% Sum of all Rj.\nvar llower..lupper: Production;\n\n% Production x S - sum(d[i])\nvar 0..lupper-llower: Surplus;\n\n% First, set up Production to be the sum of the Rj\nconstraint\n\tProduction = sum(i in 1..t)(R[i]);\n\n% the limits on production\nconstraint\n\tProduction >= llower /\\ Production <= lupper;\n\n% The number of slots occupied in each template is S.\nconstraint\n\tforall(j in 1..t)\n\t\t (sum(i in 1..n)(p[i,j]) = S);\n\n% Enough of each variation is printed.\nconstraint\n\tforall(i in 1..n)\n\t\t (sum(j in 1..t)(p[i,j]*R[j]) >= d[i]);\n\n% Symmetry constraints.\n% Variations with the same demand are symmetric.\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] == d[i+1] then\n\t\t\tlex_lesseq([p[i,  j] | j in 1..t],\n\t\t\t\t[p[i+1,j] | j in 1..t])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% pseudo symmetry\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] < d[i+1] then\n\t\t       sum (j in 1..t) (p[i,j]*R[j])\n\t\t     <= sum (j in 1..t) (p[i+1,j]*R[j])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% implied constraints on the surplus\n\n% These are presented in the paper as necessary to get good\n% performance for this model, but I think bounds consistency on the\n% sum(R[i]) constraint would produce the same amount of propagation\n\n% Set up surplus, which is bounded as production is bounded.\nconstraint\n\tSurplus = Production*S - sum(i in 1..n)(d[i]);\n\n% The surplus of each variation is also limited by the surplus.\nconstraint\n\tforall(k in 1..n)\n\t\t (sum(j in 1..t)(p[k,j]*R[j]-d[k]) <= Surplus);\n\n% The surplus of the first k variations is limited by the surplus.\nconstraint\n\tforall(k in 2..n-1)\n\t\t (sum(j in 1..t, m in 1..k)( p[m,j]*R[j]-d[m] ) <= Surplus);\n\n% Implied constraints on the run length.\nconstraint\n\tif t=2 then (\n\t\tR[1] <= Production div 2\n\t/\\\tR[2] >= Production div 2\n\t) else true endif;\n\nconstraint\n\tif t=3 then (\n\t\tR[1] <= Production div 3\n\t/\\\tR[2] <= Production div 2\n\t/\\\tR[3] >= Production div 3\n\t) else true endif;\n\n% Minimize the production.\nsolve :: int_search(array1d(1..n*t,p) ++ R, input_order, indomain_min, complete)\n    minimize Production;\n\noutput [\n    if v = 1 then \"template #\" ++ show(i) ++ \": [\" else \"\" endif ++\n    show(p[v, i]) ++\n    if v = n then \"], pressings: \" ++ show(R[i]) ++ \"\\n\" else \", \" endif\n\t| i in 1..t, v in 1..n]\n    ++ [\"Total pressings: \", show(Production), \"\\n%\\n\"];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%\n"}}, "toomany_beginner": {"node_ids": ["26b1fe9b-176c-4554-a768-b1d1d6bdbc96"], "metadata": {"model_name": "toomany", "source_code": "%% TooMany.mzn (too many solutions)\nint: n; % number of machines\nset of int: MACHINE = 1..n;\nint: k; % production per day\nint: red = 1; int: white = 2; int: black = 3; int: blue = 4;\nset of int: COLOR = 1..4;\narray[COLOR] of int: l; % lower bound on production\narray[COLOR] of int: u; % upper bound on production\n\narray[MACHINE,COLOR] of var 0..k div 2: produce;\n\nconstraint forall(m in MACHINE)\n                 (sum(c in COLOR)(produce[m,c]) <= k);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) >= l[c]);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) <= u[c]);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] > 0 /\\ produce[m,black] > 0 -> produce[m,blue] = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,blue] <= produce[m,red]);\nconstraint forall(m in MACHINE)\n                 (produce[m,red] mod 4 = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] mod 3 = 0);\n\n\nsolve maximize sum(m in MACHINE, c in COLOR)(produce[m,c]);\n\noutput [ show_int(3,produce[m,c]) ++\n         if c = 4 then \"\\n\" else \" \" endif\n       | m in MACHINE, c in COLOR ];\n\nn = 4;\nk = 11;\nl = [8,7,10,6];\nu = [14,16,12,20];\n\n"}}, "traffic_lights_table_beginner": {"node_ids": ["0c8aefc6-af68-4850-872c-fade026076a2"], "metadata": {"model_name": "traffic_lights_table", "source_code": "Model 1 :\n\n%Traffic lights problem in MiniZinc.\n% Specification:\n% Consider a four way traffic junction with eight traffic lights. Four of\n% the traffic lights are for the vehicles and can be represented by the\n% variables V1 to V4 with domains\n% {r,ry,g,y} (for red, red-yellow, green and yellow).\n%  The other four traffic lights are for the pedestrians and can be\n%  represented by the variables P1 to P4 with domains {r,g}.\n%\n% The constraints on these variables can be modelled by quaternary\n% constraints on\n% (Vi, Pi, Vj, Pj ) for 1<=i<=4, j=(1+i)mod 4 which allow just the tuples\n% {(r,r,g,g), (ry,r,y,r), (g,g,r,r), (y,r,ry,r)}.\n%\n% It would be interesting to consider other types of junction (e.g. five roads\n% intersecting) as well as modelling the evolution over time of the\n% traffic light sequence.\n\ninclude \"globals.mzn\";\n\nint: n = 4;\nint: r  = 1; % red\nint: ry = 2; % red-yellow\nint: g  = 3; % green\nint: y  = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V;\narray[1..n] of var Pedestrians: P;\n\n\nsolve satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   table([V[i], P[i], V[j], P[j]], allowed)\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\n% output [\n%  \"V: \", show(V), \"\\nP: \", show(P), \"\\n\"\n% ];\noutput [\n show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: n = 4;\nint: r = 1; % red\nint: ry = 2; % red-yellow\nint: g = 3; % green\nint: y = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V; % ;\narray[1..n] of var Pedestrians: P; %;\n\npredicate cp1d(array[int] of var int: x, array[int] of var int: y) =\n  assert(index_set(x) = index_set(y),\n           \"cp1d: x and y have different sizes\",\n     forall(i in index_set(x)) ( x[i] = y[i] ))\n; \n\n% solve satisfy;\nsolve :: int_search(V ++ P, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   exists(a in 1..4) (\n      cp1d([V[i], P[i], V[j], P[j]], [allowed[a,k] | k in 1..4])\n   )\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\noutput [\n  show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n"}}, "TTPPV_beginner": {"node_ids": ["eae09164-57e4-4de5-8ec0-114d3db83622"], "metadata": {"model_name": "TTPPV", "source_code": "% Traveling Tournament Problem with Predefined Venues\n%\n% Compact single round robin schedule minimizing total travel distance\n% The venue of each game has already been decided\n% Specialized for CIRC instances (circular distances)\n\ninclude \"globals.mzn\";\n\nint: nbTeams;\nint: nbRounds = nbTeams-1;\n\nset of int: Teams = 1..nbTeams;\nset of int: Rounds = 1..nbRounds;\nset of int: Travels = 1..nbRounds+1;\n\n% predefined venue: pv[i][j] = 1 iff i is playing at home against j\narray[Teams,Teams] of 1..2: pv; \n\n% circular distances: for i>=j, distance[i][j]=min{i-j,j-i+nbTeams}\narray[Teams,Teams] of int: distance = \n  array2d(Teams,Teams,[ if i>=j then (if i-j < j-i+nbTeams then i-j else j-i+nbTeams endif) \n                                else (if j-i < i-j+nbTeams then j-i else i-j+nbTeams endif) \n                                endif | i,j in Teams]);\n\n% output related\nint: digs = ceil(log(10.0,int2float(nbTeams)));\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% decision variables: in round k, team i plays against team opponent[i,k]\narray[Teams,Rounds] of var Teams: opponent;\n\n% auxiliary variables: venue[i,k] = 1 iff team i plays at home in round k\narray[Teams,Rounds] of var 1..2: venue;\nconstraint forall (i in Teams, k in Rounds) (venue[i,k] = pv[i,opponent[i,k]]);\n\n% auxiliary variables: travel[i,k] is the distance travelled by team i to go play in round k (includes travelling back home after last round)\narray[Teams,Travels] of var 0..(nbTeams div 2): travel;\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n% a team cannot play against itself\nconstraint forall (i in Teams, k in Rounds) (opponent[i,k] != i);\n\n% in round k, i plays j means j plays i\nconstraint forall (i in Teams, k in Rounds) (opponent[opponent[i,k],k] = i);\n\n% for each team i, all opponents are different\nconstraint forall (i in Teams) (alldifferent([opponent[i,k] | k in Rounds]));\n\n% for each round k, all opponents are different (implied constraint)\nconstraint forall (k in Rounds) (alldifferent([opponent[i,k] | i in Teams]));\n\n% for each team i, there can be at most 3 consecutive home games and at most 3 consecutive away games\nint: nbStates = 7;\nset of int: States = 1..nbStates;\narray[States,1..2] of int: delta = \n  [| 2, 5\n   | 3, 5\n   | 4, 5\n   | 0, 5\n   | 2, 6\n   | 2, 7\n   | 2, 0 |];\nconstraint forall (i in Teams) (regular( [venue[i,k] | k in Rounds], nbStates, 2, delta, 1, States));\n\n% symmetry breaking: distances are symmetric so reversing the rounds yields a schedule of same cost\nconstraint (opponent[1,1] < opponent[1,nbRounds]);\n\n% define travel variables wrt venues of current- and next-round games\nconstraint forall (i in Teams) (\n\t(venue[i,1]=1 -> travel[i,1] = 0) /\\\n\t(venue[i,1]=2 -> travel[i,1] = distance[i,opponent[i,1]]) );\nconstraint forall (i in Teams, k in 1..nbRounds-1) (\n\t((venue[i,k]=1 /\\ venue[i,k+1]=1) -> travel[i,k+1] = 0) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=1) -> travel[i,k+1] = distance[opponent[i,k],i]) /\\\n\t((venue[i,k]=1 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[i,opponent[i,k+1]]) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[opponent[i,k],opponent[i,k+1]]) );\nconstraint forall (i in Teams) (\n\t(venue[i,nbRounds]=1 -> travel[i,nbRounds+1] = 0) /\\\n\t(venue[i,nbRounds]=2 -> travel[i,nbRounds+1] = distance[opponent[i,nbRounds],i]) );\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nvar int: totalTravel;\nconstraint totalTravel = sum (i in Teams, k in Travels) (travel[i,k]);\nsolve minimize totalTravel;\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\noutput [\"SCHEDULE\\n\"] ++ \n       [ if fix(venue[i,k]) == 1 then \" \" else \"@\" endif ++\n\t show_int(digs,opponent[i,k]) ++ \" \" ++ \n         if k == nbRounds /\\ i != nbTeams then \"\\n\" else \"\" endif\n         | i in Teams, k in Rounds ] ++ [\"\\n\"] ++\n       [\"total travel = \"] ++ [show(totalTravel)] ++ [\"\\n\"];\n"}}, "vessel-loading_beginner": {"node_ids": ["e3460b1d-b972-4260-b642-545a44b38645"], "metadata": {"model_name": "vessel-loading", "source_code": "% Vessel Loading\n\nint: deck_width; % width of deck\nint: deck_length; % height of deck\nint: n_containers; % number of containers\nint: n_classes; % number of container classes\n\narray[int] of int: width;\n% width[c] = width of container c\narray[int] of int: length;\n% length[c] = length of container c\narray[int] of int: class;\n% class[c] = class of container c\narray[int, int] of int: separation;\n% separation[a, b] = the minimum allowed separation between\n%                    containers of classes a and b\n\nset of int: Containers = 1..n_containers;\n\narray[Containers] of var 0..deck_width: Left;\n% Left[c] = leftmost point of container c\narray[Containers] of var 0..deck_width: Right;\n% Right[c] = rightmost point of container c\narray[Containers] of var 0..deck_length: Bottom;\n% Bottom[c] = bottommost point of container c\narray[Containers] of var 0..deck_length: Top;\n% Top[c] = topmost point of container c\n\narray[Containers] of var 1..2: orientation;\n% orientation[c] = 2 if container c is turned 90 degrees, else 1.\n\nconstraint\n  forall (c in Containers) (\n    let {\n      array[1..2] of int: ElemWidth = [width[c], length[c]];\n      array[1..2] of int: ElemLength = [length[c], width[c]]\n    }\n    in \n      Right[c] = Left[c] + ElemWidth[orientation[c]] /\\\n      Top[c] = Bottom[c] + ElemLength[orientation[c]]\n  )\n;\n\nconstraint\n  forall(c, k in Containers where c < k) (\n    Left[c] >= Right[k] + separation[class[c], class[k]] \\/\n    Right[c] + separation[class[c], class[k]] <= Left[k] \\/\n    Bottom[c] >= Top[k] + separation[class[c], class[k]] \\/\n    Top[c] + separation[class[c], class[k]] <= Bottom[k]\n  )\n;\n\n% Excessive (pretty) output\noutput [\"\u250c\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2510\\n\"] ++\n       [if x == 0 then \"\u2502\" else \"\" endif ++\n        let {\n          bool: l = exists([fix(Left[c])   = x | c in Containers]);\n          bool: r = exists([fix(Right[c])  = x | c in Containers]);\n          bool: b = exists([fix(Bottom[c]) = y | c in Containers]);\n          bool: t = exists([fix(Top[c])    = y | c in Containers])\n        } in\n          if     l /\\ r /\\ b /\\ t then \"\u253c\"\n          elseif l /\\ r /\\ b      then \"\u252c\"\n          elseif l /\\ r /\\      t then \"\u2534\"\n          elseif l /\\      b /\\ t then \"\u251c\"\n          elseif      r /\\ b /\\ t then \"\u2524\"\n          elseif l /\\      b      then \"\u250c\"\n          elseif l /\\           t then \"\u2514\"\n          elseif      r /\\ b      then \"\u2510\"\n          elseif      r /\\      t then \"\u2518\"\n          elseif l \\/ r           then \"\u2502\"\n          elseif           b \\/ t then \"\u2500\" \n          else \" \" endif ++\n        if x == deck_width then \"\u2502\\n\" else \"\" endif\n        | y in 0..deck_length, x in 0..deck_width] ++\n        [\"\u2514\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2518\"];\n"}}, "warehouses_beginner": {"node_ids": ["75c261b6-72c3-4f49-9bc6-dfdb2d82c1dc"], "metadata": {"model_name": "warehouses", "source_code": "% Warehouse allocation\n\n% vim: ft=zinc ts=2 sw=2 et tw=0\n\n% A company needs to construct warehouses to supply stores with goods.  Each\n% warehouse possibly to be constructed has a certain capacity defining how many\n% stores it can supply.  Constructing a warehouse incurs a fixed cost.  Costs\n% for transportation from warehouses to stores depend on the locations of\n% warehouses and stores.\n%\n% Determine which warehouses should be constructed and which warehouse should\n% supply which store such that overall cost (transportation cost plus\n% construction cost) is smallest.\n%-----------------------------------------------------------------------------\n\ninclude \"globals.mzn\";\n\n%-----------------------------------------------------------------------------\n% Instance\n\nn_suppliers = 5;\nn_stores = 10;\nbuilding_cost = 30;\n\ncapacity = [1,4,2,1,3];\n\ncost_matrix =\n [|20, 24, 11, 25, 30\n  |28, 27, 82, 83, 74\n  |74, 97, 71, 96, 70\n  | 2, 55, 73, 69, 61\n  |46, 96, 59, 83,  4\n  |42, 22, 29, 67, 59\n  | 1,  5, 73, 59, 56\n  |10, 73, 13, 43, 96\n  |93, 35, 63, 85, 46\n  |47, 65, 55, 71, 95|]; \n\n%-----------------------------------------------------------------------------\n% Model\n\nint: n_suppliers;\nint: n_stores;\nint: building_cost;\narray[1..n_suppliers] of int: capacity;\narray[1..n_stores,1..n_suppliers] of int: cost_matrix;\n\nint: MaxCost = max(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]);\nint: MaxTotal =   (n_suppliers * building_cost) \n                + sum(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]); \n\narray[1..n_stores] of var 1..n_suppliers: supplier;\narray[1..n_suppliers] of var bool: open;\narray[1..n_stores] of var 1..MaxCost: cost;\nvar 1..MaxTotal: tot;\n\nconstraint\n  sum (i in 1..n_suppliers) (building_cost * bool2int(open[i])) +\n  sum (i in 1..n_stores) (cost[i])\n  = tot;\n\nconstraint\n  forall (i in 1..n_stores) (\n    cost_matrix[i,supplier[i]] = cost[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    let {\n      var int: use\n     } in\n    count(supplier,i,use) /\\ use <= capacity[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    (exists (j in 1..n_stores) (supplier[j] == i)) == open[i]\n  );\n\nsolve\n  :: int_search(\n    supplier ++ cost ++ [bool2int(open[i]) | i in 1..n_suppliers],\n    first_fail,\n    indomain_split,\n    complete\n  )\n  minimize tot;\n\noutput\n  [ \"warehouses:\" ]\n  ++\n  [ \"\\ntot = \", show(tot) ]\n  ++\n  [ \"\\nsupplier = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(supplier[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\ncost = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(cost[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\nopen = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(open[i]) ++\n    if i = n_suppliers then \"\\n]\\n\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_suppliers\n  ]\n\n%-----------------------------------------------------------------------------\n%-----------------------------------------------------------------------------\n"}}, "water_buckets1_beginner": {"node_ids": ["fe2be0eb-1264-4141-bfbb-49779261a2ed"], "metadata": {"model_name": "water_buckets1", "source_code": "Model 1 :\n\n% Water buckets problem in Minizinc\n% \"\"\"\n% Problem description\n% This is a generalization of the CSPLib specification, which is as follows: Given an 8 pint bucket of water, and two empty buckets which can contain 5 and 3 pints respectively, the problem requires to divide the water into two by pouring water between buckets (that is, to end up with 4 pints in the 8 pint bucket, and 4 pints in the 5 pint bucket) in the smallest number of transfers.\n%\n% The generalization consists in making the specification parametric with respect to the start and goal configurations, which are now inputs to the problem.\n%\n% Problem input\n%\n% * Function start, assigning an initial amount of water to each bucket\n% * Function goal, assigning the goal amount of water to each bucket \n%\n% Search space\n% The set of all possibile sequences of configurations (states), where a configuration is a triple encoding the amount of water in each bucket at a given time-step\n%\n% Constraints\n%\n% * C1: At beginning, buckets contain the amount of water specified by function start\n% * C2: At the end, buckets contain the amount of water specified by function goal\n% * C3: The configuration at each step differs from that of the next one in that the amount of water of exactly 2 buckets changes (that in the others remain the same)\n% * C4: The overall amount of water is the same at each time step\n% * C5: After each transition (involving buckets b1 and b2), either the source bucket becomes empty, or the target becomes full\n% \"\"\"\n\n\nint: nb_buckets = 3;\nint: max_step = 10; % 8 for satisfy\nset of int: buckets = 1..nb_buckets;\nset of int: steps = 1..max_step;\narray[buckets] of int: capacity = [8,5,3];\narray[buckets] of int: start = [8,0,0];\narray[buckets] of int: goal = [4,4,0];\n\n% Search space: The set of all possibile sequences of configurations (states), \n% where a configuration is a triple encoding the amount of water in each \n% bucket at a given time-step\narray[steps, buckets] of var int: state;\nvar 1..max_step: goal_step;\n\n% Objective function\nsolve minimize goal_step;\n% solve :: int_search( [ state[i,j] | i in steps, j in buckets ] , \"first_fail\", \"indomain\", \"complete\")  minimize goal_step;\n\nconstraint\n%   goal_step <= 8 % for solve satisfy\n%   /\\\n   % assertions\n   forall(b in buckets) (\n      (start[b] <= capacity[b]) /\\ (goal[b] <= capacity[b])\n   )\n   /\\\n   sum(b in buckets)(start[b]) = sum(b in buckets)(goal[b])\n   /\\\n   forall(s in steps, b in buckets) (\n      state[s,b] >= 0 /\\\n      state[s,b] <= capacity[b]\n   )\n   /\\\n   forall(b in buckets) (\n      % C1: At beginning, buckets contain the amount of water specified by function start\n      state[1,b]=start[b]\n      /\\\n      % C2: At the end, buckets contain the amount of water specified by function goal\n      state[goal_step,b] = goal[b]\n   )\n   /\\\n   forall(step in 1..max_step-1) (\n      % C3: The configuration at each step differs from that of the next one in that the amount of\n      % water of exactly 2 buckets changes (that in the others remain the same)\n      sum(b in buckets)( bool2int(state[step,b] != state[step+1, b])) = 2\n      /\\\n      % C4: The overall amount of water is the same at each time step\n      sum(b in buckets)(state[step,b]) = sum(b in buckets)(state[step+1,b])\n      /\\\n\n      % C5: After each transition (involving buckets b1 and b2), either the source\n      % bucket becomes empty, or the target becomes full\n      forall(b1, b2 in buckets where b1 != b2) (\n         ((state[step, b1] != state[step+1, b1]) /\\ (state[step, b2] != state[step+1, b2])) ->\n            (state[step+1,b1] = 0 \\/ state[step+1,b1] = capacity[b1] \\/\n             state[step+1,b2] = 0 \\/ state[step+1,b2] = capacity[b2])\n     )\n   )\n;\n\n\noutput [\n  if s = 1 /\\ b = 1 then \n    \"goal_step: \" ++ show(goal_step)\n  else \"\" endif ++\n  if b = 1 then \"\\n\" else \" \" endif ++\n  show(state[s, b])\n  | s in steps, b in buckets\n\n] \n++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\n\ninclude \"globals.mzn\";\n\nint: n_states = 15;\nint: input_max = 15;\nint: initial_state = 1;\nset of int: accepting_states = {15};\n\n\n% distance\narray[1..n_states, 1..n_states] of 0..input_max: transition_fn =\narray2d(1..n_states, 1..n_states,\n[%1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n  0, 2, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 1\n  0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 2 \n  0, 0, 0, 4, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 3\n  0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 4\n  0, 0, 0, 0, 0, 6, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 5\n  0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, % 6\n  0, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 0, 0, 0, 0, % 7\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, % 8 \n  0, 0, 0, 0, 0, 0, 0, 0, 0,10, 0, 0, 0, 0, 0, % 9\n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0,11, 0, 0, 0, 0, %10\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,12, 0, 0, 0, %11 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,13, 0, 0, %12\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,14, 0, %13 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %14\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %15\n]);\n\n\narray[1..n_states] of string:  nodes = [\n        \"8,0,0\", % 1 start\n        \"5,0,3\", % 2\n        \"5,3,0\", % 3 \n        \"2,3,3\", % 4 \n        \"2,5,1\", % 5\n        \"7,0,1\", % 6\n        \"7,1,0\", % 7\n        \"4,1,3\", % 8\n        \"3,5,0\", % 9\n        \"3,2,3\", % 10\n        \"6,2,0\", % 11\n        \"6,0,2\", % 12\n        \"1,5,2\", % 13\n        \"1,4,3\", % 14\n        \"4,4,0\"  % 15 goal\n        ];\n\n\narray[1..input_max] of var 0..input_max: x;\nvar 0..input_max: cost;\n\n% solve satisfy;\nsolve minimize cost;\n\nconstraint\nregular(x, n_states, input_max, transition_fn,\n        initial_state, accepting_states)\n;\n\nconstraint\n   cost = 2+sum([bool2int(x[i-1] != x[i] ) | i in 2..input_max])\n;\n\noutput \n[\"cost: \" ++ show(cost) ++ \"\\n\"] ++\n[show(initial_state) ++ \" \"] ++\n[\n  if fix(x[i]) < input_max then show(x[i]) ++ \" \" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(input_max) ++ \"\\n\"] ++ \n[\"\\n\\n\"] ++\n\n[show(nodes[initial_state]) ++ \"\\n\"] ++\n[\n  if fix(x[i]) < input_max then show(nodes[fix(x[i])]) ++ \"\\n\" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(nodes[input_max]) ++ \"\\n\"] ++ \n[\"\\n\"];"}}}}