{"docstore/metadata": {"all_interval_source_code": {"doc_hash": "cff038d7929de5d0c3f86c0508bcf19ba706a1c307429999ee88c49f90bcfc3a"}, "assign_source_code": {"doc_hash": "f0906b97a4a3d4b3f66426cf0a9f2719511175f3d0bc9909808a52f54628cd70"}, "aust_color_source_code": {"doc_hash": "2ad475bdd43907f99170f0da862602ef6921b76cddecdf1cc4399117bb0892b7"}, "bibd_source_code": {"doc_hash": "8dacd37d7bba46bccccb82c2daf6b46df4e34647e607e4f4c00fbe302489051b"}, "bus_scheduling_csplib_source_code": {"doc_hash": "8d1e54f2f4ca5a1653922be6240288d320151e25c8a66a16f3f64cbc0df21645"}, "car_source_code": {"doc_hash": "f040834f0240e2800b15233c57d0cc1f624b1b456c5eac7cf3e80dd592ffad15"}, "carpet_cutting_source_code": {"doc_hash": "e36c79657f7f84baa68cf04c1efcfed32a64b171daee5b51c6c15154b8f37462"}, "cell_block_source_code": {"doc_hash": "4fc15f4c144f98af7300f7ca0cb30addf907de500681377207a3e364c161d0a3"}, "clique_source_code": {"doc_hash": "191499782517efb15a5ad877a03d3bd026b70e9541c937d3c074840790d0d66e"}, "cluster_source_code": {"doc_hash": "67131cd9c129c6bfc8bbc633c57c40c04d10e4239f7f528a603137893efd1800"}, "compatible_assignment_source_code": {"doc_hash": "58ea845d93ce8e1a5bf83c9943448c341f339001c432b96202c51f86eaea7939"}, "constrained_connected_source_code": {"doc_hash": "77ba4d2f4e124f7aca0ff7a9e0e8aec5cb1f2774b07d196d7d7d841208cb6350"}, "crazy_sets_source_code": {"doc_hash": "8894c975225d73dfa761d9064e0e30147dac1de6880bc4445d1e299191bcfe5d"}, "crossfigure_source_code": {"doc_hash": "53578072276a0c5d807b4ce76b734386587fbfc4f82f4afc42a3bddfb9bdaddb"}, "curriculum_source_code": {"doc_hash": "ab5f75d8d0e9d0f2e68186eb9b91c04c9e3ba342e5d57b98e2fde0c92a94fe57"}, "diamond_free_degree_sequence_source_code": {"doc_hash": "d622cb27b47bc48df2c53ca42e80942779a2c382a2cd6ad6747ae532df8ec473"}, "doublechannel_source_code": {"doc_hash": "69304361934fb3053e18abf2162ebc133ad7a6791eb642427295986aa792229e"}, "fractions_source_code": {"doc_hash": "e2f0e77dbf3d3777e0592a62fb31ed994a8bd10cb5eae56e9ad43e2d8cd6812d"}, "golfers_source_code": {"doc_hash": "b8171cdffd86c62f6395c905c18374f3ffdccfc51d6747aa06d6363852ab123f"}, "golomb_source_code": {"doc_hash": "a7ad24592f8118cd6ea3762363721d35aece8d9767a98bf572bc0e99305eb7bd"}, "graph_source_code": {"doc_hash": "ac56a03adfbff370bebbd1d7056ebfad8858c7bfd58d26ecf31f33ad510b2b13"}, "itemset_mining_source_code": {"doc_hash": "1fe4261e5e77dc730351b6e8ef13f9a4c92cbaff00ab0beee97e9e9ff1e607b9"}, "jobshop_source_code": {"doc_hash": "cf6adca83700b4dce9328f3269f07782053a326dfcb8f4480b167ee99ce3949b"}, "K4xP2Graceful_source_code": {"doc_hash": "6579eb86a34f89b2462d07b1ceb631c1620d72045455418e36de2e3b7ce00ed4"}, "killer_sudoku_source_code": {"doc_hash": "4803ed48460f8ef1c2bc61c5f91e9148ee00099ff7fc16d3c1a42ccde7f3e18b"}, "knapsack_source_code": {"doc_hash": "b3c324f5928ce76e4bda91d7f1109b39aad4f18f73aa3ff018ef0f62625d2b84"}, "langford_source_code": {"doc_hash": "8a1290227958fc5503d2e72e405c9a77391ad583e3f944afde6e3403be9e7217"}, "loan_source_code": {"doc_hash": "97e479e5dcc5e99d3e7e615a4ba6bca112d104c414653b6e47e10b71edd33fc0"}, "ltsp_source_code": {"doc_hash": "dd74fc1417651b8a2e181808c0b58166f54b00f8758fcf160beaa6a71de101c9"}, "magic_hexagon_source_code": {"doc_hash": "e37cae924e92295a1fa19e57e2ababe5d8f8b05b9fc03f5fdfe39ab9fc084495"}, "magic_sequence_source_code": {"doc_hash": "f41c909b16fb38860176cbc324aefc71dcd04c47ad34a0924022a43a93bad041"}, "maximum_density_still_life_source_code": {"doc_hash": "55a16b27452bbc895d2c83193de70e319d3cf21911de5daca25b2b57f0b23128"}, "mip_source_code": {"doc_hash": "250f7c9cc0bd59d9cc602841077ea6cbaabf94bc50266bb7554ed961267f9d30"}, "missing_solution_source_code": {"doc_hash": "c8800ce210a941824c915904b6e15ee2c69564f22fd5957568b6c142a343a214"}, "nonogram_create_automaton2_source_code": {"doc_hash": "81de1694c603a25bf734194524a4c527bbc8264d37ae9e8956a14719c27da6ee"}, "nurses_source_code": {"doc_hash": "6c65ebf9cac75df8fd786dbc91121a5cec37159c2a1f6eb793c8cde28368e37d"}, "opd_source_code": {"doc_hash": "287519cbb95daf648e2ac55cbc7d7fb2fb4d3dd319e0fb6eb1c02f8de4e0e72f"}, "partition_source_code": {"doc_hash": "d183b1205b7e6692c280c804e13bf11465441239d30ecb73a7431f44a271226c"}, "photo_source_code": {"doc_hash": "5f62f8bc3facf15dd05b98b6f795b1f5b7e679f50c9348538fec281a83e4acc5"}, "project_scheduling_source_code": {"doc_hash": "e06f4625f22a96f2a68785c2ad765f23c4cc82da7088b8eb421941f064de6efe"}, "QuasigroupCompletion_source_code": {"doc_hash": "a3c2102cda89ee73b8efa52dd7c3bbf596b541a62f1000854aff08b2c9bcc651"}, "QuasiGroupExistence_source_code": {"doc_hash": "b539de18799c0db9424cc79d36038042971df6f5285871d9339131939620fb4a"}, "queens_source_code": {"doc_hash": "9f9b1c9732ea34cd7961668d8f48402679928e6933dfbaa203cb5dfb36aee5cd"}, "rcpsp_source_code": {"doc_hash": "6b2c113305d5911b1055905560c7783897eb8c80334f084e487d4be659d9aafa"}, "rehearsal_source_code": {"doc_hash": "b68ede0ba3fe571c7157e325d4d16761aee073d40b941057f5a23b54cfaa5d6b"}, "restart_source_code": {"doc_hash": "5b0089aa1889f268def7f87780248c1913f8a7854e9033089ad38523c0e45e60"}, "RosteringProblem_source_code": {"doc_hash": "4e895a57eb61ada64730eb86aee4d3e64d9cf35208a30dcdb27a9643daa5efcd"}, "sb_source_code": {"doc_hash": "1a6310d619364121e627aa242992c1c326b8b434091d5f9610fa6b63e4ea092e"}, "schur_source_code": {"doc_hash": "4894db43615e6db12d5427d12599e5126525482bc8c2676d817b58c862138f77"}, "setselect_source_code": {"doc_hash": "d07fef33f8f12689e6dd97209b86e0d945f88766c68f4346db88cd8ee6444927"}, "shipping_source_code": {"doc_hash": "3f0fef7a00d56cf689157a0c4fa93a9c6d26f503ffd6d5025f8e3b7e194ec1f4"}, "simple-prod-planning_source_code": {"doc_hash": "f1f5c249306214e6a9f4f91d775e64a1d01ec8f4215d8eb56bcad9de02665b4e"}, "sonet_problem_source_code": {"doc_hash": "d436192c4f74f358a66969ee6cec919b89d2a376aaf37fa567442a121ab09b53"}, "square_pack_source_code": {"doc_hash": "6eeba7481cbfb6c790d04809f716efbaf483700acc66aa87ea0bb4db2bcc07b4"}, "stableroommates_source_code": {"doc_hash": "05dc06b7c8e49b92286ff2c90642c8e0637ad4a4412820a96acacf6edead8b19"}, "steiner_source_code": {"doc_hash": "dd04bad82465b93d0f84f6a690cdc86edd8e9312d746d918642fd90ea5a67f58"}, "stoch_fjsp_source_code": {"doc_hash": "1b493398107a1092aff8fbbd2f2d90ee6b3e324fd60d81299732911364d3d81e"}, "submultisetsum_source_code": {"doc_hash": "9c317e01e54e2af2712f30e47fef0ba2a316ceec60f43f8a474f1816eb254d2b"}, "table_seating_source_code": {"doc_hash": "58d0bd625688373c07b93764a545086c64f3028f396e1f8ed5dc255c748192c9"}, "teamselect_source_code": {"doc_hash": "019a3725c2fab6d02e1975bef5055f1603f2d9f1184f1e09a28042e42093fb37"}, "template_design_source_code": {"doc_hash": "fb8044a82a613c6c81598c254710386b0540fb8736d49badd0881ddb2db79d94"}, "toomany_source_code": {"doc_hash": "b1db3a754c8a269dcf53579b5af2d618d7cbc2f06d56a1b82c9035efb0997e0c"}, "traffic_lights_table_source_code": {"doc_hash": "422310f01fe34d0ee0a18cb6d91604c03480da30b7a566b7c98ea02d246b0e7c"}, "TTPPV_source_code": {"doc_hash": "5405cb264d79ba19ff5855b1785018a93042ca768a9d26a38fa89da570cdb562"}, "vessel-loading_source_code": {"doc_hash": "6ee3e46d66b06d1c16c6a088a3d7a2862b63c7f84cd8bb66f0b9b6d9879cd547"}, "warehouses_source_code": {"doc_hash": "d80ad7c879ef4c86e2dc7155b0b541e9d7c5436a4500d5cb691803f13028f0c7"}, "water_buckets1_source_code": {"doc_hash": "5668426c44d206a8fbd87c384578625957a6b14993d579ba522ed0f712f87382"}, "89d39afd-c50b-4935-9f43-0e797b76bfd2": {"doc_hash": "cff038d7929de5d0c3f86c0508bcf19ba706a1c307429999ee88c49f90bcfc3a", "ref_doc_id": "all_interval_source_code"}, "8458a59f-67e4-400d-9979-d3b6cd942d94": {"doc_hash": "cc9eafa0a05f770170dd31125d50cb3941f50854f475a9df8d2b2a4a7c7d86dd", "ref_doc_id": "assign_source_code"}, "2060b66c-5842-4329-8b1b-bedadb8026df": {"doc_hash": "0b11741ff29b310be157325950290c6bf0d43a90092af024866bec6ed9ebe3bc", "ref_doc_id": "aust_color_source_code"}, "2f30e825-0f9e-438f-bda0-5b16979dfeee": {"doc_hash": "2b2f73d36158e536ca2d10b0692f3593882fe724c2bb466136153f649f0b6b69", "ref_doc_id": "bibd_source_code"}, "7078ad01-3380-40c3-879d-8b540e4c44d5": {"doc_hash": "045516bf5ef3d7cc1872ca9718568f1c4ec4c3da7fc2995fa409795e8821d9bc", "ref_doc_id": "bus_scheduling_csplib_source_code"}, "015ab921-3ba0-4705-8cca-fe0c9be5514a": {"doc_hash": "3a46c9428acc9985ad31487a7b8e8eafb2931ea59b4a1bfb56334bb52271c7bb", "ref_doc_id": "car_source_code"}, "8c415210-15e3-4f28-bacc-dcddbb6ab1a4": {"doc_hash": "e36c79657f7f84baa68cf04c1efcfed32a64b171daee5b51c6c15154b8f37462", "ref_doc_id": "carpet_cutting_source_code"}, "34737f83-a5d9-4cd0-a1cd-9ae21f48953a": {"doc_hash": "2e58621b162311b0c81bfc75c4dcb653cc5ab064a39e14a3ac3d1bebcc989380", "ref_doc_id": "cell_block_source_code"}, "2a58b22e-0ed9-4e9d-a400-829f4e5ca323": {"doc_hash": "87c6745f6d991e6cf84bc21f5ee85d4165250431eead9119b11dec3ff1ccc9e6", "ref_doc_id": "clique_source_code"}, "842d379a-a769-4264-991a-1f95df77375e": {"doc_hash": "94d65a1db3b3dcfcb38131fc86e593be6e49067780713e81f8a9cf31b82b1bb8", "ref_doc_id": "cluster_source_code"}, "d7edd124-9eb7-4ccf-9ac1-0a8ca24e1664": {"doc_hash": "7bad0ec4489351c07f00b9fca11545b9b75a59cc6cc0460c0fea2ac8e024e757", "ref_doc_id": "compatible_assignment_source_code"}, "57ccf9ed-0b34-4d4d-b321-a85e7d6a3e3d": {"doc_hash": "51cbbba141034e4b6d36abb903228d66a846f5d71e5d19f35dd47b034f95c110", "ref_doc_id": "constrained_connected_source_code"}, "cf002e9b-346a-4dff-bb34-3339463af5ab": {"doc_hash": "943568dc0205dd58fb3a1cb35ed7454d465442ba881ab370fc3b6725e8b5b8c7", "ref_doc_id": "crazy_sets_source_code"}, "57c899ba-fa7c-4cb5-acd8-853f6de9f590": {"doc_hash": "53578072276a0c5d807b4ce76b734386587fbfc4f82f4afc42a3bddfb9bdaddb", "ref_doc_id": "crossfigure_source_code"}, "2b9db7b9-0ec6-4122-8681-a948c0c47489": {"doc_hash": "55310316b209f73d2ead6c19b2b4d0c62bc6309e98180af2101e98be6c530005", "ref_doc_id": "curriculum_source_code"}, "1e81a748-90f5-48a9-8d14-ce0924ae6357": {"doc_hash": "5c4f6ae97fc396efa8b8b64a4faee39283a0e7e519ca6687a6be240238de2fc3", "ref_doc_id": "diamond_free_degree_sequence_source_code"}, "c8aebc2f-ec6e-4a5c-a4d3-03d01b242c54": {"doc_hash": "1e9743f336cd3f43430f694a7ec1103c3187c5f32a193d4bd7f22a733c1f0699", "ref_doc_id": "doublechannel_source_code"}, "a327a687-c8ab-47d9-980f-d2388021d622": {"doc_hash": "e2f0e77dbf3d3777e0592a62fb31ed994a8bd10cb5eae56e9ad43e2d8cd6812d", "ref_doc_id": "fractions_source_code"}, "414f3da4-7e02-4ea6-a587-5ab31d8e144f": {"doc_hash": "b8171cdffd86c62f6395c905c18374f3ffdccfc51d6747aa06d6363852ab123f", "ref_doc_id": "golfers_source_code"}, "00b794a2-70f8-4409-a5d7-f9f229dffccb": {"doc_hash": "b4241909b766bc1ce837f33ef9d92bbd05e0c9b3b356e26ab67161efb37aaadb", "ref_doc_id": "golomb_source_code"}, "1edcda41-2027-40d6-a5d8-7eb833317eaa": {"doc_hash": "b2262307f944d9fdf7ffabb89f1790e7d603886e061878f54a963ba606f582b0", "ref_doc_id": "graph_source_code"}, "d4e103bd-89fe-47bf-80b1-edc0e32cdf74": {"doc_hash": "e7a4c1774eddce969dcc7ca52b289e3dd559f2b2f4f8e3f1c5a3ea7950aaae51", "ref_doc_id": "itemset_mining_source_code"}, "cc3d5f6c-4087-4fb9-8c4f-c86f4879f7b6": {"doc_hash": "cdc71e8930c1c68d1c1aa95d71e32a895be92c4f93bc9d4ac1f4425669c087d0", "ref_doc_id": "jobshop_source_code"}, "8cdfdf97-c682-4416-b170-500fc703386f": {"doc_hash": "6579eb86a34f89b2462d07b1ceb631c1620d72045455418e36de2e3b7ce00ed4", "ref_doc_id": "K4xP2Graceful_source_code"}, "d9d2c132-5ecf-468d-a421-328f4b880b68": {"doc_hash": "4803ed48460f8ef1c2bc61c5f91e9148ee00099ff7fc16d3c1a42ccde7f3e18b", "ref_doc_id": "killer_sudoku_source_code"}, "2ef3e1a6-031d-42da-a9a3-f52535150e15": {"doc_hash": "b3c324f5928ce76e4bda91d7f1109b39aad4f18f73aa3ff018ef0f62625d2b84", "ref_doc_id": "knapsack_source_code"}, "56883237-c490-4f8a-8ec3-401b38e997d1": {"doc_hash": "99a3473ce671c44c1ea7cb2c796918f284930cf60e9bf0a2fdf69794a3219d58", "ref_doc_id": "langford_source_code"}, "82d908a5-8d31-400b-b086-afd776cbd033": {"doc_hash": "6db952eec78dd77ba9f1af49d628d2a67654ecbeaaf9d59d66756ea247ad53a7", "ref_doc_id": "loan_source_code"}, "67af9333-1b7b-4f2e-b3bc-f558ecf23e9c": {"doc_hash": "b754abb11b96305cfae1e61babba3b4e818d834954725a5a42c4455c3245a20a", "ref_doc_id": "ltsp_source_code"}, "3bb6e712-b149-4dc5-89be-d0fa988af6b6": {"doc_hash": "e37cae924e92295a1fa19e57e2ababe5d8f8b05b9fc03f5fdfe39ab9fc084495", "ref_doc_id": "magic_hexagon_source_code"}, "e085b210-cbff-4aa9-ab79-199d3932971d": {"doc_hash": "f41c909b16fb38860176cbc324aefc71dcd04c47ad34a0924022a43a93bad041", "ref_doc_id": "magic_sequence_source_code"}, "601dce60-fcf6-4521-96b8-80d68facd7fd": {"doc_hash": "3db68217c22aa139e4516fc49b01799e50e54a446fbf12093bbd510f17f98c65", "ref_doc_id": "maximum_density_still_life_source_code"}, "fbbf6306-799c-4bb4-a682-aa7b1beb6403": {"doc_hash": "5453713237d1e6b437a87952da791b935de754b2b1bd3fcebe69bc3f432ec33a", "ref_doc_id": "mip_source_code"}, "c309bf1e-14c4-4f8a-937b-25a7c1080c70": {"doc_hash": "2f31a98f7fdab29da9acfcd7659007afe802ef20305fbe2e44020659b96eecb2", "ref_doc_id": "missing_solution_source_code"}, "680db5e7-33e3-4733-9b28-afb108815d4f": {"doc_hash": "81de1694c603a25bf734194524a4c527bbc8264d37ae9e8956a14719c27da6ee", "ref_doc_id": "nonogram_create_automaton2_source_code"}, "1ca863dd-fc03-41f0-91df-f9c01dfddff6": {"doc_hash": "9e86a14f0d35d71d9da72700e49688e2bd4d6bae1aa51ca54e1dc2791e0f3bfa", "ref_doc_id": "nurses_source_code"}, "2f36fba7-47d5-450c-a8f9-e2be9fcf25b9": {"doc_hash": "287519cbb95daf648e2ac55cbc7d7fb2fb4d3dd319e0fb6eb1c02f8de4e0e72f", "ref_doc_id": "opd_source_code"}, "ed56b2fd-b5bc-49a5-bc44-93fe69cb2e08": {"doc_hash": "d183b1205b7e6692c280c804e13bf11465441239d30ecb73a7431f44a271226c", "ref_doc_id": "partition_source_code"}, "0d918c40-5c7a-4679-b04a-0de2e9292752": {"doc_hash": "40f17108553b865380938e2dea2ca78a97da191ec01a604e66d0f47653d96666", "ref_doc_id": "photo_source_code"}, "4dd2643d-6d28-471e-9f09-bbfea9722b82": {"doc_hash": "ef6dfc96ea929130a55999a711bd065a55008aa48e14a7ff8f98bd094fec860d", "ref_doc_id": "project_scheduling_source_code"}, "221df495-7c24-4f67-bd80-ef740ead3c4a": {"doc_hash": "a3c2102cda89ee73b8efa52dd7c3bbf596b541a62f1000854aff08b2c9bcc651", "ref_doc_id": "QuasigroupCompletion_source_code"}, "4fe374b4-f573-446d-be57-99f7b7b7e0c4": {"doc_hash": "b539de18799c0db9424cc79d36038042971df6f5285871d9339131939620fb4a", "ref_doc_id": "QuasiGroupExistence_source_code"}, "92f82710-0397-4ba4-a5fd-510a71acc0aa": {"doc_hash": "566c88f56fd42425780c3399f6245c7153d1a52a5f01a2e1edef3546a5460b45", "ref_doc_id": "queens_source_code"}, "9ca7cba3-b489-479b-afa9-5b2c9b3932e6": {"doc_hash": "49ecd271c9009e1967062a211bc0452897907a0b1936275f6f50f41841bd53d3", "ref_doc_id": "rcpsp_source_code"}, "299ce69c-d698-4784-8567-558e383cf857": {"doc_hash": "fd6e4a9e0a88e508d8099b09206ecd76c74c0db6db1aba4b999c597e227e0dfb", "ref_doc_id": "rehearsal_source_code"}, "438ba176-5f5d-4244-aea7-bc5a6e1a2198": {"doc_hash": "e6c466de500dc36a54eb6970dba1c84a9627a9823b48ff59d97f5f7ffdbe8e85", "ref_doc_id": "restart_source_code"}, "405d445d-d23e-483e-8068-6094b6ed1b1a": {"doc_hash": "2c62f42e6991da927f12ee95f8158c7998a6fb521a08808ce2c461fe63e8f038", "ref_doc_id": "RosteringProblem_source_code"}, "45542679-3e9c-4765-8241-0c66cdf72603": {"doc_hash": "6b9125eca9d4bcf334d41b0fa149d33a599ffa1c38c7f4c2ac7231ded20ba457", "ref_doc_id": "sb_source_code"}, "bccfa98d-d62d-4a91-8c3a-30928dcc254b": {"doc_hash": "a4b09b7bf5101e9efb32576a543d4888995cb9bd136f8d9840a331d956d15936", "ref_doc_id": "schur_source_code"}, "c0aba51c-5c79-43c5-8a9e-99dfab3eea62": {"doc_hash": "3bde30d1c1a59d19ed83eb1040aa32c57536e07c64a66e26f4cdc6facc5c762c", "ref_doc_id": "setselect_source_code"}, "daa3db9b-e979-44e5-b3d6-154275e09082": {"doc_hash": "3f0fef7a00d56cf689157a0c4fa93a9c6d26f503ffd6d5025f8e3b7e194ec1f4", "ref_doc_id": "shipping_source_code"}, "6dc48126-89e9-4e2d-8706-c67a1b7ff7ab": {"doc_hash": "f1f5c249306214e6a9f4f91d775e64a1d01ec8f4215d8eb56bcad9de02665b4e", "ref_doc_id": "simple-prod-planning_source_code"}, "ba321611-e320-44fe-b92a-5810fc24a5e8": {"doc_hash": "86a1e25084e262a1fc8b17773abae35839c114b7515f48d8a167fcd28ec46dea", "ref_doc_id": "sonet_problem_source_code"}, "4e842621-0b55-4126-8a1d-207ba6081f49": {"doc_hash": "006a63c462be0a2408df8c5cbde61fd2ab84874d53e07502024b0cc32ae0dd02", "ref_doc_id": "square_pack_source_code"}, "0a92c3d8-0a32-4f34-9b29-4e93f6c8740b": {"doc_hash": "4cc0b82dcca5ff1778f31355b89c090a490dd15878ea7f81cd2c315e9162f2a2", "ref_doc_id": "stableroommates_source_code"}, "9fa498c8-9952-46ad-8101-e109b4732b76": {"doc_hash": "0f50b5946deb090fa135f109c30fc15ecce383cde93ee5b011692e198dc7c317", "ref_doc_id": "steiner_source_code"}, "b2c0a481-5614-4db0-9618-fac709b69de3": {"doc_hash": "61be2e90bcac3eb46ed93888df5c6eb940c25b2debb1e34e7a7c08f14b61eae7", "ref_doc_id": "stoch_fjsp_source_code"}, "5b1af932-d83b-4565-88d4-a635813b9c25": {"doc_hash": "9c317e01e54e2af2712f30e47fef0ba2a316ceec60f43f8a474f1816eb254d2b", "ref_doc_id": "submultisetsum_source_code"}, "0b2ee8b1-92d6-4d4d-b00e-b32d64cce0f3": {"doc_hash": "eb9765a22aa82a0440cf032b8602ea1e0cd584ace11510b530d789f8dbd8e7fd", "ref_doc_id": "table_seating_source_code"}, "f7ab6aec-2409-4d2c-98be-002972ab5c8a": {"doc_hash": "1d9ac21990421b51febac6ba069e299f023cd278fc2d6d3b6ac7f24b99d6574f", "ref_doc_id": "teamselect_source_code"}, "443a9574-3eb8-4f42-a173-ccfd88072bbf": {"doc_hash": "a39b5da36bfb90d316302ddda035df2a88e3508a59ba3975073dae8a74d0a386", "ref_doc_id": "template_design_source_code"}, "063f7d9d-663c-424d-b4cf-b17526dcfd09": {"doc_hash": "057316b55dfe6d59ae4ea088beb053d8f7d51ac4be49b2f8da0fae3002248b75", "ref_doc_id": "toomany_source_code"}, "587f194d-6ad0-4f44-94d2-30125a63568e": {"doc_hash": "921c04d5a94c24ed4a8d6a3d60aeb69717e71287dbbb53c10f51e2debcaa755f", "ref_doc_id": "traffic_lights_table_source_code"}, "27749507-4bf0-46e0-a896-a0fa448998b1": {"doc_hash": "1ad24b024633541281989e0752121a47ed7da99dd7cc18880e38fa9ef5c84f1b", "ref_doc_id": "TTPPV_source_code"}, "f3d83aa1-d0cd-458c-8b94-e271fa020eab": {"doc_hash": "235b02adb188119bf7d928be8c28ba0b6a86ccdba5c5521a65af1242808ca53b", "ref_doc_id": "vessel-loading_source_code"}, "700e4c39-7ca2-4916-b528-320247035ca9": {"doc_hash": "8e431b138fe1002b97f7cc3c66ca240565842b490f48626e7568896215c5006d", "ref_doc_id": "warehouses_source_code"}, "5d35e7ea-28ff-40e7-a963-2befe2bf2b8d": {"doc_hash": "5668426c44d206a8fbd87c384578625957a6b14993d579ba522ed0f712f87382", "ref_doc_id": "water_buckets1_source_code"}}, "docstore/data": {"89d39afd-c50b-4935-9f43-0e797b76bfd2": {"__data__": {"id_": "89d39afd-c50b-4935-9f43-0e797b76bfd2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "all_interval_source_code", "node_type": "4", "metadata": {}, "hash": "cff038d7929de5d0c3f86c0508bcf19ba706a1c307429999ee88c49f90bcfc3a", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 : \n\n\n%\n% All interval problem in MiniZinc\n%\n% \"\"\"\n% Given the twelve standard pitch-classes (c, c%, d, ...), represented by\n% numbers 0,1,...,11, find a series in which each pitch-class occurs exactly\n% once and in which the musical intervals between neighbouring notes cover\n% the full set of intervals from the minor second (1 semitone) to the major\n% seventh (11 semitones). That is, for each of the intervals, there is a\n% pair of neigbhouring pitch-classes in the series, between which this\n% interval appears. The problem of finding such a series can be easily\n% formulated as an instance of a more general arithmetic problem on Z_n,\n% the set of integer residues modulo n. Given n in N, find a vector\n% s = (s_1, ..., s_n), such that (i) s is a permutation of\n% Z_n = {0,1,...,n-1}; and (ii) the interval vector\n% v = (|s_2-s_1|, |s_3-s_2|, ... |s_n-s_{n-1}|) is a permutation of\n% Z_n-{0} = {1,2,...,n-1}. A vector v satisfying these conditions is\n% called an all-interval series of size n; the problem of finding such\n% a series is the all-interval series problem of size n. We may also be\n% interested in finding all possible series of a given size.\n\ninclude \"globals.mzn\";\n\nint: n = 12;\n% array[1..n] of var 1..n: x;\narray[1..n] of var 1..n: x;\narray[1..n-1] of var 1..n-1: diffs;\nint: sum_distinct = ((n+1)*n) div 2;\n\n% max_regret seems to be quite good....\nsolve :: int_search(x, max_regret, indomain_split, complete) satisfy;\n\nconstraint      \n  all_different(diffs) :: domain\n  /\\  \n  all_different(x) :: domain\n  /\\ \n  forall(k in 1..n-1) (\n      diffs[k] = abs(x[k+1] - x[k])\n  )\n  /\\ % symmetry breaking\n  x[1] < x[n-1]\n  /\\\n  diffs[1] < diffs[2]\n;\n\n\noutput [\n       show(x) ++ \",\" % , \" \", show(sum_distinct), \" diffs: \", show(diffs)\n]\n\n\nModel 2 : \n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n%    all_different(series) /\\\n\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i != j)  (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n;\n\noutput\n[  show(series)\n];\n\n\nModel 3 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   %  C1: Each pitch class occurs exactly once\n   forall(i, j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   forall(i,j in classes where j < n-1 /\\ i < n-1 /\\ i!=j) (\n     abs(series[i+1] - series[i]) != abs(series[j+1] - series[j])\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput\n[ show(series)\n];\n\n\nModel 4 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[differ] of var differ: differences;\n\nsolve satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 1..n-2) (\n       differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in differ where i != j) (\n       differences[i] != differences[j]\n   )\n;\n\noutput [\n  show(series)\n];\n\n\nModel 5 : \n\n\ninclude \"globals.mzn\";\n\nint: n = 12;\nset of int: classes = 0..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\n\nsolve :: int_search(series, first_fail, indomain_median, complete) satisfy;\n\nconstraint\n  % C1: Each pitch class occurs exactly once\n  % GCAD: Exploitation of alldifferent() global constraint\n  all_different(series)\n  /\\\n\n  % C2: Differences between neighbouring notes are all different\n  % GCAD: Exploitation of alldifferent() global constraint\n  % alldifferent(all (i in classes: i <> n-1) abs(series[i+1] - series[i]));\n  all_different( \n         [ abs(series[i+1] - series[i]) | i in classes where i != n-1]\n  )\n  \n;\n\noutput [\n  show(series)\n];\n\n\nModel 6 : \n\n\nint: n= 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\n% solve satisfy;\nsolve :: int_search(series, occurrence, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   forall(i,j in classes where i != j) (\n     series[i] != series[j]\n   )\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n      differences[i]=abs(series[i+1] - series[i])\n   )\n   /\\\n   forall(i,j in 0..n-2 where i != j) (\n      differences[i] != differences[j]\n   )\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\noutput [\n  show(series)\n];\n\n\nModel 7 : \n\n\ninclude \"globals.mzn\";\nint: n = 12;\nset of int: classes = 0..n-1;\nset of int: differ = 1..n-1;\n\n% Search space: The set of permutations of integer range [0..n-1]\narray[classes] of var classes: series;\narray[0..n-2] of var differ: differences;\n\nsolve ::int_search(series, first_fail, indomain_max, complete) satisfy;\n\nconstraint\n   % C1: Each pitch class occurs exactly once\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(series)\n   /\\\n   % C2: Differences between neighbouring notes are all different\n   % AUX: Addition of auxiliary predicates\n   % Auxiliary predicate stores the interval between pairs of neighbouring notes\n   forall(i in 0..n-2) (\n          differences[i] = abs(series[i+1] - series[i])\n   )\n   /\\\n   % GCAD: Exploitation of alldifferent() global constraint\n   all_different(differences)\n   /\\\n   % SBSO: Symmetry-breaking by selective ordering\n   % The first note is less than last one\n   series[0] < series[n-1]\n;\n\n\noutput [\n   \"series: \" ++ show(series) ++ \"\\n\" ++\n   \"differences: \" ++ show(differences) \n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 6726, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8458a59f-67e4-400d-9979-d3b6cd942d94": {"__data__": {"id_": "8458a59f-67e4-400d-9979-d3b6cd942d94", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "assign_source_code", "node_type": "4", "metadata": {}, "hash": "f0906b97a4a3d4b3f66426cf0a9f2719511175f3d0bc9909808a52f54628cd70", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\nint: n;\nset of int: WORK = 1..n;\nint: m;\nset of int: TASK = 1..m;\narray[WORK,TASK] of int: profit;\narray[WORK] of var TASK: x;\n% new\narray[WORK] of var int: px =\n     [ profit[w,x[w]] | w in WORK ];\nvar int: obj = sum(w in WORK)(px[w]);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\n\nann: varselect;\nann: valselect;\n\nsolve :: int_search(px, varselect, valselect, complete)\n      maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x);\\n\"];\n\n\nvarselect = largest;\nvalselect = indomain_min;\n\n\nModel 2 : \n\n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[DOM] of var COD: task;\narray[COD] of var DOM: worker;\n\ninclude \"inverse.mzn\";\nconstraint inverse(task,worker);\n\n\nsolve maximize sum(w in COD)\n            (profit[w,task[w]]);\n\noutput [show(task)];\n\n\n\nModel 3 : \n\nint: n;\nset of int: DOM = 1..n;\nint: m;\nset of int: COD = 1..m;\narray[DOM,COD] of int: profit;\n\narray[COD] of var DOM: worker;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(worker);\n\n\nsolve maximize sum(t in COD)\n            (profit[worker[t],t]);\n\noutput [show(worker)];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1110, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2060b66c-5842-4329-8b1b-bedadb8026df": {"__data__": {"id_": "2060b66c-5842-4329-8b1b-bedadb8026df", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aust_color_source_code", "node_type": "4", "metadata": {}, "hash": "2ad475bdd43907f99170f0da862602ef6921b76cddecdf1cc4399117bb0892b7", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n% Colouring Australia using 4 colors \nint: nc = 4;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];\n\n\n Model 2 :\n\n % Colouring Australia using nc colors \nint: nc;\n\nvar 1..nc: wa;    var 1..nc: nt;     \nvar 1..nc: sa;    var 1..nc: q;     \nvar 1..nc: nsw;   var 1..nc: v;\nvar 1..nc: t;\n\nconstraint wa != nt;\nconstraint wa != sa;\nconstraint nt != sa;\nconstraint nt != q;\nconstraint sa != q;\nconstraint sa != nsw;\nconstraint sa != v;\nconstraint q != nsw;\nconstraint nsw != v;\n\nsolve satisfy;\n\noutput [\"wa=\\(wa)\",  \n   \" nt=\\(nt)\", \n   \" sa=\\(sa)\\n\",\n \"q=\\(q)\", \n \" nsw=\\(nsw)\", \n \" v=\\(v)\\n\",\n \"t=\\(t)\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1006, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2f30e825-0f9e-438f-bda0-5b16979dfeee": {"__data__": {"id_": "2f30e825-0f9e-438f-bda0-5b16979dfeee", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bibd_source_code", "node_type": "4", "metadata": {}, "hash": "8dacd37d7bba46bccccb82c2daf6b46df4e34647e607e4f4c00fbe302489051b", "class_name": "RelatedNodeInfo"}}, "text": "% bibd.mzn\n% vim: ft=zinc ts=4 sw=4 et tw=0\n% Ralph Becket <rafe@csse.unimelb.edu.au>\n% Tue Oct 23 11:28:06 EST 2007\n%\n% Balanced incomplete block designs.  See the following:\n% http://mathworld.wolfram.com/BlockDesign.html\n% http://www.dcs.st-and.ac.uk/~ianm/CSPLib/prob/prob028/spec.html\n%\n%\n%\n% A BIBD (v, b, r, k, lambda) problem is to find a binary matrix of v rows\n% of b columns such that each row sums to r, each column sums to k, and\n% the dot product beween any pair of distinct rows is lambda.\n\ninclude \"lex_lesseq.mzn\";\n\nint: v;\nint: k;\nint: lambda;\n\nint: b = (lambda * v * (v - 1)) div (k * (k - 1));\nint: r = (lambda * (v - 1)) div (k - 1);\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\narray [rows, cols] of var bool: m;\n\n    % Every row must sum to r.\n    %\nconstraint forall (i in rows) (sum (j in cols) (bool2int(m[i, j])) = r);\n\n    % Every column must sum to k.\n    %\nconstraint forall (j in cols) (sum (i in rows) (bool2int(m[i, j])) = k);\n\n    % The dot product of every pair of distinct rows must be lambda.\n    %\nconstraint\n    forall (i_a, i_b in rows where i_a < i_b) (\n        sum (j in cols) (bool2int(m[i_a, j] /\\ m[i_b, j])) = lambda\n    );\n\n    % Break row symmetry in the incidence matrix.\n    %\nconstraint forall(i in rows diff {max(rows)})(\n        lex_lesseq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    );\n\n    % Break column symmetry in the incidence matrix.\n    %\nconstraint forall(j in cols diff {max(cols)})(\n        lex_lesseq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    );\n\nsolve :: bool_search([m[i, j] | i in rows, j in cols],\n    input_order, indomain_min, complete)\n    satisfy;\n\noutput  [\"bibd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r),\n        \", k = \", show(k), \", lambda = \", show(lambda), \")\\n\\n\"] ++\n        [ ( if j > b then \"\\n\" else show(bool2int(m[i, j])) endif )\n        | i in rows, j in 1..(b + 1)\n        ];\n\n%----------------------------------------------------------------------------%\n%----------------------------------------------------------------------------%", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2060, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7078ad01-3380-40c3-879d-8b540e4c44d5": {"__data__": {"id_": "7078ad01-3380-40c3-879d-8b540e4c44d5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bus_scheduling_csplib_source_code", "node_type": "4", "metadata": {}, "hash": "8d1e54f2f4ca5a1653922be6240288d320151e25c8a66a16f3f64cbc0df21645", "class_name": "RelatedNodeInfo"}}, "text": "%\n% Bus driver scheduling problem (prob022 in CSPLib) in MiniZinc.\n%\n% Specification\n% Bus driver scheduling can be formulated as a set paritioning problem.\n% We propose 12 set partitioning problems derived from small bus driver\n% scheduling problems. These consist of a given set of tasks (pieces of\n% work) to cover and a large set of possible shifts, where each shift\n% covers a subset of the tasks and has an associated cost. We must select\n% a subset of possible shifts that covers each piece of work once and\n% only once: this is called a partition. Further,\n%\n% In the driver scheduling (unlike air crew scheduling) the main aim is\n% to reduce the number of shifts used in the solution partition and the\n% total cost of the partition is secondary. To simplify the problem we have\n% made the cost of each shift the same. This means that the goal is to\n% minimise the number of shifts.\n%\n% The problems come from four different bus companies:\n% Reading (r1 to r5a),\n% CentreWest Ealing area (c1, c1a, c2),\n% the former London Transport (t1 and t2).\n%\n% The problems have differing regulations and features (e.g. urban and\n% short distance rural bus schedules can have very different features). Note\n% that r1 and r1a are the same problem, but have different numbers of\n% generated shifts. Similarly with the problems: c1, c1a and r5, r5a.\n%\n% Problems are presented in the same format as the set partitioning\n% examples in ORLIB. The first line gives the number of rows (pieces of work),\n% columns (shifts) and the minimum number of columns need for a partition.\n% Then each line after that corresponds to one column. It starts with\n% the cost (which is always 1 in our case) then the number of rows it\n% covers, followed by the rows it covers.\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \nint: num_work;\nint: num_shifts;\nint: min_num_shifts;\narray[1..num_shifts] of set of int: shifts;\n\narray[1..num_shifts] of var 0..1: x;\nvar 0..num_shifts: tot_shifts;\n\n% solve minimize tot_shifts;\nsolve :: int_search(\n        x ++ [tot_shifts], \n        first_fail, \n        indomain_min, \n        complete) \n    minimize tot_shifts;\n    % satisfy;\n\nconstraint\n   tot_shifts = sum(x)\n   /\\\n   forall(j in 0..num_work-1) (\n       sum(i in 1..num_shifts) (x[i]*bool2int(j in shifts[i])) = 1\n   )\n   /\\\n   tot_shifts >= min_num_shifts\n\n   % /\\ % for solve satisfy (t1)\n   % tot_shifts = 7\n;\n\n\noutput [\n  \"tot_shifts: \" ++ show(tot_shifts) ++ \"\\n\" ++ \n  \"x: \" ++ show(x) ++ \"\\n\"\n] ++ \n[\n  if fix(x[i]) = 1 then show(shifts[i]) else \"\" endif\n  | i in 1..num_shifts\n] ++ \n[\"\\n\"] ++\n[\n  if fix(x[i]) = 1 then show(i) ++ \" \" else \"\" endif\n  | i in 1..num_shifts\n] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2647, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "015ab921-3ba0-4705-8cca-fe0c9be5514a": {"__data__": {"id_": "015ab921-3ba0-4705-8cca-fe0c9be5514a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "car_source_code", "node_type": "4", "metadata": {}, "hash": "f040834f0240e2800b15233c57d0cc1f624b1b456c5eac7cf3e80dd592ffad15", "class_name": "RelatedNodeInfo"}}, "text": "%\n% Car sequencing in MiniZinc.\n% include \"globals.mzn\";\n\nint: numclasses;\nint: numoptions;\nint: numcars;\nset of int: Classes = 1..numclasses;\nset of int: Options = 1..numoptions;\nset of int: Slots = 1..numcars;\n\narray[Classes] of int: numberPerClass;\n\narray[Classes,Options] of int: optionsRequired;\narray[Options] of int: windowSize;\narray[Options] of int: optMax;\n\narray[Options] of int: optionNumberPerClass = [sum(j in Classes) (numberPerClass[j] * optionsRequired[j,i]) | i in Options];\n\n% decision variables\n\narray[Slots] of var Classes: slot;\narray[Options, Slots] of var 0..1: setup;\n\n\nvar int: z = sum(s in Classes) (s*slot[s]);\n\n% solve minimize z;\nsolve :: int_search(slot, input_order, indomain_min, complete)\n  satisfy;\n\nconstraint\n  forall(c in Classes ) (\n    sum(s in Slots ) (bool2int(slot[s] = c)) = numberPerClass[c]\n  )\n  /\\\n  forall(o in Options, s in 1..numcars - windowSize[o] + 1) (\n    sum(j in s..s + windowSize[o]- 1) (setup[o,j]) <= optMax[o]\n  )\n  /\\\n  forall(o in Options, s in Slots ) (\n    setup[o,s] = optionsRequired[slot[s],o]\n  )\n  /\\\n  forall(o in Options, i in 1..optionNumberPerClass[o]) (\n    sum(s in 1..(numcars - i * windowSize[o])) (setup[o,s]) >=\n           (optionNumberPerClass[o] - i * optMax[o])\n  )\n;\n\n% for solve satisfy\n% constraint z = 82;\n\n\noutput [\n \"z: \" ++ show(z) ++ \"\\n\" ++\n \"slot: \" ++ show(slot) ++ \"\\n\"\n] ++\n[\n  if j = 1 then \"\\n\" else \" \" endif ++ \n    show(setup[i,j])\n  | i in Options, j in Slots\n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1465, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8c415210-15e3-4f28-bacc-dcddbb6ab1a4": {"__data__": {"id_": "8c415210-15e3-4f28-bacc-dcddbb6ab1a4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "carpet_cutting_source_code", "node_type": "4", "metadata": {}, "hash": "e36c79657f7f84baa68cf04c1efcfed32a64b171daee5b51c6c15154b8f37462", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\narray[ROOM] of var ROT: rot;\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)(shape[i,rot[i]] != {});\n\nconstraint forall(i in ROOM)(forall(r in ROFF)\n  (r in shape[i,rot[i]] -> \n  (x[i] + d[r,1] + d[r,3] <= l /\\\n   y[i] + d[r,2] + d[r,4] <= h)));\n\nconstraint forall(i,j in ROOM where i < j)\n  (forall(r1,r2 in ROFF)\n (r1 in shape[i,rot[i]] /\\ \n  r2 in shape[j,rot[j]] -> \n(x[i] + d[r1,1] + d[r1,3] <= x[j] + d[r2,1]\n                   \\/\n x[j] + d[r2,1] + d[r2,3] <= x[i] + d[r1,1]\n                   \\/\n y[i] + d[r1,2] + d[r1,4] <= y[j] + d[r2,2]\n                   \\/\ny[j] + d[r2,2] + d[r2,4] <= y[i] + d[r1,2])\n   ));\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nrot = \\(rot);\\n\"];\n\n\n\nModel 2 :\n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: DIM = 1..2;\narray[ROFF,DIM] of int: rect_size = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 3..4]);\narray[ROFF,DIM] of int: rect_offset = \n     array2d(ROFF,DIM, [ d[r,i] | r in ROFF, i in 1..2]);\narray[int] of set of ROFF: shapes = [ {1,3,4}, {2,5,6}, {1}, {7} ];\nset of int: SHAPE = index_set(shapes);\n%array[int] of set of RECT: s = sort([shapes[i,j] | i in 1..n, j in 1..4]);\n\narray[ROOM] of var SHAPE: kind;\narray[ROOM,DIM] of var int: coords =\n      array2d(ROOM,DIM, [ if j = 1 then x[i] else y[i] endif\n                         | i in ROOM, j in 1..2 ]);\n\n\n\ninclude \"geost.mzn\";\n\nconstraint geost_bb(2,\n                    rect_size,\n                    rect_offset,\n                    shapes,\n                    coords,\n                    kind,\n                    [0,0],\n                    [l,h]);\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\nconstraint forall(i in ROOM)\n                 (exists(r in ROT where shape[i,r] != {})\n                        (shapes[kind[i]] = shape[i,r]));\n\n\noutput [\"rect_size = \\(rect_size);\\nrect_offset = \\(rect_offset);\\n\"] ++\n       [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];\n\n\n\nModel 3 : \n\n\nint: n; % number of rooms\nset of int: ROOM = 1..n;\nint: m; % number of rectangle/offsets\nset of int: ROFF = 1..m;\narray[ROFF,1..4] of int: d; % defns\nset of int: ROT = 1..4;\narray[ROOM,ROT] of set of ROFF: shape;\nint: h; % height of roll\nint: maxl; % maximum length of roll\n\nn = 3; m = 7;\nd = [| 0,0,3,4  % (xoffset,yoffset,xsize,ysize)\n    | 0,1,4,3\n    | 1,4,1,1\n    | 3,1,1,2\n    | 4,2,1,1\n    | 1,0,2,1 \n    | 0,0,4,3 |];\nshape = [| {1,3,4}, {2,5,6}, {}, {}\n         | {1,3,4}, {2,5,6}, {}, {}\n         | {1}, {7}, {}, {}  |];\nh = 7; maxl = 12;\n\n\narray[ROOM] of var 0..maxl: x;\narray[ROOM] of var 0..h: y;\n\nset of int: SHAPE = 1..4;\narray[ROOM] of var SHAPE: kind;\n\nconstraint geost_bb(2,\n       [| 3,4 | 4,3 | 1,1 | 1,2 | 1,1 | 2,1 | 4,3 |],\n       [| 0,0 | 0,1 | 1,4 | 3,1 | 4,2 | 1,0 | 0,0 |],\n       [ {1,3,4}, {2,5,6}, {1}, {7} ],\n       [| x[1], y[1] | x[2],y[2] | x[3],y[3] |],\n       kind,\n       [ 0,0 ],\n       [ l, h]);\n\nconstraint kind[1] in {1,2};\nconstraint kind[2] in {1,2};\nconstraint kind[3] in {3,4}; \ninclude \"geost.mzn\";\n\nvar 0..maxl: l; % length of carpet used\n\nsolve minimize l;\n\noutput [\"l = \\(l);\\nx = \\(x);\\ny = \\(y);\\nkind = \\(kind);\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4327, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "34737f83-a5d9-4cd0-a1cd-9ae21f48953a": {"__data__": {"id_": "34737f83-a5d9-4cd0-a1cd-9ae21f48953a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cell_block_source_code", "node_type": "4", "metadata": {}, "hash": "4fc15f4c144f98af7300f7ca0cb30addf907de500681377207a3e364c161d0a3", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\n%constraint forall(p1, p2 in PRISONER where p1 < p2)\n%                 (abs(r[p1] - r[p2]) + abs(c[p1] - c[p2]) > 0); \ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nconstraint forall(p in PRISONER, d in danger where p != d)\n                 ( abs(r[p] - r[d]) + abs(c[p] - c[d]) > 1 );\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];\n\n\n\nModel 2 : \n\nint: k;\nset of int: PRISONER = 1..k;\nint: n;\nset of int: ROW = 1..n;\nint: m;\nset of int: COL = 1..m;\nset of PRISONER: danger;\nset of PRISONER: female;\nset of PRISONER: male = PRISONER diff female;\narray[ROW,COL] of int: cost;\n\n\narray[PRISONER] of var ROW: r;\narray[PRISONER] of var COL: c;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([r[p] * m + c[p] | p in PRISONER]);\n\nfunction var int: \n     manhattan(var int:x1, var int:y1,\n               var int:x2, var int:y2) =\n     abs(x2 - x1) + abs(y2 - y1);\n\nconstraint forall(p in PRISONER, d in danger where p != d) \n                 (manhattan(r[p],c[p],r[d],c[d]) > 1);\n\nconstraint forall(p in female)(r[p] <= (n + 1) div 2);\nconstraint forall(p in male)(r[p] >= n div 2 + 1);\n\nvar int: totalcost = sum(p in PRISONER)(cost[r[p],c[p]]);  \nsolve minimize totalcost;\n \noutput [\"cost = \\(totalcost)\\n\"] ++\n       [ \"Prisoner \\(p) \" ++ if p in female then \"(F)\" else \"(M)\" endif ++ \n         \" in [\\(r[p]),\\(c[p])].\\n\"\n       | p in PRISONER ];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2015, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2a58b22e-0ed9-4e9d-a400-829f4e5ca323": {"__data__": {"id_": "2a58b22e-0ed9-4e9d-a400-829f4e5ca323", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "clique_source_code", "node_type": "4", "metadata": {}, "hash": "191499782517efb15a5ad877a03d3bd026b70e9541c937d3c074840790d0d66e", "class_name": "RelatedNodeInfo"}}, "text": "% Maximum Clique Problem\n\nint: n = 5;\narray[1..n, 1..n] of int: adj =\n    [| 0, 1, 0, 1, 0\n     | 1, 0, 1, 0, 0\n     | 0, 1, 0, 1, 1\n     | 1, 0, 1, 0, 1\n     | 0, 0, 1, 1, 0 |];\n\n% --- naive model ---\n\n% decision variables: which vertices are in the clique?\narray[1..n] of var bool: c;\nvar int: size;\n\n% how many vertices have we selected?\nconstraint size = sum(c);\n\n% we can only pick one of any non-adjacent pair of vertices\nconstraint forall (i, j in 1..n where i < j /\\ 0 == adj[i,j]) (bool2int(c[i]) + bool2int(c[j]) <= 1);\n\nsolve maximize size;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 551, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "842d379a-a769-4264-991a-1f95df77375e": {"__data__": {"id_": "842d379a-a769-4264-991a-1f95df77375e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cluster_source_code", "node_type": "4", "metadata": {}, "hash": "67131cd9c129c6bfc8bbc633c57c40c04d10e4239f7f528a603137893efd1800", "class_name": "RelatedNodeInfo"}}, "text": "int: n; % points to be clustered\nset of int: POINT = 1..n;\narray[POINT,POINT] of int: dist; % distance between two points\nint: maxdist = max([ dist[i,j] | i,j in POINT]);\n\n\nint: k; % number of clusters\nset of int: CLUSTER = 1..k;\n\nint: maxdiam;\n\narray[POINT] of var CLUSTER: x;\n\nconstraint forall(i,j in POINT where i < j /\\ x[i] = x[j])\n                 (dist[i,j] <= maxdiam);\n\nconstraint forall(i in 1..k-1)\n                 (  min([ j | j in POINT where x[j] = i])\n                  < min([ j | j in POINT where x[j] = i+1]));\n\nvar 0..maxdist: obj = min( i,j in POINT where i < j )\n                         ( dist[i,j] + maxdist * (x[i] != x[j]) );\n\ninclude \"value_precede_chain.mzn\";\nconstraint value_precede_chain([ i | i in 1..k ],x);\n\nsolve maximize obj;\n\noutput [\"obj = \\(obj); x = \\(x)\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 800, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d7edd124-9eb7-4ccf-9ac1-0a8ca24e1664": {"__data__": {"id_": "d7edd124-9eb7-4ccf-9ac1-0a8ca24e1664", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "compatible_assignment_source_code", "node_type": "4", "metadata": {}, "hash": "58ea845d93ce8e1a5bf83c9943448c341f339001c432b96202c51f86eaea7939", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(task);\nconstraint forall(w1, w2 in W)\n                 (task[w1] != m /\\ task[w2] = task[w1] + 1 ->\n                   compatible[w1,w2]);\n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ \"task = \\(task)\\n\" ] ;\n\n\nModel 2 : \n\n\nint: n;\nset of int: W = 1..n;\nint: m;\nset of int: T = 1..2*m;\narray[W,T] of int: profit;\narray[W,W] of bool: compatible;\n\narray[W] of var T: task;\narray[T] of var opt W: worker;\n\nconstraint inverse(task,worker);\nconstraint forall(t in T where t mod m != 0)\n                 (compatible[worker[t],worker[t+1]]);\n           \n\nsolve maximize sum(w in W)(profit[w,task[w]]);\n\noutput [ if fix(occurs(worker[t])) then show(worker[t]) else \" \" endif ++ \" \"\n       | t in T ] \n       ++ [ show(task), \"\\n\" ]\n       ;\n\npredicate inverse(array[int] of var opt int: f, array[int] of var opt int: g) = \n          forall(i in index_set(f), j in index_set(g))\n                (occurs(f[i]) /\\ occurs(g[j]) ->\n                 (deopt(f[i]) = j <-> deopt(g[j]) = i));", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1198, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "57ccf9ed-0b34-4d4d-b321-a85e7d6a3e3d": {"__data__": {"id_": "57ccf9ed-0b34-4d4d-b321-a85e7d6a3e3d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "constrained_connected_source_code", "node_type": "4", "metadata": {}, "hash": "77ba4d2f4e124f7aca0ff7a9e0e8aec5cb1f2774b07d196d7d7d841208cb6350", "class_name": "RelatedNodeInfo"}}, "text": "% constrained clustering \n% Pick a maximal subset of edges so that no two nodes\n% given by the pairs (first[i],second[i]) \n% are connected.\n\nint: n;\nset of int: NODE = 1..n;\nint: m;\nset of int: EDGE = 1..m;\narray[EDGE] of NODE: pre;\narray[EDGE] of NODE: suc;\nint: d;\nset of int: DPAIR = 1..d;\narray[DPAIR] of NODE: first;\narray[DPAIR] of NODE: second;\n\nvar set of EDGE: selected;\n% a representative for each cluster\narray[NODE] of var NODE: rep;\n\n%constraint forall(e in selected)\n%                 (rep[pre[e]] = rep[suc[e]]);\nconstraint forall(e in EDGE)\n                 (e in selected -> rep[pre[e]] = rep[suc[e]]);\n\nconstraint forall(d in DPAIR)\n                 (rep[first[d]] != rep[second[d]]);\n\nsolve maximize card(selected);\n\noutput [ \"(\" ++ show(pre[e]) ++ \",\" ++ show(suc[e]) ++ \")\\n\"\n       | e in fix(selected) ]\n       ++ [show(rep),\"\\n\"]\n       ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 862, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cf002e9b-346a-4dff-bb34-3339463af5ab": {"__data__": {"id_": "cf002e9b-346a-4dff-bb34-3339463af5ab", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crazy_sets_source_code", "node_type": "4", "metadata": {}, "hash": "8894c975225d73dfa761d9064e0e30147dac1de6880bc4445d1e299191bcfe5d", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m] of var set of NUMBER: s;\n\nconstraint forall(i,j,k in 1..m where i < j /\\ j < k)\n     ( s[i] intersect s[j] intersect s[k] = {} );\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\nconstraint forall(i in 1..m, o in NUMBER)\n      (o in s[i] \n       -> exists(j in 1..c)(x[i,j] = o));\nconstraint forall(i in 1..m, j in 1..c)(x[i,j] in s[i]);\n\nsolve satisfy;\n\noutput [show(s)];\n\nn = 10;\nc = 4;\nm = 4;\n\n\n\nModel 2 : \n\n\nint: n; % maximum value\nset of int: NUMBER = 1..n;\nint: c; % cardinality of sets\nint: m; % number of sets\n\n\narray[1..m,1..c] of var NUMBER: x;\nconstraint forall(i in 1..m, j in 1..c-1)\n      ( x[i,j] < x[i,j+1] );\n\n\nconstraint forall(i in 1..m-1, j in 1..c)\n      ( x[i,j] < x[i+1,j] );\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint global_cardinality_low_up( [ x[i,j] | i in 1..m, j in 1..c ],\n                              [ i | i in 1..n ],\n                              [ 0 | i in 1..n ],\n                              [ 2 | i in 1..n ]);\n\n\nsolve satisfy;\n\n   output [ if j = 1 then \"{\" else \"\" endif ++\n   show(x[i,j])\n   ++ if j = c then \"}\" else \", \" endif\n   ++ if j = c /\\ i < m then \", \" else \"\" endif\n   | i in 1..m, j in 1..c ];\n   \n\nn = 10;\nc = 4;\nm = 4;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1451, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "57c899ba-fa7c-4cb5-acd8-853f6de9f590": {"__data__": {"id_": "57c899ba-fa7c-4cb5-acd8-853f6de9f590", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crossfigure_source_code", "node_type": "4", "metadata": {}, "hash": "53578072276a0c5d807b4ce76b734386587fbfc4f82f4afc42a3bddfb9bdaddb", "class_name": "RelatedNodeInfo"}}, "text": "% Crossfigure problem in MiniZinc.\n% \"\"\"\n% Crossfigures are the numerical equivalent of crosswords. You have a grid and some\n% clues with numerical answers to place on this grid. Clues come in several different\n% forms (for example: Across 1. 25 across times two, 2. five dozen, 5. a square number,\n% 10. prime, 14. 29 across times 21 down ...).\n% \"\"\"\n\n\nint: n = 9;\narray[1..n, 1..n] of var 0..9: M;\n\nset of int: D = 0..9999; % the max length of the numbers in this problem is 4\nvar D: A1;\nvar D: A4;\nvar D: A7;\nvar D: A8;\nvar D: A9;\nvar D: A10;\nvar D: A11;\nvar D: A13;\nvar D: A15;\nvar D: A17;\nvar D: A20;\nvar D: A23;\nvar D: A24;\nvar D: A25;\nvar D: A27;\nvar D: A28;\nvar D: A29;\nvar D: A30;\n\nvar D: D1;\nvar D: D2;\nvar D: D3;\nvar D: D4;\nvar D: D5;\nvar D: D6;\nvar D: D10;\nvar D: D12;\nvar D: D14;\nvar D: D16;\nvar D: D17;\nvar D: D18;\nvar D: D19;\nvar D: D20;\nvar D: D21;\nvar D: D22;\nvar D: D26;\nvar D: D28;\n\n\n%\n% across(Matrix, Across, Len, Row, Col)\n%\tConstrains 'Across' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding across.\n%\npredicate across(array[int, int] of var D: Matrix, var D: Across, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Across)\n   /\\\n   forall(i in 0..Len-1) (\n\n       Matrix[Row,Col+i] = tmp[i+1]\n   )\n;\n\n%\n% down(Matrix, Down, Len, Row, Col):\n%\tConstrains 'Down' to be equal to the number represented by the\n%\t'Len' digits starting at position (Row, Col) of the array 'Matrix'\n%\tand proceeding down.\n%\npredicate down(array[int,int] of var D: Matrix, var D: Down, int: Len, int: Row, int: Col) =\n   let {\n     array[1..Len] of var D: tmp\n   }\n   in\n   toNum10(tmp, Down)\n   /\\\n   forall(i in 0..Len-1) (\n      Matrix[Row+i,Col] = tmp[i+1]\n   )\n;\n\n\n%\n% converts a number <-> array\n%\npredicate toNum10(array[int] of var D: a, var D: n) =\n          let { int: len = length(a) }\n          in\n          n = sum(i in 1..len) (\n            ceil(pow(10.0, int2float(len-i))) * a[i]\n          )\n          /\\ forall(i in 1..len) (a[i] >= 0)\n;\n\n\n%\n% x is a square\n% \npredicate square(var D: x) =\n   exists(y in D) (\n      y*y = x\n   )\n;\n\n\n%\n% very simple primality test\n%\npredicate is_prime(var int: x) =\n   forall(i in 2..ceil(sqrt(9999.0))) ( \n        (i < x) -> (x mod i > 0)\n   )\n;\n\n\nsolve :: int_search(\n         [M[i,j] | i,j in 1..n] ++\n         [A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n         D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28],\n         occurrence,\n         indomain_min,\n         complete\n         ) \n     satisfy;\n\n\nconstraint\n\n   % Set up the constraints between the matrix elements and the\n   % clue numbers.\n   across(M, A1, 4, 1, 1)  /\\ \n   across(M, A4, 4, 1, 6)  /\\ \n   across(M, A7, 2, 2, 1)  /\\ \n   across(M, A8, 3, 2, 4)  /\\ \n   across(M, A9, 2, 2, 8)  /\\ \n   across(M, A10, 2, 3, 3) /\\ \n   across(M, A11, 2, 3, 6) /\\ \n   across(M, A13, 4, 4, 1) /\\ \n   across(M, A15, 4, 4, 6) /\\ \n   across(M, A17, 4, 6, 1) /\\ \n   across(M, A20, 4, 6, 6) /\\ \n   across(M, A23, 2, 7, 3) /\\ \n   across(M, A24, 2, 7, 6) /\\ \n   across(M, A25, 2, 8, 1) /\\ \n   across(M, A27, 3, 8, 4) /\\ \n   across(M, A28, 2, 8, 8) /\\ \n   across(M, A29, 4, 9, 1) /\\ \n   across(M, A30, 4, 9, 6) /\\ \n\n   down(M, D1, 4, 1, 1)  /\\ \n   down(M, D2, 2, 1, 2)  /\\ \n   down(M, D3, 4, 1, 4)  /\\ \n   down(M, D4, 4, 1, 6)  /\\ \n   down(M, D5, 2, 1, 8)  /\\ \n   down(M, D6, 4, 1, 9)  /\\ \n   down(M, D10, 2, 3, 3) /\\ \n   down(M, D12, 2, 3, 7) /\\ \n   down(M, D14, 3, 4, 2) /\\ \n   down(M, D16, 3, 4, 8) /\\ \n   down(M, D17, 4, 6, 1) /\\ \n   down(M, D18, 2, 6, 3) /\\ \n   down(M, D19, 4, 6, 4) /\\ \n   down(M, D20, 4, 6, 6) /\\ \n   down(M, D21, 2, 6, 7) /\\ \n   down(M, D22, 4, 6, 9) /\\ \n   down(M, D26, 2, 8, 2) /\\ \n   down(M, D28, 2, 8, 8) /\\ \n\n\n   % Set up the clue constraints.\n%  Across\n%  1 27 across times two\n%  4 4 down plus seventy-one\n%  7 18 down plus four\n%  8 6 down divided by sixteen\n%  9 2 down minus eighteen\n% 10 Dozen in six gross\n% 11 5 down minus seventy\n% 13 26 down times 23 across\n% 15 6 down minus 350\n% 17 25 across times 23 across\n% 20 A square number\n% 23 A prime number\n% 24 A square number\n% 25 20 across divided by seventeen\n% 27 6 down divided by four\n% 28 Four dozen\n% 29 Seven gross\n% 30 22 down plus 450 \n\n   A1 = 2 * A27         /\\ \n   A4 = D4 + 71         /\\ \n   A7 = D18 + 4         /\\ \n   A8 = D6 div 16       /\\ \n   A9 = D2 - 18         /\\ \n   A10 = 6 * 144 div 12 /\\ \n   A11 = D5 - 70        /\\ \n   A13 = D26 * A23      /\\ \n   A15 = D6 - 350       /\\ \n   A17 = A25 * A23      /\\ \n   square(A20)          /\\ \n   is_prime(A23)        /\\\n   square(A24)          /\\ \n   A25 = A20 div 17     /\\ \n   A27 = D6 div 4       /\\ \n   A28 = 4 * 12         /\\ \n   A29 = 7 * 144        /\\ \n   A30 = D22 + 450      /\\ \n\n   % Down\n   %\n   %  1 1 across plus twenty-seven\n   %  2 Five dozen\n   %  3 30 across plus 888\n   %  4 Two times 17 across\n   %  5 29 across divided by twelve\n   %  6 28 across times 23 across\n   % 10 10 across plus four\n   % 12 Three times 24 across\n   % 14 13 across divided by sixteen\n   % 16 28 down times fifteen\n   % 17 13 across minus 399\n   % 18 29 across divided by eighteen\n   % 19 22 down minus ninety-four\n   % 20 20 across minus nine\n   % 21 25 across minus fifty-two\n   % 22 20 down times six\n   % 26 Five times 24 across\n   % 28 21 down plus twenty-seven \n\n   D1 = A1 + 27     /\\ \n   D2 = 5 * 12      /\\ \n   D3 = A30 + 888   /\\ \n   D4 = 2 * A17     /\\ \n   D5 = A29 div 12  /\\ \n   D6 = A28 * A23   /\\ \n   D10 = A10 + 4    /\\ \n   D12 = A24 * 3    /\\ \n   D14 = A13 div 16 /\\ \n   D16 = 15 * D28   /\\ \n   D17 = A13 - 399  /\\ \n   D18 = A29 div 18 /\\ \n   D19 = D22 - 94   /\\ \n   D20 = A20 - 9    /\\ \n   D21 = A25 - 52   /\\ \n   D22 = 6 * D20    /\\ \n   D26 = 5 * A24    /\\ \n   D28 = D21 + 27\n\n\n   % Fix the blackboxes\n   /\\\n   M[1,5] = 0 /\\\n   M[2,3] = 0 /\\\n   M[2,7] = 0 /\\\n   M[3,2] = 0 /\\\n   M[3,5] = 0 /\\\n   M[3,8] = 0 /\\\n   M[4,5] = 0 /\\\n   M[5,1] = 0 /\\\n   M[5,3] = 0 /\\\n   M[5,4] = 0 /\\\n   M[5,5] = 0 /\\\n   M[5,6] = 0 /\\\n   M[5,7] = 0 /\\\n   M[5,9] = 0 /\\\n   M[6,5] = 0 /\\\n   M[7,2] = 0 /\\\n   M[7,5] = 0 /\\\n   M[7,8] = 0 /\\\n   M[8,3] = 0 /\\\n   M[8,7] = 0 /\\\n   M[9,5] = 0\n;\n\n\noutput [\n show([A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30,\n       D1,D2,D3,D4,D5,D6,D10,D12,D14,D16,D17,D18,D19,D20,D21,D22,D26,D28]), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(M[i,j])\n  | i,j  in 1..n\n] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 6458, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2b9db7b9-0ec6-4122-8681-a948c0c47489": {"__data__": {"id_": "2b9db7b9-0ec6-4122-8681-a948c0c47489", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "curriculum_source_code", "node_type": "4", "metadata": {}, "hash": "ab5f75d8d0e9d0f2e68186eb9b91c04c9e3ba342e5d57b98e2fde0c92a94fe57", "class_name": "RelatedNodeInfo"}}, "text": "% The balanced academic curriculum problem:\n%\n% A curriculum is a set of courses with prerequisites.\n% Each course must be assigned within a set number of periods.\n% A course cannot be scheduled before its prerequisites.\n% Each course confers a number of academic credits (it's \"load\").\n% Students have lower and upper bounds on the number of credits they can study for in a given period.\n% Students have lower and upper bounds on the number of courses they can study for in a given period.\n% The goal is to assign a period to every course satisfying these criteria, minimising the load for all periods.\n\ninclude \"globals.mzn\";\n\nint: n_courses;\nint: n_periods;\nint: load_per_period_lb;\nint: load_per_period_ub;\nint: courses_per_period_lb;\nint: courses_per_period_ub;\narray [1..n_courses] of int: course_load;\nint: max_course_load = sum(c in courses)(course_load[c]);\n\nset of int: courses = 1..n_courses;\nset of int: periods = 1..n_periods;\n\n% period course is assigned to\narray [courses] of var periods: course_period;\n% whether period i has course j assigned\narray [periods, courses] of var 0..1: x;\n% total load for each period\narray [periods] of var load_per_period_lb..load_per_period_ub: load;\n% optimisation target\nvar load_per_period_lb..load_per_period_ub: objective;\n\nconstraint forall(p in periods) (\n    forall(c in courses) (x[p,c] = bool2int(course_period[c] = p)) /\\\n    sum(i in courses) (x[p,i]) >= courses_per_period_lb /\\\n    sum(i in courses) (x[p,i]) <= courses_per_period_ub /\\\n    load[p] = sum(c in courses) (x[p,c] * course_load[c]) /\\\n    load[p] >= load_per_period_lb /\\\n    load[p] <= objective\n);\n\n% prerequisite(a, b) means \"course a has prerequisite course b\".\n\npredicate prerequisite(courses: a, courses: b) =\n    course_period[b] < course_period[a];\n\n% add some redundant linear constraints\n\nconstraint forall(p in 0..n_periods-1) (\n    let {\n\t\tvar 0..max_course_load: l = sum(c in courses) (bool2int(course_period[c] > p) * course_load[c])\n\t} in \n        l >= (n_periods-p) * load_per_period_lb /\\\n        l <= (n_periods-p) * objective\n    );\n\nsolve :: seq_search([\n      int_search([x[i,j] | i in periods, j in courses], input_order, indomain_max, complete),\n      int_search([objective], input_order, indomain_min, complete)\n    ]) minimize objective;\n\noutput \n    [show(c) ++ \"-\" ++ show(course_period[c]) ++ \"\\t\" | c in courses ] ++ [\"\\n\"] ++\n    [\"objective = \", show(objective)];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2419, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1e81a748-90f5-48a9-8d14-ce0924ae6357": {"__data__": {"id_": "1e81a748-90f5-48a9-8d14-ce0924ae6357", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "diamond_free_degree_sequence_source_code", "node_type": "4", "metadata": {}, "hash": "d622cb27b47bc48df2c53ca42e80942779a2c382a2cd6ad6747ae532df8ec473", "class_name": "RelatedNodeInfo"}}, "text": "%\n% Diamond-free Degree Sequence (CSPLib #50) in MiniZinc.\n%\n% Given a simple undirected graph G=(V,E), where V is the set of vertices and E the set of\n% undirected edges, the edge {u,v} is in E if and only if vertex u is adjacent to vertex v\u2208G.\n% The graph is simple in that there are no loop edges, i.e. we have no edges of the form {v,v}.\n% Each vertex v\u2208V has a degree dv i.e. the number of edges incident on that vertex. Consequently\n% a graph has a degree sequence d1,\u2026,dn, where di>=di+1. A diamond is a set of four vertices\n% in V such that there are at least five edges between those vertices. Conversely, a graph is\n% diamond-free if it has no diamond as an induced subgraph, i.e. for every set of four vertices\n% the number of edges between those vertices is at most four.\n%\n% In our problem we have additional properties required of the degree sequences of the graphs,\n% in particular that the degree of each vertex is greater than zero (i.e. isolated vertices\n% are disallowed), the degree of each vertex is modulo 3, and the sum of the degrees is\n% modulo 12 (i.e. |E| is modulo 6).\n%\n% The problem is then for a given value of n, produce all unique degree sequences d1,\u2026,dn such\n% that\n%\n%  * di\u2265di+1\n%  * each degree di>0 and di is modulo 3\n%  * the sum of the degrees is modulo 12\n%  * there exists a simple diamond-free graph with that degree sequence\n\n\ninclude \"globals.mzn\"; \n\nint: n = 11;\n\n% decision variables\narray[1..n,1..n] of var 0..1: x;\narray[1..n] of var 1..n: degrees;\n\n\n% solve satisfy;\nsolve :: int_search(degrees, first_fail, indomain_split, complete) satisfy;\n\nconstraint\n  forall(i,j,k,l in 1..n where i < j /\\ j < k /\\ k < l) (\n     x[i,j] + x[i,k] + x[i,l] + x[j,k] + x[j,l] + x[k,l] <= 4\n  )\n  /\\\n  forall(i in 1..n) (\n     degrees[i] = sum([x[i,j] | j in 1..n])\n     /\\ degrees[i] mod 3 = 0\n     % no loops\n     /\\ x[i,i] = 0\n  ) \n  /\\ % undirected graph\n  forall(i,j in 1..n) (\n    x[i,j] = x[j,i]\n  )\n  /\\ sum(degrees) mod 12 = 0\n\n  % symmetry breaking\n  /\\ decreasing(degrees)\n  /\\ lex2(x)\n;\n\noutput \n[ \"degrees: \", show(degrees), \"\\n\"]\n% ++\n% [\n%   if j = 1 then \"\\n\" else \" \" endif ++\n%     show(x[i,j])\n%   | i,j in 1..n\n% ]\n;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2171, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c8aebc2f-ec6e-4a5c-a4d3-03d01b242c54": {"__data__": {"id_": "c8aebc2f-ec6e-4a5c-a4d3-03d01b242c54", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "doublechannel_source_code", "node_type": "4", "metadata": {}, "hash": "69304361934fb3053e18abf2162ebc133ad7a6791eb642427295986aa792229e", "class_name": "RelatedNodeInfo"}}, "text": "% scheduling ships entering and leaving a port through k channels\nset of int: TYPE = 1..3;\nint: entering = 1;\nint: leaving  = 2;\nint: dummy = 3;\n\nint: nC; % number of channels\nset of int: CHANNEL = 1..nC;\narray[CHANNEL] of int: len;    % length in 100m units\n\nint: nS; % number of ships\nset of int: SHIP = 1..nS; % ships ENTER then LEAVE\nset of int: SHIPE = 1..nS+nC; % ships ENTER then LEAVE then nC dummy ships\n\narray[SHIP] of int: speed;   % time in minutes to traverse 100m\narray[SHIP] of int: desired; % desired time to start to enter/leave \narray[SHIP] of entering..leaving: dirn;   % entering or leaving\n\nint: leeway;  % leeway between 2 ships in 100m units\nint: maxt;    % maximum time\nset of int: TIME = 0..maxt;\n\narray[SHIPE] of var TYPE: kind = dirn ++ [ dummy | i in 1..nC];\narray[SHIPE] of var TIME:    start; % when ships enter the channel \narray[SHIPE] of var TIME:     end; % when ships leave the channel \narray[SHIPE] of var CHANNEL: channel; % which channel a ship is assigned to\n\narray[SHIP] of var SHIPE:   next;  % the next ship in the same channel (or a dummy)\n\n% dummy ships\nconstraint forall(s in nS + 1 .. nS + nC)(start[s] = maxt /\\ end[s] = maxt);\nconstraint forall(s in nS + 1 .. nS + nC)(channel[s] = s - nS);\n\n% relationships between start and ends\nconstraint forall(s in SHIP)(end[s] = start[s] + len[channel[s]]*speed[s]);\n\n\n% the next ship are all different\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(next);\n\n% no clashes in channel\nconstraint forall(s in SHIP)(if kind[s] + kind[next[s]] = entering+leaving then\n                                end[s] <= start[next[s]]\n                             else\n                                start[s] + speed[s]*leeway <= start[next[s]] /\\\n                                end[s] + speed[s]*leeway <= end[next[s]]\n                             endif);\n\n% next ship is in same channel\nconstraint forall(s in SHIP)(channel[next[s]] = channel[s]);\n\nsolve minimize sum(s in SHIP)(abs(start[s] - desired[s]));\n\noutput [ \"start = \",show(start),\n         \";\\nend = \", show(end),\n         \";\\nchannel = \", show(channel),\n         \";\\nnext = \", show(next),\n         \";\\n\" ];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2149, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a327a687-c8ab-47d9-980f-d2388021d622": {"__data__": {"id_": "a327a687-c8ab-47d9-980f-d2388021d622", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fractions_source_code", "node_type": "4", "metadata": {}, "hash": "e2f0e77dbf3d3777e0592a62fb31ed994a8bd10cb5eae56e9ad43e2d8cd6812d", "class_name": "RelatedNodeInfo"}}, "text": "%\n% Fractions problem in MiniZinc.\n%\n% Prolog benchmark problem (BProlog)\n% \"\"\"\n% Find distinct non-zero digits such that the following equation holds:\n%        A        D        G\n%     ------  + ----- + ------  = 1\n%       B*C      E*F      H*I\n\ninclude \"globals.mzn\"; \n\nvar 1..9: A;\nvar 1..9: B;\nvar 1..9: C;\nvar 1..9: D;\nvar 1..9: E;\nvar 1..9: F;\nvar 1..9: G;\nvar 1..9: H;\nvar 1..9: I;\narray[1..9] of var 1..9: Vars=[A,B,C,D,E,F,G,H,I];\n\nvar 1..81: D1;\nvar 1..81: D2;\nvar 1..81: D3;\n\n\n\n% solve satisfy;\nsolve :: int_search(Vars ++ [D1,D2,D3], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   all_different(Vars) /\\\n   D1 = 10*B+C /\\\n   D2 = 10*E+F /\\\n   D3 = 10*H+I /\\\n   A*D2*D3 + D*D1*D3 + G*D1*D2 = D1*D2*D3 /\\\n   % break the symmetry\n   A*D2 >= D*D1 /\\\n   D*D3 >= G*D2 /\\\n   %redundant constraints\n   3*A >= D1 /\\\n   3*G <= D2\n\n;\n\noutput [\n  show(Vars), \"\\n\"\n]\n;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 881, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "414f3da4-7e02-4ea6-a587-5ab31d8e144f": {"__data__": {"id_": "414f3da4-7e02-4ea6-a587-5ab31d8e144f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golfers_source_code", "node_type": "4", "metadata": {}, "hash": "b8171cdffd86c62f6395c905c18374f3ffdccfc51d6747aa06d6363852ab123f", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n\n% The social golfers problem\n% A club has a number of golfers that play rounds in groups (the number of\n% golfers is a multiple of the number of groups).  Each round, a golfer\n% plays with a group of different people, such that the same pair of golfers\n% never play together twice.\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\nset of int: places = 1..n_golfers;\n\narray [rounds, places] of var golfers: round_place_golfer;\narray [golfers, golfers] of var 0..n_rounds: golfer_golfer_round;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (p in places) (round_place_golfer[r, p])\n    );\n\n    % Break some symmetry by strictly ordering each group in each round.\n    %\nconstraint\n    forall (r in rounds, p in places) (\n        if p mod n_per_group != 0\n        then round_place_golfer[r, p] < round_place_golfer[r, p + 1]\n        else true\n        endif\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (r in rounds, g in 0..(n_groups - 1), i, j in 1..n_per_group\n            where i < j) (\n        golfer_golfer_round[\n            round_place_golfer[r, n_per_group * g + i],\n            round_place_golfer[r, n_per_group * g + j]\n        ] = r\n    );\n\nsolve\n    :: int_search([round_place_golfer[r, p] | r in rounds, p in places],\n        first_fail, indomain_min, complete)\n    satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if p = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif ) ++\n    ( if p mod n_per_group = 1 then \"   \" else \" \" endif ) ++\n    show_int(2, round_place_golfer[r, p]) | r in rounds, p in places\n];\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups, group] of var golfers: round_group_i_golfer;\n\n    % Each member of each group must be distinct.\n    %\nconstraint\n    forall (r in rounds) (\n        alldifferent (g in groups, i in group) (round_group_i_golfer[r, g, i])\n    );\n\n    % We also break some symmetry\n    % here by strictly ordering each group.\n    %\nconstraint\n    forall (r in rounds, g in groups, i in group where i < n_per_group) (\n        round_group_i_golfer[r, g, i] < round_group_i_golfer[r, g, i + 1]\n    );\n\n    % Each pair can play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups, i, j in group where i < j) (\n            bool2int(\n                round_group_i_golfer[r, g, i] = a\n            /\\  round_group_i_golfer[r, g, j] = b\n            )\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [\n    \"Social golfers:\\n\\n\", \n    \"Groups        : \", show(n_groups), \"\\n\", \n    \"No. per group : \", show(n_per_group), \"\\n\",\n    \"No. of rounds : \", show(n_rounds), \"\\n\"\n] ++ [\n    ( if g = 1 /\\ i = 1 then \"\\nround \" ++ show(r) ++ \":\" else \"\" endif) ++\n    ( if i = 1 then \"   \" else \" \" endif) ++\n    show_int(2, round_group_i_golfer[r, g, i]) \n    |  r in rounds, g in groups, i in group\n];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n\nint: n_groups;                          % The number of groups.\nint: n_per_group;                       % The size of each group.\nint: n_rounds;                          % The number of rounds.\n\nint: n_golfers = n_groups * n_per_group;\n\nset of int: groups = 1..n_groups;\nset of int: group = 1..n_per_group;\nset of int: rounds = 1..n_rounds;\nset of int: golfers = 1..n_golfers;\n\narray [rounds, groups] of var set of golfers: round_group_golfers;\n\n    % Each group has to have the right size.\n    %\nconstraint\n    forall (r in rounds, g in groups) (\n        card(round_group_golfers[r, g]) = n_per_group\n    );\n\n    % Each group in each round has to be disjoint.\n    %\nconstraint\n    forall (r in rounds) (\n        all_disjoint (g in groups) (round_group_golfers[r, g])\n    );\n\n    % Symmetry breaking.\n    %\n% constraint\n%     forall (r in rounds, g in groups where g < n_groups) (\n%         round_group_golfers[r, g] < round_group_golfers[r, g + 1]\n%     );\n\n    % Each pair may play together at most once.\n    %\nconstraint\n    forall (a, b in golfers where a < b) (\n        sum (r in rounds, g in groups) (\n            bool2int({a, b} subset round_group_golfers[r, g])\n        )\n    <=\n        1\n    );\n\nsolve satisfy;\n\noutput [    ( if   g = 1\n              then \"\\nround \" ++ show(r) ++ \":   \"\n              else \"   \"\n              endif\n            ) ++\n            show(round_group_golfers[r, g])\n       |    r in rounds, g in groups\n       ];\n\n\nModel 4 :\n\n\nint: weeks = 4;\nint: groups = 3;\nint: groupSize = 3;\nint: golfers = groups * groupSize;\n\nset of int: Golfer = 1..golfers;\nset of int: Week = 1..weeks;\nset of int: Group = 1..groups;\n\n% Search space: The set of all possible group assignments to all \n% players in each of the weeks\narray[Golfer, Week] of var Group: assign;\n\n% solve satisfy;\n% solve :: int_search([assign[i,j] | i in Golfer, j in Week ], \"first_fail\", \"indomain\", \"complete\") satisfy;\nsolve :: int_search([assign[i,j] | i in Golfer, j in Week ], \n        first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   % C1: Each group has exactly groupSize players\n   forall (gr in Group, w in Week)( % c1\n     sum (g in Golfer) (bool2int(assign[g,w] = gr)) = groupSize\n   )\n   /\\\n   % C2: Each pair of players only meets at most once\n   forall (g1, g2 in Golfer, w1, w2 in Week  where g1 != g2 /\\ w1 != w2) (\n     (bool2int(assign[g1,w1] = assign[g2,w1]) + bool2int(assign[g1,w2] = assign[g2,w2])) <= 1\n   )\n  /\\\n  % SBSA: Symmetry-breaking by selective assignment\n  % On the first week, the first groupSize golfers play in group 1, the \n  % second groupSize golfers play in group 2, etc. On the second week, \n  % golfer 1 plays in group 1, golfer 2 plays in group 2, etc.\n  forall(g in Golfer) (\n    assign[g,1]=((g-1) div groupSize) + 1 % \n  )\n  /\\\n  forall(g in Golfer where g <= groupSize)(\n    assign[g,2]=g\n  )\n\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n  show(assign[i,j])\n  | i in Golfer, j in Week\n] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 6751, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "00b794a2-70f8-4409-a5d7-f9f229dffccb": {"__data__": {"id_": "00b794a2-70f8-4409-a5d7-f9f229dffccb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golomb_source_code", "node_type": "4", "metadata": {}, "hash": "a7ad24592f8118cd6ea3762363721d35aece8d9767a98bf572bc0e99305eb7bd", "class_name": "RelatedNodeInfo"}}, "text": "% Golomb rulers\n% From csplib:\n% A Golomb ruler may be defined as a set of m integers 0 = a_1 < a_2 <\n% ... < a_m such that the m(m-1)/2 differences a_j - a_i, 1 <= i < j\n% <= m are distinct. Such a ruler is said to contain m marks and is of\n% length a_m. The objective is to find optimal (minimum length) or\n% near optimal rulers.\n%\n% This is the \"ternary constraints and an alldifferent\" model\n\ninclude \"globals.mzn\";\n\nint: m;\nint: n = m*m;\n\narray[1..m] of var 0..n: mark;\n\narray[1..(m*(m-1)) div 2] of var 0..n: differences =\n    [ mark[j] - mark[i] | i in 1..m, j in i+1..m];\n\nconstraint mark[1] = 0;\n\nconstraint forall ( i in 1..m-1 ) ( mark[i] < mark[i+1] );\n\nconstraint alldifferent(differences);\n\n    % Symmetry breaking\nconstraint differences[1] < differences[(m*(m-1)) div 2];\n\nsolve :: int_search(mark, input_order, indomain, complete)\n    minimize mark[m];\n\noutput [show(mark)];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1051, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1edcda41-2027-40d6-a5d8-7eb833317eaa": {"__data__": {"id_": "1edcda41-2027-40d6-a5d8-7eb833317eaa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "graph_source_code", "node_type": "4", "metadata": {}, "hash": "ac56a03adfbff370bebbd1d7056ebfad8858c7bfd58d26ecf31f33ad510b2b13", "class_name": "RelatedNodeInfo"}}, "text": "% a strange graph numbering problem\nvar 1..8: a;\nvar 1..8: b;\nvar 1..8: c;\nvar 1..8: d;\nvar 1..8: e;\nvar 1..8: f;\nvar 1..8: g;\nvar 1..8: h;\n\n% Each number is used exactly once\nconstraint a != b;\nconstraint a != c;\nconstraint a != d;\nconstraint a != e;\nconstraint a != f;\nconstraint a != g;\nconstraint a != h;\nconstraint b != c;\nconstraint b != d;\nconstraint b != e;\nconstraint b != f;\nconstraint b != g;\nconstraint b != h;\nconstraint c != d;\nconstraint c != e;\nconstraint c != f;\nconstraint c != g;\nconstraint c != h;\nconstraint d != e;\nconstraint d != f;\nconstraint d != g;\nconstraint d != h;\nconstraint e != f;\nconstraint e != g;\nconstraint e != h;\nconstraint f != g;\nconstraint f != h;\nconstraint g != h;\n\n% Adjacent vertices differ by at most two\nconstraint abs(a - b) >= 2;\nconstraint abs(a - c) >= 2;\nconstraint abs(a - d) >= 2;\nconstraint abs(b - c) >= 2;\nconstraint abs(b - e) >= 2;\nconstraint abs(b - f) >= 2;\nconstraint abs(c - d) >= 2;\nconstraint abs(c - e) >= 2;\nconstraint abs(c - f) >= 2;\nconstraint abs(c - g) >= 2;\nconstraint abs(d - f) >= 2;\nconstraint abs(d - g) >= 2;\nconstraint abs(e - f) >= 2;\nconstraint abs(e - h) >= 2;\nconstraint abs(f - g) >= 2;\nconstraint abs(f - h) >= 2;\nconstraint abs(g - h) >= 2;\n\nsolve satisfy;\n\noutput [\"  \\(b)-\\(e)\\n\",\n        \" /|*|\\\\\\n\",\n        \"\\(a)-\\(c)-\\(f)-\\(h)\\n\",\n        \" \\\\|*|/\\n\",\n        \"  \\(d)-\\(g)\\n\"] ++\n       [\"\\na = \\(a); b = \\(b); c = \\(c); d = \\(d);\",\n        \" e = \\(e); f = \\(f); g = \\(g); h = \\(h);\\n\"]", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1478, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d4e103bd-89fe-47bf-80b1-edc0e32cdf74": {"__data__": {"id_": "d4e103bd-89fe-47bf-80b1-edc0e32cdf74", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "itemset_mining_source_code", "node_type": "4", "metadata": {}, "hash": "1fe4261e5e77dc730351b6e8ef13f9a4c92cbaff00ab0beee97e9e9ff1e607b9", "class_name": "RelatedNodeInfo"}}, "text": "int : NrI ; \nint : NrT ; \nint : Freq ;\narray [ 1..NrT ] of set of 1..NrI : TDB;\nvar set of 1..NrI : Items ;\nconstraint card ( cover ( Items ,TDB ) ) >= Freq ;\nsolve satisfy ; \n\nfunction var set of int : cover (\n         var set of int : Items ,\n         array [ int ] of var set of int : D) = \n         let {\n                          var set of index_set (D): Trans ;\n                          constraint forall ( t in index_set (D) )\n                          ( t in Trans <-> Items subset D[ t ] );\n         } in Trans;\n\narray[1.. NrI] of int: itemprice;\nint: minUtility;\n\nconstraint sum(i in Items)(itemprice[i]) >= minUtility;\n\nNrI = 6;\nint: bread = 1;\nint: butter = 2;\nint: cheese = 3;\nint: cocoa = 4;\nint: milk = 5;\nint: vegemite = 6;\narray[1..NrI] of string: name = [\"bread\",\"butter\",\"cheese\",\"cocoa\",\"milk\",\"vegemite\"];\nitemprice = [1,2,1,2,1,1];\n\nNrT = 7;\nTDB = [ { butter, cheese, milk, vegemite },\n        { butter, cocoa, milk, vegemite },\n\t{ bread, cocoa, cheese, milk },\n\t{ bread, butter, cheese, vegemite }, \n\t{ bread, cheese, milk, vegemite },\n\t{ bread, butter, cheese, cocoa, milk },\n\t{ bread, cheese, milk }];\n\nFreq = 4;\nminUtility = 3;\n\noutput [ name[i] ++ \" \" | i in fix(Items) ];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1201, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cc3d5f6c-4087-4fb9-8c4f-c86f4879f7b6": {"__data__": {"id_": "cc3d5f6c-4087-4fb9-8c4f-c86f4879f7b6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "jobshop_source_code", "node_type": "4", "metadata": {}, "hash": "cf6adca83700b4dce9328f3269f07782053a326dfcb8f4480b167ee99ce3949b", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\n% only one task on any machine at one time\n%constraint forall(ma in MACH)\n%                 (forall(j1,j2 in JOB where j1 < j2)\n%                       (forall(t1,t2 in TASK where mc[j1,t1] = ma /\\ mc[j2,t2] = ma)\n%                              (nonoverlap(s[j1,t1],d[j1,t1],s[j2,t2],d[j2,t2]))));\n\nconstraint forall(j1, j2 in JOB, t1, t2 in TASK \n       where j1 < j2 /\\ mc[j1,t1] = mc[j2,t2])\n      (nonoverlap(s[j1,t1],d[j1,t1],\n                  s[j2,t2],d[j2,t2]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve :: int_search([s[j,t] | j in JOB, t in TASK], input_order, indomain_min, complete)\n      minimize makespan;\n\noutput [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 2 : \n\n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n   %:: int_search([s[j,t]|j in JOB,t in TASK],input_order,indomain_min,complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],smallest, indomain_min, complete)\n   %:: int_search([s[j,t]|j in JOB,t in TASK],dom_w_deg, indomain_min, complete)\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK]; \n\n\n\nModel 3 : \n\n\nint: n;\nset of int: JOB = 1..n;\nint: m;\nset of int: MACH = 1..m;\nset of int: TASK = 1..m;\narray[JOB,TASK] of int:  d;  % length of task\narray[JOB,TASK] of MACH: mc; % which machine\n\nint: maxt = sum(j in JOB, t in TASK)(d[j,t]);\n\narray[JOB,TASK] of var 0..maxt: s; % start time\n\n% performs tasks in a job in order\nconstraint forall(j in JOB, t in 1..m-1)\n                 (s[j,t] + d[j,t] <= s[j,t+1]);\n\ninclude \"disjunctive.mzn\";\n\nconstraint forall(ma in MACH)\n                 ( let { array[int] of var int: ss = [ s[j,t] | j in JOB, t in TASK where mc[j,t] = ma ];\n                         array[int] of int:     dd = [ d[j,t] | j in JOB, t in TASK where mc[j,t] = ma ]; } in\n                   disjunctive(ss,dd));\n\n\nvar 0..maxt: makespan = max(j in JOB)(s[j,m] + d[j,m]);\n\nsolve  \n%      ::\n%      seq_search([ int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete),\n%                  int_search([makespan], input_order, indomain_min, complete)])\n%      seq_search([ int_search([makespan], input_order, indomain_min, complete),\n%                   int_search([s[i,j]| i in JOB, j in TASK],\n%                             smallest, indomain_min, complete)])\n         minimize makespan;\n\noutput [ \"makespan = \", show(makespan), \"\\n\"] ++\n       [ show_int(3,s[j,t]) ++ if t = m  then \"\\n\" else \" \" endif\n       | j in JOB, t in TASK];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3913, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8cdfdf97-c682-4416-b170-500fc703386f": {"__data__": {"id_": "8cdfdf97-c682-4416-b170-500fc703386f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "K4xP2Graceful_source_code", "node_type": "4", "metadata": {}, "hash": "6579eb86a34f89b2462d07b1ceb631c1620d72045455418e36de2e3b7ce00ed4", "class_name": "RelatedNodeInfo"}}, "text": "% K4P2 Graceful Graph in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: m = 16;\nint: n = 8;\narray[1..n] of var 0..m: nodes;\narray[1..m, 1..2] of var 1..n: graph;\narray[1..m] of var 1..m: edges;\n\n\n\nsolve :: int_search(nodes, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..m) (\n    abs(nodes[graph[i,1]] - nodes[graph[i,2]]) = edges[i]  \n  )\n  /\\\n  all_different(edges) \n  /\\ \n  all_different(nodes)\n;\n\ngraph =\narray2d(1..m, 1..2,\n[1, 2,\n1, 3,\n1, 4,\n2, 3,\n2, 4,\n3, 4,\n\n5, 6,\n5, 7,\n5, 8,\n6, 7,\n6, 8,\n7, 8,\n\n1, 5,\n2, 6,\n3, 7,\n4, 8]);\n\noutput\n[\n  \"nodes: \" ++ show(nodes) ++ \"\\n\" ++\n  \"edges: \" ++ show(edges) ++ \"\\n\"\n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 636, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d9d2c132-5ecf-468d-a421-328f4b880b68": {"__data__": {"id_": "d9d2c132-5ecf-468d-a421-328f4b880b68", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "killer_sudoku_source_code", "node_type": "4", "metadata": {}, "hash": "4803ed48460f8ef1c2bc61c5f91e9148ee00099ff7fc16d3c1a42ccde7f3e18b", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n%\n% Killer Sudoku in MiniZinc.\n\n%   Killer sudoku (also killer su doku, sumdoku, sum doku, addoku, or\n%   samunamupure) is a puzzle that combines elements of sudoku and kakuro.\n%   Despite the name, the simpler killer sudokus can be easier to solve\n%   than regular sudokus, depending on the solver's skill at mental arithmetic;\n%   the hardest ones, however, can take hours to crack.\n \n%   The objective is to fill the grid with numbers from 1 to 9 in a way that\n%   the following conditions are met:\n \n%     * Each row, column, and nonet contains each number exactly once.\n%     * The sum of all numbers in a cage must match the small number printed\n%       in its corner.\n%     * No number appears more than once in a cage. (This is the standard rule\n%       for killer sudokus, and implies that no cage can include more\n%       than 9 cells.)\n \n%   In 'Killer X', an additional rule is that each of the long diagonals\n%   contains each number once.\n%   \"\"\"\n \n\nint: num_p = 29; % number of segments\nint: num_hints = 4;  % number of hints per segments (that's max number of hints)\nint: max_val = 100;\narray[1..num_p, 1..2*num_hints+1] of 0..max_val: P =\n  array2d(1..num_p, 1..2*num_hints+1, [\n    1,1,  1,2, 0,0, 0,0,   3,\n    1,3,  1,4, 1,5, 0,0,  15,\n    1,6,  2,5, 2,6, 3,5,  22,\n    1,7,  2,7, 0,0, 0,0,   4,\n    1,8,  2,8, 0,0, 0,0,  16,\n    1,9,  2,9, 3,9, 4,9,  15,\n    2,1,  2,2, 3,1, 3,2,  25,\n    2,3,  2,4, 0,0, 0,0,  17,\n    3,3,  3,4, 4,4, 0,0,   9,\n    3,6,  4,6, 5,6, 0,0,   8,\n    3,7,  3,8, 4,7, 0,0,  20,\n    4,1,  5,1, 0,0, 0,0,   6,\n    4,2,  4,3, 0,0, 0,0,  14,\n    4,5,  5,5, 6,5, 0,0,  17,\n    4,8,  5,7, 5,8, 0,0,  17,\n    5,2,  5,3, 6,2, 0,0,  13,\n    5,4,  6,4, 7,4, 0,0,  20,\n    5,9,  6,9, 0,0, 0,0,  12,\n    6,1,  7,1, 8,1, 9,1,  27,\n    6,3,  7,2, 7,3, 0,0,   6,\n    6,6,  7,6, 7,7, 0,0,  20,\n    6,7,  6,8, 0,0, 0,0,   6,\n    7,5,  8,4, 8,5, 9,4,  10,\n    7,8,  7,9, 8,8, 8,9,  14,\n    8,2,  9,2, 0,0, 0,0,   8,\n    8,3,  9,3, 0,0, 0,0,  16,\n    8,6,  8,7, 0,0, 0,0,  15,\n    9,5,  9,6, 9,7, 0,0,  13,\n    9,8,  9,9, 0,0, 0,0,  17\n   ]);\n\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\nconstraint\n \n  forall(i in 1..n) (\n        all_different([x[i,j] | j in 1..n]) /\\\n        all_different([x[j,i] | j in 1..n])\n  )\n  /\\\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n  /\\ % calculate the hints\n  forall(p in 1..num_p) (\n     sum(i in 1..num_hints where P[p,2*(i-1)+1] > 0) (x[  P[p, 2*(i-1)+1], P[p,2*(i-1)+2]  ]) = P[p, 2*num_hints+1]\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\"; \nint: n = 9;\narray[1..n, 1..n] of var 1..9: x;\n\nint: num_segments = 29; % number of segments\n\narray[1..n, 1..n] of int: segments =\narray2d(1..n, 1..n,\n[\n  1, 1, 2, 2, 2, 3, 4, 5, 6, % 1\n  7, 7, 8, 8, 3, 3, 4, 5, 6, % 2\n  7, 7, 9, 9, 3,10,11,11, 6, % 3\n 13,14,14, 9,15,10,11,12, 6, % 4\n 13,16,16,17,15,10,12,12,18, % 5\n 19,16,20,17,15,21,22,22,18, % 6\n 19,20,20,17,23,21,21,24,24, % 7\n 19,25,26,23,23,27,27,24,24, % 8\n 19,25,26,23,28,28,28,29,29, % 9\n]);\n\narray[1..num_segments] of int: segment_sums =\n[\n   3, % 1\n  15, % 2\n  22, % 3\n   4, % 4\n  16, % 5\n  15, % 6\n  25, % 7\n  17, % 8\n   9, % 9\n   8, % 10\n  20, % 11\n  17, % 12\n   6, % 13\n  14, % 14\n  17, % 15\n  13, % 16\n  20, % 17\n  12, % 18\n  27, % 19\n   6, % 20\n  20, % 21\n   6, % 22\n  10, % 23\n  14, % 24\n   8, % 25\n  16, % 26\n  15, % 27\n  13, % 28\n  17  % 29\n];\n\n% solve satisfy;\nsolve :: int_search([x[i,j] | i,j in 1..n], first_fail, indomain_min, complete) satisfy;\n\n% Standard Sudoku constraints\nconstraint\n  % rows and columns\n  forall(i in 1..n) (\n     all_different([x[i,j] | j in 1..n]) /\\\n     all_different([x[j,i] | j in 1..n])\n  )\n  /\\ % blocks\n  forall(i in 0..2,j in 0..2) (\n    all_different([x[r,c] | r in i*3+1..i*3+3, c in j*3+1..j*3+3] )\n  )\n;\n\n% Handle the segments\nconstraint\n  forall(p in 1..num_segments) (\n    segment_sums[p] = sum([x[i,j] | i,j in 1..n where segments[i,j] = p])\n  )\n;\n\noutput [\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(x[i,j])\n  | i,j in 1..n\n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4176, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2ef3e1a6-031d-42da-a9a3-f52535150e15": {"__data__": {"id_": "2ef3e1a6-031d-42da-a9a3-f52535150e15", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "knapsack_source_code", "node_type": "4", "metadata": {}, "hash": "b3c324f5928ce76e4bda91d7f1109b39aad4f18f73aa3ff018ef0f62625d2b84", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 : \n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\narray[OBJ] of var int: x; % how many of each object\n\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in OBJ)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\nModel 2 : \n\n\nint: n;    set of int: OBJ = 1..n;\narray[OBJ] of int: size;\narray[OBJ] of int: value;\nint: limit;\narray[OBJ] of var int: x;\nconstraint forall(i in OBJ)(x[i] >= 0);\nconstraint sum(i in OBJ)(size[i]*x[i])<= limit;\nsolve maximize sum(i in OBJ)(value[i]*x[i]);\nn = 4;\nsize = [5,8,9,12];\nvalue = [3,5,7,8];\nlimit = 29;\n\n\n\nModel 3 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var 0..1: x; \n\nconstraint sum(i in 1..n)(size[i] * x[i]) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * x[i]);\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 4 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\narray[1..n] of var bool: x; \n\nconstraint sum(i in 1..n)(size[i] * bool2int(x[i])) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(x[i]));\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 5 : \n\n\n\nint: n; % number of objects\nset of int: OBJ = 1..n;\nint: capacity;\narray[OBJ] of int: profit;\narray[OBJ] of int: size;\n\nvar set of OBJ: x; \n\n\nconstraint sum(i in x)(size[i]) <= capacity;\n\nsolve maximize sum(i in x)(profit[i]);\n\n\noutput [\"x = \", show(x), \"\\n\"];\n\n\n\nModel 6 : \n\n\nint: n; % number of objects\nint: capacity;\narray[1..n] of int: profit;\narray[1..n] of int: size;\n\nvar set of 1..n: x;\n\nconstraint sum(i in 1..n)(size[i] * bool2int(i in x)) <= capacity;\nsolve maximize sum(i in 1..n)(profit[i] * bool2int(i in x));\n\noutput [\"x = \", show(x), \"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1845, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "56883237-c490-4f8a-8ec3-401b38e997d1": {"__data__": {"id_": "56883237-c490-4f8a-8ec3-401b38e997d1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "langford_source_code", "node_type": "4", "metadata": {}, "hash": "8a1290227958fc5503d2e72e405c9a77391ad583e3f944afde6e3403be9e7217", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n                 (x[d,c+1] = x[d,c] + d + 1);\n\nsolve satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ if fix(x[d,c]) = p then show(d) ++ \" \" else \"\" endif\n          | p in POS, d in DIG, c in COPY ]\n       ;\n\n\n\nModel 2 : \n\n\n% Langford's number problem in MiniZinc.\n%\n% Arrange 2 sets of positive integers 1..k to a sequence,\n% such that, following the first occurence of an integer i,\n% each subsequent occurrence of i, appears i+1 indices later\n% than the last.\n% For example, for k=4, a solution would be 41312432\n\ninclude \"globals.mzn\";\n\nint: k;\nset of int: positionDomain = 1..2*k;\n\narray[positionDomain] of var positionDomain: position;\n% better presentation:\narray[positionDomain] of var 1..k: solution;\n\nsolve :: int_search(position, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n  forall(i in 1..k) (\n     position[i+k] = position[i] + i+1 /\\\n     % hakank: added this\n     solution[position[i]] = i /\\ \n     solution[position[k+i]] = i\n  )\n  /\\   \n  all_different(position)\n  /\\ % symmetry breaking\n  solution[1] < solution[2*k]\n;\n\n\noutput [\n  show(solution), \"\\n\"\n\n];\n\n%\n% data\n%\nk = 4;\n% k = 7;\n% k = 8;\n% k = 10;\n% k = 20;\n\n\n\nModel 3 : \n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\narray[DIG,COPY] of var POS: x;\n\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"inverse.mzn\";\nconstraint inverse([x[d,c] | d in DIG, c in COPY], y);\n\n%include \"alldifferent.mzn\";\n%constraint alldifferent([x[d,c] | d in DIG, c in COPY]);\n\nconstraint forall(d in DIG, c in 1..m-1)\n      (x[d,c+1] = x[d,c] + d + 1);\n\n%constraint forall(d in DIG, c in 1..m-1, p in POS)\n%                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve \n      %:: int_search(y, input_order, indomain_min, complete) \n      %:: int_search([x[d,c] | d in DIG, c in COPY], input_order, indomain_min, complete) \n      satisfy;\n\noutput [show(x),\"\\n\"]\n       ++ [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;\n\n\nModel 4 :\n\n\n% Langfords problem (m,n) m copies of digits 1..n\n% where any two consecutive copies of digit k\n% are separated by k other digits\nint: n;\nset of int: DIG = 1..n;\nint: m;\nset of int: COPY = 1..m;\nint: l = m*n;\nset of int: POS = 1..l;\n\nset of int: DIGCOPY = 1..l;\narray[POS] of var DIGCOPY: y;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\nconstraint forall(d in DIG, c in 1..m-1, p in POS)\n                 (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1);\n\nsolve satisfy;\n\noutput [ show((y[p] - 1) div m + 1) ++ \" \"\n          | p in POS ]\n       ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3107, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "82d908a5-8d31-400b-b086-afd776cbd033": {"__data__": {"id_": "82d908a5-8d31-400b-b086-afd776cbd033", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "loan_source_code", "node_type": "4", "metadata": {}, "hash": "97e479e5dcc5e99d3e7e615a4ba6bca112d104c414653b6e47e10b71edd33fc0", "class_name": "RelatedNodeInfo"}}, "text": "% variables\nvar float: R;        % quarterly repayment\nvar float: P;        % principal initially borrowed\nvar 0.0 .. 10.0: I;  % interest rate\n\n% intermediate variables\nvar float: B1; % balance after one quarter\nvar float: B2; % balance after two quarters\nvar float: B3; % balance after three quarters\nvar float: B4; % balance owing at end\n\nconstraint B1 = P * (1.0 + I) - R;\nconstraint B2 = B1 * (1.0 + I) - R;\nconstraint B3 = B2 * (1.0 + I) - R; \nconstraint B4 = B3 * (1.0 + I) - R;\n\nsolve satisfy;\n\noutput [\n \"Borrowing \", show_float(0, 2, P), \" at \", show(I*100.0), \n \"% interest, and repaying \", show_float(0, 2, R), \n  \"\\nper quarter for 1 year leaves \", show_float(0, 2, B4), \" owing\\n\"\n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 697, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "67af9333-1b7b-4f2e-b3bc-f558ecf23e9c": {"__data__": {"id_": "67af9333-1b7b-4f2e-b3bc-f558ecf23e9c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ltsp_source_code", "node_type": "4", "metadata": {}, "hash": "dd74fc1417651b8a2e181808c0b58166f54b00f8758fcf160beaa6a71de101c9", "class_name": "RelatedNodeInfo"}}, "text": "int: n; % number of cities\nset of int: CITY = 1..n;\nset of int: POS = 1..n;\narray[CITY] of int: coord; % coordinate of city \nint: m; % number of precedences\nset of int: PREC = 1..m;\narray[PREC] of CITY: left;\narray[PREC] of CITY: right;\n\narray[CITY] of var POS: order;\narray[POS] of var CITY: city;\n\ninclude \"inverse.mzn\";\nconstraint inverse(order,city);\n\nconstraint forall(i in PREC)(order[left[i]] < order[right[i]]);\n\nsolve minimize sum(i in 1..n-1)(abs(coord[city[i]] - coord[city[i+1]]));", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 493, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3bb6e712-b149-4dc5-89be-d0fa988af6b6": {"__data__": {"id_": "3bb6e712-b149-4dc5-89be-d0fa988af6b6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_hexagon_source_code", "node_type": "4", "metadata": {}, "hash": "e37cae924e92295a1fa19e57e2ababe5d8f8b05b9fc03f5fdfe39ab9fc084495", "class_name": "RelatedNodeInfo"}}, "text": "% Magic Hexagon in MiniZinc.\n\ninclude \"globals.mzn\"; \n\nset of int: N = 1..19;\nvar N: a;\nvar N: b;\nvar N: c;\nvar N: d;\nvar N: e;\nvar N: f;\nvar N: g;\nvar N: h;\nvar N: i;\nvar N: j;\nvar N: k;\nvar N: l;\nvar N: m;\nvar N: n;\nvar N: o;\nvar N: p;\nvar N: q;\nvar N: r;\nvar N: s;\n\narray[N] of var N: LD = [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s];\n\nsolve satisfy;\n\nconstraint\n  all_different(LD) /\\\n\n  a + b + c =  38 /\\\n  d + e + f + g =  38 /\\\n  h + i + j + k + l =  38 /\\ \n  m + n + o + p =  38 /\\ \n  q + r + s =  38 /\\ \n  a + d + h =  38 /\\ \n  b + e + i + m =  38 /\\ \n  c + f + j + n + q =  38 /\\ \n  g + k + o + r =  38 /\\ \n  l + p + s =  38 /\\ \n  c + g + l =  38 /\\ \n  b + f + k + p =  38 /\\ \n  a + e + j + o + s =  38 /\\ \n  d + i + n + r =  38 /\\ \n  h + m + q =  38 /\\ \n\n  a < c /\\\n  a < h /\\\n  a < l /\\\n  a < q /\\\n  a < s /\\\n  c < h\n;\n\noutput\n[\n  show(LD)\n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 869, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e085b210-cbff-4aa9-ab79-199d3932971d": {"__data__": {"id_": "e085b210-cbff-4aa9-ab79-199d3932971d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_sequence_source_code", "node_type": "4", "metadata": {}, "hash": "f41c909b16fb38860176cbc324aefc71dcd04c47ad34a0924022a43a93bad041", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n% Magic sequence in MiniZinc.\n% A magic sequence of length n is a sequence of integers x0 . . xn-1 between 0 and n-1, such that for all i in 0 to n-1, the number i occurs exactly xi times in the sequence. For instance, 6,2,1,0,0,0,1,0,0,0 is a magic sequence since 0 occurs 6 times in it, 1 occurs twice, ...\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n  forall(i in 0..n-1) (\n    s[i] = sum(j in 0..n-1) (bool2int(s[j] = i))\n  )\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 2 : \n\n\nint: n =  20;\narray[0..n-1] of var 0..n-1: s;\n\nsolve satisfy;\n\nconstraint\n        forall(i in 0..n-1) (\n                s[i] = sum(j in 0..n-1) (bool2int(s[j]=i))\n        )\n        /\\ \n        sum(i in 0..n-1) (s[i])=n \n        /\\\n        sum(i in 0..n-1) (s[i]*i) =n\n;\n\n\noutput [\n       show(s), \"\\n\",\n];\n\n\n\nModel 3 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  10;\narray[0..n-1] of var 0..n-1: s;\narray[0..n-1] of int: value = array1d(0..n-1, [i | i in 0..n-1]); % helper for distribute\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   distribute(s, value, s)         /\\ \n   sum(i in 0..n-1) (s[i])   = n   /\\\n   sum(i in 0..n-1) (s[i]*i) = n\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\n\nModel 4 :\n\n\ninclude \"globals.mzn\";\n\nint: n =  100;\narray[0..n-1] of var 0..n-1: s;\n\n% solve satisfy;\nsolve :: int_search(s, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n   global_cardinality(s,array1d(0..n-1, set2array(index_set(s))), s) :: domain\n;\n\n\noutput [\n       show(s), \"\\n\"\n];\n\n\nModel 5 : \n\n\n% Magic squares in MiniZinc\n\ninclude \"globals.mzn\";\n\nint: n = 3;\n\nint: total = ( n * (n*n + 1)) div 2;\narray[1..n,1..n] of var 1..n*n: magic;\n\n\n% solve satisfy;\nsolve :: int_search(\n        [magic[i,j] | i in 1..n, j in 1..n], \n        first_fail,\n        indomain_min,\n        complete) \n    satisfy;\n\n\nconstraint\n\n        all_different([magic[i,j] | i in 1..n, j in 1..n]) :: domain\n        /\\\n        forall(k in 1..n) (\n           sum(i in 1..n) (magic[k,i]) = total % :: domain\n           /\\\n           sum(i in 1..n) (magic[i,k]) = total %:: domain\n        )\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,i]) = total  %:: domain\n       /\\ % diagonal\n       sum(i in 1..n) (magic[i,n-i+1]) = total %:: domain\n;\n\n% symmetry breaking\n% Activating all these constraints we get the\n% \"standard\" way of counting the number of solutions:\n%    1, 0, 1, 880, 275305224\n% i.e. this sequence: http://oeis.org/A006052\n%\n% Without the constraints the number of solutions are:\n%  N  #solutions\n%  -------------\n%  1     1\n%  2     0\n%  3     8\n%  4  7040\n%  5  many... \n%\n% constraint\n%    magic[1,1] < magic[1,n]\n%    /\\ magic[1,n] < magic[n,1]\n%    /\\ magic[1,1] < magic[n,n]\n% ;\n\n\noutput [\n  \"Total: \" ++ show(total) ++ \"\\n\"\n] ++\n[\n    %   show(magic)\n  if j = 1 then \"\\n\" else \"\" endif ++\n    if fix(magic[i,j]) < 10 then \" \" else \"\" endif ++\n    show(magic[i,j]) ++ \" \"\n  | i,j in 1..n\n] \n++ \n[\"\\n\"];\n\n\nModel 6 : \n\n\n% Magic square integer programming version in MiniZinc.\n% In recreational mathematics, a magic square of order n is an\n% arrangement of n^2 numbers, usually distinct integers, in a square,\n% such that n numbers in all rows, all columns, and both diagonals sum\n% to the same constant. A normal magic square contains the integers\n% from 1 to n^2.\n\n\n% square order\nint: n = 3; \n\n% integers to be placed\nset of 1..n*n: N = 1..n*n;\n\n% x[i,j,k] = 1 means that cell (i,j) contains integer k\narray[1..n, 1..n, N] of var 0..1: x;\n\narray[1..n, 1..n] of var 1..n*n: square;\n\nvar int: s; % the magic sum\n\nsolve :: int_search(\n        [x[i,j,k] | i,j in 1..n, k in N] ++ \n        [square[i,j] | i,j in 1..n] ++\n        [s],\n        first_fail,\n        indomain_min, \n        complete % \"credit(640, bbs(5))\" % \"complete\"\n      ) \n    satisfy;\n\nconstraint \n  s >= 0 \n  /\\\n  s <= n*n*n\n  /\\\n  % each cell must be assigned exactly one integer\n  forall(i in 1..n, j in 1..n) (\n     sum(k in N) (x[i,j,k]) = 1\n  )\n  /\\\n  % each integer must be assigned exactly to one cell\n  forall(k in N) (\n     sum(i in 1..n, j in 1..n) (x[i,j,k]) = 1\n  )\n\n  /\\\n  % the sum in each row must be the magic sum \n  forall(i in 1..n) (\n     sum(j in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in each column must be the magic sum\n  forall(j in 1..n) (\n     sum(i in 1..n, k in N) (k * x[i,j,k]) = s\n  )\n\n  /\\\n  % the sum in the diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,i,k]) = s\n\n  /\\\n  % the sum in the co-diagonal must be the magic sum\n  sum(i in 1..n, k in N) (k * x[i,n-i+1,k]) = s\n\n  /\\\n  % for output\n  forall(i,j in 1..n) ( square[i,j] = sum(k in N) (k * x[i,j,k]))\n;\n\n\noutput [ \n   \"\\ns: \", show(s)\n] ++\n[\n  if  j = 1 then \"\\n\" else \" \" endif ++\n    show(square[i,j]) \n  | i,j in 1..n\n\n] ++ [\"\\n\"];\n\n% printf \"\\n\";\n% printf \"Magic sum is %d\\n\", s;\n% printf \"\\n\";\n% for{i in 1..n}\n% {  printf{j in 1..n} \"%3d\", sum{k in N} k * x[i,j,k];\n%    printf \"\\n\";\n% }\n% printf \"\\n\";", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4964, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "601dce60-fcf6-4521-96b8-80d68facd7fd": {"__data__": {"id_": "601dce60-fcf6-4521-96b8-80d68facd7fd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "maximum_density_still_life_source_code", "node_type": "4", "metadata": {}, "hash": "55a16b27452bbc895d2c83193de70e319d3cf21911de5daca25b2b57f0b23128", "class_name": "RelatedNodeInfo"}}, "text": "% Maximum density still life in MiniZinc.\n\n% include \"globals.mzn\"; \nint: size = 7; % to change\n\nset of int: objFunctionBoardCoord      = 2..size+1;\nset of int: checkConstraintsBoardCoord = 1..size+2;\nset of int: augmentedBoardCoord        = 0..size+3;\n\n% Search space: The set of all possible assignments of 0s (dead) and 1s (live) \n% to the cells of the board section. However, to be able to easily express \n% constraints on \"boundary\" cells, we take as search space the set of 0/1 \n% boards of size n+4 by n+4: the actual stable pattern appears in the sub-board \n% defined by ignoring the first/last two rows/columns.\narray[augmentedBoardCoord,augmentedBoardCoord] of var 0..1: grid;\n\nvar int: z = sum(r in objFunctionBoardCoord, c in objFunctionBoardCoord) (grid[r,c]);\n\n% Objective function: Maximize the number of live cells in the sub-board defined \n% by ignoring the first/last two/ rows/columns.\n\n\n% solve maximize z;\nsolve :: int_search(\n        [grid[i,j] | i,j in augmentedBoardCoord], \n        smallest, \n        indomain_max, \n        complete) \n    maximize z;\n\nconstraint\n\n  % C1: Cells in the first/last two rows/columns are all 0 (dead)\n  forall(x in augmentedBoardCoord) (\n    grid[0,x] = 0 /\\\n    grid[1,x] = 0 /\\\n    grid[size+2,x] = 0 /\\  \n    grid[size+3,x] = 0 /\\\n    grid[x,0] == 0 /\\       \n    grid[x,1] == 0 /\\\n    grid[x,size+2] = 0 /\\  \n    grid[x,size+3] = 0 \n  )\n  /\\\n  forall(r in checkConstraintsBoardCoord,c in checkConstraintsBoardCoord) (\n    % C2: Each cell of the board (except those of the first/last row/column) \n    %     that has exactly three live neighbors is alive. \n    %     Together with constraint C1, this implies that cells in the\n    %     second/last-but-one row/column cannot have three live neighbors.\n    (\n      ( ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] + \n          grid[r,c-1] + grid[r,c+1] + \n          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1]\n          ) = 3 \n       ) -> (grid[r,c] = 1)\n    )\n    /\\    \n\n    % C3: Each live cell must have 2 or 3 live neighbors (cells of the first/last \n    % row/column may be ignored by this constraint)\n    (\n       (grid[r,c] = 1) -> \n                      (\n                        2 <= \n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          )\n                        /\\\n                        ( grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] +\n                          grid[r,c-1] + grid[r,c+1] +\n                          grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] \n                          ) <= 3\n                      )\n    )\n  )\n  \n  /\\\n  % SBSO: Symmetry-breaking by selective ordering\n  % The assignment is forced to respect an ordering on the values that occur in corner entries\n  % of the board. In particular:  \n  % - if the NW-corner cell is dead, the SE-corner cell\n  % must be dead too \n  % - if the NE-corner cell is dead, the SW-corner cell must be dead too\n  % \n  grid[2,2] >= grid[size+1,size+1] /\\\n  grid[2,size+1] >= grid[size+1,2]\n;\n\n\noutput [\n  if j = 0 then \"\\n\" else \" \" endif ++\n    show(grid[i,j])\n  | i,j in augmentedBoardCoord\n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3237, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fbbf6306-799c-4bb4-a682-aa7b1beb6403": {"__data__": {"id_": "fbbf6306-799c-4bb4-a682-aa7b1beb6403", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "mip_source_code", "node_type": "4", "metadata": {}, "hash": "250f7c9cc0bd59d9cc602841077ea6cbaabf94bc50266bb7554ed961267f9d30", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.0*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 2 : \n\n\nvar float: B;\nvar float: C;\nvar float: D;\n\n\nsolve maximize 1.0*B - 1.0*C + 1.0*D;\nconstraint 2.0*B - 1.0*C + 2.0*D <=  4.0;\nconstraint 2.0*B - 3.0*C + 1.0*D <= -5.0;\nconstraint -1.0*B + 1.0*C - 2.0*D <= -1.0;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 3 :\n\n\nvar int: B;\nvar int: C;\nvar int: D;\n\nconstraint 2.0*B + 2.0*C + 1.0*D <= 30.0;\nconstraint 1.5*B + 2.0*C + 3.0*D <= 25.0;\nconstraint 2.0*B + 1.0*C + 1.0*D <= 20.0;\nsolve maximize 3.0*B + 1.0*C + 3.0*D;\n\nconstraint B >= 0 /\\ C >= 0 /\\ D >= 0\n\n\n\nModel 4 :\n\n\nsolve maximize 21*x + 11*y;\n\nvar int: x;\nvar int: y;\nconstraint 7*x + 4*y <= 13;\nconstraint x >= 0 /\\ y >= 0; \n\n\n\nModel 5 : \n\n\nsolve maximize 8*x + 5*y;\n\nvar int: x;\nvar int: y;\nconstraint x + y <= 6;\nconstraint 9*x + 5*y <= 45;\nconstraint x >= 0 /\\ y >= 0;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1049, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c309bf1e-14c4-4f8a-937b-25a7c1080c70": {"__data__": {"id_": "c309bf1e-14c4-4f8a-937b-25a7c1080c70", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "missing_solution_source_code", "node_type": "4", "metadata": {}, "hash": "c8800ce210a941824c915904b6e15ee2c69564f22fd5957568b6c142a343a214", "class_name": "RelatedNodeInfo"}}, "text": "% Missing Solutions\nint: n; % no of people\nset of int: PERSON = 1..n;\nint: male = 1; int: female = 2;\nset of int: GENDER = male..female;\narray[PERSON] of GENDER: gender;\narray[PERSON] of int: age;\n\narray[1..n] of var PERSON: order;\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(order);\n\n% males and females alternate\nconstraint forall(i in 1..n)\n                 (i mod 2 = 0 <-> gender[order[i]] = female);\n\n% age does not grow bu more than 10\nconstraint forall(i in 1..n-1)\n                 (age[order[i+1]] - age[order[i]] <= 10);\n\nsolve satisfy;\n\noutput [ show(order), \"\\n\"] ++\n       [\"[\"] ++ [ show(age[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                | i in 1..n ] ++\n       [\"[\"] ++ [ show(gender[order[i]]) ++ if i < n then \", \" else \"]\\n\" endif\n                 | i in 1..n ];\n\n\n%n = 6;\n%gender = [male,male,male,female,female,female];\n%age = [13, 25, 34, 40, 16, 13];\n\nn = 5;\ngender = [male,male,female,female,female];\nage = [13,25,34,40,16];\n\n%order = [4,2,3,1,5];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1000, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "680db5e7-33e3-4733-9b28-afb108815d4f": {"__data__": {"id_": "680db5e7-33e3-4733-9b28-afb108815d4f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "nonogram_create_automaton2_source_code", "node_type": "4", "metadata": {}, "hash": "81de1694c603a25bf734194524a4c527bbc8264d37ae9e8956a14719c27da6ee", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n% Nonoram solver using regular and is written in all-MiniZinc.\n\ninclude \"globals.mzn\"; \n\nint: rows;\nint: row_rule_len;\narray[1..rows, 1..row_rule_len] of int: row_rules;\nint: cols;\nint: col_rule_len;\narray[1..cols, 1..col_rule_len] of int: col_rules;\n\n\narray[1..rows, 1..cols] of var 1..2: x;\n\nsolve :: int_search(\n     [x[i,j] | j in 1..cols, i in 1..rows], \n     first_fail, \n     indomain_min, \n     complete) \nsatisfy;\n\n%\n% The approach is rather simple:\n%  - zero_positions is a set of the positions in the state table where the \n%    state 0 should be, which also correspond to the state of the pattern \"0\"\n%  - when this have been identified everything else comes to rest\n%\n% On the other hand, the calculation of the states is hairy, very hairy.\n%\npredicate make_automaton(array[int] of var int: x, array[int] of int: pattern) =\n    let {\n        int: n = length(pattern),\n        % fix for \"zero clues\"\n        int: len = max(length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern),1),\n        int: leading_zeros = sum(i in 1..n) (bool2int(pattern[i] = 0)),\n        set of int: zero_positions = {sum(j in 1..i) (pattern[j]+1) -leading_zeros | i in 1..n where pattern[i] > 0},\n       array[1..2*len] of 0..len*2: states = \n     if (length([pattern[i] | i in 1..n where pattern[i] > 0]) + sum(pattern)) = 0 then \n       [1,1]  % fix for \"zero clues\"\n     else \n    [1, 2] ++\n    [\n       if i div 2 in zero_positions then\n           if i mod 2 = 0 then\n            0\n           else\n            (i div 2) + 1\n           endif\n       elseif (i-1) div 2 in zero_positions then\n           if i mod 2 = 0 then\n            (i div 2)+1\n           else\n            (i div 2)+2\n           endif\n       else\n         if not( (((i-1) div 2) - 1) in zero_positions) then\n            if i mod 2 = 0 then\n               (i div 2) + 1\n            else \n              if (i div 2) + 1 in zero_positions then\n                  (i div 2) + 2\n              else \n                  0\n              endif\n            endif\n          else\n             if i mod 2 = 0 then\n                 (i div 2) + 1\n             else \n                if not((i div 2) + 1 in zero_positions) then\n                   0\n                else \n                   (i div 2) + 2 \n                endif\n             endif\n          endif\n       endif\n    | i in 3..2*(len-1)]\n    ++\n    [len, 0]\n    endif\n    } \n    in\n    regular(\n       x,\n       len, \n       2, \n       array2d(1..len, 1..2, states),\n       1, \n       {len}) % :: domain\n;\n\nconstraint\n\n      forall(j in 1..cols) (\n        make_automaton([x[i,j] | i in 1..rows], [col_rules[j,k] | k in 1..col_rule_len])\n      )\n      /\\\n      forall(i in 1..rows) (\n        make_automaton([x[i,j] | j in 1..cols], [row_rules[i,k] | k in 1..row_rule_len])\n      )\n\n;\n\noutput \n[\n  if j = 1 then \"\\n\" else \"\" endif ++\n     if fix(x[i,j]) = 1 then \" \" else \"#\" endif\n    \n  | i in 1..rows, j in 1..cols\n] \n++ \n[\n  \"\\n\"\n];\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\nint: X;\nint: Y;\n\nint: maxlen;\n\narray [1..Y,1..maxlen] of int: rows;\n\narray [1..X,1..maxlen] of int: cols;\n\narray[1..2, 1..2, 1..2] of 0..1: nonmul = \n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 1, 1,\n         1, 0, 0, 1]\n    );\n\narray[1..2, 1..2, 1..2] of 0..1: nonadd =\n    array3d(1..2, 1..2, 1..2,\n        [0, 0, 0, 1,\n         1, 0, 0, 1]\n    );\n\n% variables\n%\narray[1..Y, 1..X] of var 1..2: A;\n\n% All variables in a region must be different\n% Ordering to ensure each variable is handled exactly once\npredicate nonogram_row(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: row) =\n    nonogram([A[row, v] | v in 1..X], cons);\n\npredicate nonogram_col(\n        array[1..Y, 1..X] of var 1..2: A,\n        array[int] of 0..1: cons,\n        int: col) = \n    nonogram([A[v,col] | v in 1..Y], cons);\n\npredicate nonogram(array[int] of var 1..2: A, array [int] of int: cons) = \n    let {\n          int: n = if cons[1] = 0 then 0 else max(index_set(cons)) endif,\n          array [1..n + 1, 1..2] of int: consarr =\n              if cons[1] = 0 then [|1, 0|] \n              else array2d(1..n + 1, 1..2,\n                [1, 2] ++\n                [    i * nonmul[cons[i - 1] + 1, cons[i] + 1, s] + \n                     nonadd[cons[i - 1] + 1, cons[i] + 1, s] \n                     | i in 2..n, s in 1..2 \n                ] ++ \n                [n+1,0]\n              )\n              endif\n     } in (\n         regular(A, n + 1, 2, consarr, 1, {n + 1})\n     );\n\nconstraint forall(i in 1..Y) (\n    nonogram_row(A, [rows[i, j] | j in 1..maxlen where rows[i, j] >= 0], i)\n);\n\nconstraint forall(i in 1..X) (\n    nonogram_col(A, [cols[i, j] | j in 1..maxlen where cols[i, j] >= 0], i)\n);\n\nsolve :: int_search(array1d(1..X*Y,A),input_order,indomain_max,complete) satisfy;\n\noutput [\n    if fix(A[r, c]) = 1 then \" \" else \".\" endif ++ \n    if c = Y then \"\\n\" else \" \" endif\n    | r in 1..X, c in 1..Y\n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4924, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1ca863dd-fc03-41f0-91df-f9c01dfddff6": {"__data__": {"id_": "1ca863dd-fc03-41f0-91df-f9c01dfddff6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "nurses_source_code", "node_type": "4", "metadata": {}, "hash": "6c65ebf9cac75df8fd786dbc91121a5cec37159c2a1f6eb793c8cde28368e37d", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 : \n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\ninclude \"global_cardinality_low_up.mzn\";\nconstraint forall(d in DAY)\n                 (global_cardinality_low_up([x[n,d] | n in NURSE ],                                               [ day, night ], [ o, l ], [o, u])); \n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];\n\n\n\nModel 2 :\n\n\nint: k; % number of nurses\nset of int: NURSE = 1..k;\nint: m; % number of days\nset of int: DAY = 1..m;\nset of int: SHIFT = 1..3;\nint: day = 1; int: night = 2; int: dayoff = 3;\narray[SHIFT] of string: code = [\"d\", \"n\", \"-\"];\nint: o; % number on day shift\nint: l; % lower bound for nightshift\nint: u; % upper bound for nightshift\n\n\narray[NURSE,DAY] of var SHIFT: x;\n\nconstraint forall(n in NURSE, d in 1..m-2)\n                 ( x[n,d] = night /\\ x[n,d+1] = night \n                   -> x[n,d+2] = dayoff);\n\nconstraint forall(n in NURSE, d in 1..m-1)\n                 (x[n,d] = night -> x[n,d+1] != day);\n\nconstraint forall(d in DAY)\n                 (let {var int: on = sum(n in NURSE)\n                                        (bool2int(x[n,d]=night))        \n                      } in l <= on /\\ on <= u);\n\nsolve satisfy;\n\noutput [ code[fix(x[n,d])] \n         ++ if d = m then \"\\n\" else \" \" endif\n       | n in NURSE, d in DAY];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1901, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2f36fba7-47d5-450c-a8f9-e2be9fcf25b9": {"__data__": {"id_": "2f36fba7-47d5-450c-a8f9-e2be9fcf25b9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "opd_source_code", "node_type": "4", "metadata": {}, "hash": "287519cbb95daf648e2ac55cbc7d7fb2fb4d3dd319e0fb6eb1c02f8de4e0e72f", "class_name": "RelatedNodeInfo"}}, "text": "%% Design of Collateralised Debt Obligations Squared (CDO^2) Transactions\n% An OPD (v, b, r) problem is to find a binary matrix of v rows\n% and b columns such that each row sums to r, and\n% the dot product beween any pair of distinct rows is minimal.\n\n%Requires MiniZinc >= 2.0.2 for the symmetry_breaking_constraint predicate\n\ninclude \"lex_greatereq.mzn\";\n\n%instance data\nint: v;\nint: b;\nint: r;\n\n\nset of int: rows = 1..v;\nset of int: cols = 1..b;\n\n\n%computing a lower bound for lambda\nint: rv = r*v;\nint: rvmodb = rv mod b;\nint: floorrv = rv div b;\nint: ceilrv = rv div b + bool2int(rv mod b != 0);\nint: num = (ceilrv*ceilrv*rvmodb+floorrv*floorrv*(b-rvmodb)-rv);\nint: denom = v*(v-1);\nint: lb_lambda = num div denom + bool2int( num mod denom !=0);\n\n% This line is there for debugging purposes, it can be safely removed\nint: tmp = trace(\"Computed lower bound for lambda: \"++show(lb_lambda)++\"\\n\",lb_lambda);\n\n\n% lambda is called objective for the MiniZinc Challenge\nvar lb_lambda..b: objective;\n\n\narray [rows, cols] of var 0..1: m;\n\n\n% Every row must sum to r.\nconstraint forall (i in rows) (sum (j in cols) (m[i, j]) = r);\n\n% The dot product of every pair of distinct rows must be at most lambda for an OPD and a PD, and equal to lambda for a BIBD\nconstraint forall (i_a, i_b in rows where i_a < i_b) (\n    sum (j in cols) (m[i_a, j] * m[i_b, j]) <= objective\n);\n\n\n% Break row symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(i in rows diff {max(rows)})(\n        lex_greatereq([m[i, j] | j in cols], [m[i+1, j] | j in cols])\n    )\n);\n% Break column symmetry in the incidence matrix.\nconstraint symmetry_breaking_constraint(\n    forall(j in cols diff {max(cols)})(\n        lex_greatereq([m[i, j] | i in rows], [m[i, j+1] | i in rows])\n    )\n);\n\n\nsolve \n    :: seq_search([int_search([m[i, j] | i in rows, j in cols], input_order, indomain_max, complete),\n       \t\t   int_search([objective], input_order,indomain_min,complete)])\n    minimize objective; \n\n\n% Disabled the full solution. Printing only the objective value, lower bound, and parameters.\noutput  [\"opd: (v = \", show(v), \", b = \", show(b), \", r = \", show(r), \"). Found lambda = \", show(objective),\"\\tlb: \", show(lb_lambda)]\n%       ++[\"\\n\\n\"] ++ \n%\t[ ( if j > b then \"\\n\" else \n%\t        if fix(m[i,j])=1 then \"*\" else \" \" endif\n%\t    endif )\n%       | i in rows, j in 1..(b + 1) ]\n;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2382, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ed56b2fd-b5bc-49a5-bc44-93fe69cb2e08": {"__data__": {"id_": "ed56b2fd-b5bc-49a5-bc44-93fe69cb2e08", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "partition_source_code", "node_type": "4", "metadata": {}, "hash": "d183b1205b7e6692c280c804e13bf11465441239d30ecb73a7431f44a271226c", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 : \n\n% Partitioning problem\n% Partition 2*n numbers into two groups, each of size n, such that\n% their sums are equal and the sums of their squares are equal.\n\ninclude \"globals.mzn\";\n\n% Instance\n\nn = 32;\n\n% Model\n\nint: n;\n\narray[1..n] of var 1..2*n: x;\narray[1..n] of var 1..2*n: y;\n\nconstraint true\n    %   Break symmetries by ordering numbers in each group\n    /\\  forall (i in 2..n) (x[i-1] < x[i] /\\ y[i-1] < y[i])\n    %   Break symmetries by ordering the groups\n    /\\  x[1] < y[1]\n    \n    %   Partition the numbers\n    /\\  (alldifferent(x++y)) :: bounds\n    \n    %   The sums are equal\n    /\\  sum (x) = 2*n*(2*n+1) div 4\n    /\\  sum (y) = 2*n*(2*n+1) div 4\n    \n    %   The sums of the squares are equal\n    /\\  let {\n            array[1..n] of var 1..4*n*n: sx,\n            array[1..n] of var 1..4*n*n: sy\n        } in\n        forall (i in 1..n) (sx[i]=x[i]*x[i] /\\ sy[i] = y[i]*y[i])\n    /\\  sum (sx) = 2*n*(2*n+1)*(4*n+1) div 12\n    /\\  sum (sy) = 2*n*(2*n+1)*(4*n+1) div 12\n;\n\nsolve ::int_search(x++y,first_fail,indomain_min,complete) satisfy;\n\noutput\n    [\"x = \",show(x),\"\\n\",\"y = \",show(y),\"\\n\",\n     \"sum = \",show(2*n*(2*n+1) div 4),\"\\n\",\n     \"sum of squares = \", show(2*n*(2*n+1)*(4*n+1) div 12), \"\\n\"\n     ];\n\n\n\nModel 2 :\n\n\n\n%\n% Set partition problem in Minizinc.\n%\n%  This is a partition problem.\n%  Given the set S = {1, 2, ..., n},\n%  it consists in finding two sets A and B such that:\n%  <ul>\n%  <li>A U B = S,</li>\n%  <li>|A| = |B|,</li>\n%  <li>sum(A) = sum(B),</li>\n%  <li>sum_squares(A) = sum_squares(B).</li>\n%  </ul>\n \n%\ninclude \"globals.mzn\";\n \nint: n = 16;\nset of 1..n: S = 1..n;\nint: num_sets = 2;\narray[1..num_sets] of var set of S: a;\narray[1..num_sets] of var 0..n*n: sums;\narray[1..num_sets] of var 0..n*n*n*n: sum_squared;\n \n \n%\n% set_sum\n% sums the elements in the set s\n%\npredicate set_sum(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i)\n;\n \npredicate set_sum_squared(var set of int: s, var int: the_sum) =\n   the_sum = sum(i in ub(s)) (bool2int(i in s)*i*i)\n;\n \n \nsolve :: set_search(a, first_fail, indomain_min, complete) satisfy;\n% solve maximize sums[1];\n \nconstraint\n  assert(n mod 4 == 0, \"n must be a multiple of 4\")\n;\n \nconstraint\n   % use all the elements in S and it should be disjoint sets\n   partition_set(a, S)\n   /\\\n   forall(i in 1..num_sets) (  \n     a[i] `set_sum` sums[i]\n     /\\ a[i] `set_sum_squared` sum_squared[i]\n   )\n   /\\\n   forall(i in 2..num_sets) (\n     card(a[i]) > 0 /\\ % this is needed by eclipse\n     card(a[i]) = card(a[i-1]) /\\\n     sums[i] = sums[i-1]\n     /\\ sum_squared[i] = sum_squared[i-1]\n   )\n \n  % symmetry breaking\n  /\\ 1 in a[1]\n \n;\n \noutput [\n   \"a: \" ++ show(a) ++ \"\\n\" ++\n   \"sums: \" ++ show(sums) ++ \"\\n\" ++\n   \"sum_squared: \" ++ show(sum_squared) ++ \"\\n\"\n];\n \n% For model seeker\n% output [\n%    show(set2array(fix(a[i]))) ++ \",\"\n%   | i in 1..num_sets\n% ];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2890, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0d918c40-5c7a-4679-b04a-0de2e9292752": {"__data__": {"id_": "0d918c40-5c7a-4679-b04a-0de2e9292752", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "photo_source_code", "node_type": "4", "metadata": {}, "hash": "5f62f8bc3facf15dd05b98b6f795b1f5b7e679f50c9348538fec281a83e4acc5", "class_name": "RelatedNodeInfo"}}, "text": "int:n ;\nset of int: PERSON = 1..n;\nset of int: POS = 1..n;\narray[PERSON,PERSON] of int: friend;\n\n%array[PERSON] of var POS: x;\narray[POS] of var PERSON: y;\n\n%include \"inverse.mzn\";\n%constraint inverse(x,y);\n\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(y);\n\n%constraint alldifferent(x);\n\n%y[i] = sum(j in 1..n)(bool2int(x[j] = i) * j);\n\nsolve maximize sum(i in 1..n-1)(friend[y[i],y[i+1]]);", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 397, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4dd2643d-6d28-471e-9f09-bbfea9722b82": {"__data__": {"id_": "4dd2643d-6d28-471e-9f09-bbfea9722b82", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "project_scheduling_source_code", "node_type": "4", "metadata": {}, "hash": "e06f4625f22a96f2a68785c2ad765f23c4cc82da7088b8eb421941f064de6efe", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\nconstraint forall(i in PREC)\n                 (start[pre[i,1]] + duration[pre[i,1]] <= start[pre[i,2]]);\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];\n\n\n\nModel 2 :\n\n\nint: n = 8; % no of tasks max\nset of int: TASK = 1..n;\nint: foundations = 1; int: interior_walls =2; int: exterior_walls = 3;\nint: chimney = 4; int: roof = 5; int: doors = 6;\nint: tiles = 7; int: windows = 8;\narray[TASK] of int: duration =\n  [7,4,3,3,2,2,3,3];\nint: p = 8; % number of precedences\nset of int: PREC = 1..p;\narray[PREC,1..2] of TASK: pre = \n  [| foundations, interior_walls \n   | foundations, exterior_walls\n   | foundations, chimney\n   | exterior_walls, roof\n   | exterior_walls, windows\n   | interior_walls, doors\n   | chimney, tiles\n   | roof, tiles |];\n\n\nint: t = sum(duration);\narray[TASK] of var 0..t: start;\n\npredicate precedes(var int:s1, var int:d1, var int:s2)=\n          s1 + d1 <= s2; \n\nconstraint forall(i in PREC)\n                 (precedes(start[pre[i,1]],duration[pre[i,1]],start[pre[i,2]]));\n\npredicate nonoverlap(var int:s1, var int:d1,\n                     var int:s2, var int:d2)=\n          s1 + d1 <= s2 \\/ s2 + d2 <= s1;\n\nset of TASK: CARPENTRY = { interior_walls, exterior_walls, roof };\nconstraint forall(t1, t2 in CARPENTRY where t1 < t2)\n      (nonoverlap(start[t1],duration[t1],start[t2],duration[t2]));\n\nvar int: makespan = max(t in TASK)(start[t] + duration[t]);\n\nsolve minimize makespan;\n\noutput [show(makespan),\" = \", show(start)];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2170, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "221df495-7c24-4f67-bd80-ef740ead3c4a": {"__data__": {"id_": "221df495-7c24-4f67-bd80-ef740ead3c4a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasigroupCompletion_source_code", "node_type": "4", "metadata": {}, "hash": "a3c2102cda89ee73b8efa52dd7c3bbf596b541a62f1000854aff08b2c9bcc651", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n% Quasigroup with Holes (aka Latin Square Completion)\n\ninclude \"alldifferent.mzn\";\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n\narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N] of var PuzzleRange: puzzle;\n\n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j] = start[i,j] else true endif );\n\n% All different in rows\nconstraint forall (i in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | j in PuzzleRange ] ) );\n\n% All different in columns.\nconstraint forall (j in PuzzleRange) (\n                   alldifferent( [ puzzle[i,j] | i in PuzzleRange ] ) );\n\nsolve satisfy;\n\noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: N;\nint: digs = ceil(log(10.0,int2float(N))); % digits for output\nset of int: PuzzleRange = 1..N;\n \narray[1..N,1..N] of 0..N: start; %% initial board 0 = empty\narray[1..N,1..N, 1..N] of var 0..1: puzzle;\n \n% fill initial board\nconstraint forall(i,j in PuzzleRange)(\n  if start[i,j] > 0 then puzzle[i,j, start[i,j]] = 1 else true endif );\n \n% All different in rows\nconstraint forall (i,k in PuzzleRange) (\n        sum(j in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% All different in columns\nconstraint forall (j,k in PuzzleRange) (\n        sum(i in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\n% Each cell must have a number assigned\nconstraint forall (i,j in PuzzleRange) (\n        sum(k in PuzzleRange)(puzzle[i,j,k]) == 1\n);\n\nsolve satisfy;\n \noutput [ show_int(digs,puzzle[i,j]) ++ \" \" ++\n        if j == N /\\ i != N then \"\\n\" else \"\" endif\n        | i,j in PuzzleRange ] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1760, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4fe374b4-f573-446d-be57-99f7b7b7e0c4": {"__data__": {"id_": "4fe374b4-f573-446d-be57-99f7b7b7e0c4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasiGroupExistence_source_code", "node_type": "4", "metadata": {}, "hash": "b539de18799c0db9424cc79d36038042971df6f5285871d9339131939620fb4a", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n\n% Quasigroup problem in MiniZinc.\n% The quasiGroup existence problem\n% An m order quasigroup  is an mxm multiplication table of integers 1..m,\n% where each element occurrs exactly once in each row and column and certain\n% multiplication axioms hold (in this case, we want axiom 7 to hold).\n%\n% QG7.m problems are order m quasigroups for which (b*a)*b = a*(b*a).\n\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n% solve satisfy;\n \nconstraint\n      \n     % assign the \"reflected\" quasigroup to qGColumns to access its columns\n     %  forall row,col : nDomain .\n     %    quasiGroupColumns[col,row] = quasiGroup[row,col],\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % all values in the diagonals\n     forall( i in nDomain ) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n \n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row, col] | row in nDomain])\n     )\n     /\\\n \n     % this strange constraint\n     % corresponds to:\n     % quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i], j] \n     forall(i,j in nDomain) (\n              quasiGroup[i, quasiGroup[j,i]] = quasiGroup[quasiGroup[j,i],j]\n     )\n     /\\\n     % some implied? constraint\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n%\n% data\n%\nn = 5;\n\n\n\nModel 2 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 9; % solutions for n=5, n=9...\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 3 : \n\n\ninclude \"globals.mzn\";\n \nint: n = 4;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n \n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (i != j) ->\n         (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n \n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n \n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\n\nModel 4 :\n\ninclude \"globals.mzn\";\n \nint: n;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n% solve :: int_search(qgDiagonal, first_fail, indomain_min, complete) satisfy;\n \nconstraint\n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain])\n     )\n     /\\\n     %  (j*i)*(i*j) = i\n     forall(i in nDomain) (\n         forall(j in nDomain) (\n        quasiGroup[quasiGroup[i,j],quasiGroup[j,i]] = i\n         )\n     )\n \n     % Idempotency\n     % forall i : nDomain .\n     %     (quasiGroup[i,i] = i),\n \n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     % allDifferent(qgDiagonal) %,\n \n     % anti-Abelian\n     % forall i : nDomain .\n     %   forall j : nDomain .\n     %     (i != j) =>\n     %     (quasiGroup[i,j] != quasiGroup[j,i]),\n \n     % if (i*i)=j then (j*j) = i\n     % forall i : nDomain .\n     %  forall j : nDomain .\n     %    (quasiGroup[i,i]=j) => (quasiGroup[j,j]=i),\n \n \n     % Symmetry-breaking constraints   \n     % forall i : nDomain .\n     %      quasiGroup[i,n-1] + 2 >= i\n \n;\n \noutput\n[ \"\\nqgDiagonal: \", show(qgDiagonal)\n] ++\n[ \"\\nquasiGroup: \"\n] ++\n[\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n \n \n \n \n%\n% data\n%\nn = 4; % 4 works\n\n\nModel 5 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 6 :\n\n\ninclude \"globals.mzn\";\n \nint: n = 5;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\narray[nDomain] of var nDomain: qgDiagonal;\n \n% solve satisfy;\nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain], first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % accessor for diagonal\n     forall(i in nDomain) (\n         qgDiagonal[i] = quasiGroup[i,i]\n     )\n     /\\\n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain ] )\n     )\n     /\\\n     % All columns have to be different\n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain] )\n     )\n     /\\\n     % (j*i)*(i*j) = i\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n                quasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i\n          )\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     % All-diff diagonal\n     all_different(qgDiagonal)\n \n     /\\\n     % anti-Abelian\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n           (i != j) ->\n             (quasiGroup[i,j] != quasiGroup[j,i])\n       )\n     )\n     /\\\n     % if (i*i)=j then (j*j) = i\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints\n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];\n\n\nModel 7 :\n\n\n\ninclude \"globals.mzn\";\n \nint: n = 7;\nset of int: nDomain = 0..n-1;\n \narray[nDomain, nDomain] of var nDomain: quasiGroup;\n \nsolve :: int_search([quasiGroup[row, col] | row, col in nDomain],\n        first_fail, indomain_min, complete) satisfy;\n \nconstraint\n \n     % All rows have to be different\n     forall(row in nDomain) (\n          all_different([quasiGroup[row,col] | col in nDomain])\n     )\n     /\\\n     % All columns have to be different       \n     forall(col in nDomain) (\n          all_different([quasiGroup[row,col] | row in nDomain ])\n     )\n     /\\\n     % ((i*j)*j)*j = a\n     forall(i in nDomain) (\n          forall(j in nDomain) (\n            quasiGroup[quasiGroup[quasiGroup[i,j],j],j] = i\n          )\n     )\n     /\\\n     % Idempotency\n     forall(i in nDomain) (\n          quasiGroup[i,i] = i\n     )\n     /\\\n     % Implied (from Colton,Miguel 01)\n     forall(i in nDomain) (\n       forall(j in nDomain) (\n         (quasiGroup[i,j]=i) <-> (quasiGroup[j,i]=i)\n       )\n     )\n     /\\\n     % Symmetry-breaking constraints   \n     forall(i in nDomain) (\n           quasiGroup[i,n-1] + 2 >= i\n     )\n;\n \noutput [\n  if col = 0 then \"\\n\" else \" \" endif ++\n    show(quasiGroup[row, col])\n  | row, col in nDomain\n] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 10965, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "92f82710-0397-4ba4-a5fd-510a71acc0aa": {"__data__": {"id_": "92f82710-0397-4ba4-a5fd-510a71acc0aa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "queens_source_code", "node_type": "4", "metadata": {}, "hash": "9f9b1c9732ea34cd7961668d8f48402679928e6933dfbaa203cb5dfb36aee5cd", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n% n queens problem in MiniZinc.\n\ninclude \"globals.mzn\";\n\nint: n;\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail, \n        indomain_min, \n        complete) \n    satisfy;\n\n% solve satisfy;\n\nconstraint all_different(queens);\n\nconstraint\n    forall(i, j in 1..n where i < j) (\n         queens[i] != queens[j] /\\\n         queens[i] + i != queens[j] + j /\\\n         queens[i] - i != queens[j] - j\n    ) \n ;\n\noutput [\n  show(queens) ++ \"\\n\"\n\n];\n\n% data\nn = 8;\n\n\n\nModel 2 : \n\n\ninclude \"globals.mzn\";\n\nint: n;\n\narray[1..n] of var 1..n: queens;\n\nsolve :: int_search(\n        queens, \n        first_fail,\n        indomain_median,\n        complete\n       )\n     satisfy;\n\n% solve satisfy;\nconstraint all_different(queens); %  :: domain;\nconstraint all_different([queens[i]+i | i in 1..n]) :: domain;\nconstraint all_different([queens[i]-i | i in 1..n]) :: domain;\n\noutput \n[\n  \"queens: \" ++ show(queens)\n] ++ \n% [\n%   if j = 1 then \"\\n\" else \"\" endif ++\n%      if fix(queens[i]) = j then          \n%         show_int(2,j)\n%      else\n%         \"__\"\n%      endif\n%   | i in 1..n, j in 1..n\n% ] ++\n[\"\\n\"]\n;\n\n% data\nn = 8;\n\n\nModel 3 :\n\n\n\nint: n;                                 % The number of queens.\n\narray [1..n] of var 1..n: q;\n\ninclude \"alldifferent.mzn\";\n\nconstraint alldifferent(q);\nconstraint alldifferent(i in 1..n)(q[i] + i);\nconstraint alldifferent(i in 1..n)(q[i] - i);\n\n\nsolve \n%      :: int_search(q, input_order, indomain_min, complete) \n%      :: int_search(q, first_fail, indomain_min, complete) \n%      :: int_search(q, smallest, indomain_min, complete)\n%      :: int_search(q, largest, indomain_min, complete)\n%      :: int_search(q, input_order, indomain_max, complete) \n%      :: int_search(q, first_fail, indomain_max, complete) \n%      :: int_search(q, smallest, indomain_max, complete)\n%      :: int_search(q, largest, indomain_max, complete)\n%      :: int_search(q, input_order, indomain_median, complete) \n%      :: int_search(q, first_fail, indomain_median, complete) \n%      :: int_search(q, smallest, indomain_median, complete)\n%      :: int_search(q, largest, indomain_median, complete)\n%      :: int_search(q, input_order, indomain_random, complete) \n%      :: int_search(q, first_fail, indomain_random, complete) \n%      :: int_search(q, smallest, indomain_random, complete)\n%      :: int_search(q, largest, indomain_random, complete)\n      satisfy;\n\n%output\t\n%%\t[\tif fix(q[i]) = j then \"Q \" else \". \" endif ++\n%\t \tif j = n then \"\\n\" else \"\" endif\n%\t|\ti, j in 1..n\n%\t];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2540, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9ca7cba3-b489-479b-afa9-5b2c9b3932e6": {"__data__": {"id_": "9ca7cba3-b489-479b-afa9-5b2c9b3932e6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rcpsp_source_code", "node_type": "4", "metadata": {}, "hash": "6b2c113305d5911b1055905560c7783897eb8c80334f084e487d4be659d9aafa", "class_name": "RelatedNodeInfo"}}, "text": "int: n; % number of tasks\nset of int: TASK = 1..n;\narray[TASK] of int: d; % duration\n\nint: m; % number of resources\nset of int: RESOURCE = 1..m;\narray[RESOURCE] of int: L; % resource limit\narray[RESOURCE,TASK] of int: res; % usage\n\nint: l; % number of precedences\nset of int: PREC = 1..l;\narray[PREC,1..2] of TASK: pre; % predecessor/successor pairs\n\nint: maxt; % maximum time\nset of int: TIME = 0..maxt;\n\narray[TASK] of var TIME: s; % start time\n\nconstraint forall(p in PREC)(s[pre[p,1]]+d[pre[p,1]] <= s[pre[p,2]]);\n\ninclude \"cumulative.mzn\";\nconstraint forall(r in RESOURCE)\n                 (cumulative(s,d,[res[r,t]|t in TASK],L[r]));\n%constraint forall(r in RESOURCE) \n%                 ( let { array[int] of var int: ss = \n%                              [ s[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: dd = \n%                              [ d[t] | t in TASK where res[r,t] > 0 ];\n%                         array[int] of var int: rr = \n%                              [ res[r,t] | t in TASK where res[r,t] > 0 ]; } in\n%                   cumulative(ss,dd,rr,L[r]));\n\nsolve minimize max(t in TASK)(s[t] + d[t]);\n\noutput [show(s)];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1176, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "299ce69c-d698-4784-8567-558e383cf857": {"__data__": {"id_": "299ce69c-d698-4784-8567-558e383cf857", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rehearsal_source_code", "node_type": "4", "metadata": {}, "hash": "b68ede0ba3fe571c7157e325d4d16761aee073d40b941057f5a23b54cfaa5d6b", "class_name": "RelatedNodeInfo"}}, "text": "%\n% Scheduling a Rehearsal in MiniZinc.\n% A concert is to consist of nine pieces of music of different durations\n% each involving a different combination of the five members of the orchestra.\n% Players can arrive at rehearsals immediately before the first piece in which\n% they are involved and depart immediately after the last piece in which\n% they are involved. The problem is to devise an order in which the pieces\n% can be rehearsed so as to minimize the total time that players are waiting\n% to play, i.e. the total time when players are present but not currently\n% playing. In the table below, 1 means that the player is required for\n% the corresponding piece, 0 otherwise. The duration (i.e. rehearsal time)\n% is in some unspecified time units.\n%\n%    Piece       1    2   3    4    5  6    7   8    9\n%    Player 1    1    1   0    1    0  1    1   0    1\n%    Player 2    1    1   0    1    1  1    0   1    0\n%    Player 3    1    1   0    0    0  0    1   1    0\n%    Player 4    1    0   0    0    1  1    0   0    1\n%    Player 5    0    0   1    0    1  1    1   1    0\n%    Duration    2    4   1    3    3  2    5   7    6\n%\n% For example, if the nine pieces were rehearsed in numerical order as\n% given above, then the total waiting time would be:\n%       Player 1: 1+3+7=11\n%       Player 2: 1+5=6\n%       Player 3: 1+3+3+2=9\n%       Player 4: 4+1+3+5+7=20\n%       Player 5: 3\n% giving a total of 49 units. The optimal sequence, as we shall see,\n% is much better than this.\n%\n% ...\n%\n% The minimum waiting time for the rehearsal problem is 17 time units, and\n% an optimal sequence is 3, 8, 2, 7, 1, 6, 5, 4, 9.\n%\n% \"\"\"\n\n\ninclude \"globals.mzn\"; \n\n\nint: num_pieces;\nint: num_players;\narray[1..num_pieces] of int: duration;\narray[1..num_players, 1..num_pieces] of 0..1: rehearsal;\n\n\n%\n% Decision variables\n%\narray[1..num_pieces] of var 1..num_pieces: rehearsal_order;\narray[1..num_players] of var 0..sum(duration): waiting_time; % waiting time for players\narray[1..num_players] of var 1..num_pieces: p_from; % first rehearsal\narray[1..num_players] of var 1..num_pieces: p_to;   % last rehearsal\nvar 0..sum(duration): total_waiting_time = sum(waiting_time); % objective\n\nsolve :: int_search(\n         rehearsal_order % ++ waiting_time% ++ p_from ++ p_to ++ [total_waiting_time]\n         , \n         first_fail, % occurrence, % max_regret, % first_fail, \n         indomain_max, % indomain_max, \n         complete) \n     minimize total_waiting_time;\n     % satisfy;\n\n% solve :: labelling_ff minimize total_waiting_time;\n\nconstraint\n  all_different(rehearsal_order) :: domain\n  /\\\n\n  % This solution is my own without glancing at Smith's models...\n  forall(p in 1..num_players) (\n     % This versions is much faster than using exists (see below)\n     % fix the range from..to, i.e. don't count all that start with 0 \n     % or ends with 0.\n     % This means that we collect the rehearsals with many 0 at the ends\n     %\n     p_from[p] < p_to[p]\n     /\\\n     % skipping rehearsal at start (don't come yet)\n     forall(i in 1..num_pieces) (\n        i < p_from[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\\n     % skipping rehearsal at end (go home after last rehearsal)\n     forall(i in 1..num_pieces) (\n        i > p_to[p] -> (rehearsal[p, rehearsal_order[i]] = 0)\n     )\n     /\\ % and now: count the waiting time for from..to\n     waiting_time[p] = \n         sum(i in 1..num_pieces) (\n              duration[rehearsal_order[i]] * bool2int(\n                                             i >= p_from[p] /\\ i <= p_to[p] \n                                             /\\\n                                             rehearsal[p,rehearsal_order[i]] = 0\n                                )\n     ) \n\n%      % alternative solution with exists. \n%      %  More elegant (= declarative) in my book but slower.\n%      exists(from, to in 1..num_pieces) ( \n%         % skipping rehearsal at start (don't come yet)\n%         forall(i in 1..from-1) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\\n%         % skipping rehearsal at end (go home after last rehearsal)\n%         forall(i in to+1..num_pieces) (\n%            rehearsal[p, rehearsal_order[i]] = 0\n%         )\n%         /\\ % and now: count the waiting time for from..to\n%         waiting_time[p] = \n%             sum(i in from..to) (\n%                  duration[rehearsal_order[i]]*\n%                                  bool2int(\n%                                       rehearsal[p,rehearsal_order[i]] = 0\n%                                   )\n%          ) \n%      )\n\n\n  )\n\n  /\\ % symmetry breaking\n  rehearsal_order[1] < rehearsal_order[num_pieces]\n\n  % for all solutions\n  % /\\ total_waiting_time = 17\n;\n\n\n%\n% data\n%\n%\n% num_pieces = 9;\n% num_players = 5;\n% duration = [2, 4, 1, 3, 3, 2, 5, 7, 6];\n% rehearsal = array2d(1..num_players, 1..num_pieces, \n%     [\n%      1,1,0,1,0,1,1,0,1,\n%      1,1,0,1,1,1,0,1,0,\n%      1,1,0,0,0,0,1,1,0,\n%      1,0,0,0,1,1,0,0,1,\n%      0,0,1,0,1,1,1,1,0\n%   ]);\n\n%\n% This is the problem from the Choco v 2.1 example \n% num_pieces = 5;\n% num_players = 3;\n% duration = [4,6,3,5,7];\n% rehearsal =  array2d(1..num_players, 1..num_pieces, \n%         [\n%         1,1,0,1,0,\n%         0,1,1,0,1,\n%         1,1,0,1,1   \n%   ]);\n\n\noutput[\n  \"order: \" , show(rehearsal_order), \"\\n\",\n  \"waiting_time: \", show(waiting_time), \"\\n\",\n  \"total_waiting_time: \" , show(total_waiting_time), \"\\n\",\n] ++ \n[\n  if j = 1 then \"\\n\" else \" \" endif ++\n    show(rehearsal[p, rehearsal_order[j]]) ++ \" \"\n  | p in 1..num_players, j in 1..num_pieces, \n] ++ \n[\"\\n\"]\n;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 5565, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "438ba176-5f5d-4244-aea7-bc5a6e1a2198": {"__data__": {"id_": "438ba176-5f5d-4244-aea7-bc5a6e1a2198", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "restart_source_code", "node_type": "4", "metadata": {}, "hash": "5b0089aa1889f268def7f87780248c1913f8a7854e9033089ad38523c0e45e60", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 : \n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;\n\n\nModel 2 :\n\n\narray[1..10] of var 1..10:x;\n\nconstraint forall(i,j in 1..10 where i < j)\n                 (x[i] != x[j]);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_max, complete)\n      satisfy;\n\n\nModel 3 : \n\n\narray[1..10] of var 1..10:x;\ninclude \"alldifferent.mzn\";\nconstraint alldifferent(x);\nconstraint forall(i in 2..10)(x[i] <= 9);\nconstraint x[1] >= 9;\n\nsolve :: int_search(x, input_order, indomain_min, complete)\n      satisfy;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 760, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "405d445d-d23e-483e-8068-6094b6ed1b1a": {"__data__": {"id_": "405d445d-d23e-483e-8068-6094b6ed1b1a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "RosteringProblem_source_code", "node_type": "4", "metadata": {}, "hash": "4e895a57eb61ada64730eb86aee4d3e64d9cf35208a30dcdb27a9643daa5efcd", "class_name": "RelatedNodeInfo"}}, "text": "include \"all_equal.mzn\";\ninclude \"global_cardinality.mzn\";\n\n% load parameters\ninclude \"parameters.dzn\";\n\nint: daysPerWeek = 7;\n\n% the number of weeks\nint: numberOfWeeks;\n\nint: numberOfDays = numberOfWeeks * daysPerWeek;\n\n% the minimum number of days in a row with the same shift\nint: s_min;\n\n% the maximum number of days in a row with the same shift\nint: s_max; \n\n% 3 shifts: early = 1, late = 2 and night shift = 3 + day off (rest day) = 0\nint: numberOfShifts = 3;\n\n% the shift requirement matrix, including at M_{i,j} the needed employees for day i and shift j\narray[1..daysPerWeek, 1..numberOfShifts+1] of int: shiftRequirements;\n\n\n% the variables X \narray[1..numberOfWeeks * daysPerWeek] of var 0..numberOfShifts: plan1d;\narray[1..numberOfWeeks,1..daysPerWeek] of var 0..numberOfShifts: plan2d;\narray[1..daysPerWeek,1..numberOfWeeks] of var 0..numberOfShifts: plan2dT;\n\n% helper arrays\narray[1..s_min,1..s_min] of var 0..numberOfShifts: s_min_arrays;\narray[1..s_max,1..s_max] of var 0..numberOfShifts: s_max_arrays;\n\n% convert the 2D plan into 1D\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan1d[(week-1) * daysPerWeek + day]\n           );  \n\n% transpose the 2D plan\nconstraint forall(week in 1..numberOfWeeks, day in 1..daysPerWeek) (\n                 plan2d[week, day] == plan2dT[day, week]\n           );\n\n% C_equalDays: constrains that weekend days (Saturday and Sunday) always have the same shift\nconstraint forall(week in 1..numberOfWeeks) (\n               plan2d[week, daysPerWeek - 1] == plan2d[week, daysPerWeek]\n           );                        \n\n                                                                                                                                \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_min, j in 1..s_min) (\n                 s_min_arrays[i, j] == plan1d[((numberOfDays - s_min - 1 + i + j) mod numberOfDays) + 1]\n           );                                            \n                                            \n% C_shiftRepetitions:for every shift type a minimum number of consecutive assignments to this shift is given\nconstraint forall(day in 1..numberOfDays - s_min) (\n               plan1d[day] != plan1d[day+1] -> all_equal(plan1d[day+1..day+s_min])\n           );     \n% the constraints over the array bounds           \nconstraint forall(d in 1..s_min) (\n               plan1d[d + numberOfDays - s_min] != plan1d[((d + numberOfDays - s_min) mod numberOfDays) +1] -> all_equal(s_min_arrays[d,1..s_min])\n           );                     \n\n           \n% create the sub arrays other the array bounds\nconstraint forall(i in 1..s_max, j in 1..s_max) (\n                 s_max_arrays[i, j] == plan1d[((numberOfDays - s_max - 2 + i + j) mod numberOfDays) + 1]\n           );                      \n                                            \n% C_shiftRepetitions:for every shift type a maximum number of consecutive assignments to this shift is given           \nconstraint forall(day in 1..numberOfWeeks * daysPerWeek - s_max) (\n               (all_equal(plan1d[day..day+s_max])) -> (plan1d[day] != plan1d[day + s_max])\n           );               \n% the constraints over the array bounds             \nconstraint forall(d in 1..s_max) (\n               (all_equal(s_max_arrays[d, 1..s_max])) -> (plan1d[d + numberOfDays - s_max] != plan1d[d])\n           );                     \n\n                               \n                                                                                                   \n% C_restDays: at least 2 days must be rest days every 2 weeks.\nconstraint forall(day in 1..(numberOfWeeks - 2) * daysPerWeek) (\n               count(j in plan1d[day..day + daysPerWeek * 2])(j=0) >= 2                   \n           );            \nconstraint forall(i in 1..2 * daysPerWeek-1) (\n               count(j in plan1d[numberOfWeeks * daysPerWeek-i .. numberOfWeeks * daysPerWeek] ++ plan1d[1..2*daysPerWeek-i])(j=0) >= 2    \n           );         \n                                            \n% C_shiftOrder: restricts the order of shifts. There is a forward rotating principle. This means, that after an early shift there can only follow a shift with the same or a higher value, or a rest shift.\nconstraint forall(day in 2..numberOfWeeks * daysPerWeek - 1) (\n               plan1d[day] <= plan1d[day + 1] \\/ plan1d[day+1] == 0\n           );         \nconstraint plan1d[1] >= plan1d[numberOfDays] \\/ plan1d[1] == 0;\n                      \n% C_shiftRequirements: for every weekday for each shift the number of required staff is provided (e.g. usually less staff is required on the weekend) \nconstraint forall(day in 1..daysPerWeek) (\n              (global_cardinality(row(plan2dT,day),[0,1,2,3],row(shiftRequirements,day)))   \n           );    \n           \n% solve the problem           \nsolve :: int_search(plan1d, input_order, indomain_min, complete)\n      satisfy;           \n      \n% print the problem      \noutput [ show(row(plan2d,j)) ++ \"\\n\" | j in 1..numberOfWeeks ] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 5048, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "45542679-3e9c-4765-8241-0c66cdf72603": {"__data__": {"id_": "45542679-3e9c-4765-8241-0c66cdf72603", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sb_source_code", "node_type": "4", "metadata": {}, "hash": "1a6310d619364121e627aa242992c1c326b8b434091d5f9610fa6b63e4ea092e", "class_name": "RelatedNodeInfo"}}, "text": "% Solitaire Battleships is a puzzle where\n% we are given a partially filled in board and the number\n% of ships in each row and column and have to fill it with ships\n \n% \"Improved\" version does not introduce reified set_in\n\nint: width;   % height of board (usually 10)\nint: height;  % width of board (usually 10)\nint: maxship; % maximal length of ship (usually 4)\n\n\nset of int: ROWS = 1..width;\nset of int: COLS = 1..height;\nset of int: XROWS = 0..width+1;    % extended rows\nset of int: XCOLS = 0..height+1;   % extended cols\n\n%% ship types enumerated type\nset of int: SHIPS = 1..maxship;  % different ship types\nint: submarine = 1;\nint: destroyer = 2;\nint: cruiser = 3;\nint: battleship = 4;\n\n\n%% the PIECES enumerated type!\nset of int: PIECES = 1..7;\nint: w = 1; % water\nint: c = 2; % circle (submarine)\nint: l = 3; % left end of ship\nint: r = 4; % right end of ship\nint: t = 5; % top of ship\nint: b = 6; % bottom of ship\nint: m = 7; % middle of ship\narray[PIECES] of string: code = [\".\",\"c\",\"l\",\"r\",\"t\",\"b\",\"m\"];\n\narray[ROWS,COLS] of 0..7: hint; % the initial board configuration\narray[ROWS] of int: rowsum;     % sums for each row\narray[COLS] of int: colsum;     % sums for each col\narray[SHIPS] of int: ship; % the number of each type of ship (usually [4,3,2,1]).\n\n\n\n% variables \narray[XROWS,XCOLS] of var PIECES: board;  % the board\n \narray[XROWS,XCOLS] of var 0..1: fill;     % which pieces are ships\n\narray[PIECES] of var 0..width*height: npiece; % number of pieces of each type\n\n\n% model\n\n% ensure hints are respected\nconstraint forall(i in ROWS, j in COLS)(\n\t\t\t   if hint[i,j] != 0 then\n\t\t\t   \t\tboard[i,j] == hint[i,j]\n\t\t\t   else true endif\n\t       ); \n\n% make extended rows and cols empty\nconstraint forall(i in XROWS)(board[i,0] == w /\\ board[i,width+1] == w);\nconstraint forall(j in COLS)(board[0,j] == w /\\ board[height+1,j] == w);\n\n% ensure that the fill array matches the board\nconstraint forall(i in XROWS, j in XCOLS)(\n\t\t\t   fill[i,j] = bool2int(board[i,j] != w)\n\t       ); \n\n% spacing constraints: gaps betwen ships\nconstraint forall(i in ROWS, j in COLS)(\n\t   (board[i,j] == w \\/ board[i+1,j+1] == w)\n\t/\\ (board[i,j] == w \\/ board[i+1,j-1] == w)   % diagonal constraints\n            /\\ (board[i,j] in {c,l,r,t} -> board[i-1,j] == w)\n            /\\ (board[i,j] in {c,l,r,b} -> board[i+1,j] == w)\n            /\\ (board[i,j] in {c,l,t,b} -> board[i,j-1] == w)\n            /\\ (board[i,j] in {c,r,t,b} -> board[i,j+1] == w)\n           );\n               \t\t\t                       \n% ship shape constraints\nconstraint forall(i in ROWS, j in COLS)(\n               %% a left piece needs a right piece or middle to the right\n\t\t\t   (board[i,j] == l -> (board[i,j+1] == r \\/ board[i,j+1] == m))\n\t\t\t/\\ (board[i,j] == r -> (board[i,j-1] == l \\/ board[i,j-1] == m))\n\t\t\t/\\ (board[i,j] == t -> (board[i+1,j] == b \\/ board[i+1,j] == m))\n\t\t\t/\\ (board[i,j] == b -> (board[i-1,j] == t \\/ board[i-1,j] == m))\n\t\t\t   %% a middle piece has to have two opposite sides filled\n\t\t\t/\\ (board[i,j] == m -> (   fill[i-1,j] == fill[i+1,j]\n\t\t\t                        /\\ fill[i,j-1] == fill[i,j+1]\n\t\t\t                        /\\ fill[i-1,j] + fill[i,j-1] == 1))\n\t\t   );\n\t\t   \n% sum up pieces\nconstraint forall(p in PIECES)(\n\t\t\t   sum(i in ROWS, j in COLS)(bool2int(board[i,j] == p)) == npiece[p]\n\t\t   );\n\n% piece sum constraints\nconstraint npiece[c] == ship[submarine]; % submarines\nconstraint npiece[l] == npiece[r]; % left right (probably redundant)\nconstraint npiece[t] == npiece[b]; % top bottom\nconstraint npiece[l] + npiece[t] == sum(s in destroyer..maxship)(ship[s]); \n                                   % no of ends\nconstraint npiece[m] == sum(s in cruiser..maxship)(ship[s] * (s - 2)); \n                                   % no of middles \t\t   \n\t\t    \n% count number of bigger ships\n% at least for standard battleships you can probably simply\n% enforce this constraint for s in destroyer..destroyer\t\t\n% and still be guaranteed a correct solution    \nconstraint forall(s in destroyer..maxship)(\n\t           sum(i in ROWS,j in COLS)(bool2int(\n\t\t\t       if j + s - 1 <= width then\n\t\t\t          board[i,j] == l /\\ board[i,j+s-1] == r     % ship length s lr\n\t\t\t       /\\ forall(k in j+1..j+s-2)(board[i,k] == m)\n\t\t\t       else false endif\n\t\t\t    \\/\n\t\t\t       if i + s - 1 <= height then\n\t\t\t          board[i,j] == t /\\ board[i+s-1,j] == b     % ship length s tb\n\t\t\t       /\\ forall(k in i+1..i+s-2)(board[k,j] == m)\n\t\t\t       else false endif\n\t\t       )) = ship[s]\n\t\t   );\t\t    \n\t\t    \t\t    \n\n% row sums respected\nconstraint forall(i in ROWS)(\n               sum(j in COLS)(fill[i,j]) == rowsum[i]\n           );\n           \n% column sums respected           \nconstraint forall(j in COLS)(\n               sum(i in ROWS)(fill[i,j]) == colsum[j]\n           );           \n\n\nsolve :: int_search([ fill[i,j] | i in ROWS, j in COLS], \n      \t\t  input_order, indomain_min, complete)\n      satisfy;\n\noutput [ code[fix(board[i,j])] ++ \n\t\t if j == width then \" \" ++ show(rowsum[i]) ++ \"\\n\"\n\t\t else \"\" endif\n\t   | i in ROWS, j in COLS ]  ++\n\t   [ show(colsum[j]) | j in COLS ] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 5061, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bccfa98d-d62d-4a91-8c3a-30928dcc254b": {"__data__": {"id_": "bccfa98d-d62d-4a91-8c3a-30928dcc254b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "schur_source_code", "node_type": "4", "metadata": {}, "hash": "4894db43615e6db12d5427d12599e5126525482bc8c2676d817b58c862138f77", "class_name": "RelatedNodeInfo"}}, "text": "%% schurs numbers\n%%\n%% determine if n balls labelled 1..n\n%% can be placed in c boxes with no box containing a triple {x,y,z} where x+y=z\n \n\nint: n; %% number of balls\nint: c; %% number of boxes\n\narray[1..n] of var 1..c: box;\n\nconstraint forall(i in 1..n-1, j in i+1 .. n - i)(\n\t   \t    box[i] != box[j] \\/ \n\t\t    box[i] != box[i+j] \\/ \n\t\t    box[j] != box[i+j]);\n\nsolve satisfy;\n\noutput [\"n = \", show(n), \";\\nc = \", show(c), \";\\nbox = \",show(box),\";\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 456, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c0aba51c-5c79-43c5-8a9e-99dfab3eea62": {"__data__": {"id_": "c0aba51c-5c79-43c5-8a9e-99dfab3eea62", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "setselect_source_code", "node_type": "4", "metadata": {}, "hash": "d07fef33f8f12689e6dd97209b86e0d945f88766c68f4346db88cd8ee6444927", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n\n% setselect\nint: n; % number of elements\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 2 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\nvar set of 1..n: x;\n\nconstraint forall(i in 1..k)(card(x intersect s[i]) <= 1);\nconstraint card(x) = u;\n\nsolve maximize sum(i in x)(i);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 3 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 1..n: x;\n%constraint forall(i in 1..u-1)(x[i] < x[i+1]);\nconstraint forall(i,j in 1..u where i < j)(x[i] != x[j]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];\n\n\n\nModel 4 : \n\n\n\n% setselect revised\nint: n; % number of elements\nint: u; % cardinality bound of chosen set\nint: k; % number of subsets\narray[1..k] of set of 1..n: s;\n\narray[1..u] of var 0..n: x;\nconstraint forall(i in 1..u-1)(x[i] >= (x[i] != 0) + x[i+1]);\n\nconstraint forall(i in 1..k)(sum(j in 1..u)(x[j] in s[i]) <= 1);\n\nsolve maximize sum(x);\n\noutput [\"x = \", show(x), \";\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1392, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "daa3db9b-e979-44e5-b3d6-154275e09082": {"__data__": {"id_": "daa3db9b-e979-44e5-b3d6-154275e09082", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "shipping_source_code", "node_type": "4", "metadata": {}, "hash": "3f0fef7a00d56cf689157a0c4fa93a9c6d26f503ffd6d5025f8e3b7e194ec1f4", "class_name": "RelatedNodeInfo"}}, "text": "int: W; % number of Warehousse\nset of int: WARE = 1..W;\nint: F; % number of Factories\nset of int: FACT = 1..F;\n\narray[WARE] of int: demand;\narray[FACT] of int: production;\n\narray[FACT,WARE] of int: cost;\n\narray[FACT,WARE] of var int: ship;\n\n%int: m = max(demand);\n%array[FACT,WARE] of var 0..m: ship;\nconstraint forall(f in FACT, w in WARE)(ship[f,w] >= 0);\n\nconstraint forall(w in WARE)\n                 (sum(f in FACT)(ship[f,w]) >= demand[w]);\n\nconstraint forall(f in FACT)\n                 (sum(w in WARE)(ship[f,w]) <= production[f]);\n\nsolve minimize sum(f in FACT, w in WARE)\n                  (cost[f,w]*ship[f,w]);\n\n\noutput [ show_int(2,ship[f,w]) ++\n         if w == W then \"\\n\" else \" \" endif\n       | f in FACT, w in WARE ];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 735, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6dc48126-89e9-4e2d-8706-c67a1b7ff7ab": {"__data__": {"id_": "6dc48126-89e9-4e2d-8706-c67a1b7ff7ab", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "simple-prod-planning_source_code", "node_type": "4", "metadata": {}, "hash": "f1f5c249306214e6a9f4f91d775e64a1d01ec8f4215d8eb56bcad9de02665b4e", "class_name": "RelatedNodeInfo"}}, "text": "% Number of different products\nint: nproducts; \nset of int: Products = 1..nproducts;  \n\n%profit per unit for each product\narray[Products] of int: profit;\narray[Products] of string: pname; \n\n%Number of resources\nint: nresources; \nset of int: Resources = 1..nresources; \n\n%amount of each resource available\narray[Resources] of int: capacity; \narray[Resources] of string: rname;\n\n%units of each resource required to produce 1 unit of product\narray[Products, Resources] of int: consumption; \nconstraint assert(forall (r in Resources, p in Products) \n           (consumption[p,r] >= 0), \"Error: negative consumption\");\n\n% bound on number of Products\nint: mproducts = max (p in Products) \n                     (min (r in Resources where consumption[p,r] > 0) \n                          (capacity[r] div consumption[p,r]));\n\n% Variables: how much should we make of each product\narray[Products] of var 0..mproducts: produce;\narray[Resources] of var 0..max(capacity): used;\n\n% Production cannot use more than the available Resources:\nconstraint forall (r in Resources) (     \n      used[r] = sum (p in Products)(consumption[p, r] * produce[p]) \n      /\\ used[r] <= capacity[r]\n);    \n\n% Maximize profit\nsolve maximize sum (p in Products) (profit[p]*produce[p]);\n\noutput [ show(pname[p]) ++ \" = \" ++ show(produce[p]) ++ \";\\n\" |\n         p in Products ] ++\n       [ show(rname[r]) ++ \" = \" ++ show(used[r]) ++ \";\\n\" |\n         r in Resources ];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1433, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ba321611-e320-44fe-b92a-5810fc24a5e8": {"__data__": {"id_": "ba321611-e320-44fe-b92a-5810fc24a5e8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sonet_problem_source_code", "node_type": "4", "metadata": {}, "hash": "d436192c4f74f358a66969ee6cec919b89d2a376aaf37fa567442a121ab09b53", "class_name": "RelatedNodeInfo"}}, "text": "% The SONET problem is a network design problem: set up a network between\n% n nodes, where only certain nodes require a connection.\n% Nodes are connected by putting them on a ring, where all nodes\n% on a ring can communicate. Putting a node on a ring requires a so-called\n% ADM, and each ring has a capacity of nodes, i.e. ADMs. There is a certain\n% amount of rings, r, that is available. The objective is to set up a network\n% by using a minimal amount of ADMs.\n%\n%\n% About the problem model\n%\n% The problem model has the amount of rings ('r'), amount of nodes('n'),\n% the 'demand' (which nodes require communication) and node-capacity of each\n% ring ('capacity_nodes') as parameters.\n% The assignement of nodes to rings is modelled by a 2-dimensional matrix 'rings',\n% indexed by the amnount of rings and nodes. The matrix-domain is boolean:\n% If the node in column j is assigned to the ring in row i, then rings[i,j] = 1\n% and 0 otherwise. So all the '1's in the matrix 'rings' stand for an ADM.\n% Hence the objective is to minimise the sum over all columns and rows of matrix\n% 'rings'.\n% \"\"\"\n\nint: r;  % upper bound for amount of rings\nint: n;  % amount of clients\n\n\n% original comment: \n% we have double entries here because of the symmetric structure!\narray[1..n, 1..n] of 0..1: demand;\narray[1..r] of 1..n: capacity_nodes;\n\narray[1..r, 1..n] of var 0..1: rings;\nvar int: z =  sum(ring in 1..r, client in 1..n) (rings[ring, client]);\n\nsolve minimize z;\n% solve satisfy;\n\n\nconstraint\n%   z <= 7 % for solve satisfy\n%   /\\\n\n   % original comment:\n   % if there is a demand between 2 nodes, then there has to exist \n   % a ring, on which they are both installed\n   forall(client1,client2 in 1..n where client1 < client2) (\n      (demand[client1,client2] = 1) ->\n           exists(ring in 1..r) (\n                 rings[ring,client1] + rings[ring, client2] >= 2\n           )\n   )   \n   /\\\n   % original comment:\n   % capacity of each ring must not be exceeded     \n   forall(ring in 1..r) (\n        sum(client in 1..n) (\n              rings[ring, client]\n              ) <= capacity_nodes[ring] \n   )\n;\n\n\n%\n% data\n% (sonet_problem1nu.param)\n%\nr = 4;\nn = 5;\n\ndemand =\narray2d(1..n, 1..n,\n        [0,1,0,1,0,\n         1,0,1,0,0,\n         0,1,0,0,1,\n         1,0,0,0,0,\n         0,0,1,0,0])\n;\n\ncapacity_nodes = [3,2,2,1];\n\n\noutput \n[\n  \"z: \", show(z)\n] ++\n[\n  if client = 1 then \"\\n\" else \" \" endif ++\n    show(rings[ring, client])\n  | ring in 1..r, client in 1..n\n] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2477, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4e842621-0b55-4126-8a1d-207ba6081f49": {"__data__": {"id_": "4e842621-0b55-4126-8a1d-207ba6081f49", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "square_pack_source_code", "node_type": "4", "metadata": {}, "hash": "6eeba7481cbfb6c790d04809f716efbaf483700acc66aa87ea0bb4db2bcc07b4", "class_name": "RelatedNodeInfo"}}, "text": "int: n; % number of squares\nset of int: SQUARE = 1..n;\nint: maxl = sum(i in SQUARE)(i);\nint: mina = sum(i in SQUARE)(i*i);\n\nvar n..maxl: height;\nvar n..maxl: width;\nvar mina .. n*maxl: area = height * width;\n\narray[SQUARE] of var 0..maxl: x;\narray[SQUARE] of var 0..maxl: y;\n\n% squares fit in the rectangle\nconstraint forall(s in SQUARE)(x[s] + s <= width);\nconstraint forall(s in SQUARE)(y[s] + s <= height);\n\n% non overlap\nconstraint forall(s1, s2 in SQUARE where s1 < s2)\n                 (x[s1] + s1 <= x[s2] \\/\n                  x[s2] + s2 <= x[s1] \\/  \n                  y[s1] + s1 <= y[s2] \\/ \n                  y[s2] + s2 <= y[s1]);\narray[SQUARE] of int: size = [ i | i in SQUARE ];\n\n% non overlap with global diffn\ninclude \"diffn.mzn\";\n%constraint diffn(x,y,size,size);\n\n% redundant cumulative constraints\ninclude \"cumulative.mzn\";\n%constraint cumulative(x,size,size,height);\n%constraint cumulative(y,size,size,width);\n\n% variables ordered in reverse size x[n], y[n], x[n-1], y[n-1], ..., x[1], y[1]\n%array[1..2*n] of var 0..maxl: vs = [ if i mod 2 = 0 then x[n+1 - i div 2] \n%                                     else y[n+1 - i div 2] endif | i in 2..2*n+1 ];\n\nsolve :: seq_search([\n         int_search([area,height,width], input_order, indomain_min, complete) \n         %,int_search(vs, input_order, indomain_min, complete)\n         ])\n      minimize area;\n\noutput [\"area = \",show(area), \"\\n\"] ++\n[\"height = \",show(height), \"\\n\"] ++\n[\"width = \",show(width), \"\\n\"] ++\n[\"x = \", show(x), \"\\n\"] ++\n[\"y = \", show(y), \"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1529, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0a92c3d8-0a32-4f34-9b29-4e93f6c8740b": {"__data__": {"id_": "0a92c3d8-0a32-4f34-9b29-4e93f6c8740b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "stableroommates_source_code", "node_type": "4", "metadata": {}, "hash": "05dc06b7c8e49b92286ff2c90642c8e0637ad4a4412820a96acacf6edead8b19", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\nset of int: AGENT0 = 0..n;    % zero indicates no agent\narray[AGENT,1..n-1] of AGENT0: pref; % preference order for each agent\n     % the preference order is padded by zeros\narray[AGENT] of int: npref = [ sum(j in 1..n-1)(bool2int(pref[i,j] > 0))\n                             | i in AGENT ];\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..n-1)\n                               (pref[i,j] != i /\\ \n                                (pref[i,j] = 0 <-> j > npref[i])) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref[i,j1] != pref[i,j2]),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n%% ranking information: rank = 0 means not ranked\narray[AGENT,AGENT] of 0..n-1: rank = \n     array2d(AGENT,AGENT, [ max([bool2int(pref[i1,j] = i2) * j | j in 1..n-1])\n                          | i1, i2 in AGENT ]);\n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] > rank[i,j] -> a[j] < rank[j,i]\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref[i,p] } in \n                   a[i] = rank[i,j] -> a[j] = rank[j,i]\n                 );\n\nsolve satisfy;\n\noutput  [ if i < fix(pref[i,a[i]]) then \"(\" ++ show(i) ++ \",\" ++ show(pref[i,a[i]]) ++ \")\\n\"\n          else \"\" endif\n        | i in AGENT ]\n       ++ [show(rank),\"\\n\"] \n %      ++ [show(npref),\"\\n\"] \n %      ++ [show(a),\"\\n\"]\n        ;\n       \n\n\nModel 2 :\n\n\n\n% Taken from the paper by Patrick Prosser at CPAIOR 2014\nint: n; % number of agents\nset of int: AGENT = 1..n;\n\narray[AGENT] of int: npref; % number of preferences of each agent\narray[AGENT] of int: cum_npref = [ sum(j in 1..i-1)(npref[j]) | i in AGENT];\narray[1..sum(npref)] of int: preferences;  % all preferences in one list\n\nfunction AGENT: pref(AGENT: i, 1..n-1: j) = \n         assert(j in 1..npref[i], \"Called pref(\" ++ show(i) ++ \",\" ++ show(j) ++ \") too large preference\\n\",\n         preferences[cum_npref[i] + j]);\n\nconstraint forall(i in AGENT)\n                 (assert(forall(j in 1..npref[i])\n                               (pref(i,j) != i) /\\\n                         forall(j1, j2 in 1..npref[i] where j1 < j2)\n                               (pref(i,j1) != pref(i,j2)),\n                         \"Agent \" ++ show(i) ++ \"has erroneous preferences\"));\n\n\n%% ranking information: rank = 0 means not ranked but shoulnt occur!\nfunction 0..n-1: rank(AGENT: i1, AGENT: i2) = \n                 max([bool2int(pref(i1,j) = i2) * j | j in 1..npref[i1]]); \n\narray[AGENT] of var 1..n: a;\n%% constraint (1)\nconstraint forall(i in AGENT)(a[i] <= npref[i] + 1);\n%% constraint (2)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] > rank(i,j) -> a[j] < rank(j,i)\n                 );\n%% constraint (3)\nconstraint forall(i in AGENT, p in 1..npref[i])\n                 ( let { int: j = pref(i,p) } in \n                   a[i] = rank(i,j) -> a[j] = rank(j,i)\n                 );\n\nsolve satisfy;\n\n   output  [ if fix(a[i]) < npref[i] /\\ i < pref(i,fix(a[i]))\n             then \"(\" ++ show(i) ++ \",\" ++ show(pref(i,fix(a[i]))) ++ \")\\n\"\n             else \"\" endif\n           | i in AGENT ]\n %      ++ [show(rank),\"\\n\"] \n       ++\n       [show(npref),\"\\n\"] \n       ++ [show(a),\"\\n\"]\n        ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3643, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9fa498c8-9952-46ad-8101-e109b4732b76": {"__data__": {"id_": "9fa498c8-9952-46ad-8101-e109b4732b76", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "steiner_source_code", "node_type": "4", "metadata": {}, "hash": "dd04bad82465b93d0f84f6a690cdc86edd8e9312d746d918642fd90ea5a67f58", "class_name": "RelatedNodeInfo"}}, "text": "% The ternary Steiner problem of order n is to find n(n-1)/6 sets of elements in {1,2,...,n}\n% such that each set contains three elements and any two sets have at most one element in common.\n% For example, the following shows a solution for size n=7:\n%\n%      {1,2,3}, {1,4,5}, {1,6,7}, {2,4,6}, {2,5,7}, {3,4,7}, {3,5,6}\n\ninclude \"globals.mzn\";\n\nint: N = 7; \nint: NB = N *(N-1) div 6;\narray[1..NB] of var set of 1..N: Sets;\n\n% solve satisfy;\nsolve::set_search(Sets, first_fail, indomain_min, complete) satisfy;\n\n\n\nconstraint\n   forall(i in index_set(Sets)) (\n      card(Sets[i]) = 3\n   )\n   /\\ \n   forall(i,j in index_set(Sets) where i < j) (\n      card( Sets[i] intersect Sets[j]) <= 1\n   )\n   /\\ % symmetry breaking\n   decreasing(Sets)\n\n;\n\noutput [\n       \"N: \", show(N), \" NB: \", show(NB), \"\\n\",\n       \"Sets: \", show(Sets)\n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 830, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b2c0a481-5614-4db0-9618-fac709b69de3": {"__data__": {"id_": "b2c0a481-5614-4db0-9618-fac709b69de3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "stoch_fjsp_source_code", "node_type": "4", "metadata": {}, "hash": "1b493398107a1092aff8fbbd2f2d90ee6b3e324fd60d81299732911364d3d81e", "class_name": "RelatedNodeInfo"}}, "text": "% Stochastic General Assignment Problem \n% First stage:\n%    assign task to machines \n% Second stage:\n%    based on observed processign times, schedule taks on respective machines\n% Objective:\n%    minimise expected makespan\n\ninclude \"globals.mzn\";\n\n% Parameters\n\nint: no_mach;   % Number of machines\nint: no_jobs;   % Number of jobs\nint: no_task;   % Number of total tasks\nint: no_optt;   % Number of total optional tasks\n\nset of int: Mach  = 1..no_mach;\nset of int: Jobs  = 1..no_jobs;\nset of int: Tasks = 1..no_task;\nset of int: OptTs = 1..no_optt;\n\narray [Jobs] of set of int: tasks;\narray [Tasks] of set of int: optts;\n\narray [OptTs] of int: optt_mach;\narray [SCENARIOS1,OptTs] of int: optt_dur;\n\n\narray [Jobs] of int: last_task = [ max(tasks[j]) | j in Jobs ];\n%---------implications for multi scenarion solving ---------------\nint: nbScenarios;\nset of int: SCENARIOS1 = 1..nbScenarios;\nint: first_scen;\nint: last_scen;\nset of int: SCENARIOS = first_scen..last_scen;\narray[SCENARIOS1] of int: weights;\n\n%-------end of multi scenario addons ----------------\narray [Tasks] of int: task_job = \n    [ min(j in Jobs where t in tasks[j])(j) | t in Tasks ];\narray [SCENARIOS,Tasks] of int: task_mins =\n    array2d(SCENARIOS,Tasks,[ sum(k in tasks[task_job[t]])(if k < t then task_mind[s,k] else 0 endif)\n    |   s in SCENARIOS, t in Tasks ]);\narray [SCENARIOS,Tasks] of int: task_maxs =\n    array2d(SCENARIOS,Tasks,[ t_max[s] -\n        sum(k in tasks[task_job[t]])(if k < t then 0 else task_mind[s,k] endif)\n    |   s in SCENARIOS,  t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_mind =\n    array2d(SCENARIOS,Tasks,[ min(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS,t in Tasks ]);\n\narray [SCENARIOS,Tasks] of int: task_maxd = \n    array2d(SCENARIOS,Tasks,[ max(o in optts[t])(optt_dur[s,o]) | s in SCENARIOS, t in Tasks ]);\n\n    % Additional deirved parameters for optional tasks\n    %\narray [OptTs] of int: optt_task =\n    [ min(t in Tasks where o in optts[t])(t) | o in OptTs ];\n\narray[SCENARIOS1] of int: min_dur = [ min([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\narray[SCENARIOS1] of int: max_dur = [ max([optt_dur[s,t] | t in OptTs]) | s in SCENARIOS1];\nset of int: Durs = min(min_dur)..max(max_dur);\n\n    % Parameters related to the planning horizon\n    %\narray[SCENARIOS1] of int: t_max = [sum(t in Tasks)(max(o in optts[t])(optt_dur[s,o])) | s in SCENARIOS1];\n\nset of int: Times = 0..max(t_max);\n\n%-----------------------------------------------------------------------------%\n% Variables\n\n    % Start time variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Times: start =\n    array2d(SCENARIOS,Tasks,[ let { var task_mins[s,t]..task_maxs[s,t]: k } in k | s in SCENARIOS, t in Tasks ]);\n\n    % Duration variables for tasks\n    %\narray [SCENARIOS,Tasks] of var Durs: dur =\n    array2d(SCENARIOS,Tasks,[ if task_mind[s,t] = task_maxd[s,t] then task_mind[s,t] else\n        let { var task_mind[s,t]..task_maxd[s,t]: d } in d endif\n    |   s in SCENARIOS,t in Tasks ]);\n\n    % Variables whether an optional task is executed\n    %\narray [OptTs] of var bool: b;\n\narray[SCENARIOS] of var Times: de_objective;\n\nset of int: StochTimes = 0..sum(t_max);\nvar StochTimes: objective;\n%-----------------------------------------------------------------------------%\n% Constraints\n\n    % Precedence relations\n    %\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs, i in tasks[j] where i < last_task[j])(\n            start[s,i] + dur[s,i] <= start[s,i + 1]\n        )    \n    );\n\n    % Duration constraints\n    %\nconstraint\n    forall(o in OptTs,s in SCENARIOS)(\n        let { int: t = optt_task[o] } in (\n            if card(optts[t]) = 1 then\n                b[o] = true\n            else\n                b[o] -> dur[s,t] = optt_dur[s,o]\n            endif\n        )\n    );\n\n    % Optional tasks' constraints\n    %\nconstraint\n    forall(t in Tasks where card(optts[t]) > 1)(\n        ( sum(o in optts[t])(bool2int(b[o])) <= 1     )\n    /\\  ( exists(o in optts[t])(b[o])                 )\n    );\n\nconstraint\n    forall(t in Tasks where card(optts[t]) = 2)(\n        let {\n            int: o1 = min(optts[t]),\n            int: o2 = max(optts[t])\n        } in ( b[o1] <-> not(b[o2]) )\n    );\n\n    % Resource constraints\n    %\nconstraint\n    forall(m in Mach,s in SCENARIOS)(\n        let {\n            set of int: MTasks = { o | o in OptTs where optt_mach[o] = m }\n        } in (\n            cumulative(\n                [ start[s,optt_task[o]] | o in MTasks ],\n                [ optt_dur[s,o]         | o in MTasks ],\n                [ bool2int(b[o])      | o in MTasks ],\n                1\n            )\n        )\n    );\n\n% Objective constraint\nconstraint\n    forall(s in SCENARIOS)(\n        forall(j in Jobs)(start[s,last_task[j]] + dur[s,last_task[j]] <= de_objective[s])\n    );\nconstraint \n        objective = sum(s in SCENARIOS)(weights[s]*de_objective[s]);\n%-----------------------------------------------------------------------------%\n% Solve item\n\nsolve \n    :: search\n    minimize objective;\n\n%------------------------------------------------------------------------------%\n% Searches\n\nann: s_mindur   = int_search([dur[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_minstart = int_search([start[s,t] |s in SCENARIOS, t in Tasks], smallest, indomain_min, complete);\nann: s_bool     = bool_search(b, input_order, indomain_max, complete);\nann: s_obj      = int_search(de_objective, input_order, indomain_min, complete);\n\nann: search = seq_search([s_mindur, s_bool, s_minstart, s_obj]);\n\n%-----------------------------------------------------------------------------%\n% Output\n\noutput \n[   \"objective = \", show(de_objective), \";\\n\",\n    \"stoch obj = \", show(objective), \";\\n\",\n    \"start = \", show(start), \";\\n\",\n    \"dur = \", show(dur), \";\\n\",\n    \"b = \", show(b), \";\\n\",\n];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 5829, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5b1af932-d83b-4565-88d4-a635813b9c25": {"__data__": {"id_": "5b1af932-d83b-4565-88d4-a635813b9c25", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "submultisetsum_source_code", "node_type": "4", "metadata": {}, "hash": "9c317e01e54e2af2712f30e47fef0ba2a316ceec60f43f8a474f1816eb254d2b", "class_name": "RelatedNodeInfo"}}, "text": "% subsetsum problem\narray[int] of int: number;\nint: target;\n\nset of int: NUMBER = index_set(number);\nvar set of NUMBER: selected;\n\nconstraint sum(i in selected)\n              (number[i]) = target;\nsolve satisfy;\n\noutput [show(selected)];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 237, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0b2ee8b1-92d6-4d4d-b00e-b32d64cce0f3": {"__data__": {"id_": "0b2ee8b1-92d6-4d4d-b00e-b32d64cce0f3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "table_seating_source_code", "node_type": "4", "metadata": {}, "hash": "58d0bd625688373c07b93764a545086c64f3028f396e1f8ed5dc255c748192c9", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n          forall(t in TABLE)(not ({p1,p2} subset table[t]));\n\nconstraint forall(t in TABLE)(card(table[t]) <= S);\n\nconstraint forall(p in PERSON)(exists(t in TABLE)(p in table[t]));\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))\n                  ( let { var TABLE: tn1 = sum(t in TABLE)(t * bool2int(couples[c,1] in table[t]));\n                          var TABLE: tn2 = sum(t in TABLE)(t * bool2int(couples[c,2] in table[t]));\n                    } in  tn1 + tn2);\n\n\n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};\n\n\n\nModel 2 : \n\n\nint: n;\nset of int: PERSON = 1..n;\nint: T; % number of tables\nset of int: TABLE = 1..T;\nint: S; % tables size\narray[int,1..2] of PERSON: couples;\nset of PERSON: key;\n\narray[TABLE] of var set of PERSON: table;\narray[PERSON] of var TABLE: seat;\n\n\npredicate not_same_table(PERSON:p1, PERSON: p2) =\n                        seat[p1] != seat[p2];\n\nconstraint global_cardinality_low_up(seat, [t|t in TABLE], [0|t in TABLE], [S|t in TABLE]);\n\nconstraint forall(c in index_set_1of2(couples))\n                 (not_same_table(couples[c,1],couples[c,2]));\n\nconstraint forall(p1,p2 in key where p1 < p2)\n                 (not_same_table(p1,p2));\n\nvar int: obj = sum(c in index_set_1of2(couples))(seat[couples[c,1]] + seat[couples[c,2]]);\n\nconstraint forall(t in TABLE, p in PERSON)(p in table[t] <-> seat[p] = t);    \n\nsolve minimize obj;\n\noutput [show(table), \" = \", show(obj)];\n\n\nn = 20;\nT = 5;\nS = 5;\ncouples = [| 1, 2 | 4, 5 | 6, 7 | 8, 10\n           | 11, 12 | 13, 14 | 17, 18 |];\nkey = {1, 6, 7, 8};", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2141, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f7ab6aec-2409-4d2c-98be-002972ab5c8a": {"__data__": {"id_": "f7ab6aec-2409-4d2c-98be-002972ab5c8a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "teamselect_source_code", "node_type": "4", "metadata": {}, "hash": "019a3725c2fab6d02e1975bef5055f1603f2d9f1184f1e09a28042e42093fb37", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\narray[CAPTAIN] of var set of PLAYER: team = [Xavier,Yuri,Zena];\n\nset of int: CAPTAIN = 1..3;\narray[CAPTAIN,PLAYER] of int: value;\n \nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |]; \n\nconstraint card(Xavier intersect GOALIE) >= 1;\nconstraint card(Xavier intersect DEFENCE) >= 2;\nconstraint card(Xavier intersect OFFENCE) >= 2;\nconstraint card(Xavier) = 6;\n\n\nconstraint card(Yuri intersect GOALIE) >= 1;\nconstraint card(Yuri intersect DEFENCE) >= 2;\nconstraint card(Yuri intersect OFFENCE) >= 2;\nconstraint card(Yuri) = 6;\n\nconstraint card(Zena intersect GOALIE) >= 1;\nconstraint card(Zena intersect DEFENCE) >= 2;\nconstraint card(Zena intersect OFFENCE) >= 2;\nconstraint card(Zena) = 6;\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nsolve maximize obj;\n\nvar int: obj = sum(c in CAPTAIN)(sum(p in team[c])(value[c,p]));\n\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];\n\n\n\nModel 2 :\n\n\n% team select problem\n\nset of int: PLAYER = 1..11;\nset of int: GOALIE = 1..2;\nset of int: DEFENCE = 3..6;\nset of int: OFFENCE = 7..11;\narray[PLAYER] of string: name =\n  [\"Ant\",\"Bee\",\"Cip\",\"Deb\",\"Eve\",\"Fin\",\"Ged\",\"Hel\",\"Ila\",\"Jan\",\"Kim\"];\nset of int: CAPTAIN = 1..3;\nint: xavier = 1; int: yuri = 2; int: zena = 3;\narray[CAPTAIN,PLAYER] of int: value;\nvalue = [| 2, 5, 6, 8, 9, 5, 8, 7, 7, 4, 6\n         | 9, 8, 4, 7, 6, 4, 5, 3, 5, 5, 7\n         | 8, 4, 3, 3, 6, 2, 5, 5, 3, 2, 5 |];\n\nvar set of PLAYER: Xavier;\nvar set of PLAYER: Yuri;\nvar set of PLAYER: Zena;\n\npredicate correct_team(var set of PLAYER: team) = \n          card(team) = 6 /\\ \n          card(team intersect GOALIE) >= 1 /\\\n          card(team intersect DEFENCE) >= 2 /\\\n          card(team intersect OFFENCE) >= 2;\n\nconstraint correct_team(Xavier) /\\ correct_team(Yuri) /\\ correct_team(Zena);\n\nconstraint card(Xavier intersect Yuri) <= 2;\nconstraint card(Xavier intersect Zena) <= 2;\n\nvar int: obj = sum(p in Xavier)(value[xavier,p]) +\n               sum(p in Yuri)(value[yuri,p]) +\n               sum(p in Zena)(value[zena,p]);\n\nsolve maximize obj;\n\noutput [\"Xavier: \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Xavier) ] ++\n       [\"\\nYuri:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Yuri) ] ++\n       [\"\\nZena:   \"] ++\n       [ show(name[p]) ++ \" \" | p in fix(Zena) ] ++\n       [\"\\nobj = \", show(obj), \";\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2927, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "443a9574-3eb8-4f42-a173-ccfd88072bbf": {"__data__": {"id_": "443a9574-3eb8-4f42-a173-ccfd88072bbf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "template_design_source_code", "node_type": "4", "metadata": {}, "hash": "fb8044a82a613c6c81598c254710386b0540fb8736d49badd0881ddb2db79d94", "class_name": "RelatedNodeInfo"}}, "text": "% Template design\ninclude \"globals.mzn\";\n\nint: S;   \t\t% Number of slots per template.\nint: t;   \t\t% Number of templates.\nint: n;   \t\t% Number of variations.\narray[1..n] of int: d; \t% How much of each variation we must print?\n\n% Lower and upper bounds for the total production.\n%\nint: llower = ceil(sum(i in 1..n)(int2float(d[i]))/int2float(S));\nint: lupper = 2*llower; % If t>1, this should be the optimal Production_{t-1}-1.\n\n% # Slots allocated to variation i in template j\narray[1..n,1..t] of var 0..S: p;\n\n% # Pressings of template j.\narray[1..t] of var 1..lupper: R;\n\n% Sum of all Rj.\nvar llower..lupper: Production;\n\n% Production x S - sum(d[i])\nvar 0..lupper-llower: Surplus;\n\n% First, set up Production to be the sum of the Rj\nconstraint\n\tProduction = sum(i in 1..t)(R[i]);\n\n% the limits on production\nconstraint\n\tProduction >= llower /\\ Production <= lupper;\n\n% The number of slots occupied in each template is S.\nconstraint\n\tforall(j in 1..t)\n\t\t (sum(i in 1..n)(p[i,j]) = S);\n\n% Enough of each variation is printed.\nconstraint\n\tforall(i in 1..n)\n\t\t (sum(j in 1..t)(p[i,j]*R[j]) >= d[i]);\n\n% Symmetry constraints.\n% Variations with the same demand are symmetric.\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] == d[i+1] then\n\t\t\tlex_lesseq([p[i,  j] | j in 1..t],\n\t\t\t\t[p[i+1,j] | j in 1..t])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% pseudo symmetry\nconstraint\n\tforall(i in 1..n-1) (\n\t\tif d[i] < d[i+1] then\n\t\t       sum (j in 1..t) (p[i,j]*R[j])\n\t\t     <= sum (j in 1..t) (p[i+1,j]*R[j])\n\t\telse\n\t\t\ttrue\n\t\tendif\n\t);\n\n% implied constraints on the surplus\n\n% These are presented in the paper as necessary to get good\n% performance for this model, but I think bounds consistency on the\n% sum(R[i]) constraint would produce the same amount of propagation\n\n% Set up surplus, which is bounded as production is bounded.\nconstraint\n\tSurplus = Production*S - sum(i in 1..n)(d[i]);\n\n% The surplus of each variation is also limited by the surplus.\nconstraint\n\tforall(k in 1..n)\n\t\t (sum(j in 1..t)(p[k,j]*R[j]-d[k]) <= Surplus);\n\n% The surplus of the first k variations is limited by the surplus.\nconstraint\n\tforall(k in 2..n-1)\n\t\t (sum(j in 1..t, m in 1..k)( p[m,j]*R[j]-d[m] ) <= Surplus);\n\n% Implied constraints on the run length.\nconstraint\n\tif t=2 then (\n\t\tR[1] <= Production div 2\n\t/\\\tR[2] >= Production div 2\n\t) else true endif;\n\nconstraint\n\tif t=3 then (\n\t\tR[1] <= Production div 3\n\t/\\\tR[2] <= Production div 2\n\t/\\\tR[3] >= Production div 3\n\t) else true endif;\n\n% Minimize the production.\nsolve :: int_search(array1d(1..n*t,p) ++ R, input_order, indomain_min, complete)\n    minimize Production;\n\noutput [\n    if v = 1 then \"template #\" ++ show(i) ++ \": [\" else \"\" endif ++\n    show(p[v, i]) ++\n    if v = n then \"], pressings: \" ++ show(R[i]) ++ \"\\n\" else \", \" endif\n\t| i in 1..t, v in 1..n]\n    ++ [\"Total pressings: \", show(Production), \"\\n%\\n\"];\n\n%-----------------------------------------------------------------------------%\n%-----------------------------------------------------------------------------%", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2997, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "063f7d9d-663c-424d-b4cf-b17526dcfd09": {"__data__": {"id_": "063f7d9d-663c-424d-b4cf-b17526dcfd09", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "toomany_source_code", "node_type": "4", "metadata": {}, "hash": "b1db3a754c8a269dcf53579b5af2d618d7cbc2f06d56a1b82c9035efb0997e0c", "class_name": "RelatedNodeInfo"}}, "text": "%% TooMany.mzn (too many solutions)\nint: n; % number of machines\nset of int: MACHINE = 1..n;\nint: k; % production per day\nint: red = 1; int: white = 2; int: black = 3; int: blue = 4;\nset of int: COLOR = 1..4;\narray[COLOR] of int: l; % lower bound on production\narray[COLOR] of int: u; % upper bound on production\n\narray[MACHINE,COLOR] of var 0..k div 2: produce;\n\nconstraint forall(m in MACHINE)\n                 (sum(c in COLOR)(produce[m,c]) <= k);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) >= l[c]);\nconstraint forall(c in COLOR)\n                 (sum(m in MACHINE)(produce[m,c]) <= u[c]);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] > 0 /\\ produce[m,black] > 0 -> produce[m,blue] = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,blue] <= produce[m,red]);\nconstraint forall(m in MACHINE)\n                 (produce[m,red] mod 4 = 0);\nconstraint forall(m in MACHINE)\n                 (produce[m,white] mod 3 = 0);\n\n\nsolve maximize sum(m in MACHINE, c in COLOR)(produce[m,c]);\n\noutput [ show_int(3,produce[m,c]) ++\n         if c = 4 then \"\\n\" else \" \" endif\n       | m in MACHINE, c in COLOR ];\n\nn = 4;\nk = 11;\nl = [8,7,10,6];\nu = [14,16,12,20];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1223, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "587f194d-6ad0-4f44-94d2-30125a63568e": {"__data__": {"id_": "587f194d-6ad0-4f44-94d2-30125a63568e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "traffic_lights_table_source_code", "node_type": "4", "metadata": {}, "hash": "422310f01fe34d0ee0a18cb6d91604c03480da30b7a566b7c98ea02d246b0e7c", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n%Traffic lights problem in MiniZinc.\n% Specification:\n% Consider a four way traffic junction with eight traffic lights. Four of\n% the traffic lights are for the vehicles and can be represented by the\n% variables V1 to V4 with domains\n% {r,ry,g,y} (for red, red-yellow, green and yellow).\n%  The other four traffic lights are for the pedestrians and can be\n%  represented by the variables P1 to P4 with domains {r,g}.\n%\n% The constraints on these variables can be modelled by quaternary\n% constraints on\n% (Vi, Pi, Vj, Pj ) for 1<=i<=4, j=(1+i)mod 4 which allow just the tuples\n% {(r,r,g,g), (ry,r,y,r), (g,g,r,r), (y,r,ry,r)}.\n%\n% It would be interesting to consider other types of junction (e.g. five roads\n% intersecting) as well as modelling the evolution over time of the\n% traffic light sequence.\n\ninclude \"globals.mzn\";\n\nint: n = 4;\nint: r  = 1; % red\nint: ry = 2; % red-yellow\nint: g  = 3; % green\nint: y  = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V;\narray[1..n] of var Pedestrians: P;\n\n\nsolve satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   table([V[i], P[i], V[j], P[j]], allowed)\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\n% output [\n%  \"V: \", show(V), \"\\nP: \", show(P), \"\\n\"\n% ];\noutput [\n show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\nint: n = 4;\nint: r = 1; % red\nint: ry = 2; % red-yellow\nint: g = 3; % green\nint: y = 4; % yellow\n\nset of int: Cars = {r,ry,g,y};\nset of int: Pedestrians = {r,g};\n\narray[1..4, 1..4] of Cars: allowed;\n\narray[1..n] of var Cars: V; % ;\narray[1..n] of var Pedestrians: P; %;\n\npredicate cp1d(array[int] of var int: x, array[int] of var int: y) =\n  assert(index_set(x) = index_set(y),\n           \"cp1d: x and y have different sizes\",\n     forall(i in index_set(x)) ( x[i] = y[i] ))\n; \n\n% solve satisfy;\nsolve :: int_search(V ++ P, first_fail, indomain_min, complete) satisfy;\n\nconstraint\n forall(i in 1..n, j in 1..n where j = (1+i) mod 4)  (\n   exists(a in 1..4) (\n      cp1d([V[i], P[i], V[j], P[j]], [allowed[a,k] | k in 1..4])\n   )\n )\n;\n\n\nallowed = array2d(1..4, 1..4, \n[\n r,r,g,g, \n ry,r,y,r, \n g,g,r,r, \n y,r,ry,r\n]);\n\n\noutput [\n  show(V[i]) ++ \" \" ++ show(P[i]) ++ \" \"\n  | i in 1..n\n] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2367, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "27749507-4bf0-46e0-a896-a0fa448998b1": {"__data__": {"id_": "27749507-4bf0-46e0-a896-a0fa448998b1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "TTPPV_source_code", "node_type": "4", "metadata": {}, "hash": "5405cb264d79ba19ff5855b1785018a93042ca768a9d26a38fa89da570cdb562", "class_name": "RelatedNodeInfo"}}, "text": "% Traveling Tournament Problem with Predefined Venues\n%\n% Compact single round robin schedule minimizing total travel distance\n% The venue of each game has already been decided\n% Specialized for CIRC instances (circular distances)\n\ninclude \"globals.mzn\";\n\nint: nbTeams;\nint: nbRounds = nbTeams-1;\n\nset of int: Teams = 1..nbTeams;\nset of int: Rounds = 1..nbRounds;\nset of int: Travels = 1..nbRounds+1;\n\n% predefined venue: pv[i][j] = 1 iff i is playing at home against j\narray[Teams,Teams] of 1..2: pv; \n\n% circular distances: for i>=j, distance[i][j]=min{i-j,j-i+nbTeams}\narray[Teams,Teams] of int: distance = \n  array2d(Teams,Teams,[ if i>=j then (if i-j < j-i+nbTeams then i-j else j-i+nbTeams endif) \n                                else (if j-i < i-j+nbTeams then j-i else i-j+nbTeams endif) \n                                endif | i,j in Teams]);\n\n% output related\nint: digs = ceil(log(10.0,int2float(nbTeams)));\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% decision variables: in round k, team i plays against team opponent[i,k]\narray[Teams,Rounds] of var Teams: opponent;\n\n% auxiliary variables: venue[i,k] = 1 iff team i plays at home in round k\narray[Teams,Rounds] of var 1..2: venue;\nconstraint forall (i in Teams, k in Rounds) (venue[i,k] = pv[i,opponent[i,k]]);\n\n% auxiliary variables: travel[i,k] is the distance travelled by team i to go play in round k (includes travelling back home after last round)\narray[Teams,Travels] of var 0..(nbTeams div 2): travel;\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n% a team cannot play against itself\nconstraint forall (i in Teams, k in Rounds) (opponent[i,k] != i);\n\n% in round k, i plays j means j plays i\nconstraint forall (i in Teams, k in Rounds) (opponent[opponent[i,k],k] = i);\n\n% for each team i, all opponents are different\nconstraint forall (i in Teams) (alldifferent([opponent[i,k] | k in Rounds]));\n\n% for each round k, all opponents are different (implied constraint)\nconstraint forall (k in Rounds) (alldifferent([opponent[i,k] | i in Teams]));\n\n% for each team i, there can be at most 3 consecutive home games and at most 3 consecutive away games\nint: nbStates = 7;\nset of int: States = 1..nbStates;\narray[States,1..2] of int: delta = \n  [| 2, 5\n   | 3, 5\n   | 4, 5\n   | 0, 5\n   | 2, 6\n   | 2, 7\n   | 2, 0 |];\nconstraint forall (i in Teams) (regular( [venue[i,k] | k in Rounds], nbStates, 2, delta, 1, States));\n\n% symmetry breaking: distances are symmetric so reversing the rounds yields a schedule of same cost\nconstraint (opponent[1,1] < opponent[1,nbRounds]);\n\n% define travel variables wrt venues of current- and next-round games\nconstraint forall (i in Teams) (\n\t(venue[i,1]=1 -> travel[i,1] = 0) /\\\n\t(venue[i,1]=2 -> travel[i,1] = distance[i,opponent[i,1]]) );\nconstraint forall (i in Teams, k in 1..nbRounds-1) (\n\t((venue[i,k]=1 /\\ venue[i,k+1]=1) -> travel[i,k+1] = 0) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=1) -> travel[i,k+1] = distance[opponent[i,k],i]) /\\\n\t((venue[i,k]=1 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[i,opponent[i,k+1]]) /\\\n\t((venue[i,k]=2 /\\ venue[i,k+1]=2) -> travel[i,k+1] = distance[opponent[i,k],opponent[i,k+1]]) );\nconstraint forall (i in Teams) (\n\t(venue[i,nbRounds]=1 -> travel[i,nbRounds+1] = 0) /\\\n\t(venue[i,nbRounds]=2 -> travel[i,nbRounds+1] = distance[opponent[i,nbRounds],i]) );\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nvar int: totalTravel;\nconstraint totalTravel = sum (i in Teams, k in Travels) (travel[i,k]);\nsolve minimize totalTravel;\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\noutput [\"SCHEDULE\\n\"] ++ \n       [ if fix(venue[i,k]) == 1 then \" \" else \"@\" endif ++\n\t show_int(digs,opponent[i,k]) ++ \" \" ++ \n         if k == nbRounds /\\ i != nbTeams then \"\\n\" else \"\" endif\n         | i in Teams, k in Rounds ] ++ [\"\\n\"] ++\n       [\"total travel = \"] ++ [show(totalTravel)] ++ [\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3772, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f3d83aa1-d0cd-458c-8b94-e271fa020eab": {"__data__": {"id_": "f3d83aa1-d0cd-458c-8b94-e271fa020eab", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "vessel-loading_source_code", "node_type": "4", "metadata": {}, "hash": "6ee3e46d66b06d1c16c6a088a3d7a2862b63c7f84cd8bb66f0b9b6d9879cd547", "class_name": "RelatedNodeInfo"}}, "text": "% Vessel Loading\n\nint: deck_width; % width of deck\nint: deck_length; % height of deck\nint: n_containers; % number of containers\nint: n_classes; % number of container classes\n\narray[int] of int: width;\n% width[c] = width of container c\narray[int] of int: length;\n% length[c] = length of container c\narray[int] of int: class;\n% class[c] = class of container c\narray[int, int] of int: separation;\n% separation[a, b] = the minimum allowed separation between\n%                    containers of classes a and b\n\nset of int: Containers = 1..n_containers;\n\narray[Containers] of var 0..deck_width: Left;\n% Left[c] = leftmost point of container c\narray[Containers] of var 0..deck_width: Right;\n% Right[c] = rightmost point of container c\narray[Containers] of var 0..deck_length: Bottom;\n% Bottom[c] = bottommost point of container c\narray[Containers] of var 0..deck_length: Top;\n% Top[c] = topmost point of container c\n\narray[Containers] of var 1..2: orientation;\n% orientation[c] = 2 if container c is turned 90 degrees, else 1.\n\nconstraint\n  forall (c in Containers) (\n    let {\n      array[1..2] of int: ElemWidth = [width[c], length[c]];\n      array[1..2] of int: ElemLength = [length[c], width[c]]\n    }\n    in \n      Right[c] = Left[c] + ElemWidth[orientation[c]] /\\\n      Top[c] = Bottom[c] + ElemLength[orientation[c]]\n  )\n;\n\nconstraint\n  forall(c, k in Containers where c < k) (\n    Left[c] >= Right[k] + separation[class[c], class[k]] \\/\n    Right[c] + separation[class[c], class[k]] <= Left[k] \\/\n    Bottom[c] >= Top[k] + separation[class[c], class[k]] \\/\n    Top[c] + separation[class[c], class[k]] <= Bottom[k]\n  )\n;\n\n% Excessive (pretty) output\noutput [\"\u250c\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2510\\n\"] ++\n       [if x == 0 then \"\u2502\" else \"\" endif ++\n        let {\n          bool: l = exists([fix(Left[c])   = x | c in Containers]);\n          bool: r = exists([fix(Right[c])  = x | c in Containers]);\n          bool: b = exists([fix(Bottom[c]) = y | c in Containers]);\n          bool: t = exists([fix(Top[c])    = y | c in Containers])\n        } in\n          if     l /\\ r /\\ b /\\ t then \"\u253c\"\n          elseif l /\\ r /\\ b      then \"\u252c\"\n          elseif l /\\ r /\\      t then \"\u2534\"\n          elseif l /\\      b /\\ t then \"\u251c\"\n          elseif      r /\\ b /\\ t then \"\u2524\"\n          elseif l /\\      b      then \"\u250c\"\n          elseif l /\\           t then \"\u2514\"\n          elseif      r /\\ b      then \"\u2510\"\n          elseif      r /\\      t then \"\u2518\"\n          elseif l \\/ r           then \"\u2502\"\n          elseif           b \\/ t then \"\u2500\" \n          else \" \" endif ++\n        if x == deck_width then \"\u2502\\n\" else \"\" endif\n        | y in 0..deck_length, x in 0..deck_width] ++\n        [\"\u2514\"] ++ [\"\u2500\" | t in 0..deck_width] ++ [\"\u2518\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2710, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "700e4c39-7ca2-4916-b528-320247035ca9": {"__data__": {"id_": "700e4c39-7ca2-4916-b528-320247035ca9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "warehouses_source_code", "node_type": "4", "metadata": {}, "hash": "d80ad7c879ef4c86e2dc7155b0b541e9d7c5436a4500d5cb691803f13028f0c7", "class_name": "RelatedNodeInfo"}}, "text": "% Warehouse allocation\n\n% vim: ft=zinc ts=2 sw=2 et tw=0\n\n% A company needs to construct warehouses to supply stores with goods.  Each\n% warehouse possibly to be constructed has a certain capacity defining how many\n% stores it can supply.  Constructing a warehouse incurs a fixed cost.  Costs\n% for transportation from warehouses to stores depend on the locations of\n% warehouses and stores.\n%\n% Determine which warehouses should be constructed and which warehouse should\n% supply which store such that overall cost (transportation cost plus\n% construction cost) is smallest.\n%-----------------------------------------------------------------------------\n\ninclude \"globals.mzn\";\n\n%-----------------------------------------------------------------------------\n% Instance\n\nn_suppliers = 5;\nn_stores = 10;\nbuilding_cost = 30;\n\ncapacity = [1,4,2,1,3];\n\ncost_matrix =\n [|20, 24, 11, 25, 30\n  |28, 27, 82, 83, 74\n  |74, 97, 71, 96, 70\n  | 2, 55, 73, 69, 61\n  |46, 96, 59, 83,  4\n  |42, 22, 29, 67, 59\n  | 1,  5, 73, 59, 56\n  |10, 73, 13, 43, 96\n  |93, 35, 63, 85, 46\n  |47, 65, 55, 71, 95|]; \n\n%-----------------------------------------------------------------------------\n% Model\n\nint: n_suppliers;\nint: n_stores;\nint: building_cost;\narray[1..n_suppliers] of int: capacity;\narray[1..n_stores,1..n_suppliers] of int: cost_matrix;\n\nint: MaxCost = max(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]);\nint: MaxTotal =   (n_suppliers * building_cost) \n                + sum(i in 1..n_stores, j in 1..n_suppliers)(cost_matrix[i,j]); \n\narray[1..n_stores] of var 1..n_suppliers: supplier;\narray[1..n_suppliers] of var bool: open;\narray[1..n_stores] of var 1..MaxCost: cost;\nvar 1..MaxTotal: tot;\n\nconstraint\n  sum (i in 1..n_suppliers) (building_cost * bool2int(open[i])) +\n  sum (i in 1..n_stores) (cost[i])\n  = tot;\n\nconstraint\n  forall (i in 1..n_stores) (\n    cost_matrix[i,supplier[i]] = cost[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    let {\n      var int: use\n     } in\n    count(supplier,i,use) /\\ use <= capacity[i]\n  );\n\nconstraint\n  forall (i in 1..n_suppliers) (\n    (exists (j in 1..n_stores) (supplier[j] == i)) == open[i]\n  );\n\nsolve\n  :: int_search(\n    supplier ++ cost ++ [bool2int(open[i]) | i in 1..n_suppliers],\n    first_fail,\n    indomain_split,\n    complete\n  )\n  minimize tot;\n\noutput\n  [ \"warehouses:\" ]\n  ++\n  [ \"\\ntot = \", show(tot) ]\n  ++\n  [ \"\\nsupplier = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(supplier[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\ncost = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(cost[i]) ++\n    if i = n_stores then \"\\n]\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_stores\n  ]\n  ++\n  [ \"\\nopen = [\\n\" ]\n  ++\n  [ \"\\t\" ++ show(open[i]) ++\n    if i = n_suppliers then \"\\n]\\n\"\n    elseif i mod 5 = 0 then \",\\n\"\n    else \",\"\n    endif\n  | i in 1..n_suppliers\n  ]\n\n%-----------------------------------------------------------------------------\n%-----------------------------------------------------------------------------", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3065, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5d35e7ea-28ff-40e7-a963-2befe2bf2b8d": {"__data__": {"id_": "5d35e7ea-28ff-40e7-a963-2befe2bf2b8d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "water_buckets1_source_code", "node_type": "4", "metadata": {}, "hash": "5668426c44d206a8fbd87c384578625957a6b14993d579ba522ed0f712f87382", "class_name": "RelatedNodeInfo"}}, "text": "Model 1 :\n\n% Water buckets problem in Minizinc\n% \"\"\"\n% Problem description\n% This is a generalization of the CSPLib specification, which is as follows: Given an 8 pint bucket of water, and two empty buckets which can contain 5 and 3 pints respectively, the problem requires to divide the water into two by pouring water between buckets (that is, to end up with 4 pints in the 8 pint bucket, and 4 pints in the 5 pint bucket) in the smallest number of transfers.\n%\n% The generalization consists in making the specification parametric with respect to the start and goal configurations, which are now inputs to the problem.\n%\n% Problem input\n%\n% * Function start, assigning an initial amount of water to each bucket\n% * Function goal, assigning the goal amount of water to each bucket \n%\n% Search space\n% The set of all possibile sequences of configurations (states), where a configuration is a triple encoding the amount of water in each bucket at a given time-step\n%\n% Constraints\n%\n% * C1: At beginning, buckets contain the amount of water specified by function start\n% * C2: At the end, buckets contain the amount of water specified by function goal\n% * C3: The configuration at each step differs from that of the next one in that the amount of water of exactly 2 buckets changes (that in the others remain the same)\n% * C4: The overall amount of water is the same at each time step\n% * C5: After each transition (involving buckets b1 and b2), either the source bucket becomes empty, or the target becomes full\n% \"\"\"\n\n\nint: nb_buckets = 3;\nint: max_step = 10; % 8 for satisfy\nset of int: buckets = 1..nb_buckets;\nset of int: steps = 1..max_step;\narray[buckets] of int: capacity = [8,5,3];\narray[buckets] of int: start = [8,0,0];\narray[buckets] of int: goal = [4,4,0];\n\n% Search space: The set of all possibile sequences of configurations (states), \n% where a configuration is a triple encoding the amount of water in each \n% bucket at a given time-step\narray[steps, buckets] of var int: state;\nvar 1..max_step: goal_step;\n\n% Objective function\nsolve minimize goal_step;\n% solve :: int_search( [ state[i,j] | i in steps, j in buckets ] , \"first_fail\", \"indomain\", \"complete\")  minimize goal_step;\n\nconstraint\n%   goal_step <= 8 % for solve satisfy\n%   /\\\n   % assertions\n   forall(b in buckets) (\n      (start[b] <= capacity[b]) /\\ (goal[b] <= capacity[b])\n   )\n   /\\\n   sum(b in buckets)(start[b]) = sum(b in buckets)(goal[b])\n   /\\\n   forall(s in steps, b in buckets) (\n      state[s,b] >= 0 /\\\n      state[s,b] <= capacity[b]\n   )\n   /\\\n   forall(b in buckets) (\n      % C1: At beginning, buckets contain the amount of water specified by function start\n      state[1,b]=start[b]\n      /\\\n      % C2: At the end, buckets contain the amount of water specified by function goal\n      state[goal_step,b] = goal[b]\n   )\n   /\\\n   forall(step in 1..max_step-1) (\n      % C3: The configuration at each step differs from that of the next one in that the amount of\n      % water of exactly 2 buckets changes (that in the others remain the same)\n      sum(b in buckets)( bool2int(state[step,b] != state[step+1, b])) = 2\n      /\\\n      % C4: The overall amount of water is the same at each time step\n      sum(b in buckets)(state[step,b]) = sum(b in buckets)(state[step+1,b])\n      /\\\n\n      % C5: After each transition (involving buckets b1 and b2), either the source\n      % bucket becomes empty, or the target becomes full\n      forall(b1, b2 in buckets where b1 != b2) (\n         ((state[step, b1] != state[step+1, b1]) /\\ (state[step, b2] != state[step+1, b2])) ->\n            (state[step+1,b1] = 0 \\/ state[step+1,b1] = capacity[b1] \\/\n             state[step+1,b2] = 0 \\/ state[step+1,b2] = capacity[b2])\n     )\n   )\n;\n\n\noutput [\n  if s = 1 /\\ b = 1 then \n    \"goal_step: \" ++ show(goal_step)\n  else \"\" endif ++\n  if b = 1 then \"\\n\" else \" \" endif ++\n  show(state[s, b])\n  | s in steps, b in buckets\n\n] \n++ [\"\\n\"];\n\n\n\nModel 2 : \n\n\n\ninclude \"globals.mzn\";\n\nint: n_states = 15;\nint: input_max = 15;\nint: initial_state = 1;\nset of int: accepting_states = {15};\n\n\n% distance\narray[1..n_states, 1..n_states] of 0..input_max: transition_fn =\narray2d(1..n_states, 1..n_states,\n[%1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n  0, 2, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 1\n  0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 2 \n  0, 0, 0, 4, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 3\n  0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, % 4\n  0, 0, 0, 0, 0, 6, 0, 0, 9, 0, 0, 0, 0, 0, 0, % 5\n  0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, % 6\n  0, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 0, 0, 0, 0, % 7\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, % 8 \n  0, 0, 0, 0, 0, 0, 0, 0, 0,10, 0, 0, 0, 0, 0, % 9\n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0,11, 0, 0, 0, 0, %10\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,12, 0, 0, 0, %11 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,13, 0, 0, %12\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,14, 0, %13 \n  0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %14\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, %15\n]);\n\n\narray[1..n_states] of string:  nodes = [\n        \"8,0,0\", % 1 start\n        \"5,0,3\", % 2\n        \"5,3,0\", % 3 \n        \"2,3,3\", % 4 \n        \"2,5,1\", % 5\n        \"7,0,1\", % 6\n        \"7,1,0\", % 7\n        \"4,1,3\", % 8\n        \"3,5,0\", % 9\n        \"3,2,3\", % 10\n        \"6,2,0\", % 11\n        \"6,0,2\", % 12\n        \"1,5,2\", % 13\n        \"1,4,3\", % 14\n        \"4,4,0\"  % 15 goal\n        ];\n\n\narray[1..input_max] of var 0..input_max: x;\nvar 0..input_max: cost;\n\n% solve satisfy;\nsolve minimize cost;\n\nconstraint\nregular(x, n_states, input_max, transition_fn,\n        initial_state, accepting_states)\n;\n\nconstraint\n   cost = 2+sum([bool2int(x[i-1] != x[i] ) | i in 2..input_max])\n;\n\noutput \n[\"cost: \" ++ show(cost) ++ \"\\n\"] ++\n[show(initial_state) ++ \" \"] ++\n[\n  if fix(x[i]) < input_max then show(x[i]) ++ \" \" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(input_max) ++ \"\\n\"] ++ \n[\"\\n\\n\"] ++\n\n[show(nodes[initial_state]) ++ \"\\n\"] ++\n[\n  if fix(x[i]) < input_max then show(nodes[fix(x[i])]) ++ \"\\n\" else \" \" endif\n  | i in 1..input_max where fix(x[i]) < input_max\n] ++ \n[show(nodes[input_max]) ++ \"\\n\"] ++ \n[\"\\n\"];", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 6128, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"all_interval_source_code": {"node_ids": ["89d39afd-c50b-4935-9f43-0e797b76bfd2"], "metadata": {}}, "assign_source_code": {"node_ids": ["8458a59f-67e4-400d-9979-d3b6cd942d94"], "metadata": {}}, "aust_color_source_code": {"node_ids": ["2060b66c-5842-4329-8b1b-bedadb8026df"], "metadata": {}}, "bibd_source_code": {"node_ids": ["2f30e825-0f9e-438f-bda0-5b16979dfeee"], "metadata": {}}, "bus_scheduling_csplib_source_code": {"node_ids": ["7078ad01-3380-40c3-879d-8b540e4c44d5"], "metadata": {}}, "car_source_code": {"node_ids": ["015ab921-3ba0-4705-8cca-fe0c9be5514a"], "metadata": {}}, "carpet_cutting_source_code": {"node_ids": ["8c415210-15e3-4f28-bacc-dcddbb6ab1a4"], "metadata": {}}, "cell_block_source_code": {"node_ids": ["34737f83-a5d9-4cd0-a1cd-9ae21f48953a"], "metadata": {}}, "clique_source_code": {"node_ids": ["2a58b22e-0ed9-4e9d-a400-829f4e5ca323"], "metadata": {}}, "cluster_source_code": {"node_ids": ["842d379a-a769-4264-991a-1f95df77375e"], "metadata": {}}, "compatible_assignment_source_code": {"node_ids": ["d7edd124-9eb7-4ccf-9ac1-0a8ca24e1664"], "metadata": {}}, "constrained_connected_source_code": {"node_ids": ["57ccf9ed-0b34-4d4d-b321-a85e7d6a3e3d"], "metadata": {}}, "crazy_sets_source_code": {"node_ids": ["cf002e9b-346a-4dff-bb34-3339463af5ab"], "metadata": {}}, "crossfigure_source_code": {"node_ids": ["57c899ba-fa7c-4cb5-acd8-853f6de9f590"], "metadata": {}}, "curriculum_source_code": {"node_ids": ["2b9db7b9-0ec6-4122-8681-a948c0c47489"], "metadata": {}}, "diamond_free_degree_sequence_source_code": {"node_ids": ["1e81a748-90f5-48a9-8d14-ce0924ae6357"], "metadata": {}}, "doublechannel_source_code": {"node_ids": ["c8aebc2f-ec6e-4a5c-a4d3-03d01b242c54"], "metadata": {}}, "fractions_source_code": {"node_ids": ["a327a687-c8ab-47d9-980f-d2388021d622"], "metadata": {}}, "golfers_source_code": {"node_ids": ["414f3da4-7e02-4ea6-a587-5ab31d8e144f"], "metadata": {}}, "golomb_source_code": {"node_ids": ["00b794a2-70f8-4409-a5d7-f9f229dffccb"], "metadata": {}}, "graph_source_code": {"node_ids": ["1edcda41-2027-40d6-a5d8-7eb833317eaa"], "metadata": {}}, "itemset_mining_source_code": {"node_ids": ["d4e103bd-89fe-47bf-80b1-edc0e32cdf74"], "metadata": {}}, "jobshop_source_code": {"node_ids": ["cc3d5f6c-4087-4fb9-8c4f-c86f4879f7b6"], "metadata": {}}, "K4xP2Graceful_source_code": {"node_ids": ["8cdfdf97-c682-4416-b170-500fc703386f"], "metadata": {}}, "killer_sudoku_source_code": {"node_ids": ["d9d2c132-5ecf-468d-a421-328f4b880b68"], "metadata": {}}, "knapsack_source_code": {"node_ids": ["2ef3e1a6-031d-42da-a9a3-f52535150e15"], "metadata": {}}, "langford_source_code": {"node_ids": ["56883237-c490-4f8a-8ec3-401b38e997d1"], "metadata": {}}, "loan_source_code": {"node_ids": ["82d908a5-8d31-400b-b086-afd776cbd033"], "metadata": {}}, "ltsp_source_code": {"node_ids": ["67af9333-1b7b-4f2e-b3bc-f558ecf23e9c"], "metadata": {}}, "magic_hexagon_source_code": {"node_ids": ["3bb6e712-b149-4dc5-89be-d0fa988af6b6"], "metadata": {}}, "magic_sequence_source_code": {"node_ids": ["e085b210-cbff-4aa9-ab79-199d3932971d"], "metadata": {}}, "maximum_density_still_life_source_code": {"node_ids": ["601dce60-fcf6-4521-96b8-80d68facd7fd"], "metadata": {}}, "mip_source_code": {"node_ids": ["fbbf6306-799c-4bb4-a682-aa7b1beb6403"], "metadata": {}}, "missing_solution_source_code": {"node_ids": ["c309bf1e-14c4-4f8a-937b-25a7c1080c70"], "metadata": {}}, "nonogram_create_automaton2_source_code": {"node_ids": ["680db5e7-33e3-4733-9b28-afb108815d4f"], "metadata": {}}, "nurses_source_code": {"node_ids": ["1ca863dd-fc03-41f0-91df-f9c01dfddff6"], "metadata": {}}, "opd_source_code": {"node_ids": ["2f36fba7-47d5-450c-a8f9-e2be9fcf25b9"], "metadata": {}}, "partition_source_code": {"node_ids": ["ed56b2fd-b5bc-49a5-bc44-93fe69cb2e08"], "metadata": {}}, "photo_source_code": {"node_ids": ["0d918c40-5c7a-4679-b04a-0de2e9292752"], "metadata": {}}, "project_scheduling_source_code": {"node_ids": ["4dd2643d-6d28-471e-9f09-bbfea9722b82"], "metadata": {}}, "QuasigroupCompletion_source_code": {"node_ids": ["221df495-7c24-4f67-bd80-ef740ead3c4a"], "metadata": {}}, "QuasiGroupExistence_source_code": {"node_ids": ["4fe374b4-f573-446d-be57-99f7b7b7e0c4"], "metadata": {}}, "queens_source_code": {"node_ids": ["92f82710-0397-4ba4-a5fd-510a71acc0aa"], "metadata": {}}, "rcpsp_source_code": {"node_ids": ["9ca7cba3-b489-479b-afa9-5b2c9b3932e6"], "metadata": {}}, "rehearsal_source_code": {"node_ids": ["299ce69c-d698-4784-8567-558e383cf857"], "metadata": {}}, "restart_source_code": {"node_ids": ["438ba176-5f5d-4244-aea7-bc5a6e1a2198"], "metadata": {}}, "RosteringProblem_source_code": {"node_ids": ["405d445d-d23e-483e-8068-6094b6ed1b1a"], "metadata": {}}, "sb_source_code": {"node_ids": ["45542679-3e9c-4765-8241-0c66cdf72603"], "metadata": {}}, "schur_source_code": {"node_ids": ["bccfa98d-d62d-4a91-8c3a-30928dcc254b"], "metadata": {}}, "setselect_source_code": {"node_ids": ["c0aba51c-5c79-43c5-8a9e-99dfab3eea62"], "metadata": {}}, "shipping_source_code": {"node_ids": ["daa3db9b-e979-44e5-b3d6-154275e09082"], "metadata": {}}, "simple-prod-planning_source_code": {"node_ids": ["6dc48126-89e9-4e2d-8706-c67a1b7ff7ab"], "metadata": {}}, "sonet_problem_source_code": {"node_ids": ["ba321611-e320-44fe-b92a-5810fc24a5e8"], "metadata": {}}, "square_pack_source_code": {"node_ids": ["4e842621-0b55-4126-8a1d-207ba6081f49"], "metadata": {}}, "stableroommates_source_code": {"node_ids": ["0a92c3d8-0a32-4f34-9b29-4e93f6c8740b"], "metadata": {}}, "steiner_source_code": {"node_ids": ["9fa498c8-9952-46ad-8101-e109b4732b76"], "metadata": {}}, "stoch_fjsp_source_code": {"node_ids": ["b2c0a481-5614-4db0-9618-fac709b69de3"], "metadata": {}}, "submultisetsum_source_code": {"node_ids": ["5b1af932-d83b-4565-88d4-a635813b9c25"], "metadata": {}}, "table_seating_source_code": {"node_ids": ["0b2ee8b1-92d6-4d4d-b00e-b32d64cce0f3"], "metadata": {}}, "teamselect_source_code": {"node_ids": ["f7ab6aec-2409-4d2c-98be-002972ab5c8a"], "metadata": {}}, "template_design_source_code": {"node_ids": ["443a9574-3eb8-4f42-a173-ccfd88072bbf"], "metadata": {}}, "toomany_source_code": {"node_ids": ["063f7d9d-663c-424d-b4cf-b17526dcfd09"], "metadata": {}}, "traffic_lights_table_source_code": {"node_ids": ["587f194d-6ad0-4f44-94d2-30125a63568e"], "metadata": {}}, "TTPPV_source_code": {"node_ids": ["27749507-4bf0-46e0-a896-a0fa448998b1"], "metadata": {}}, "vessel-loading_source_code": {"node_ids": ["f3d83aa1-d0cd-458c-8b94-e271fa020eab"], "metadata": {}}, "warehouses_source_code": {"node_ids": ["700e4c39-7ca2-4916-b528-320247035ca9"], "metadata": {}}, "water_buckets1_source_code": {"node_ids": ["5d35e7ea-28ff-40e7-a963-2befe2bf2b8d"], "metadata": {}}}}