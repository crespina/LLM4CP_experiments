{"docstore/metadata": {"all_interval_beginner_expert": {"doc_hash": "f1faf2675bb794b61c7e9bfea11e5414404fc9f07ff51ffccd81f7d5a4f846fe"}, "assign_beginner_expert": {"doc_hash": "4f92bba9c6243219f418a57ab60d2c4c3ef5b4be93f543a33baed06fef23126e"}, "aust_color_beginner_expert": {"doc_hash": "ef1fc895357cc901369f0de097ad00ef73c7e0c8bffcfe5c6a5e8eae3083d099"}, "bibd_beginner_expert": {"doc_hash": "5dc85efd7bf9956696850b3704dcfec987b5421bfb24ba262ab79df247cb1124"}, "bus_scheduling_csplib_beginner_expert": {"doc_hash": "06812da7c359334c2de3ba764a2d1ca220742f446aaf16fa86ca1ead3cbd7d24"}, "car_beginner_expert": {"doc_hash": "0adfd9643d3ae7f7d01e9a7ed696a3a7c36eb02d69590ec60a45452ed955df52"}, "carpet_cutting_beginner_expert": {"doc_hash": "66112389fab0c4bf8cbe7c78d8c6b8b52a4059e91818a9d4391c856ee0295bf2"}, "cell_block_beginner_expert": {"doc_hash": "dfd157d93fcb218cec23425ca41daae84c7bf86d839358c797587e74f54206ad"}, "clique_beginner_expert": {"doc_hash": "eaea55832c3fd6f32892e1bbcf0fb5a0df9d8a7fe0c922ea59e52bf4edf3d47f"}, "cluster_beginner_expert": {"doc_hash": "3aa3d7eea78195d582bf91c873ebfb1a43bf6c5f7246b3bfe9b651327574950e"}, "compatible_assignment_beginner_expert": {"doc_hash": "3584d145152a55530b978d32176036ed3632cfb2d0e35510ca3a0d40dc912a1b"}, "constrained_connected_beginner_expert": {"doc_hash": "7a19ed5745fb89ee4fa8de21a43a0b53136183838310d81546e9ba5275bb2758"}, "crazy_sets_beginner_expert": {"doc_hash": "3ddda73d5563bacd9e14790e9cf8ec13c5f5aa4119f6e9c465606f5ff94aead7"}, "crossfigure_beginner_expert": {"doc_hash": "af6be7dc00fcc3797d98ee647765ee513aa7a5791c817f8114c992277aa2729b"}, "curriculum_beginner_expert": {"doc_hash": "dd4f5afebb63bb6aa9d703acf3a6812fcf405ee37271f04ce4c3d15fd42957ab"}, "diamond_free_degree_sequence_beginner_expert": {"doc_hash": "4108a20f982bb09a6df3262bdf201567a346d2f86c0ed854ac35096769b35e39"}, "doublechannel_beginner_expert": {"doc_hash": "881e05f7b8642ab70fe6a86b181de9a20c0b67d561923606af36294d274cba01"}, "fractions_beginner_expert": {"doc_hash": "49bcc6b7d0db6cc09acd531f6af130bb375f52be35e84cb5db36d1d6ab22b8ed"}, "golfers_beginner_expert": {"doc_hash": "c043d04a17ebb8e83df21a658ac464b1bdaff575a221b40e01f2acd5cda92cab"}, "golomb_beginner_expert": {"doc_hash": "4688c1904a789a5aa6b2f91abc0d49a455980bf6ca474158bf88105dbba79b04"}, "graph_beginner_expert": {"doc_hash": "a755dbdb45aa8f63a6ce62f883f88fbc42fb122da4b6e3454472c700ea701aac"}, "itemset_mining_beginner_expert": {"doc_hash": "5eaccc604ec195f7aaa89f51242e2a8257d478ee9a337191c5fc4f6e086ad0e2"}, "jobshop_beginner_expert": {"doc_hash": "9fa80d97dbdb031c4c24bc1218211d224b4e73c17487a60ba6d010aa0c738e21"}, "K4xP2Graceful_beginner_expert": {"doc_hash": "5fc20eca015a93e799aa6adcef980bb9161841f92a8a27ce76c0030331a0f6ab"}, "killer_sudoku_beginner_expert": {"doc_hash": "dda39e28494e4b7311b991e526501d298d9f03c1273e83d4176143b56a264899"}, "knapsack_beginner_expert": {"doc_hash": "28cdd4b4a824f2fedb57c40b3ff83eaf09ed0e38c82beb9b13dac5ea4644b4d6"}, "langford_beginner_expert": {"doc_hash": "f479eb6563e072ce8a1e2508549e7d2f9c5280885072bd937fdfd45885676b1b"}, "loan_beginner_expert": {"doc_hash": "34497803228b633e1b338b7cab13ceb19418216fc339a18b4e0e00890ff951c5"}, "ltsp_beginner_expert": {"doc_hash": "9b571610c3b12d83f21792ea47d2caf817b1cfad4a79e8fb6fcc5de003bc51a1"}, "magic_hexagon_beginner_expert": {"doc_hash": "95c0421c9eaee6fa6fc1054a0e33ccdfd01ecd2291d48f926d244b54ca1797d6"}, "magic_sequence_beginner_expert": {"doc_hash": "951abaaceffc1670ce6bc7e8f02e2522b76ac7f546d19417079ec091651f90b9"}, "maximum_density_still_life_beginner_expert": {"doc_hash": "b68464aa157cacd706eec81af677a0a0b2299ac9150eac5411e6674ef8d3a1ac"}, "mip_beginner_expert": {"doc_hash": "33046256a0a76ade480daa897c738b9f45a136d39c6c58adc37b5c554a5f1ca6"}, "missing_solution_beginner_expert": {"doc_hash": "d54385633b11889fdbeb41dd749ab459fe43f6d64a0625aa9d07f4a7a641be27"}, "nonogram_create_automaton2_beginner_expert": {"doc_hash": "73421059c9e0b0dce4b451c6c016701664e860e88c23c052ce598582c54a4a08"}, "nurses_beginner_expert": {"doc_hash": "e823638328b70c3cf9ad43df99fad51aeeda23d4f3a71a881f15b71f14aeddc5"}, "opd_beginner_expert": {"doc_hash": "18af0f7d109beaf1e25b3afd5f45cd3b8aeb5b7dbb76a23e04df7cf4406522cd"}, "partition_beginner_expert": {"doc_hash": "b0cdeab64f59055d23ddcda0e6612d7f9d6ab3554140df36bb9c6ce3172b5bd2"}, "photo_beginner_expert": {"doc_hash": "a96aebdc7a5e7b72e5891ce31c299b16d3ce5317c1be163d58c5cca5479122c2"}, "project_scheduling_beginner_expert": {"doc_hash": "e686cac0baaa1640398469b344ce7e04b554744de3ae55d7aacec926ace999d2"}, "QuasigroupCompletion_beginner_expert": {"doc_hash": "5794ef7d14bd44fbe84259b2328699d3f25efe1d03e19c53c508e0ebfff0cdb0"}, "QuasiGroupExistence_beginner_expert": {"doc_hash": "b7b9bd4300d3a660dddde45be65675a1f3b37bfe05dde42bd6026dd611dc2870"}, "queens_beginner_expert": {"doc_hash": "0ba6635e3b707d6f85784d2f17454b5685f34824c464dd4eee0a185592d5d745"}, "rcpsp_beginner_expert": {"doc_hash": "8241d9dbf135e371283de2d22a1057c58dc94cdc709391bfbbeb1d780f61f735"}, "rehearsal_beginner_expert": {"doc_hash": "8b15869553b0a7935f1b22636ad4005d194aa1be4b20c9c733e897060999f090"}, "restart_beginner_expert": {"doc_hash": "252dd4323c415b99f6c3a8b00ad838b650bc29d3f08afc6ad6b6b3f5f99f0b9b"}, "RosteringProblem_beginner_expert": {"doc_hash": "ca3de7c49d0e6d999a1d98b3ed05681df258bac74dba9e676b6d704222a1c4a9"}, "sb_beginner_expert": {"doc_hash": "d70f6bd37ceb72d79b728bdddbc69cba5afd3882cda2f58a59d52b3719e2844a"}, "schur_beginner_expert": {"doc_hash": "b73d5da02a5a756fd9d3c2ee8373f3d0ab394d22b08f255505cb716cd86b7766"}, "setselect_beginner_expert": {"doc_hash": "9f404516a136e670e25ca3994d0392fd205eea508a1c58057ab095504ed84359"}, "shipping_beginner_expert": {"doc_hash": "fb0dffdaeafb4a67548a6386bc6275dc71ebc34e7e6ed84462d98cbacd4a47b8"}, "simple-prod-planning_beginner_expert": {"doc_hash": "dd09900e8238db8ba9be7aee180e421e9993d9cba34950f4fd586c03ba60253d"}, "sonet_problem_beginner_expert": {"doc_hash": "b74ebc561dc3dbffbc58195b1135170bcb74927007f9dd20284120601b4f4679"}, "square_pack_beginner_expert": {"doc_hash": "2bf1a2523a0dc932e3a9508e11e6692f216c4dc5ed1110606e0dadad7eeb7698"}, "stableroommates_beginner_expert": {"doc_hash": "a6802947757cff27e4eb02a2e60b970bfaf607007cc116e66700e57f7a5c4ba5"}, "steiner_beginner_expert": {"doc_hash": "73d4a2dd1c12df3efe66645888cb57a42b79fa15b29bd02997ca2464826079f9"}, "stoch_fjsp_beginner_expert": {"doc_hash": "9cbb7dfc2174aeee41ada796deeaf2898f87d7f37fee7d6a433104a7c4a305c0"}, "submultisetsum_beginner_expert": {"doc_hash": "7aee6879a108807d48800caff8077486c3fde88ba971f04f6f6d3878c35182d0"}, "table_seating_beginner_expert": {"doc_hash": "da08788b0de91acb0d9218033a4e6b48b86bad271ea7854d86aa8388366e6187"}, "teamselect_beginner_expert": {"doc_hash": "108e7bdf4f8001f82e8c434fd782c33084c473ef2ef0787865ff2cab2899eed2"}, "template_design_beginner_expert": {"doc_hash": "9e806f530c118bcfebfff5a34ceb0f22345d23e9bc2b9e314513accfc86ebbef"}, "toomany_beginner_expert": {"doc_hash": "b3b30ae57f5b680f7b4e8488ec5ef7ded7348415f74d99ffb56e0aa87d2759aa"}, "traffic_lights_table_beginner_expert": {"doc_hash": "c01fc789e427b83f4f99507b8665dcdc08b2215d44abd3afdbc07bb8d76539c7"}, "TTPPV_beginner_expert": {"doc_hash": "588759dd749f0073748469f581d9578337b3ee62d5d836e1af3efef0d258b9d8"}, "vessel-loading_beginner_expert": {"doc_hash": "07231b2bd4da7906caa83ad10c244e919b34a7c9b7bdee3f2cd63d3e514b97b5"}, "warehouses_beginner_expert": {"doc_hash": "f7bf16bd5a9d14f09b22acd0fe51d853124c9907d68919937a8dd2c5ccec81be"}, "water_buckets1_beginner_expert": {"doc_hash": "b7bd492e5c6d78c3d05195987b043bf9732ccefc20fea7d83550d3e752927e38"}, "10a41c3b-825b-437d-9603-32ba9a8109fb": {"doc_hash": "014cb80d3670fa8c4c973cd41e248e2a2f3537c5e1e9ee8788c06cee3609f2a3", "ref_doc_id": "all_interval_beginner_expert"}, "502510e6-38a7-4f69-80f3-e7b5fd36b3f1": {"doc_hash": "85f64a05c7e454c212bad36ae17575bb18604e2fa46042d3bd0607598fd70c4d", "ref_doc_id": "assign_beginner_expert"}, "4ea733f0-ef9b-45ce-9133-e561ab85407d": {"doc_hash": "460676c3341a93ec7c7bbfb6d468006b0f188f17f9ec1c3b7ea4fe26bfad4708", "ref_doc_id": "aust_color_beginner_expert"}, "eaf3b20c-6c20-47bf-95f1-9751559b7b5c": {"doc_hash": "439e27a254beac2f354754a45fdfd6509e1ad07b2a27807422d8b0fdbfd013d4", "ref_doc_id": "bibd_beginner_expert"}, "aeeb0fa8-de5f-42cf-ae23-aa57d34654af": {"doc_hash": "4cb2b0e43f51b9466cd0951283e78ca7d70519d8e8583aececde7a8a47f6afb0", "ref_doc_id": "bus_scheduling_csplib_beginner_expert"}, "b382bc22-daf9-4074-88c4-74ae612b0152": {"doc_hash": "9398c43f5b3b1fce6f0799d57387578ff49eaa975c08b3b630aa07410861c537", "ref_doc_id": "car_beginner_expert"}, "eb87af12-3413-4931-b4c7-ce06229d7cb0": {"doc_hash": "3cea9405c1839797beaff2e94f604bf67dddd464cb3e328821acda754eb09e1d", "ref_doc_id": "carpet_cutting_beginner_expert"}, "13644c23-51d7-497c-b413-0e596d99578e": {"doc_hash": "b0ceb83606c541220926b3660506b339fbf04a4c3f3ef3b6017716d987022f83", "ref_doc_id": "cell_block_beginner_expert"}, "a9200264-3493-4081-a936-f164b53dd568": {"doc_hash": "6a2c1e305cf240f95dc7b84c3f9da5aa0111f880165951faab86dbda442bfe5b", "ref_doc_id": "clique_beginner_expert"}, "c6cd639e-6b0e-4e96-952b-c05a0d4a89d2": {"doc_hash": "7c8dab9d1f2ed7ebe43d485fc094b3bc7c2e166d6ea056800d13558f6ec9742e", "ref_doc_id": "cluster_beginner_expert"}, "a69b543f-2323-45d2-9147-06e7a484fbc1": {"doc_hash": "a758c8d7adceb4021be43ce3b74a23103b2b2c43f0d9d5c8b23f298b9aedde43", "ref_doc_id": "compatible_assignment_beginner_expert"}, "7a92bcc8-ddb9-41e1-8a96-ecedf3eb747e": {"doc_hash": "75753a5d35736f41040264bd844b45412e6de11cbfee338033781be6fe563bcf", "ref_doc_id": "constrained_connected_beginner_expert"}, "36a1cf45-c299-449d-82ad-a436ed119432": {"doc_hash": "a9b19650fc8ef9a321bb086adfc6dfb74c23a9132959d0aabff03a5c05c22c49", "ref_doc_id": "crazy_sets_beginner_expert"}, "c96c9bcc-b8bb-4755-bfc0-aaf3a818979c": {"doc_hash": "2eb1d48ff6a95c377406d1eb6d1e4b94d12e057ce3349ca1e888291bd7659fe9", "ref_doc_id": "crossfigure_beginner_expert"}, "564060f0-af90-421e-8f1a-ee30cf9e957b": {"doc_hash": "6cfd1eae8d99cbc3a8b4129f84c030cc076d761a19f751d6832ae817d67d1282", "ref_doc_id": "curriculum_beginner_expert"}, "31d4889c-203a-4ca4-b3f0-2989f1ec8720": {"doc_hash": "10048a53cbb358e9b283a6910db64994a5d86e44dc2d00fdc6d47b3fc939c5c9", "ref_doc_id": "diamond_free_degree_sequence_beginner_expert"}, "3de27e3f-d51b-4219-ba6c-47518d3b1855": {"doc_hash": "4391fb5b7ba1c18d12b68e07de3df5788492f7189fa3f9530107cc827771e376", "ref_doc_id": "doublechannel_beginner_expert"}, "f21ae6b8-2269-4cd6-a51e-3d952387a666": {"doc_hash": "08e8bf4570c579436672f3aa4808f30df1faf422d4e5b472100acba49631935e", "ref_doc_id": "fractions_beginner_expert"}, "b6b5bf31-c85b-4bda-91f3-5ea35c333f6a": {"doc_hash": "c22d6a965f474c75da246242f5298f73ed112725e911dd1e8ffac4b64840b5bf", "ref_doc_id": "golfers_beginner_expert"}, "b54533e8-e76c-4cbc-83d7-826257e2ec23": {"doc_hash": "79b903a6f1dab8bf08a417bde1d082d211f9a79dfe80c890eac3bfad61a4995f", "ref_doc_id": "golomb_beginner_expert"}, "91d12d56-bdf2-4c0f-9071-e33a01698ec4": {"doc_hash": "b8883ed2e57cf6c503e2e26df9c27f2eaf917c5371425e09bfd3becadf6714c7", "ref_doc_id": "graph_beginner_expert"}, "a2141adc-f942-4133-9ee0-29133809f49e": {"doc_hash": "9c56dafae98d100f9c468264ebafc4ce61db78ec73ae1027944380473d8edbcd", "ref_doc_id": "itemset_mining_beginner_expert"}, "4ab0855e-03ec-4271-bc5d-6c83520be420": {"doc_hash": "ca967a37ad620350e6cff8785107ccac460d5b0c83fe2ef10fc03467b3a1ab38", "ref_doc_id": "jobshop_beginner_expert"}, "9f80b197-588b-4250-93cd-6139f70fca12": {"doc_hash": "608d2b9d9b6d00a82c9f0f6f09fe6437e7a5d81c91260634bcd7b333c6736360", "ref_doc_id": "K4xP2Graceful_beginner_expert"}, "f1501c1b-dbb5-47fb-b8c4-b62776d02787": {"doc_hash": "443bc40b3d79021e7083a732662afde618e2defabadfa976c171146a687a4f66", "ref_doc_id": "killer_sudoku_beginner_expert"}, "4031cb6b-f2fd-4d2d-a074-9f9b1fb8a879": {"doc_hash": "6109d72551346f013e91071c56b8bb452766294b56185945677ed4c40c90f477", "ref_doc_id": "knapsack_beginner_expert"}, "919a8845-f00f-413f-b82d-bb122f665cc2": {"doc_hash": "4aa175f1e6c1c7cf591d4e2a5d080bc327a02cc0a85abfbd0d2afb475ad05569", "ref_doc_id": "langford_beginner_expert"}, "a0f71dd3-2577-4c74-afd4-f2a41c55bbe0": {"doc_hash": "6576b21e05a8ef2786380e135f39e1e35903dc22a4ab88a2e0b373e5495445c1", "ref_doc_id": "loan_beginner_expert"}, "441f92ef-4998-4014-a630-2276a79f8eab": {"doc_hash": "c6764d30eb5b6d8347c719c3ebc19f794941e5cdc7f08c971a760d034176a20b", "ref_doc_id": "ltsp_beginner_expert"}, "9bcaca8d-87ad-4e82-83c9-3519d6186f7d": {"doc_hash": "614af5508bca8adfd641dbc123e3586ee2302d38271f0f274cd6cbbf3424fc7e", "ref_doc_id": "magic_hexagon_beginner_expert"}, "2d6c539e-bed2-4de0-b4b0-c3c49e80c89f": {"doc_hash": "cd792309def2a9afdcea32497139d21f8759c24c106a57a9afc045b244f51775", "ref_doc_id": "magic_sequence_beginner_expert"}, "5c9b6aaf-6639-4a08-9512-a17bc3b672c6": {"doc_hash": "cbcc6718217f6e7ac51703f79936f06118b68582317b777c9843bfcff02a38c1", "ref_doc_id": "maximum_density_still_life_beginner_expert"}, "bdd3450b-722b-4d06-876d-6e354c285337": {"doc_hash": "b694fbe9fadb3f1835e93e10e826fc6ed8c827849868737fe81ca3259351ebe8", "ref_doc_id": "mip_beginner_expert"}, "1cc311cd-0939-49d7-9810-ef181b1b85d1": {"doc_hash": "4bf1a1279ddee029cb02fd8f11d6ae1671ac5aba7c1e9d20f4c4043eb5b8eba4", "ref_doc_id": "missing_solution_beginner_expert"}, "17562cb6-b29c-4d38-9656-fed7bcd463e5": {"doc_hash": "f4c7326f0d62cbf31c1f5e8d90a1c9c7cf6a9b9c6c17b00a78058acc1269434b", "ref_doc_id": "nonogram_create_automaton2_beginner_expert"}, "6c0f0626-9c1f-46f1-a260-90ca703d6834": {"doc_hash": "e6690c0a78c2200b668483f6a1e420f8d198a9690ba1e8f4f3c06fcf97aa2f84", "ref_doc_id": "nurses_beginner_expert"}, "bf60802e-6c34-405f-8415-fbff0aac98c6": {"doc_hash": "b8155ae8290cfbe9dc092124948022b187df554b8ea1d343f955fc748262a7ff", "ref_doc_id": "opd_beginner_expert"}, "08844db2-f742-4667-a653-dde01e76e51a": {"doc_hash": "d248a886da2ba5edda58924d3d27aad03bdec33cedd4a12bcb8864d5303c1568", "ref_doc_id": "partition_beginner_expert"}, "f87ba9d8-bd1f-4208-bc54-9eeba153bfe4": {"doc_hash": "7757b4eca99ad418a6a7546b192c804859fa271e46869363fb0fb6e21ccd6cb2", "ref_doc_id": "photo_beginner_expert"}, "d13ef289-8446-44d0-95bd-a39e3d16e05c": {"doc_hash": "b59586b6a3531a718fc5dfac3628f385c9b51c6f6ce0ee65e0766096c007f1f6", "ref_doc_id": "project_scheduling_beginner_expert"}, "da7ea70a-b481-42b4-8872-b77a47e28ddb": {"doc_hash": "a401c4fbe41718ce88b10aac7597fc7e069c1440e70487c6c37c3abb17a0f05a", "ref_doc_id": "QuasigroupCompletion_beginner_expert"}, "32f176d6-92c5-4941-b074-336ccf863065": {"doc_hash": "33ec5109a3ce1ffebc38b64f458365d7a9f051e2a54c576af09da89f650cfbeb", "ref_doc_id": "QuasiGroupExistence_beginner_expert"}, "8007fb48-f42c-47dd-b33a-44d6e8a80d8b": {"doc_hash": "441b19d1e42d4b0a2a6cdb17229cfb58c4468a6ff425366ec99594fbc0c365ae", "ref_doc_id": "queens_beginner_expert"}, "9f575d86-aef4-4a8c-a5ce-7624de1ce454": {"doc_hash": "33306468394f726870b888015eecafb3cc2f63b0289109d21daf8bd5f602a5a0", "ref_doc_id": "rcpsp_beginner_expert"}, "90833a59-9f76-4f0e-b7a1-e1d6c6b055ec": {"doc_hash": "eeec0376f486ec613318c710c39d8781fc1ffba080db6ba5ef72446cd5fdb88d", "ref_doc_id": "rehearsal_beginner_expert"}, "b1f58f26-7b1b-4f3f-88e5-c8e9ed95a536": {"doc_hash": "fe1db7cdd7701bcf9023dd2ec4c62b10cb73a732d97f1090ac760f80e9488e91", "ref_doc_id": "restart_beginner_expert"}, "66d30a23-3825-424b-8f69-193f98bf99f4": {"doc_hash": "0ea575c67491d6883b8acb42a42c0aa83f0e9ff0c369f7581cb1b149fc10ec4f", "ref_doc_id": "RosteringProblem_beginner_expert"}, "1fc4024d-6423-447f-858e-7e58c9f10a3a": {"doc_hash": "c5b92b030e1ea623f8c58faa4b6a2799898b07310ca89b2e88f0dfb4b5f56aa8", "ref_doc_id": "sb_beginner_expert"}, "48c52e70-f43e-43f2-8e86-cd5b6d81d107": {"doc_hash": "4db0ee4161a5c1b2483faf484a5a34a7d247eb7613e112c449d8b4fee5c2fc7a", "ref_doc_id": "schur_beginner_expert"}, "6267f07d-f1a6-4f1c-844c-4bf452fa805a": {"doc_hash": "b3f629bd73f0a7c64433ce3dc65d1b45801c969cd2266844524c75c142d57b06", "ref_doc_id": "setselect_beginner_expert"}, "5037c1c5-9780-4897-bb81-789ba80876d4": {"doc_hash": "82a9980368004b49efe2f29fcb9fec6e5111599b1cd374787757c0e2a7e2e8df", "ref_doc_id": "shipping_beginner_expert"}, "f60fdec3-676c-4a65-a02a-db16ae35dd4d": {"doc_hash": "1cbecf2daeeeaaec7d08b27bc4c03156262d7fb932f23514a56418dc0b7ed4c0", "ref_doc_id": "simple-prod-planning_beginner_expert"}, "31c36fa2-d800-4eac-839e-987a1286ccdf": {"doc_hash": "96ee4507b6ebaca0f0d7d8105ffc7a18477f459e866516ddecde78b5ef9ab3a2", "ref_doc_id": "sonet_problem_beginner_expert"}, "8760ac65-5154-4be7-8bb5-1f2d2cc1840b": {"doc_hash": "9a2b2e48ef656b4c2d7e974ea733de792a471ea56a57f9f95a0b031cb21b3646", "ref_doc_id": "square_pack_beginner_expert"}, "9b656723-e1cd-42c9-9d34-ccb177763904": {"doc_hash": "d42037b4edd4f16e984514e4c36699f4333cf490a931b44cd3264f389606a93a", "ref_doc_id": "stableroommates_beginner_expert"}, "60a56f2c-939f-419d-ac47-c4678591eb3b": {"doc_hash": "62b9e1dcb2d9945035146ee41db3a8ce7e6e6ba4e844de10fd265ab4fe9120a1", "ref_doc_id": "steiner_beginner_expert"}, "09e314d4-f60e-4e32-ae33-6417ed6bab61": {"doc_hash": "233dcba3efd868672e3aad785d1bfd42fce1c30a8b9a45120ee14502e1c3dd93", "ref_doc_id": "stoch_fjsp_beginner_expert"}, "c55e1a44-e9d6-41b4-961f-48f12424c8c5": {"doc_hash": "e5a7759edabd342b932c29d74c4f01c92f82c80704f9473af044b16b5c314f72", "ref_doc_id": "submultisetsum_beginner_expert"}, "413fd4c3-f1ce-40c8-9fce-4a102e912125": {"doc_hash": "37c20d47bb1519fb669ebf9e08083a993f8f3654d8c02b2760868b008330a845", "ref_doc_id": "table_seating_beginner_expert"}, "03cde710-c624-4179-8be7-259bf1a346f2": {"doc_hash": "8f0dc6e2935675fcf8d127b0d870e443614bc9267e2d293c00509d212236e5da", "ref_doc_id": "teamselect_beginner_expert"}, "a710d984-d82b-48bb-952f-e2bc9f18dafd": {"doc_hash": "8ba8dbcdf55cc562fe27a7c9ad623a9b63a9c1a9cc5dd91c9aa89bafa57f0f1d", "ref_doc_id": "template_design_beginner_expert"}, "7d42eaba-f0b2-47b7-b14e-23c3695ed353": {"doc_hash": "52bcd943d226cef8265f5d75995ff3e209f36c4e5faf5f018f07c0d6c1e83acb", "ref_doc_id": "toomany_beginner_expert"}, "ef56d123-cf49-4fe5-a326-73e64a01a3c1": {"doc_hash": "651e2b7dfe34d5879acbff4f29809255c9f848cf724f8f389a46f7e9d6124f86", "ref_doc_id": "traffic_lights_table_beginner_expert"}, "2d4b7fbf-183a-4a3e-8f8f-b0d58c0212c0": {"doc_hash": "f8b7f12ea287b226edc2bf33c3fdbb410767d9c1b18d41a44b56dd3b8052e42e", "ref_doc_id": "TTPPV_beginner_expert"}, "566c8757-1aff-49da-9c8d-82c455356942": {"doc_hash": "ab2ff3e7a87d15d26412441c1d09c814159be5c53e9436ec146b4a5ee3298924", "ref_doc_id": "vessel-loading_beginner_expert"}, "c4c1ac9d-fb86-43c6-9f4e-714007b2e02b": {"doc_hash": "53e8da0f5d48d493e76c07edab5cb00327755cab0374a396a0fb85a1122273b8", "ref_doc_id": "warehouses_beginner_expert"}, "73337856-f433-4527-bcd7-bb46331d6a2b": {"doc_hash": "e53d7c1c7d7ea55731dc12e4a17805a42a2bf44b12443b20d27ab3e2f48f4ca9", "ref_doc_id": "water_buckets1_beginner_expert"}}, "docstore/data": {"10a41c3b-825b-437d-9603-32ba9a8109fb": {"__data__": {"id_": "10a41c3b-825b-437d-9603-32ba9a8109fb", "embedding": null, "metadata": {"model_name": "all_interval"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "all_interval_beginner_expert", "node_type": "4", "metadata": {"model_name": "all_interval"}, "hash": "f1faf2675bb794b61c7e9bfea11e5414404fc9f07ff51ffccd81f7d5a4f846fe", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** All-Interval Series Problem\n\n**What the problem is about in everyday terms:** Imagine you have 12 different musical notes (like C, C#, D, etc.). You want to arrange these notes in a special order so that each note appears only once, and the distance between each pair of adjacent notes is different from the distance between any other pair of adjacent notes. For example, if the distance between the first two notes is 2 semitones, then there should be no other pair of adjacent notes with a distance of 2 semitones.\n\n**Main variables and what they mean:**\n\n* `x` or `series`: an array of 12 variables, each representing a musical note (0 to 11). This array represents the order in which the notes will be played.\n* `diffs` or `differences`: an array of variables representing the distance between each pair of adjacent notes.\n\n**Basic restrictions or rules of the problem:**\n\n* Each note must appear only once in the series.\n* The distance between each pair of adjacent notes must be different from the distance between any other pair of adjacent notes.\n\n**Goal of the problem:** Find an arrangement of the 12 notes that satisfies the above rules.\n\nNote that the different models provided are different ways of solving the same problem, but the underlying problem remains the same.\n                    ======\n                    Description 2:\n                    ---------\n                    name: All-Interval Series Problem\n\ndescription: The All-Interval Series Problem is a classic problem in constraint programming that involves finding a series of pitch classes such that each pitch class occurs exactly once and the musical intervals between neighboring notes cover the full set of intervals from the minor second (1 semitone) to the major seventh (11 semitones).\n\nvariables: x = (x_1, ..., x_n) where x_i \u2208 {0, ..., n-1} for i = 1, ..., n; diffs = (diffs_1, ..., diffs_{n-1}) where diffs_i \u2208 {1, ..., n-1} for i = 1, ..., n-1\n\nThe variables x represent the pitch classes in the series, and the variables diffs represent the intervals between neighboring notes.\n\nconstraints: \nall_different(x) \u2227 all_different(diffs) \u2227 \n\u2200k \u2208 {1, ..., n-1} (diffs_k = |x_{k+1} - x_k|) \u2227 \nx_1 < x_{n-1} \u2227 diffs_1 < diffs_2\n\nThe constraints ensure that each pitch class occurs exactly once, each interval occurs exactly once, the intervals are calculated correctly, and some symmetry-breaking constraints are added to reduce the search space.\n\nobjective: The problem is a satisfaction problem, meaning that the goal is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2774, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "502510e6-38a7-4f69-80f3-e7b5fd36b3f1": {"__data__": {"id_": "502510e6-38a7-4f69-80f3-e7b5fd36b3f1", "embedding": null, "metadata": {"model_name": "assign"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "assign_beginner_expert", "node_type": "4", "metadata": {"model_name": "assign"}, "hash": "4f92bba9c6243219f418a57ab60d2c4c3ef5b4be93f543a33baed06fef23126e", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **The Assignment Problem**\n\n**What is it about?**\nImagine you have a group of workers and a list of tasks that need to be done. Each worker can do one task, and each task can be done by one worker. The problem is to assign each worker to a task in a way that maximizes the total profit or benefit.\n\n**Main variables:**\n\n* `WORK` (or `DOM`): a set of workers\n* `TASK` (or `COD`): a set of tasks\n* `x` (or `task` or `worker`): a variable that represents the assignment of a worker to a task\n* `profit`: a table that shows the profit or benefit of assigning a worker to a task\n* `obj`: the total profit or benefit of the assignment\n\n**Basic restrictions or rules:**\n\n* Each worker can do only one task.\n* Each task can be done by only one worker.\n* The assignment must be done in a way that maximizes the total profit or benefit.\n\n**Goal:**\nThe goal is to find an assignment of workers to tasks that maximizes the total profit or benefit.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Assignment Problem\n\ndescription: The Assignment Problem is a classic problem in combinatorial optimization and operations research. It involves finding the optimal assignment of a set of workers to a set of tasks, where each worker can be assigned to at most one task and each task can be assigned to at most one worker, in order to maximize the total profit or value of the assignments.\n\nvariables: x, px, task, worker\nx: an array of variables, where x[w] represents the task assigned to worker w\npx: an array of variables, where px[w] represents the profit of assigning worker w to task x[w]\ntask: an array of variables, where task[w] represents the worker assigned to task w\nworker: an array of variables, where worker[t] represents the task assigned to worker t\nThese variables represent the assignment of workers to tasks and the corresponding profits.\n\nconstraints: alldifferent(x), inverse(task,worker), alldifferent(worker)\nalldifferent(x): ensures that each worker is assigned to at most one task\ninverse(task,worker): ensures that each task is assigned to at most one worker and each worker is assigned to at most one task\nalldifferent(worker): ensures that each task is assigned to at most one worker\nThese constraints ensure that the assignment is one-to-one, i.e., each worker is assigned to at most one task and each task is assigned to at most one worker.\n\nobjective: maximize obj, where obj = sum(w in WORK)(px[w]) or obj = sum(t in COD)(profit[worker[t],t])\nThe objective is to maximize the total profit of the assignments, which is the sum of the profits of assigning each worker to their assigned task.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2758, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4ea733f0-ef9b-45ce-9133-e561ab85407d": {"__data__": {"id_": "4ea733f0-ef9b-45ce-9133-e561ab85407d", "embedding": null, "metadata": {"model_name": "aust_color"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aust_color_beginner_expert", "node_type": "4", "metadata": {"model_name": "aust_color"}, "hash": "ef1fc895357cc901369f0de097ad00ef73c7e0c8bffcfe5c6a5e8eae3083d099", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **The Australian Map Colouring Problem**\n\nThis problem is about colouring a map of Australia with different colours. Imagine you have a map of Australia with six states: Western Australia (WA), Northern Territory (NT), South Australia (SA), Queensland (Q), New South Wales (NSW), and Victoria (V), plus Tasmania (T).\n\n**Main variables:**\n\n* wa, nt, sa, q, nsw, v, and t: These are the colours assigned to each state.\n\n**Basic restrictions or rules:**\n\n* Each state must have a different colour from its neighbouring states.\n\n**Goal:**\n\n* Find a way to colour the map of Australia using a certain number of colours (4 or more) such that no two neighbouring states have the same colour.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Graph Colouring Problem (Australia Map Colouring)\n\ndescription: The Graph Colouring Problem is a classic problem in constraint programming, where we need to assign colours to the regions of a map such that no two adjacent regions have the same colour. In this specific instance, we are colouring the map of Australia, which is divided into six regions: Western Australia (wa), Northern Territory (nt), South Australia (sa), Queensland (q), New South Wales (nsw), and Victoria (v), plus Tasmania (t).\n\nvariables: wa, nt, sa, q, nsw, v, t \u2208 {1, ..., nc} \nThese variables represent the colours assigned to each region of the Australia map, where nc is the total number of colours available.\n\nconstraints: wa \u2260 nt, wa \u2260 sa, nt \u2260 sa, nt \u2260 q, sa \u2260 q, sa \u2260 nsw, sa \u2260 v, q \u2260 nsw, nsw \u2260 v \nThese constraints ensure that no two adjacent regions have the same colour. For example, wa \u2260 nt means that Western Australia and Northern Territory cannot have the same colour.\n\nobjective: satisfy \nThe objective of the problem is to find a feasible solution that satisfies all the constraints, i.e., to find a colouring of the Australia map such that no two adjacent regions have the same colour. There is no objective to minimize or maximize a specific value.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2128, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eaf3b20c-6c20-47bf-95f1-9751559b7b5c": {"__data__": {"id_": "eaf3b20c-6c20-47bf-95f1-9751559b7b5c", "embedding": null, "metadata": {"model_name": "bibd"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bibd_beginner_expert", "node_type": "4", "metadata": {"model_name": "bibd"}, "hash": "5dc85efd7bf9956696850b3704dcfec987b5421bfb24ba262ab79df247cb1124", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Balanced Incomplete Block Design (BIBD)\n\nThis problem is about creating a special kind of table with certain properties. Imagine you have a bunch of people, and you want to divide them into groups to play games or do activities together. You want to make sure that each person plays with the same number of other people, and each group has the same number of people. Also, you want to make sure that any two people play together in the same group a certain number of times.\n\nThe main variables are:\n\n* v: the number of people\n* k: the number of people in each group\n* lambda: the number of times any two people play together in the same group\n* b: the number of groups (calculated based on v, k, and lambda)\n* r: the number of groups each person is in (calculated based on v, k, and lambda)\n* m: a table that shows which people are in which groups (this is the main thing we're trying to figure out)\n\nThe basic restrictions or rules of the problem are:\n\n* Each person is in the same number of groups (r)\n* Each group has the same number of people (k)\n* Any two people play together in the same group the same number of times (lambda)\n\nThe goal of the problem is to find a table (m) that satisfies all these rules.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Balanced Incomplete Block Design (BIBD)\n\ndescription: A Balanced Incomplete Block Design (BIBD) is a combinatorial design in which a set of v elements is divided into b blocks, each of size k, such that each element occurs in r blocks, and every pair of elements occurs together in \u03bb blocks. The goal is to find a binary matrix representing the incidence of elements in blocks, satisfying these conditions.\n\nvariables: m[i, j] for i in {1, ..., v}, j in {1, ..., b} - m[i, j] represents whether element i is in block j (true) or not (false).\n\nconstraints: \n1. \u2200i in {1, ..., v} (\u2211(j in {1, ..., b}) bool2int(m[i, j]) = r) - Each element occurs in r blocks.\n2. \u2200j in {1, ..., b} (\u2211(i in {1, ..., v}) bool2int(m[i, j]) = k) - Each block contains k elements.\n3. \u2200i, i' in {1, ..., v} where i < i' (\u2211(j in {1, ..., b}) bool2int(m[i, j] \u2227 m[i', j]) = \u03bb) - Every pair of elements occurs together in \u03bb blocks.\n4. \u2200i in {1, ..., v-1} (lex_lesseq([m[i, j] | j in {1, ..., b}], [m[i+1, j] | j in {1, ..., b}])) - Break row symmetry in the incidence matrix.\n5. \u2200j in {1, ..., b-1} (lex_lesseq([m[i, j] | i in {1, ..., v}], [m[i, j+1] | i in {1, ..., v}])) - Break column symmetry in the incidence matrix.\n\nobjective: The problem is a satisfaction problem, meaning that the goal is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2802, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aeeb0fa8-de5f-42cf-ae23-aa57d34654af": {"__data__": {"id_": "aeeb0fa8-de5f-42cf-ae23-aa57d34654af", "embedding": null, "metadata": {"model_name": "bus_scheduling_csplib"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bus_scheduling_csplib_beginner_expert", "node_type": "4", "metadata": {"model_name": "bus_scheduling_csplib"}, "hash": "06812da7c359334c2de3ba764a2d1ca220742f446aaf16fa86ca1ead3cbd7d24", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Bus Driver Scheduling Problem\n\nThis problem is about creating a schedule for bus drivers to cover all the tasks (like driving routes) with the minimum number of drivers needed.\n\nThe main variables are:\n\n* Tasks (or pieces of work): these are the bus routes or driving jobs that need to be covered.\n* Shifts: these are the possible schedules for the bus drivers, which cover some of the tasks.\n* x: this is a variable that decides which shifts to choose for the drivers.\n* tot_shifts: this is the total number of shifts (or drivers) needed to cover all the tasks.\n\nThe basic restrictions or rules of the problem are:\n\n* Each task must be covered by exactly one shift (or driver).\n* Each shift can cover multiple tasks.\n* We want to use the minimum number of shifts (or drivers) to cover all the tasks.\n\nThe goal of the problem is to minimize the total number of shifts (or drivers) needed to cover all the tasks.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Bus Driver Scheduling Problem\n\ndescription: The Bus Driver Scheduling Problem is a classic problem in constraint programming that involves assigning bus drivers to shifts to cover a set of tasks (pieces of work) while minimizing the number of shifts used. Each shift has a set of tasks it covers, and the goal is to select a subset of shifts that covers each task exactly once.\n\nvariables: x = (x[1], ..., x[num_shifts]) \u2208 {0, 1}^num_shifts, tot_shifts \u2208 {0, ..., num_shifts}\n\nThe decision variables x[i] represent whether shift i is selected (x[i] = 1) or not (x[i] = 0). The variable tot_shifts represents the total number of shifts used in the solution.\n\nconstraints: \ntot_shifts = \u2211(x)\n\u2200j \u2208 {0, ..., num_work-1}, \u2211(i \u2208 {1, ..., num_shifts}) (x[i] * bool2int(j \u2208 shifts[i])) = 1\ntot_shifts \u2265 min_num_shifts\n\nThe first constraint sets the total number of shifts used to the sum of the x variables. The second constraint ensures that each task is covered exactly once by the selected shifts. The third constraint sets a lower bound on the total number of shifts used.\n\nobjective: Minimize tot_shifts", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2213, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b382bc22-daf9-4074-88c4-74ae612b0152": {"__data__": {"id_": "b382bc22-daf9-4074-88c4-74ae612b0152", "embedding": null, "metadata": {"model_name": "car"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "car_beginner_expert", "node_type": "4", "metadata": {"model_name": "car"}, "hash": "0adfd9643d3ae7f7d01e9a7ed696a3a7c36eb02d69590ec60a45452ed955df52", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Car Sequencing Problem**\n\nThis problem is about arranging cars on a production line in a specific order. Imagine a factory that produces cars with different features, such as sunroofs, leather seats, or navigation systems. The goal is to sequence the cars in a way that minimizes the total number of changes needed to switch between different features.\n\n**Main Variables:**\n\n* `slot`: represents the type of car (e.g., sedan, SUV, etc.) assigned to each production slot.\n* `setup`: indicates whether a specific feature (e.g., sunroof) is installed on a car in a particular slot.\n\n**Basic Restrictions or Rules:**\n\n* Each type of car has a specific number of units to be produced.\n* Certain features require a minimum number of consecutive cars to be produced together (e.g., a sunroof requires 3 consecutive cars).\n* The production line has a limited capacity for each feature (e.g., only 5 cars with leather seats can be produced in a row).\n\n**Goal:**\n\nThe goal is to minimize the total number of changes needed to switch between different car types and features while satisfying the production requirements and restrictions.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Car Sequencing Problem\n\ndescription: The Car Sequencing Problem is a classic problem in constraint programming that involves scheduling the production of cars with different options and classes. The goal is to find an optimal sequence of cars to produce, taking into account the availability of options and the constraints on the production process.\n\nvariables: \n`slot[s] \u2208 Classes, s \u2208 Slots` \n`setup[o, s] \u2208 {0, 1}, o \u2208 Options, s \u2208 Slots`\n\nThe decision variables are `slot` and `setup`. `slot[s]` represents the class of the car produced in slot `s`, and `setup[o, s]` represents whether option `o` is installed in the car produced in slot `s`.\n\nconstraints: \n`\u2200c \u2208 Classes, \u2211(s \u2208 Slots) (bool2int(slot[s] = c)) = numberPerClass[c]`\n`\u2200o \u2208 Options, s \u2208 1..numcars - windowSize[o] + 1, \u2211(j \u2208 s..s + windowSize[o]- 1) (setup[o, j]) \u2264 optMax[o]`\n`\u2200o \u2208 Options, s \u2208 Slots, setup[o, s] = optionsRequired[slot[s], o]`\n`\u2200o \u2208 Options, i \u2208 1..optionNumberPerClass[o], \u2211(s \u2208 1..(numcars - i * windowSize[o])) (setup[o, s]) \u2265 (optionNumberPerClass[o] - i * optMax[o])`\n\nThe constraints ensure that: \n- each class of cars is produced the required number of times, \n- the number of consecutive cars with a particular option does not exceed the maximum allowed, \n- each car is produced with the required options, \n- and the total number of cars with a particular option is at least the minimum required.\n\nobjective: \n`minimize z = \u2211(s \u2208 Classes) (s * slot[s])`\n\nThe objective is to minimize the total \"cost\" of the production sequence, where the cost of each car is proportional to its class.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2910, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eb87af12-3413-4931-b4c7-ce06229d7cb0": {"__data__": {"id_": "eb87af12-3413-4931-b4c7-ce06229d7cb0", "embedding": null, "metadata": {"model_name": "carpet_cutting"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "carpet_cutting_beginner_expert", "node_type": "4", "metadata": {"model_name": "carpet_cutting"}, "hash": "66112389fab0c4bf8cbe7c78d8c6b8b52a4059e91818a9d4391c856ee0295bf2", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Carpet Cutting Problem\n\n**What the problem is about in everyday terms:** Imagine you have a roll of carpet and you need to cut it to fit different rooms in a house. Each room has a specific shape and size, and you want to use the minimum amount of carpet possible to cover all the rooms.\n\n**Main variables and what they mean:**\n\n* `n`: The number of rooms in the house.\n* `m`: The number of different rectangle shapes that can be used to cut the carpet.\n* `ROOM`: A set of integers representing the rooms in the house.\n* `ROFF`: A set of integers representing the different rectangle shapes.\n* `d`: An array of integers representing the definitions of the rectangle shapes (x-offset, y-offset, x-size, y-size).\n* `shape`: An array of sets of integers representing the shapes that can be used for each room.\n* `h`: The height of the roll of carpet.\n* `maxl`: The maximum length of the roll of carpet.\n* `x` and `y`: Arrays of variables representing the x and y coordinates of the top-left corner of each room.\n* `rot`: An array of variables representing the rotation of each room (0, 90, 180, or 270 degrees).\n* `l`: A variable representing the length of carpet used.\n\n**Basic restrictions or rules of the problem:**\n\n* Each room must be covered by a single piece of carpet.\n* The carpet must be cut from the roll in a way that minimizes waste.\n* The shapes of the rooms and the carpet pieces must fit together without overlapping.\n\n**Goal of the problem:** The goal is to find the minimum length of carpet needed to cover all the rooms.\n\nIn summary, the Carpet Cutting Problem is about finding the most efficient way to cut a roll of carpet to fit different rooms in a house, using the minimum amount of carpet possible.\n                    ======\n                    Description 2:\n                    ---------\n                    name: 2D Rectangular Cutting Stock Problem\n\ndescription: The 2D Rectangular Cutting Stock Problem is a classic problem in operations research and computer science. It involves cutting a set of rectangles from a larger rectangular roll of material, such as wood or metal, to minimize waste. Each rectangle has a specific size and offset, and can be rotated by 90 degrees. The goal is to find the optimal placement of the rectangles on the roll to minimize the total length of the roll used.\n\nvariables: x[i], y[i], rot[i], l, kind[i]\n\n* x[i] and y[i] are the coordinates of the top-left corner of room i on the roll.\n* rot[i] is the rotation of room i (0, 90, 180, or 270 degrees).\n* l is the total length of the roll used.\n* kind[i] is the shape of room i (1, 2, 3, or 4).\n\nconstraints: \nforall(i in ROOM)(shape[i,rot[i]] != {}),\nforall(i in ROOM)(forall(r in ROFF)(r in shape[i,rot[i]] -> x[i] + d[r,1] + d[r,3] <= l /\\ y[i] + d[r,2] + d[r,4] <= h)),\nforall(i,j in ROOM where i < j)(forall(r1,r2 in ROFF)(r1 in shape[i,rot[i]] /\\ r2 in shape[j,rot[j]] -> x[i] + d[r1,1] + d[r1,3] <= x[j] + d[r2,1] \\/ x[j] + d[r2,1] + d[r2,3] <= x[i] + d[r1,1] \\/ y[i] + d[r1,2] + d[r1,4] <= y[j] + d[r2,2] \\/ y[j] + d[r2,2] + d[r2,4] <= y[i] + d[r1,2])),\ngeost_bb(2, rect_size, rect_offset, shapes, coords, kind, [0,0], [l,h]),\nkind[i] in {1,2,3,4}\n\n* The first constraint ensures that each room has a non-empty shape.\n* The second constraint ensures that each rectangle in a room does not exceed the roll's length and height.\n* The third constraint ensures that no two rooms overlap.\n* The fourth constraint is a geometric constraint that ensures the rectangles are placed correctly on the roll.\n* The fifth constraint ensures that each room has a valid shape.\n\nobjective: minimize l", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 3751, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "13644c23-51d7-497c-b413-0e596d99578e": {"__data__": {"id_": "13644c23-51d7-497c-b413-0e596d99578e", "embedding": null, "metadata": {"model_name": "cell_block"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cell_block_beginner_expert", "node_type": "4", "metadata": {"model_name": "cell_block"}, "hash": "dfd157d93fcb218cec23425ca41daae84c7bf86d839358c797587e74f54206ad", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Here is the explanation of the problem:\n\n**Prisoner Allocation Problem**\n\nThis problem is about allocating prisoners to cells in a prison. Imagine a prison with a certain number of rows and columns of cells. Each prisoner needs to be assigned to a specific cell.\n\n**Main Variables:**\n\n* `k`: The total number of prisoners.\n* `PRISONER`: A set of prisoners, each identified by a unique number from 1 to `k`.\n* `n` and `m`: The number of rows and columns of cells in the prison, respectively.\n* `r` and `c`: Variables that represent the row and column of each prisoner's cell, respectively.\n* `danger`: A set of prisoners who are considered dangerous.\n* `female` and `male`: Sets of female and male prisoners, respectively.\n* `cost`: A table that shows the cost of assigning each prisoner to each cell.\n\n**Basic Restrictions or Rules:**\n\n* Each prisoner must be assigned to a unique cell.\n* Prisoners who are considered dangerous should not be placed next to each other.\n* Female prisoners should be placed in the top half of the prison, while male prisoners should be placed in the bottom half.\n\n**Goal:**\n\nThe goal is to assign prisoners to cells in a way that minimizes the total cost of the assignments. The cost is calculated by summing up the costs of assigning each prisoner to their assigned cell.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Prisoner Allocation Problem\n\ndescription: The Prisoner Allocation Problem is a classic constraint satisfaction problem that involves allocating prisoners to cells in a prison. The prison has a certain number of rows and columns, and each prisoner has a specific cost associated with being placed in a particular cell. The goal is to allocate the prisoners to cells in such a way that the total cost is minimized, while also satisfying certain constraints. These constraints include ensuring that prisoners who are deemed \"dangerous\" are not placed in adjacent cells, and that female prisoners are placed in cells in the top half of the prison, while male prisoners are placed in cells in the bottom half.\n\nvariables: r, c (arrays of variables, where r[p] and c[p] represent the row and column of prisoner p, respectively)\n\nThese variables represent the decision of which cell to allocate each prisoner to.\n\nconstraints: \nalldifferent([r[p] * m + c[p] | p in PRISONER]) (each prisoner must be allocated to a unique cell)\nforall(p in PRISONER, d in danger where p != d) (manhattan(r[p],c[p],r[d],c[d]) > 1) (dangerous prisoners must not be placed in adjacent cells)\nforall(p in female)(r[p] <= (n + 1) div 2) (female prisoners must be placed in cells in the top half of the prison)\nforall(p in male)(r[p] >= n div 2 + 1) (male prisoners must be placed in cells in the bottom half of the prison)\n\nThese constraints ensure that the allocation of prisoners to cells is valid and satisfies the rules of the prison.\n\nobjective: minimize totalcost (the total cost of allocating prisoners to cells)", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 3094, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a9200264-3493-4081-a936-f164b53dd568": {"__data__": {"id_": "a9200264-3493-4081-a936-f164b53dd568", "embedding": null, "metadata": {"model_name": "clique"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "clique_beginner_expert", "node_type": "4", "metadata": {"model_name": "clique"}, "hash": "eaea55832c3fd6f32892e1bbcf0fb5a0df9d8a7fe0c922ea59e52bf4edf3d47f", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Maximum Clique Problem\n\nThis problem is about finding a group of friends in a social network where everyone in the group knows each other.\n\nThe main variables are:\n\n* `c`: an array that says whether each person is in the group or not (true or false)\n* `size`: the total number of people in the group\n\nThe basic restrictions or rules of the problem are:\n\n* If two people don't know each other, they can't both be in the group\n* We want to find the largest possible group of friends\n\nThe goal of the problem is to find the largest group of friends (maximize `size`).\n                    ======\n                    Description 2:\n                    ---------\n                    name: Maximum Clique Problem\n\ndescription: The Maximum Clique Problem is a classic problem in graph theory and computer science. Given a graph, the goal is to find the largest subset of vertices such that every pair of vertices in the subset is connected by an edge. This problem has applications in social network analysis, data mining, and computer vision, among others.\n\nvariables: c = (c_1, ..., c_n), size\n\nThe decision variables c_i (i = 1, ..., n) are boolean variables indicating whether vertex i is included in the clique or not. The variable size is an integer representing the total number of vertices in the clique.\n\nconstraints: size = \u2211_{i=1}^n c_i, \u2200i, j \u2208 {1, ..., n} where i < j and adj[i, j] = 0, c_i + c_j \u2264 1\n\nThe first constraint ensures that the size of the clique is equal to the sum of the boolean variables c_i. The second constraint ensures that for any pair of non-adjacent vertices i and j, at most one of them can be included in the clique.\n\nobjective: Maximize size", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1755, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c6cd639e-6b0e-4e96-952b-c05a0d4a89d2": {"__data__": {"id_": "c6cd639e-6b0e-4e96-952b-c05a0d4a89d2", "embedding": null, "metadata": {"model_name": "cluster"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cluster_beginner_expert", "node_type": "4", "metadata": {"model_name": "cluster"}, "hash": "3aa3d7eea78195d582bf91c873ebfb1a43bf6c5f7246b3bfe9b651327574950e", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Problem Name:** Clustering Problem\n\n**What the problem is about:** Imagine you have a bunch of points on a map, and you want to group them into clusters so that points in the same cluster are close to each other.\n\n**Main Variables:**\n\n* `n`: The number of points on the map.\n* `POINT`: A set of points, each represented by a number from 1 to `n`.\n* `dist`: A table that shows the distance between each pair of points.\n* `k`: The number of clusters you want to create.\n* `CLUSTER`: A set of cluster numbers, from 1 to `k`.\n* `x`: An array that assigns each point to a cluster number.\n* `maxdiam`: The maximum distance between points in the same cluster.\n\n**Basic Restrictions or Rules:**\n\n* Points in the same cluster should be close to each other (within `maxdiam` distance).\n* Each cluster should have at least one point.\n* Clusters should be numbered in a way that points in cluster `i` are all closer to each other than points in cluster `i+1`.\n\n**Goal of the Problem:** The goal is to find a way to cluster the points so that the total distance between points in the same cluster is as small as possible, while also making sure that points in different clusters are far enough apart.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Capacitated Clustering Problem\n\ndescription: The Capacitated Clustering Problem is a classic problem in constraint programming that involves dividing a set of points into a fixed number of clusters, such that the maximum distance between any two points in the same cluster does not exceed a certain limit, and the clusters are ordered in a way that the points in each cluster are contiguous.\n\nvariables: x (array of variables, where x[i] represents the cluster assignment of point i)\n\nThe decision variables x represent the assignment of each point to a cluster.\n\nconstraints: \n\u2200i,j in POINT where i < j /\\ x[i] = x[j], dist[i,j] \u2264 maxdiam \n\u2200i in 1..k-1, min([ j | j in POINT where x[j] = i]) < min([ j | j in POINT where x[j] = i+1])\nvalue_precede_chain([ i | i in 1..k ],x)\n\nThe first constraint ensures that the distance between any two points in the same cluster does not exceed the maximum diameter. The second constraint ensures that the points in each cluster are contiguous, i.e., the points in cluster i are all less than the points in cluster i+1. The third constraint is a global constraint that ensures the same contiguity property.\n\nobjective: maximize obj = min( i,j in POINT where i < j ) ( dist[i,j] + maxdist * (x[i] != x[j]) )\n\nThe objective is to maximize the minimum distance between any two points in different clusters, while also penalizing the assignment of points to different clusters.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2802, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a69b543f-2323-45d2-9147-06e7a484fbc1": {"__data__": {"id_": "a69b543f-2323-45d2-9147-06e7a484fbc1", "embedding": null, "metadata": {"model_name": "compatible_assignment"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "compatible_assignment_beginner_expert", "node_type": "4", "metadata": {"model_name": "compatible_assignment"}, "hash": "3584d145152a55530b978d32176036ed3632cfb2d0e35510ca3a0d40dc912a1b", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Problem Name:** Task Assignment Problem\n\n**What the problem is about:** Imagine you have a set of tasks that need to be done, and a set of workers who can do these tasks. Each task has a certain profit associated with it, and each worker can do a specific set of tasks. The problem is to assign tasks to workers in a way that maximizes the total profit.\n\n**Main variables:**\n\n* `task`: an array that assigns a task to each worker\n* `worker`: an array that assigns a worker to each task\n* `profit`: a 2D array that stores the profit of each task for each worker\n* `compatible`: a 2D array that indicates whether two workers can work together on consecutive tasks\n\n**Basic restrictions or rules:**\n\n* Each task must be assigned to a worker\n* Each worker can only do one task at a time\n* If two workers are assigned to consecutive tasks, they must be compatible with each other\n\n**Goal:** The goal is to maximize the total profit by assigning tasks to workers in a way that satisfies the above rules.\n\nIn simple terms, the problem is about finding the best way to assign tasks to workers to get the most profit, while making sure that workers who need to work together can do so.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Task Scheduling Problem\n\ndescription: The Task Scheduling Problem is a classic problem in constraint programming where we have a set of tasks and a set of workers. Each task has a profit associated with it, and each worker can perform a subset of tasks. The problem is to assign tasks to workers such that the total profit is maximized, subject to certain constraints.\n\nvariables: task[w] (w \u2208 W), worker[t] (t \u2208 T)\nThe decision variables are task[w] which represents the task assigned to worker w, and worker[t] which represents the worker assigned to task t.\n\nconstraints: \nalldifferent(task), \n\u2200w1, w2 \u2208 W (task[w1] \u2260 m \u2227 task[w2] = task[w1] + 1 \u2192 compatible[w1, w2]), \ninverse(task, worker), \n\u2200t \u2208 T (t mod m \u2260 0 \u2192 compatible[worker[t], worker[t+1]])\n\nThe constraints are: \n- Each worker is assigned a unique task (alldifferent(task)).\n- If two tasks are assigned to two consecutive workers, then the tasks must be compatible (compatible[w1, w2]).\n- The inverse constraint ensures that each task is assigned to a unique worker and each worker is assigned a unique task (inverse(task, worker)).\n- If two tasks are consecutive, then the workers assigned to these tasks must be compatible (compatible[worker[t], worker[t+1]]).\n\nobjective: Maximize \u2211(w \u2208 W) profit[w, task[w]]\nThe objective is to maximize the total profit by assigning tasks to workers such that the profit of each task is maximized.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2780, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7a92bcc8-ddb9-41e1-8a96-ecedf3eb747e": {"__data__": {"id_": "7a92bcc8-ddb9-41e1-8a96-ecedf3eb747e", "embedding": null, "metadata": {"model_name": "constrained_connected"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "constrained_connected_beginner_expert", "node_type": "4", "metadata": {"model_name": "constrained_connected"}, "hash": "7a19ed5745fb89ee4fa8de21a43a0b53136183838310d81546e9ba5275bb2758", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Constrained Clustering**\n\nThis problem is about grouping things together in a way that follows certain rules.\n\n**Main Variables:**\n\n* `selected`: a set of connections between things (called edges)\n* `rep`: a way to represent each group (called a cluster)\n\n**Basic Restrictions or Rules:**\n\n* If two things are connected (an edge), they must be in the same group (cluster)\n* Certain pairs of things cannot be in the same group (given by `first` and `second` arrays)\n\n**Goal:**\n\nThe goal is to find the largest number of connections (edges) that can be included while following the rules, and to group the things together in a way that makes sense.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Constrained Clustering\n\ndescription: The Constrained Clustering problem is a variant of the traditional clustering problem, where we want to group nodes into clusters such that no two nodes in the same cluster are connected by a forbidden edge. The goal is to find the maximum number of edges that can be included in the clustering while satisfying the constraints.\n\nvariables: selected \u2286 EDGE, rep: NODE \u2192 NODE\nThe decision variables are `selected`, a subset of edges that will be included in the clustering, and `rep`, a function that assigns a representative node to each node in the graph.\n\nconstraints: \u2200e \u2208 EDGE: e \u2208 selected \u2192 rep[pre[e]] = rep[suc[e]], \u2200d \u2208 DPAIR: rep[first[d]] \u2260 rep[second[d]]\nThe constraints ensure that if an edge is selected, its endpoints must have the same representative node, and that the representative nodes of nodes connected by a forbidden edge must be different.\n\nobjective: maximize |selected|\nThe objective is to maximize the number of edges included in the clustering.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1860, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "36a1cf45-c299-449d-82ad-a436ed119432": {"__data__": {"id_": "36a1cf45-c299-449d-82ad-a436ed119432", "embedding": null, "metadata": {"model_name": "crazy_sets"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crazy_sets_beginner_expert", "node_type": "4", "metadata": {"model_name": "crazy_sets"}, "hash": "3ddda73d5563bacd9e14790e9cf8ec13c5f5aa4119f6e9c465606f5ff94aead7", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Problem Name:** Unknown (no specific name is given)\n\n**What the problem is about in everyday terms:** Imagine you have a set of numbers from 1 to 10, and you want to divide these numbers into 4 groups, each containing 4 numbers. The goal is to create these groups in a way that no three groups have a common number.\n\n**Main variables and what they mean:**\n\n* `n`: the maximum value in the set of numbers (in this case, 10)\n* `c`: the number of elements in each group (in this case, 4)\n* `m`: the number of groups (in this case, 4)\n* `s`: an array of sets, where each set represents a group of numbers\n* `x`: a 2D array of numbers, where each row represents a group and each column represents a position in the group\n\n**Basic restrictions or rules of the problem:**\n\n* Each group must have exactly 4 numbers.\n* No three groups can have a common number.\n* The numbers in each group must be in increasing order.\n* The numbers in each group must be unique.\n\n**Goal of the problem:** The goal is to find a way to divide the numbers into groups that satisfy all the rules and restrictions.\n\nNote: The problem is not trying to minimize or maximize anything, it's just trying to find a feasible solution that satisfies all the constraints.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Error-Correcting Code Design\n\ndescription: The problem of Error-Correcting Code Design involves designing a set of codes such that any three codes have no element in common. This problem is a classic problem in constraint programming and is used in various applications such as coding theory and data storage.\n\nvariables: s[i], x[i,j]\n\nThe decision variables are s[i] which represents the i-th set of codes, and x[i,j] which represents the j-th element of the i-th set.\n\nconstraints: \ns[i] intersect s[j] intersect s[k] = {}, \nx[i,j] < x[i,j+1], \nx[i,j] < x[i+1,j], \no in s[i] -> exists(j in 1..c)(x[i,j] = o), \nx[i,j] in s[i]\n\nThe constraints ensure that any three sets have no element in common, the elements in each set are in increasing order, and the elements in each set are distinct. The last two constraints ensure that the x[i,j] variables are correctly assigned to the sets s[i].\n\nobjective: satisfy\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, i.e., to design a set of codes such that any three codes have no element in common.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2525, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c96c9bcc-b8bb-4755-bfc0-aaf3a818979c": {"__data__": {"id_": "c96c9bcc-b8bb-4755-bfc0-aaf3a818979c", "embedding": null, "metadata": {"model_name": "crossfigure"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crossfigure_beginner_expert", "node_type": "4", "metadata": {"model_name": "crossfigure"}, "hash": "af6be7dc00fcc3797d98ee647765ee513aa7a5791c817f8114c992277aa2729b", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Crossfigure problem\n\n**What the problem is about in everyday terms:** Imagine you have a grid of numbers, like a crossword puzzle, but instead of words, you have numerical clues to fill in. The clues are given in the form of mathematical equations, and you need to figure out the correct numbers to put in each box to satisfy all the equations.\n\n**What the main variables are and what they mean:**\n\n* `M` is a 9x9 grid of numbers, where each number is between 0 and 9.\n* `A1`, `A4`, ..., `A30` are variables that represent the answers to the \"across\" clues.\n* `D1`, `D2`, ..., `D28` are variables that represent the answers to the \"down\" clues.\n\n**What the basic restrictions or rules of the problem are:**\n\n* Each number in the grid `M` must be between 0 and 9.\n* The numbers in the grid must satisfy the mathematical equations given in the clues.\n* Some numbers in the grid are fixed to be 0 (these are the \"black boxes\").\n\n**What the goal of the problem is:** The goal is to find a solution that satisfies all the mathematical equations and fills in the entire grid `M` with numbers between 0 and 9.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Crossfigure Problem\n\ndescription: The Crossfigure problem is a numerical puzzle where a 9x9 grid is filled with numbers such that each row, column, and some predefined regions satisfy certain numerical clues. The clues are given in the form of arithmetic operations and comparisons involving the numbers in the grid.\n\nvariables: M[i,j] (i, j = 1..9), A1, A4, ..., A30, D1, D2, ..., D28\n\nThe variables M[i,j] represent the numbers in the 9x9 grid. The variables A1, A4, ..., A30 and D1, D2, ..., D28 represent the numerical answers to the clues, which are placed horizontally (Across) and vertically (Down) in the grid, respectively.\n\nconstraints: \nacross(M, A1, 4, 1, 1) /\\ ... /\\ down(M, D28, 2, 8, 8) /\\ \nA1 = 2 * A27 /\\ ... /\\ D28 = D21 + 27 /\\ \nM[1,5] = 0 /\\ ... /\\ M[9,5] = 0\n\nThe constraints can be divided into three categories: \n1. The across and down predicates, which ensure that the numbers in the grid are correctly placed to form the numerical answers to the clues.\n2. The clue constraints, which define the relationships between the numerical answers, such as arithmetic operations and comparisons.\n3. The blackbox constraints, which fix certain cells in the grid to be zero.\n\nobjective: The objective of the problem is to find a feasible solution that satisfies all the constraints, i.e., to fill the grid with numbers such that all the clues are satisfied. There is no objective function to minimize or maximize.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2798, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "564060f0-af90-421e-8f1a-ee30cf9e957b": {"__data__": {"id_": "564060f0-af90-421e-8f1a-ee30cf9e957b", "embedding": null, "metadata": {"model_name": "curriculum"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "curriculum_beginner_expert", "node_type": "4", "metadata": {"model_name": "curriculum"}, "hash": "dd4f5afebb63bb6aa9d703acf3a6812fcf405ee37271f04ce4c3d15fd42957ab", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    The Balanced Academic Curriculum Problem.\n\nThis problem is about creating a schedule for a set of university courses. Each course has a certain number of credits, and students can only take a certain number of credits and courses per period. The goal is to assign each course to a period in a way that minimizes the total number of credits per period.\n\nThe main variables are:\n\n* Courses: these are the university courses that need to be scheduled.\n* Periods: these are the time slots when the courses can be taught.\n* Course load: this is the number of credits each course is worth.\n* Course period: this is the period when each course is taught.\n* Load: this is the total number of credits for all courses in a period.\n\nThe basic restrictions or rules of the problem are:\n\n* Each course must be assigned to a period.\n* A course cannot be taught before its prerequisites (i.e., courses that must be taken before it).\n* Students can only take a certain number of credits and courses per period.\n* The total number of credits per period should be within a certain range.\n\nThe goal of the problem is to minimize the total number of credits per period, while satisfying all the above rules.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Balanced Academic Curriculum Problem\n\ndescription: The Balanced Academic Curriculum Problem is a classic constraint programming problem that involves assigning courses to periods in a curriculum while satisfying various constraints. Each course has a certain load (number of credits) and prerequisites, and students have limits on the number of credits and courses they can take in a period. The goal is to assign courses to periods such that the total load in each period is minimized.\n\nvariables: $course_period[c] \\in \\{1, ..., n_periods\\} \\forall c \\in courses, x[p, c] \\in \\{0, 1\\} \\forall p \\in periods, c \\in courses, load[p] \\in [load_per_period_lb, load_per_period_ub] \\forall p \\in periods, objective \\in [load_per_period_lb, load_per_period_ub]$\n\nThe decision variables are: \n- $course_period[c]$ represents the period to which course $c$ is assigned.\n- $x[p, c]$ is a binary variable indicating whether course $c$ is assigned to period $p$.\n- $load[p]$ represents the total load (number of credits) in period $p$.\n- $objective$ is the minimum total load across all periods.\n\nconstraints: \n$course_period[c] = p \\Leftrightarrow x[p, c] = 1 \\forall p \\in periods, c \\in courses$\n$\\sum_{i \\in courses} x[p, i] \\geq courses_per_period_lb \\forall p \\in periods$\n$\\sum_{i \\in courses} x[p, i] \\leq courses_per_period_ub \\forall p \\in periods$\n$load[p] = \\sum_{c \\in courses} x[p, c] * course_load[c] \\forall p \\in periods$\n$load[p] \\geq load_per_period_lb \\forall p \\in periods$\n$load[p] \\leq objective \\forall p \\in periods$\n$course_period[b] < course_period[a] \\forall a, b \\in courses : prerequisite(a, b)$\n$l \\geq (n_periods - p) * load_per_period_lb \\forall p \\in 0..n_periods-1$\n$l \\leq (n_periods - p) * objective \\forall p \\in 0..n_periods-1$\n\nThe constraints are:\n- Each course is assigned to exactly one period.\n- The number of courses in each period is within the bounds.\n- The total load in each period is calculated correctly.\n- The total load in each period is within the bounds.\n- The load in each period is less than or equal to the objective.\n- Courses are assigned to periods respecting their prerequisites.\n- Redundant linear constraints to help the solver.\n\nobjective: Minimize $objective$, which represents the minimum total load across all periods.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 3665, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "31d4889c-203a-4ca4-b3f0-2989f1ec8720": {"__data__": {"id_": "31d4889c-203a-4ca4-b3f0-2989f1ec8720", "embedding": null, "metadata": {"model_name": "diamond_free_degree_sequence"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "diamond_free_degree_sequence_beginner_expert", "node_type": "4", "metadata": {"model_name": "diamond_free_degree_sequence"}, "hash": "4108a20f982bb09a6df3262bdf201567a346d2f86c0ed854ac35096769b35e39", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Diamond-free Degree Sequence**\n\n**What is the problem about?**\nImagine you have a bunch of friends, and some of them are friends with each other. You want to know how many friends each person has, and how those friendships are connected, without having any groups of four friends who are all friends with each other (this is called a \"diamond\").\n\n**Main variables:**\n\n* `x`: a table that shows if two friends are friends with each other (1 if they are, 0 if they're not)\n* `degrees`: a list that shows how many friends each person has\n\n**Basic restrictions or rules:**\n\n* Each person has at least one friend (no one is alone)\n* The number of friends each person has is a multiple of 3 (e.g., 3, 6, 9, etc.)\n* The total number of friendships is a multiple of 6\n* There are no groups of four friends who are all friends with each other (no \"diamonds\")\n\n**Goal:**\nFind all possible ways to assign friends to each person, following the rules above, and without having any \"diamonds\".\n                    ======\n                    Description 2:\n                    ---------\n                    name: Diamond-free Degree Sequence\n\ndescription: The Diamond-free Degree Sequence problem is a constraint satisfaction problem that involves finding all unique degree sequences of a simple, undirected, and diamond-free graph. A diamond-free graph is a graph that does not contain a diamond subgraph, which is a set of four vertices with at least five edges between them. The problem requires that each vertex has a degree greater than zero, the degree of each vertex is a multiple of 3, and the sum of the degrees is a multiple of 12.\n\nvariables: x[i,j], degrees[i]\n\nThe decision variables are x[i,j], which represents the adjacency matrix of the graph, where x[i,j] = 1 if there is an edge between vertices i and j, and x[i,j] = 0 otherwise. The variables degrees[i] represent the degree of each vertex i, which is the number of edges incident on that vertex.\n\nconstraints: \nx[i,j] + x[i,k] + x[i,l] + x[j,k] + x[j,l] + x[k,l] <= 4, \ndegrees[i] = sum([x[i,j] | j in 1..n]), \ndegrees[i] mod 3 = 0, \nx[i,i] = 0, \nx[i,j] = x[j,i], \nsum(degrees) mod 12 = 0, \ndecreasing(degrees), \nlex2(x)\n\nThe constraints ensure that the graph is diamond-free, each vertex has a degree greater than zero and a multiple of 3, the sum of the degrees is a multiple of 12, and the graph is undirected. The symmetry breaking constraints decreasing(degrees) and lex2(x) are used to reduce the number of symmetric solutions.\n\nobjective: satisfy", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2595, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3de27e3f-d51b-4219-ba6c-47518d3b1855": {"__data__": {"id_": "3de27e3f-d51b-4219-ba6c-47518d3b1855", "embedding": null, "metadata": {"model_name": "doublechannel"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "doublechannel_beginner_expert", "node_type": "4", "metadata": {"model_name": "doublechannel"}, "hash": "881e05f7b8642ab70fe6a86b181de9a20c0b67d561923606af36294d274cba01", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Problem Name:** Ship Scheduling\n\n**What the problem is about:** Imagine a busy port with multiple channels where ships come and go. We need to schedule when each ship enters and leaves the port through which channel, so that they don't crash into each other.\n\n**Main variables:**\n\n* `SHIP`: Each ship is represented by a number.\n* `CHANNEL`: Each channel in the port is represented by a number.\n* `start`: The time when each ship starts to enter or leave the port.\n* `end`: The time when each ship finishes entering or leaving the port.\n* `channel`: The channel assigned to each ship.\n* `next`: The next ship that will use the same channel.\n\n**Basic restrictions or rules:**\n\n* Each ship must enter and leave the port through one of the channels.\n* Ships must not collide with each other in the same channel.\n* There must be a safe distance (called \"leeway\") between two ships in the same channel.\n* Each channel has a limited length, and ships take different times to traverse it.\n\n**Goal of the problem:** We want to find a schedule that minimizes the total difference between the desired start time and the actual start time for all ships. In other words, we want to make sure that each ship starts entering or leaving the port as close as possible to its desired time.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Ship Scheduling Problem\n\ndescription: The Ship Scheduling Problem is a classic constraint satisfaction problem that involves scheduling ships entering and leaving a port through multiple channels. The goal is to assign a start time, end time, and channel to each ship such that there are no clashes between ships in the same channel, and the total deviation from the desired start times is minimized.\n\nvariables: \nstart[s], end[s], channel[s], next[s], kind[s] for s in SHIPE\nThese variables represent the start time, end time, assigned channel, and the next ship in the same channel for each ship, respectively. The kind variable represents the direction of the ship (entering or leaving).\n\nconstraints: \nforall(s in nS + 1 .. nS + nC)(start[s] = maxt /\\ end[s] = maxt)\nforall(s in nS + 1 .. nS + nC)(channel[s] = s - nS)\nforall(s in SHIP)(end[s] = start[s] + len[channel[s]]*speed[s])\nalldifferent(next)\nforall(s in SHIP)(if kind[s] + kind[next[s]] = entering+leaving then end[s] <= start[next[s]] else start[s] + speed[s]*leeway <= start[next[s]] /\\ end[s] + speed[s]*leeway <= end[next[s]])\nforall(s in SHIP)(channel[next[s]] = channel[s])\n\nThese constraints ensure that dummy ships have a start and end time of maxt, and are assigned to their own channel. They also ensure that the end time of a ship is calculated based on its start time, speed, and channel length. The alldifferent constraint ensures that each ship has a unique next ship in the same channel. The remaining constraints ensure that there are no clashes between ships in the same channel, and that the next ship in the same channel is correctly assigned.\n\nobjective: \nminimize sum(s in SHIP)(abs(start[s] - desired[s]))\n\nThe objective is to minimize the total deviation from the desired start times for all ships.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 3261, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f21ae6b8-2269-4cd6-a51e-3d952387a666": {"__data__": {"id_": "f21ae6b8-2269-4cd6-a51e-3d952387a666", "embedding": null, "metadata": {"model_name": "fractions"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fractions_beginner_expert", "node_type": "4", "metadata": {"model_name": "fractions"}, "hash": "49bcc6b7d0db6cc09acd531f6af130bb375f52be35e84cb5db36d1d6ab22b8ed", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Fractions problem\n\n**What the problem is about:** Imagine you have 9 distinct digits (from 1 to 9) that you want to use to create three fractions that add up to 1. The fractions are created by combining the digits in a specific way.\n\n**Main variables and their meanings:**\n\n* A, B, C, D, E, F, G, H, I: These are the 9 distinct digits (from 1 to 9) that we want to use to create the fractions.\n* D1, D2, D3: These are the denominators (the numbers at the bottom) of the three fractions.\n\n**Basic restrictions or rules:**\n\n* Each digit can only be used once.\n* The digits must be combined in a specific way to create the fractions.\n* The three fractions must add up to 1.\n\n**Goal of the problem:** Find a way to combine the 9 digits to create three fractions that add up to 1, while following the rules and restrictions mentioned above.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Fractions Problem\n\ndescription: The Fractions Problem is a classic constraint satisfaction problem where the goal is to find distinct non-zero digits such that the following equation holds: A/(BC) + D/(EF) + G/(HI) = 1.\n\nvariables: A, B, C, D, E, F, G, H, I, D1, D2, D3\nThese variables represent the digits in the equation. A, B, C, D, E, F, G, H, and I are the digits in the numerators and denominators of the fractions, and D1, D2, and D3 are intermediate variables used to calculate the denominators.\n\nconstraints: \nall_different(Vars) \nD1 = 10*B+C \nD2 = 10*E+F \nD3 = 10*H+I \nA*D2*D3 + D*D1*D3 + G*D1*D2 = D1*D2*D3 \nA*D2 >= D*D1 \nD*D3 >= G*D2 \n3*A >= D1 \n3*G <= D2\n\nThese constraints ensure that: \n- all digits are distinct, \n- the intermediate variables D1, D2, and D3 are correctly calculated, \n- the equation A/(BC) + D/(EF) + G/(HI) = 1 holds, \n- and some symmetry-breaking and redundant constraints are added to help the solver.\n\nobjective: satisfy\nThe objective of the problem is to find a solution that satisfies all the constraints, rather than to minimize or maximize a specific value.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2200, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b6b5bf31-c85b-4bda-91f3-5ea35c333f6a": {"__data__": {"id_": "b6b5bf31-c85b-4bda-91f3-5ea35c333f6a", "embedding": null, "metadata": {"model_name": "golfers"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golfers_beginner_expert", "node_type": "4", "metadata": {"model_name": "golfers"}, "hash": "c043d04a17ebb8e83df21a658ac464b1bdaff575a221b40e01f2acd5cda92cab", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Social Golfers Problem\n\n**What the problem is about in everyday terms:** Imagine a group of golfers who want to play golf together in small groups over several rounds. The goal is to arrange the golfers into groups for each round such that each golfer plays with different people in each round, and no two golfers play together more than once.\n\n**Main variables and what they mean:**\n\n* `n_groups`: The number of groups that the golfers will be divided into.\n* `n_per_group`: The number of golfers in each group.\n* `n_rounds`: The number of rounds that the golfers will play.\n* `golfers`: The set of all golfers.\n* `rounds`: The set of all rounds.\n* `places` or `groups`: The set of all possible positions or groups that a golfer can be assigned to.\n\n**Basic restrictions or rules of the problem:**\n\n* Each group must have the same number of golfers.\n* Each golfer must play with different people in each round.\n* No two golfers can play together more than once.\n\n**Goal of the problem:** The goal is to find an arrangement of golfers into groups for each round that satisfies the above rules and restrictions.\n\nNote that the different models provided are different ways of representing the same problem, but the overall problem remains the same.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Social Golfers Problem\n\ndescription: The Social Golfers Problem is a classic constraint satisfaction problem that involves scheduling golfers into groups for multiple rounds of golf, such that each golfer plays with a different set of golfers in each round, and no two golfers play together more than once.\n\nvariables: `round_place_golfer[r, p]`, `golfer_golfer_round[g1, g2]`, `round_group_i_golfer[r, g, i]`, `round_group_golfers[r, g]`, `assign[g, w]`\n\nThese variables represent the assignment of golfers to groups and rounds. Specifically, `round_place_golfer[r, p]` represents the golfer assigned to place `p` in round `r`, `golfer_golfer_round[g1, g2]` represents the round in which golfers `g1` and `g2` play together, `round_group_i_golfer[r, g, i]` represents the golfer assigned to group `g` and position `i` in round `r`, `round_group_golfers[r, g]` represents the set of golfers assigned to group `g` in round `r`, and `assign[g, w]` represents the group assignment of golfer `g` in week `w`.\n\nconstraints: \n`alldifferent (p in places) (round_place_golfer[r, p])`, \n`round_place_golfer[r, p] < round_place_golfer[r, p + 1]`, \n`golfer_golfer_round[g1, g2] = r`, \n`alldifferent (g in groups, i in group) (round_group_i_golfer[r, g, i])`, \n`round_group_i_golfer[r, g, i] < round_group_i_golfer[r, g, i + 1]`, \n`sum (r in rounds, g in groups, i, j in group where i < j) (bool2int(round_group_i_golfer[r, g, i] = a /\\ round_group_i_golfer[r, g, j] = b)) <= 1`, \n`card(round_group_golfers[r, g]) = n_per_group`, \n`all_disjoint (g in groups) (round_group_golfers[r, g])`, \n`sum (r in rounds, g in groups) (bool2int({a, b} subset round_group_golfers[r, g])) <= 1`, \n`sum (g in Golfer) (bool2int(assign[g,w] = gr)) = groupSize`, \n`(bool2int(assign[g1,w1] = assign[g2,w1]) + bool2int(assign[g1,w2] = assign[g2,w2])) <= 1`, \n`assign[g,1]=((g-1) div groupSize) + 1`, \n`assign[g,2]=g`\n\nThese constraints ensure that each golfer is assigned to a unique group and position in each round, that each group has the correct size, that each pair of golfers plays together at most once, and that the symmetry of the problem is broken.\n\nobjective: The objective of the problem is to find a feasible assignment of golfers to groups and rounds that satisfies all the constraints. There is no objective function to minimize or maximize.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 3837, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b54533e8-e76c-4cbc-83d7-826257e2ec23": {"__data__": {"id_": "b54533e8-e76c-4cbc-83d7-826257e2ec23", "embedding": null, "metadata": {"model_name": "golomb"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golomb_beginner_expert", "node_type": "4", "metadata": {"model_name": "golomb"}, "hash": "4688c1904a789a5aa6b2f91abc0d49a455980bf6ca474158bf88105dbba79b04", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Golomb Ruler Problem\n\nThis problem is about creating a special kind of ruler with marks on it. Imagine a ruler with some marks on it, and we want to find the best way to place these marks so that the ruler is as short as possible.\n\nThe main variables are:\n\n* `m`: the number of marks on the ruler\n* `mark`: an array that stores the positions of the marks on the ruler\n* `differences`: an array that stores the differences between the positions of the marks\n\nThe basic restrictions or rules of the problem are:\n\n* The marks must be placed in order from left to right (i.e., the first mark is at position 0, and each subsequent mark is to the right of the previous one)\n* All the differences between the positions of the marks must be unique (i.e., no two differences can be the same)\n\nThe goal of the problem is to find the shortest ruler that satisfies these rules. In other words, we want to minimize the length of the ruler.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Golomb Ruler Problem\n\ndescription: The Golomb Ruler Problem is a classic problem in constraint programming that involves finding a set of distinct integers, called marks, such that the differences between all pairs of marks are also distinct. The goal is to find a Golomb ruler with the minimum length, which is the maximum mark value.\n\nvariables: mark[1..m] \u2208 {0, ..., n}\n\nThe decision variables are an array of m integers, mark[i], representing the i-th mark on the ruler, where 0 \u2264 mark[i] \u2264 n. These variables determine the positions of the marks on the ruler.\n\nconstraints: \nmark[1] = 0\nmark[i] < mark[i+1] \u2200 i \u2208 {1, ..., m-1}\nalldifferent(differences)\ndifferences[1] < differences[(m*(m-1)) div 2]\n\nThe constraints are:\n- The first mark is fixed at 0.\n- Each mark is strictly greater than the previous one, ensuring that the marks are in increasing order.\n- The differences between all pairs of marks are distinct, which is the core constraint of the Golomb Ruler Problem.\n- A symmetry-breaking constraint is added to ensure that the differences are in increasing order, which helps to reduce the search space.\n\nobjective: minimize mark[m]\n\nThe objective is to minimize the maximum mark value, which represents the length of the Golomb ruler.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2376, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "91d12d56-bdf2-4c0f-9071-e33a01698ec4": {"__data__": {"id_": "91d12d56-bdf2-4c0f-9071-e33a01698ec4", "embedding": null, "metadata": {"model_name": "graph"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "graph_beginner_expert", "node_type": "4", "metadata": {"model_name": "graph"}, "hash": "a755dbdb45aa8f63a6ce62f883f88fbc42fb122da4b6e3454472c700ea701aac", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Graph Numbering Problem**\n\nThis problem is about labeling the vertices of a graph with numbers from 1 to 8, such that each number is used only once.\n\n**Main Variables:**\n\n* a, b, c, d, e, f, g, h: These are the labels or numbers assigned to the vertices of the graph.\n\n**Basic Restrictions or Rules:**\n\n* Each number from 1 to 8 can only be used once.\n* The numbers assigned to adjacent vertices (connected by an edge) must differ by at least 2.\n\n**Goal:**\n\nThe goal is to find an assignment of numbers to the vertices that satisfies the above rules. There is no specific objective to minimize or maximize, the goal is simply to find a valid solution.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Graph Labeling Problem\n\ndescription: This problem is a variant of the graph labeling problem, where we have a graph with 8 vertices and we need to assign a unique label from 1 to 8 to each vertex such that adjacent vertices have labels that differ by at least 2.\n\nvariables: a, b, c, d, e, f, g, h \u2208 {1, ..., 8}\nThese variables represent the labels assigned to each vertex of the graph.\n\nconstraints: \na \u2260 b, a \u2260 c, ..., g \u2260 h (28 constraints)\nThese constraints ensure that each label is used exactly once, i.e., no two vertices have the same label.\n\n|a - b| \u2265 2, |a - c| \u2265 2, ..., |g - h| \u2265 2 (16 constraints)\nThese constraints ensure that adjacent vertices have labels that differ by at least 2.\n\nobjective: satisfy\nThe objective of this problem is to find a feasible assignment of labels to the vertices that satisfies all the constraints, i.e., a solution that meets the conditions of unique labeling and adjacent vertices differing by at least 2.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1806, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a2141adc-f942-4133-9ee0-29133809f49e": {"__data__": {"id_": "a2141adc-f942-4133-9ee0-29133809f49e", "embedding": null, "metadata": {"model_name": "itemset_mining"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "itemset_mining_beginner_expert", "node_type": "4", "metadata": {"model_name": "itemset_mining"}, "hash": "5eaccc604ec195f7aaa89f51242e2a8257d478ee9a337191c5fc4f6e086ad0e2", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Problem Name:** Item Selection Problem\n\n**What the problem is about:** Imagine you have a list of items (like bread, butter, cheese, etc.) and you want to choose some of them to buy. You also have some bundles of items that are often bought together (like butter, cheese, and milk). You want to choose a set of items that covers most of these bundles and also has a total price above a certain minimum.\n\n**Main variables:**\n\n* `Items`: the set of items you choose to buy\n* `TDB`: the bundles of items that are often bought together\n* `itemprice`: the price of each item\n* `minUtility`: the minimum total price you want to achieve\n\n**Basic restrictions or rules:**\n\n* You want to choose a set of items that covers at least a certain number of bundles (defined by `Freq`)\n* The total price of the chosen items should be at least `minUtility`\n\n**Goal of the problem:** Find a set of items that covers most of the bundles and has a total price above the minimum, while satisfying the rules above.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Market Basket Analysis\n\ndescription: The Market Basket Analysis problem is a classic problem in data mining and constraint programming. It involves finding a set of items that are frequently purchased together in a transactional database. The goal is to identify a set of items that covers a minimum number of transactions, with a minimum total utility or value.\n\nvariables: Items \u2208 2^{1..NrI}\n\nThe decision variable Items is a set of items, represented as a subset of the universe of items {1..NrI}. It represents the set of items that are frequently purchased together.\n\nconstraints: \ncard(cover(Items, TDB)) \u2265 Freq\n\u2211(i in Items)(itemprice[i]) \u2265 minUtility\n\nThe first constraint ensures that the set of items covers at least Freq transactions in the transactional database TDB. The cover function is a custom function that returns the set of transactions that are covered by the items.\n\nThe second constraint ensures that the total utility or value of the items in the set is at least minUtility.\n\nobjective: satisfy\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function. The goal is to find a set of items that covers a minimum number of transactions with a minimum total utility or value.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2484, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4ab0855e-03ec-4271-bc5d-6c83520be420": {"__data__": {"id_": "4ab0855e-03ec-4271-bc5d-6c83520be420", "embedding": null, "metadata": {"model_name": "jobshop"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "jobshop_beginner_expert", "node_type": "4", "metadata": {"model_name": "jobshop"}, "hash": "9fa80d97dbdb031c4c24bc1218211d224b4e73c17487a60ba6d010aa0c738e21", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Job Shop Scheduling\n\n**What the problem is about in everyday terms:** Imagine you have a workshop with multiple machines, and you need to perform a series of tasks (or jobs) on these machines. Each task has a specific duration and requires a specific machine. The goal is to schedule these tasks in a way that minimizes the total time it takes to complete all the tasks.\n\n**Main variables and what they mean:**\n\n* `n`: The number of jobs (or tasks) to be performed.\n* `m`: The number of machines in the workshop.\n* `JOB`: A set of integers representing the jobs (1 to `n`).\n* `MACH`: A set of integers representing the machines (1 to `m`).\n* `TASK`: A set of integers representing the tasks (1 to `m`).\n* `d`: An array that stores the duration of each task.\n* `mc`: An array that stores the machine required for each task.\n* `s`: An array of variables that represents the start time of each task.\n* `makespan`: A variable that represents the total time it takes to complete all the tasks.\n\n**Basic restrictions or rules of the problem:**\n\n* Each task must be performed in a specific order (e.g., task 1 must be completed before task 2).\n* Each machine can only perform one task at a time.\n* The start time of each task must be greater than or equal to the completion time of the previous task.\n\n**Goal of the problem:** The goal is to minimize the `makespan`, which is the total time it takes to complete all the tasks.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Job Shop Scheduling Problem\n\ndescription: The Job Shop Scheduling Problem is a classic problem in operations research and computer science that involves scheduling a set of jobs on a set of machines. Each job consists of a sequence of tasks, and each task requires a specific machine. The goal is to find a schedule that minimizes the total time required to complete all jobs.\n\nvariables: s[j,t] (start time of task t of job j), makespan (maximum completion time of all jobs)\n\nThe decision variables s[j,t] represent the start time of task t of job j, and makespan represents the maximum completion time of all jobs.\n\nconstraints: \ns[j,t] + d[j,t] <= s[j,t+1] (tasks in a job are performed in order), \nnonoverlap(s[j1,t1],d[j1,t1],s[j2,t2],d[j2,t2]) (only one task on any machine at one time), \ndisjunctive(ss,dd) (tasks on the same machine do not overlap)\n\nThe constraints ensure that tasks in a job are performed in order, only one task on any machine can be performed at a time, and tasks on the same machine do not overlap.\n\nobjective: minimize makespan\n\nThe objective is to minimize the maximum completion time of all jobs, which is represented by the makespan variable.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2862, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9f80b197-588b-4250-93cd-6139f70fca12": {"__data__": {"id_": "9f80b197-588b-4250-93cd-6139f70fca12", "embedding": null, "metadata": {"model_name": "K4xP2Graceful"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "K4xP2Graceful_beginner_expert", "node_type": "4", "metadata": {"model_name": "K4xP2Graceful"}, "hash": "5fc20eca015a93e799aa6adcef980bb9161841f92a8a27ce76c0030331a0f6ab", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **K4P2 Graceful Graph**\n\nThis problem is about creating a special kind of graph, which is like a network of connected points.\n\n**Main variables:**\n\n* **nodes**: These are the points in the graph, and we need to assign a number to each one.\n* **graph**: This is the connection between the points, telling us which points are connected to each other.\n* **edges**: These are the connections between the points, and we need to assign a number to each connection.\n\n**Basic restrictions or rules:**\n\n* The difference between the numbers of two connected points must be equal to the number of the connection between them.\n* All connections must have different numbers.\n* All points must have different numbers.\n\n**Goal:**\n\nThe goal is to find a way to assign numbers to the points and connections so that all the rules are satisfied.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Graceful Graph\n\ndescription: The Graceful Graph problem is a well-known problem in graph theory and constraint programming. It involves labeling the nodes of a graph with integers from 1 to m, such that the absolute difference between the labels of two adjacent nodes is equal to the edge label. The goal is to find a labeling that satisfies these conditions and makes the edge labels distinct.\n\nvariables: nodes \u2208 {0, ..., m}^n, graph \u2208 {1, ..., n}^(m \u00d7 2), edges \u2208 {1, ..., m}^m\nThe decision variables are:\n- nodes: an array of length n, where each element represents the label of a node in the graph.\n- graph: a 2D array of size m \u00d7 2, where each row represents an edge in the graph, and the two columns represent the nodes connected by the edge.\n- edges: an array of length m, where each element represents the label of an edge in the graph.\n\nconstraints: \n\u2200i \u2208 {1, ..., m} (|nodes[graph[i,1]] - nodes[graph[i,2]]| = edges[i]) \u2227 \nall_different(edges) \u2227 \nall_different(nodes)\nThe constraints are:\n- For each edge, the absolute difference between the labels of the two nodes connected by the edge is equal to the edge label.\n- All edge labels are distinct.\n- All node labels are distinct.\n\nobjective: The problem does not have an objective function to minimize or maximize. The goal is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2379, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f1501c1b-dbb5-47fb-b8c4-b62776d02787": {"__data__": {"id_": "f1501c1b-dbb5-47fb-b8c4-b62776d02787", "embedding": null, "metadata": {"model_name": "killer_sudoku"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "killer_sudoku_beginner_expert", "node_type": "4", "metadata": {"model_name": "killer_sudoku"}, "hash": "dda39e28494e4b7311b991e526501d298d9f03c1273e83d4176143b56a264899", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Killer Sudoku\n\n**What the problem is about in everyday terms:** Killer Sudoku is a puzzle game that combines elements of Sudoku and Kakuro. The goal is to fill a 9x9 grid with numbers from 1 to 9, following certain rules.\n\n**Main variables and what they mean:**\n\n* `x[i, j]`: represents the number in the cell at row `i` and column `j` of the grid.\n* `P` and `segments`: represent the \"cages\" or groups of cells that have specific sum constraints.\n* `num_p` and `num_segments`: represent the number of cages or segments in the puzzle.\n* `num_hints`: represents the maximum number of hints or cells in each cage.\n\n**Basic restrictions or rules of the problem:**\n\n* Each row, column, and 3x3 sub-grid (called a \"nonet\") must contain each number from 1 to 9 exactly once.\n* The sum of the numbers in each cage must match the given sum for that cage.\n* No number can appear more than once in a cage.\n\n**Goal of the problem:** The goal is to find a solution that satisfies all the constraints and rules, filling the entire grid with numbers from 1 to 9.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Killer Sudoku\n\ndescription: Killer Sudoku is a puzzle that combines elements of Sudoku and Kakuro. The objective is to fill a 9x9 grid with numbers from 1 to 9 such that each row, column, and nonet (3x3 sub-grid) contains each number exactly once. Additionally, the sum of all numbers in a \"cage\" (a group of cells) must match the small number printed in its corner.\n\nvariables: x[i, j] (i, j \u2208 {1, ..., 9}) - decision variables representing the value of each cell in the grid.\n\nconstraints:\n- \u2200i \u2208 {1, ..., 9} (\u2200j \u2208 {1, ..., 9} x[i, j] \u2260 x[i, k] \u2227 \u2200j \u2208 {1, ..., 9} x[j, i] \u2260 x[k, i]) - each row and column contains each number exactly once\n- \u2200i, j \u2208 {0, ..., 2} (\u2200r, c \u2208 {i*3+1, ..., i*3+3} \u00d7 {j*3+1, ..., j*3+3} x[r, c] \u2260 x[r', c'] for r \u2260 r' or c \u2260 c') - each nonet contains each number exactly once\n- \u2200p \u2208 {1, ..., num_segments} (\u2211(i, j) \u2208 {1, ..., n} \u00d7 {1, ..., n} where segments[i, j] = p x[i, j] = segment_sums[p]) - the sum of all numbers in a cage must match the small number printed in its corner\n\nobjective: satisfy - the objective is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2425, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4031cb6b-f2fd-4d2d-a074-9f9b1fb8a879": {"__data__": {"id_": "4031cb6b-f2fd-4d2d-a074-9f9b1fb8a879", "embedding": null, "metadata": {"model_name": "knapsack"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "knapsack_beginner_expert", "node_type": "4", "metadata": {"model_name": "knapsack"}, "hash": "28cdd4b4a824f2fedb57c40b3ff83eaf09ed0e38c82beb9b13dac5ea4644b4d6", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Knapsack Problem**\n\nThis problem is about packing objects of different sizes and values into a bag with a limited capacity. Imagine you're going on a trip and you have a small bag that can only hold so much weight. You have several items you want to bring, each with a different weight and importance to you. You want to pack the most important items that fit in the bag without exceeding its weight limit.\n\n**Main variables:**\n\n* `n`: the number of objects\n* `capacity`: the maximum weight the bag can hold\n* `profit` (or `value`): how important each object is to you\n* `size`: how much each object weighs\n* `x`: which objects to pack in the bag (how many of each object to take)\n\n**Basic restrictions or rules:**\n\n* You can't pack more objects than you have.\n* The total weight of the packed objects can't exceed the bag's capacity.\n* You can't pack a fraction of an object (you either take it or leave it).\n\n**Goal:**\n\nThe goal is to pack the objects that give you the most importance (or value) while staying within the bag's weight limit.\n                    ======\n                    Description 2:\n                    ---------\n                    name: 0/1 Knapsack Problem\n\ndescription: The 0/1 Knapsack Problem is a classic problem in combinatorial optimization. Given a set of objects, each with a weight and a value, determine the subset of objects to include in a knapsack of limited capacity to maximize the total value while not exceeding the knapsack's capacity.\n\nvariables: x (x[i] for i in OBJ or x[i] for i in 1..n)\n\nThe decision variables x represent the number of each object to include in the knapsack. In some models, x is a binary variable (0 or 1) indicating whether to include the object or not, while in others, x is an integer variable representing the quantity of each object to include.\n\nconstraints: x[i] >= 0, sum(i in OBJ)(size[i] * x[i]) <= capacity\n\nThe constraints ensure that the number of each object included is non-negative and that the total weight of the selected objects does not exceed the knapsack's capacity.\n\nobjective: maximize sum(i in OBJ)(profit[i] * x[i])\n\nThe objective is to maximize the total value of the objects included in the knapsack.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2280, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "919a8845-f00f-413f-b82d-bb122f665cc2": {"__data__": {"id_": "919a8845-f00f-413f-b82d-bb122f665cc2", "embedding": null, "metadata": {"model_name": "langford"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "langford_beginner_expert", "node_type": "4", "metadata": {"model_name": "langford"}, "hash": "f479eb6563e072ce8a1e2508549e7d2f9c5280885072bd937fdfd45885676b1b", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Langford's Problem\n\n**What the problem is about in everyday terms:** Imagine you have a set of numbers from 1 to n, and you want to arrange them in a sequence in a special way. Each number should appear m times in the sequence. The rule is that if a number k appears, the next time it appears, it should be k+1 positions later in the sequence.\n\n**Main variables and what they mean:**\n\n* n: the highest number in the set (e.g., if n=4, the set is {1, 2, 3, 4})\n* m: how many times each number should appear in the sequence\n* x (or y): the sequence of numbers, where each number is a position in the sequence\n\n**Basic restrictions or rules of the problem:**\n\n* Each number from 1 to n should appear m times in the sequence.\n* If a number k appears, the next time it appears, it should be k+1 positions later in the sequence.\n\n**Goal of the problem:** The goal is to find a sequence that satisfies the rules above.\n\nNote that the different models are just different ways of representing the same problem, and the explanation above applies to all of them.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Langford's Problem\n\ndescription: Langford's problem is a classic constraint satisfaction problem that involves arranging m copies of digits 1 to n in a sequence such that any two consecutive copies of digit k are separated by k other digits.\n\nvariables: x[d,c], y[p] \nx[d,c] represents the position of the c-th copy of digit d in the sequence, and y[p] represents the digit at position p in the sequence. \n\nconstraints: \nalldifferent([x[d,c] | d in DIG, c in COPY]), \ninverse([x[d,c] | d in DIG, c in COPY], y), \nforall(d in DIG, c in 1..m-1) (x[d,c+1] = x[d,c] + d + 1), \nalldifferent(y), \nforall(d in DIG, c in 1..m-1, p in POS) (y[p] = m*(d-1) + c <-> y[p+d+1] = m*(d-1) + c + 1)\n\nThe first constraint ensures that all positions in the sequence are distinct. The second constraint links the x and y variables. The third constraint ensures that the Langford's condition is satisfied, i.e., any two consecutive copies of digit k are separated by k other digits. The fourth constraint ensures that all digits in the sequence are distinct. The fifth constraint is an alternative way to ensure the Langford's condition.\n\nobjective: satisfy\nThe objective of the problem is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2552, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a0f71dd3-2577-4c74-afd4-f2a41c55bbe0": {"__data__": {"id_": "a0f71dd3-2577-4c74-afd4-f2a41c55bbe0", "embedding": null, "metadata": {"model_name": "loan"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "loan_beginner_expert", "node_type": "4", "metadata": {"model_name": "loan"}, "hash": "34497803228b633e1b338b7cab13ceb19418216fc339a18b4e0e00890ff951c5", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Loan Repayment Problem\n\nThis problem is about borrowing money and paying it back with interest over a year.\n\nThe main variables are:\n- R: the amount of money you pay back each quarter (like a monthly payment, but every 3 months)\n- P: the amount of money you borrow initially\n- I: the interest rate, which is like a fee for borrowing money\n- B1, B2, B3, B4: these are like snapshots of how much you still owe after each quarter\n\nThe basic rules are:\n- You borrow some money (P) and promise to pay it back with some extra (I) as interest.\n- Each quarter, you pay back some money (R), and the amount you still owe changes based on the interest rate.\n\nThe goal of the problem is to find a way to pay back the loan over a year, with the given interest rate, and see how much you still owe at the end.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Loan Repayment Problem\n\ndescription: This problem models a loan repayment scenario where a borrower takes a loan with a certain principal amount and interest rate, and repays the loan in quarterly installments over a year. The problem calculates the balance owing at the end of the year.\n\nvariables: R, P, I, B1, B2, B3, B4\nR is the quarterly repayment amount, P is the principal amount borrowed, I is the interest rate, and B1, B2, B3, B4 are the balances owing after each quarter.\n\nconstraints: B1 = P * (1.0 + I) - R, B2 = B1 * (1.0 + I) - R, B3 = B2 * (1.0 + I) - R, B4 = B3 * (1.0 + I) - R\nThese constraints model the balance update after each quarter, where the new balance is the previous balance plus the interest accrued minus the repayment amount.\n\nobjective: satisfy\nThe objective of this problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1925, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "441f92ef-4998-4014-a630-2276a79f8eab": {"__data__": {"id_": "441f92ef-4998-4014-a630-2276a79f8eab", "embedding": null, "metadata": {"model_name": "ltsp"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ltsp_beginner_expert", "node_type": "4", "metadata": {"model_name": "ltsp"}, "hash": "9b571610c3b12d83f21792ea47d2caf817b1cfad4a79e8fb6fcc5de003bc51a1", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Traveling Salesman Problem**\n\nThis problem is about planning a route for a salesman who needs to visit a certain number of cities and return to the starting point.\n\n**Main variables:**\n\n* `n`: the number of cities\n* `coord`: the coordinates of each city (think of it like the address of each city)\n* `order`: the order in which the salesman visits each city\n* `city`: the city at each position in the order\n\n**Basic restrictions or rules:**\n\n* The salesman must visit each city exactly once\n* The salesman must follow the precedences (rules) that specify which city must be visited before another city\n* The salesman must return to the starting point at the end of the route\n\n**Goal:**\n\nThe goal is to find the shortest possible route that visits all cities and returns to the starting point, while following the precedences and rules. In other words, we want to minimize the total distance traveled by the salesman.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Traveling Salesman Problem with Precedences\n\ndescription: The Traveling Salesman Problem with Precedences is a variant of the classic Traveling Salesman Problem. It involves finding the shortest possible tour that visits a set of cities and returns to the starting city, with the additional constraint that certain cities must be visited in a specific order.\n\nvariables: order \u2208 {1, ..., n}^n, city \u2208 {1, ..., n}^n\nThe decision variables are two arrays, order and city, which represent the order in which the cities are visited. The order array maps each city to its position in the tour, and the city array maps each position in the tour to the corresponding city.\n\nconstraints: \n\u2200i \u2208 PREC, order[left[i]] < order[right[i]]\ninverse(order, city)\nThe constraints ensure that the precedences are respected, i.e., if city A must be visited before city B, then the position of city A in the tour must be less than the position of city B. The inverse constraint ensures that the order and city arrays are inverses of each other, i.e., the position of a city in the tour is equal to the city at that position.\n\nobjective: minimize \u2211(i=1 to n-1) |coord[city[i]] - coord[city[i+1]]|\nThe objective is to minimize the total distance traveled, which is calculated as the sum of the distances between consecutive cities in the tour.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2440, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9bcaca8d-87ad-4e82-83c9-3519d6186f7d": {"__data__": {"id_": "9bcaca8d-87ad-4e82-83c9-3519d6186f7d", "embedding": null, "metadata": {"model_name": "magic_hexagon"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_hexagon_beginner_expert", "node_type": "4", "metadata": {"model_name": "magic_hexagon"}, "hash": "95c0421c9eaee6fa6fc1054a0e33ccdfd01ecd2291d48f926d244b54ca1797d6", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Magic Hexagon\n\nThis problem is about creating a special kind of hexagon (a six-sided shape) with numbers inside it. Imagine a hexagon divided into smaller triangles, and each triangle has a number in it.\n\nThe main variables are the numbers that go inside the triangles. There are 19 numbers in total, and they are represented by letters like a, b, c, and so on.\n\nThe basic rules of the problem are:\n\n* Each triangle must have a different number in it.\n* The numbers in each row of triangles must add up to 38.\n* The numbers in each column of triangles must also add up to 38.\n* Some specific triangles have to have smaller numbers than others.\n\nThe goal of the problem is to find a way to arrange the numbers in the triangles so that all the rules are followed.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Magic Hexagon Problem\n\ndescription: The Magic Hexagon Problem is a classic constraint satisfaction problem where the goal is to find a configuration of numbers in a hexagonal shape such that the sums of numbers along each line and diagonal are equal to a certain value.\n\nvariables: a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s \u2208 {1, ..., 19}\n\nThese variables represent the numbers to be placed in the hexagonal shape.\n\nconstraints: \nall_different(LD) \u2227 \na + b + c = 38 \u2227 \nd + e + f + g = 38 \u2227 \nh + i + j + k + l = 38 \u2227 \nm + n + o + p = 38 \u2227 \nq + r + s = 38 \u2227 \na + d + h = 38 \u2227 \nb + e + i + m = 38 \u2227 \nc + f + j + n + q = 38 \u2227 \ng + k + o + r = 38 \u2227 \nl + p + s = 38 \u2227 \nc + g + l = 38 \u2227 \nb + f + k + p = 38 \u2227 \na + e + j + o + s = 38 \u2227 \nd + i + n + r = 38 \u2227 \nh + m + q = 38 \u2227 \na < c \u2227 \na < h \u2227 \na < l \u2227 \na < q \u2227 \na < s \u2227 \nc < h\n\nThese constraints ensure that all numbers are distinct, the sums of numbers along each line and diagonal are equal to 38, and some additional ordering constraints to break symmetry.\n\nobjective: satisfy\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2150, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2d6c539e-bed2-4de0-b4b0-c3c49e80c89f": {"__data__": {"id_": "2d6c539e-bed2-4de0-b4b0-c3c49e80c89f", "embedding": null, "metadata": {"model_name": "magic_sequence"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_sequence_beginner_expert", "node_type": "4", "metadata": {"model_name": "magic_sequence"}, "hash": "951abaaceffc1670ce6bc7e8f02e2522b76ac7f546d19417079ec091651f90b9", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Magic Sequence and Magic Square\n\n**What the problem is about in everyday terms:** This problem is about finding a special kind of sequence or arrangement of numbers that has certain properties. In the case of the magic sequence, it's a sequence of numbers where each number appears a certain number of times, and that number is equal to the value of the number itself. For example, if the sequence has a 6, it means the number 6 appears 6 times in the sequence. In the case of the magic square, it's an arrangement of numbers in a square grid where each row, column, and diagonal adds up to the same total.\n\n**Main variables and what they mean:**\n\n* `s` or `magic`: an array of variables that represent the magic sequence or square.\n* `n`: the length of the sequence or the size of the square.\n* `total`: the total sum of the numbers in the magic square.\n\n**Basic restrictions or rules of the problem:**\n\n* In the magic sequence, each number appears a certain number of times, and that number is equal to the value of the number itself.\n* In the magic square, each row, column, and diagonal adds up to the same total.\n* Each cell in the magic square can only contain one number.\n\n**Goal of the problem:**\n\n* Find a magic sequence or square that satisfies the rules and restrictions.\n* In some cases, the goal is to find all possible solutions or to count the number of solutions.\n                    ======\n                    Description 2:\n                    ---------\n                    **Model 1, 2, 3, and 4: Magic Sequence**\n\nname: Magic Sequence\n\ndescription: A magic sequence of length n is a sequence of integers x0, ..., xn-1 between 0 and n-1, such that for all i in 0 to n-1, the number i occurs exactly xi times in the sequence.\n\nvariables: s (array of var 0..n-1)\n\nThe decision variable s is an array of length n, where each element si represents the number of times the integer i appears in the sequence.\n\nconstraints: \nforall(i in 0..n-1) (s[i] = sum(j in 0..n-1) (bool2int(s[j] = i)))\nsum(i in 0..n-1) (s[i]) = n\nsum(i in 0..n-1) (s[i]*i) = n\ndistribute(s, value, s)\nglobal_cardinality(s, array1d(0..n-1, set2array(index_set(s))), s)\n\nThe constraints ensure that each number i in the sequence appears exactly si times, the sum of all si is equal to n, and the sum of all si*i is equal to n. The distribute and global_cardinality constraints are used to model the magic sequence property.\n\nobjective: satisfy\n\nThe objective is to find a feasible solution that satisfies all the constraints.\n\n**Model 5: Magic Square**\n\nname: Magic Square\n\ndescription: A magic square of order n is an arrangement of n^2 numbers, usually distinct integers, in a square, such that n numbers in all rows, all columns, and both diagonals sum to the same constant.\n\nvariables: magic (array of var 1..n*n), total (int)\n\nThe decision variable magic is a 2D array of size n x n, where each element magic[i,j] represents the integer in the cell (i,j) of the magic square. The variable total is the magic sum.\n\nconstraints: \nall_different([magic[i,j] | i in 1..n, j in 1..n])\nforall(k in 1..n) (sum(i in 1..n) (magic[k,i]) = total)\nforall(k in 1..n) (sum(i in 1..n) (magic[i,k]) = total)\nsum(i in 1..n) (magic[i,i]) = total\nsum(i in 1..n) (magic[i,n-i+1]) = total\n\nThe constraints ensure that all numbers in the magic square are distinct, the sum of each row, column, and diagonal is equal to the magic sum total.\n\nobjective: satisfy\n\nThe objective is to find a feasible solution that satisfies all the constraints.\n\n**Model 6: Magic Square (Integer Programming Version)**\n\nname: Magic Square (Integer Programming Version)\n\ndescription: A magic square of order n is an arrangement of n^2 numbers, usually distinct integers, in a square, such that n numbers in all rows, all columns, and both diagonals sum to the same constant.\n\nvariables: x (array of var 0..1), square (array of var 1..n*n), s (int)\n\nThe decision variable x is a 3D array of size n x n x n, where x[i,j,k] = 1 if the cell (i,j) contains the integer k. The variable square is a 2D array of size n x n, where square[i,j] represents the integer in the cell (i,j) of the magic square. The variable s is the magic sum.\n\nconstraints: \ns >= 0 /\\ s <= n*n*n\nforall(i in 1..n, j in 1..n) (sum(k in N) (x[i,j,k]) = 1)\nforall(k in N) (sum(i in 1..n, j in 1..n) (x[i,j,k]) = 1)\nforall(i in 1..n) (sum(j in 1..n, k in N) (k * x[i,j,k]) = s)\nforall(j in 1..n) (sum(i in 1..n, k in N) (k * x[i,j,k]) = s)\nsum(i in 1..n, k in N) (k * x[i,i,k]) = s\nsum(i in 1..n, k in N) (k * x[i,n-i+1,k]) = s\nforall(i,j in 1..n) (square[i,j] = sum(k in N) (k * x[i,j,k]))\n\nThe constraints ensure that each cell contains exactly one integer, each integer is assigned to exactly one cell, the sum of each row, column, and diagonal is equal to the magic sum s, and the magic square is correctly constructed.\n\nobjective: satisfy\n\nThe objective is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 5083, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5c9b6aaf-6639-4a08-9512-a17bc3b672c6": {"__data__": {"id_": "5c9b6aaf-6639-4a08-9512-a17bc3b672c6", "embedding": null, "metadata": {"model_name": "maximum_density_still_life"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "maximum_density_still_life_beginner_expert", "node_type": "4", "metadata": {"model_name": "maximum_density_still_life"}, "hash": "b68464aa157cacd706eec81af677a0a0b2299ac9150eac5411e6674ef8d3a1ac", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Problem Name:** Maximum Density Still Life\n\n**What the problem is about:** Imagine you have a grid of cells that can be either alive (represented by 1) or dead (represented by 0). The goal is to find a pattern of alive and dead cells that follows certain rules and has the maximum number of alive cells.\n\n**Main variables:**\n\n* `grid`: a 2D array that represents the grid of cells, where each cell can be either alive (1) or dead (0).\n* `z`: the total number of alive cells in the grid.\n\n**Basic restrictions or rules:**\n\n* Cells in the outermost rows and columns of the grid must be dead.\n* A cell becomes alive if it has exactly three alive neighbors.\n* An alive cell must have either two or three alive neighbors to stay alive.\n* The pattern of alive and dead cells must be symmetrical in certain ways.\n\n**Goal:** The goal is to maximize the number of alive cells (`z`) in the grid while following the rules above.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Maximum Density Still Life\n\ndescription: The Maximum Density Still Life problem is a classic problem in constraint programming, which involves finding a stable pattern of live and dead cells in a grid, such that the density of live cells is maximized. The problem is inspired by Conway's Game of Life, where live cells follow certain rules to survive or die in each generation. In this problem, the goal is to find a pattern that is stable, meaning it does not change over time, and has the maximum number of live cells.\n\nvariables: `grid[r,c]` for `r, c in augmentedBoardCoord`\n\nThe decision variables are the elements of the `grid` array, which represent the state of each cell in the grid. The value of `grid[r,c]` is 0 if the cell at row `r` and column `c` is dead, and 1 if it is live.\n\nconstraints: \n`grid[0,x] = 0 /\\ grid[1,x] = 0 /\\ grid[size+2,x] = 0 /\\ grid[size+3,x] = 0 /\\ grid[x,0] == 0 /\\ grid[x,1] == 0 /\\ grid[x,size+2] = 0 /\\ grid[x,size+3] = 0` for `x in augmentedBoardCoord`\n`((grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] + grid[r,c-1] + grid[r,c+1] + grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] ) = 3) -> (grid[r,c] = 1)` for `r, c in checkConstraintsBoardCoord`\n`(grid[r,c] = 1) -> (2 <= (grid[r-1,c-1] + grid[r-1,c] + grid[r-1,c+1] + grid[r,c-1] + grid[r,c+1] + grid[r+1,c-1] + grid[r+1,c] + grid[r+1,c+1] ) <= 3)` for `r, c in checkConstraintsBoardCoord`\n`grid[2,2] >= grid[size+1,size+1] /\\ grid[2,size+1] >= grid[size+1,2]`\n\nThe constraints ensure that the pattern is stable and follows the rules of Conway's Game of Life. The first constraint sets the boundary cells to be dead. The second constraint ensures that each cell with exactly three live neighbors is alive. The third constraint ensures that each live cell has two or three live neighbors. The last constraint is a symmetry-breaking constraint, which forces the assignment to respect an ordering on the values that occur in corner entries of the board.\n\nobjective: Maximize `z = sum(r in objFunctionBoardCoord, c in objFunctionBoardCoord) (grid[r,c])`\n\nThe objective is to maximize the number of live cells in the grid, which is represented by the variable `z`.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 3268, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bdd3450b-722b-4d06-876d-6e354c285337": {"__data__": {"id_": "bdd3450b-722b-4d06-876d-6e354c285337", "embedding": null, "metadata": {"model_name": "mip"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "mip_beginner_expert", "node_type": "4", "metadata": {"model_name": "mip"}, "hash": "33046256a0a76ade480daa897c738b9f45a136d39c6c58adc37b5c554a5f1ca6", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Problem Name:** Resource Allocation Problem\n\n**What the problem is about in everyday terms:** Imagine you have three types of resources (let's call them B, C, and D) and you want to allocate them in the best way possible to maximize your profit or benefit. You have some limitations on how much of each resource you can use, and you want to find the optimal combination that gives you the highest return.\n\n**Main variables and what they mean:**\n\n* B, C, and D: These are the three types of resources you have. They can be thought of as quantities of something (e.g., money, materials, labor).\n* x and y: In some models, these are used instead of B and C, but they represent the same idea - quantities of resources.\n\n**Basic restrictions or rules of the problem:**\n\n* You can't use more resources than you have available (represented by the \"less than or equal to\" constraints).\n* You can't use a negative amount of resources (represented by the \"greater than or equal to 0\" constraints).\n\n**Goal of the problem:**\n\n* Maximize the total benefit or profit you get from allocating the resources. This is represented by the \"maximize\" objective function, which combines the resources in a specific way to give you a total value.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Linear Programming Problem\n\ndescription: This is a classic Linear Programming Problem, which involves finding the optimal values of decision variables to maximize or minimize a linear objective function, subject to a set of linear constraints.\n\nvariables: x, y, B, C, D\nThese variables represent the quantities of different items or resources that need to be optimized. In the context of Linear Programming, they are often referred to as decision variables.\n\nconstraints: \n2.0*B + 2.0*C + 1.0*D <= 30.0, \n1.0*B + 2.0*C + 3.0*D <= 25.0, \n2.0*B + 1.0*C + 1.0*D <= 20.0, \n7*x + 4*y <= 13, \nx + y <= 6, \n9*x + 5*y <= 45, \n2.0*B - 1.0*C + 2.0*D <= 4.0, \n2.0*B - 3.0*C + 1.0*D <= -5.0, \n-1.0*B + 1.0*C - 2.0*D <= -1.0, \nB >= 0, C >= 0, D >= 0, x >= 0, y >= 0\nThese constraints represent the limitations and restrictions on the values of the decision variables. They can be interpreted as resource constraints, capacity constraints, or other types of limitations that need to be satisfied.\n\nobjective: Maximize 3.0*B + 1.0*C + 3.0*D, Maximize 1.0*B - 1.0*C + 1.0*D, Maximize 21*x + 11*y, Maximize 8*x + 5*y\nThe objective of the problem is to maximize the given linear function, which represents the profit, revenue, or other performance metric that needs to be optimized.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2692, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1cc311cd-0939-49d7-9810-ef181b1b85d1": {"__data__": {"id_": "1cc311cd-0939-49d7-9810-ef181b1b85d1", "embedding": null, "metadata": {"model_name": "missing_solution"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "missing_solution_beginner_expert", "node_type": "4", "metadata": {"model_name": "missing_solution"}, "hash": "d54385633b11889fdbeb41dd749ab459fe43f6d64a0625aa9d07f4a7a641be27", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Seating Arrangement Problem**\n\nThis problem is about arranging people in a line, like in a queue or at a table, in a specific order.\n\n**Main Variables:**\n\n* `n`: The number of people.\n* `gender`: An array that stores the gender of each person (male or female).\n* `age`: An array that stores the age of each person.\n* `order`: An array that stores the order in which the people should be arranged.\n\n**Basic Restrictions or Rules:**\n\n* The people should be arranged in a line, one after the other.\n* Males and females should alternate in the line (i.e., a male should be followed by a female, and vice versa).\n* The age difference between two people sitting next to each other should not be more than 10 years.\n\n**Goal:**\n\nThe goal is to find an arrangement of people that satisfies all the above rules. There is no specific goal to minimize or maximize anything; we just want to find a valid arrangement.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Alternating Marriage Problem\n\ndescription: This problem involves arranging a sequence of people of different genders and ages in a specific order, subject to certain constraints. The goal is to find an ordering that satisfies the conditions.\n\nvariables: order \u2208 {1, ..., n}^n\nThe decision variable is an array `order` of length `n`, where each element `order[i]` represents the person at position `i` in the sequence.\n\nconstraints: \nalldifferent(order)\n\u2200i \u2208 {1, ..., n} : (i mod 2 = 0 \u2194 gender[order[i]] = female)\n\u2200i \u2208 {1, ..., n-1} : age[order[i+1]] - age[order[i]] \u2264 10\n\nThe constraints are:\n- `alldifferent(order)`: Each person must appear exactly once in the sequence.\n- `\u2200i \u2208 {1, ..., n} : (i mod 2 = 0 \u2194 gender[order[i]] = female)`: Males and females must alternate in the sequence.\n- `\u2200i \u2208 {1, ..., n-1} : age[order[i+1]] - age[order[i]] \u2264 10`: The age difference between consecutive people in the sequence must not exceed 10.\n\nobjective: satisfy\nThe objective is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific value.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2182, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "17562cb6-b29c-4d38-9656-fed7bcd463e5": {"__data__": {"id_": "17562cb6-b29c-4d38-9656-fed7bcd463e5", "embedding": null, "metadata": {"model_name": "nonogram_create_automaton2"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "nonogram_create_automaton2_beginner_expert", "node_type": "4", "metadata": {"model_name": "nonogram_create_automaton2"}, "hash": "73421059c9e0b0dce4b451c6c016701664e860e88c23c052ce598582c54a4a08", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Nonogram Problem**\n\n**What is it about?**\nThe Nonogram problem is about creating a picture using a set of rules. Imagine you have a grid of squares, and you need to fill some of them with colors (let's say black and white) to create a specific image. The rules tell you how many consecutive squares of each color should be in each row and column.\n\n**Main variables:**\n\n* `x` or `A`: a 2D array that represents the grid of squares, where each square can be either 1 (white) or 2 (black).\n* `rows` and `cols`: 2D arrays that contain the rules for each row and column, respectively.\n* `row_rules` and `col_rules`: 2D arrays that contain the specific rules for each row and column.\n\n**Basic restrictions or rules:**\n\n* Each row and column must follow the rules specified in `rows` and `cols`, respectively.\n* The rules specify how many consecutive squares of each color should be in each row and column.\n\n**Goal:**\nThe goal is to find a valid configuration of the grid that satisfies all the rules, creating a specific image.\n\nIn simpler terms, the problem is about solving a puzzle where you need to fill a grid with black and white squares according to some rules, and the goal is to create a specific picture.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Nonogram\n\ndescription: A Nonogram is a puzzle where a set of clues are given to fill in a grid with two colors (usually black and white). The clues are given in the form of row and column constraints, specifying the sequence of colors in each row and column. The goal is to fill in the grid such that the clues are satisfied.\n\nvariables: A[i, j] for i in 1..Y, j in 1..X, where A[i, j] \u2208 {1, 2}\n\nThe variables A[i, j] represent the color of the cell at row i and column j in the grid, where 1 and 2 correspond to the two colors.\n\nconstraints: \n\u2200i in 1..Y, nonogram_row(A, [rows[i, j] | j in 1..maxlen where rows[i, j] >= 0], i)\n\u2200i in 1..X, nonogram_col(A, [cols[i, j] | j in 1..maxlen where cols[i, j] >= 0], i)\n\nThe constraints ensure that the row and column constraints are satisfied. The nonogram_row and nonogram_col predicates enforce the regular expression constraints for each row and column, respectively.\n\nobjective: The objective is to find a feasible solution that satisfies all the constraints, i.e., to fill in the grid such that all row and column constraints are met. There is no objective function to minimize or maximize.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2550, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6c0f0626-9c1f-46f1-a260-90ca703d6834": {"__data__": {"id_": "6c0f0626-9c1f-46f1-a260-90ca703d6834", "embedding": null, "metadata": {"model_name": "nurses"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "nurses_beginner_expert", "node_type": "4", "metadata": {"model_name": "nurses"}, "hash": "e823638328b70c3cf9ad43df99fad51aeeda23d4f3a71a881f15b71f14aeddc5", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Nurse Scheduling Problem.\n\nThis problem is about creating a schedule for nurses to work at a hospital. Imagine you are the manager of a hospital and you need to create a schedule for your nurses to work over a certain number of days.\n\nThe main variables are:\n\n* Nurses (represented by numbers 1 to k): These are the people who will be working at the hospital.\n* Days (represented by numbers 1 to m): These are the days of the week/month that the nurses will be working.\n* Shifts (represented by numbers 1 to 3): These are the different types of shifts that the nurses can work, such as day shift, night shift, or a day off.\n\nThe basic restrictions or rules of the problem are:\n\n* If a nurse works a night shift two days in a row, they must have a day off on the third day.\n* If a nurse works a night shift, they cannot work a day shift the next day.\n* There must be a certain number of nurses working the night shift each day (between a lower and upper bound).\n\nThe goal of the problem is to create a schedule that satisfies all these rules and restrictions.\n\nNote that the two models are essentially the same, with the second model being a slightly different implementation of the same problem.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Nurse Scheduling Problem\n\ndescription: The Nurse Scheduling Problem is a classic constraint satisfaction problem that involves creating a schedule for a set of nurses over a set of days, where each nurse can be assigned to one of three shifts: day, night, or day off. The problem aims to find a schedule that satisfies certain constraints, such as ensuring that a nurse who works two consecutive night shifts gets a day off on the third day, and that the number of nurses working night shifts on each day is within a certain range.\n\nvariables: x[n,d] \u2208 {1, 2, 3} \u2200n \u2208 NURSE, \u2200d \u2208 DAY\nThe decision variables x[n,d] represent the shift assigned to nurse n on day d, where 1 corresponds to a day shift, 2 corresponds to a night shift, and 3 corresponds to a day off.\n\nconstraints: \n1. \u2200n \u2208 NURSE, \u2200d \u2208 1..m-2: (x[n,d] = 2 \u2227 x[n,d+1] = 2) \u2192 x[n,d+2] = 3\nThis constraint ensures that if a nurse works two consecutive night shifts, they get a day off on the third day.\n\n2. \u2200n \u2208 NURSE, \u2200d \u2208 1..m-1: x[n,d] = 2 \u2192 x[n,d+1] \u2260 1\nThis constraint ensures that a nurse who works a night shift on one day does not work a day shift on the next day.\n\n3. \u2200d \u2208 DAY: l \u2264 \u2211(n \u2208 NURSE) (bool2int(x[n,d] = 2)) \u2264 u\nThis constraint ensures that the number of nurses working night shifts on each day is within the range [l, u].\n\nobjective: satisfy\nThe objective of the problem is to find a schedule that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2859, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bf60802e-6c34-405f-8415-fbff0aac98c6": {"__data__": {"id_": "bf60802e-6c34-405f-8415-fbff0aac98c6", "embedding": null, "metadata": {"model_name": "opd"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "opd_beginner_expert", "node_type": "4", "metadata": {"model_name": "opd"}, "hash": "18af0f7d109beaf1e25b3afd5f45cd3b8aeb5b7dbb76a23e04df7cf4406522cd", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Design of Collateralised Debt Obligations Squared (CDO^2) Transactions\n\n**What the problem is about in everyday terms:** Imagine you have a set of boxes (v) and each box can hold a certain number of items (r). You want to put items into the boxes in a way that each box has exactly r items, and the items in each box are distributed in a way that is as different as possible from the items in every other box.\n\n**Main variables and what they mean:**\n\n* v: the number of boxes\n* b: the maximum number of items that can be put into each box\n* r: the exact number of items that each box should have\n* m: a matrix that shows which items are in each box (0 means the item is not in the box, 1 means it is)\n* objective (also called lambda): a measure of how different the items in each box are from the items in every other box\n\n**Basic restrictions or rules of the problem:**\n\n* Each box must have exactly r items\n* The items in each box should be distributed in a way that is as different as possible from the items in every other box\n\n**Goal of the problem:** Find a way to put items into the boxes that minimizes the objective (lambda), which means making the items in each box as different as possible from the items in every other box.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Orthogonal Pairs of Designs (OPD) problem\n\ndescription: The OPD problem is a classical problem in combinatorial design theory, which involves finding a binary matrix of v rows and b columns such that each row sums to r, and the dot product between any pair of distinct rows is minimal. This problem has applications in the design of Collateralised Debt Obligations Squared (CDO^2) transactions.\n\nvariables: m[i, j] (i in rows, j in cols), objective\n\nThe decision variables are the elements of the binary matrix m, where m[i, j] represents the value of the element at row i and column j. The variable objective represents the minimum dot product between any pair of distinct rows.\n\nconstraints: \nsum (j in cols) (m[i, j]) = r (forall i in rows), \nsum (j in cols) (m[i_a, j] * m[i_b, j]) <= objective (forall i_a, i_b in rows where i_a < i_b), \nlex_greatereq([m[i, j] | j in cols], [m[i+1, j] | j in cols]) (forall i in rows diff {max(rows)}), \nlex_greatereq([m[i, j] | i in rows], [m[i, j+1] | i in rows]) (forall j in cols diff {max(cols)})\n\nThe constraints ensure that each row sums to r, the dot product between any pair of distinct rows is at most lambda, and the row and column symmetries are broken.\n\nobjective: minimize objective", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2738, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "08844db2-f742-4667-a653-dde01e76e51a": {"__data__": {"id_": "08844db2-f742-4667-a653-dde01e76e51a", "embedding": null, "metadata": {"model_name": "partition"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "partition_beginner_expert", "node_type": "4", "metadata": {"model_name": "partition"}, "hash": "b0cdeab64f59055d23ddcda0e6612d7f9d6ab3554140df36bb9c6ce3172b5bd2", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Partition Problem**\n\nThis problem is about dividing a set of numbers into two groups, so that the sum of the numbers in each group is equal, and the sum of the squares of the numbers in each group is also equal.\n\n**Main Variables:**\n\n* `x` and `y` are the two groups of numbers.\n* `n` is the number of numbers in each group.\n\n**Basic Restrictions:**\n\n* Each group must have the same number of numbers (`n`).\n* The numbers in each group must be different from each other.\n* The sum of the numbers in each group must be equal.\n* The sum of the squares of the numbers in each group must be equal.\n\n**Goal:**\n\nThe goal is to find two groups of numbers that satisfy all the restrictions above.\n\nIn simpler terms, imagine you have a set of numbers, and you want to divide them into two groups, so that the total value of each group is the same, and the total value of the squares of each group is also the same.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Partition Problem\n\ndescription: The Partition Problem is a classic problem in constraint programming that involves dividing a set of 2n numbers into two disjoint subsets, each of size n, such that the sum of the numbers in each subset is equal, and the sum of the squares of the numbers in each subset is also equal.\n\nvariables: x, y (arrays of var 1..2n), sx, sy (arrays of var 1..4n^2)\n\nx and y are arrays of decision variables representing the two subsets of numbers. sx and sy are auxiliary variables used to calculate the sum of squares of the numbers in each subset.\n\nconstraints: \nx[i-1] < x[i], y[i-1] < y[i] (ordering constraints)\nx[1] < y[1] (symmetry breaking constraint)\nalldifferent(x++y) (partitioning constraint)\nsum(x) = 2n(2n+1) div 4, sum(y) = 2n(2n+1) div 4 (sum equality constraints)\nsx[i] = x[i]*x[i], sy[i] = y[i]*y[i] (definition of sum of squares)\nsum(sx) = 2n(2n+1)(4n+1) div 12, sum(sy) = 2n(2n+1)(4n+1) div 12 (sum of squares equality constraints)\n\nThe constraints ensure that the two subsets are disjoint, have the same sum, and the same sum of squares. The ordering constraints and symmetry breaking constraint are used to reduce the search space.\n\nobjective: satisfy (there is no objective function to minimize or maximize, the goal is to find a feasible solution)", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2403, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f87ba9d8-bd1f-4208-bc54-9eeba153bfe4": {"__data__": {"id_": "f87ba9d8-bd1f-4208-bc54-9eeba153bfe4", "embedding": null, "metadata": {"model_name": "photo"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "photo_beginner_expert", "node_type": "4", "metadata": {"model_name": "photo"}, "hash": "a96aebdc7a5e7b72e5891ce31c299b16d3ce5317c1be163d58c5cca5479122c2", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Social Golfers Problem.\n\nThis problem is about organizing a group of people to play golf together in a way that makes everyone happy. Imagine you have a group of friends who want to play golf together, and you want to arrange them into pairs to play together.\n\nThe main variables are:\n\n* PERSON: This represents each individual person in the group.\n* POS: This represents the position or pair that each person will play in.\n* friend: This is a table that shows how much each person likes to play with each other person.\n* x and y: These are variables that will be used to decide who plays with whom.\n\nThe basic restrictions or rules of the problem are:\n\n* Each person must play with someone.\n* No two people can play in the same position (pair).\n* The goal is to make sure that people play with their friends as much as possible.\n\nThe goal of the problem is to maximize the total happiness of all the golfers, which is measured by how much they like to play with the person they are paired with.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Social Golfer Problem\n\ndescription: The Social Golfer Problem is a classic constraint satisfaction problem that involves scheduling golfers into groups of a fixed size over a series of rounds, such that each golfer plays with every other golfer exactly once.\n\nvariables: x[i] (i in PERSON), y[j] (j in POS)\n\nThe decision variables are x and y, where x[i] represents the position of person i in the schedule, and y[j] represents the person assigned to position j in the schedule.\n\nconstraints: \ninverse(x, y), \nalldifferent(y), \n%alldifferent(x), \ny[i] = sum(j in 1..n)(bool2int(x[j] = i) * j)\n\nThe constraints ensure that each person is assigned a unique position, and each position is assigned a unique person (inverse and alldifferent constraints). The third constraint is a redundant constraint that is commented out, and the fourth constraint ensures that the y array is correctly defined as the inverse of the x array.\n\nobjective: maximize sum(i in 1..n-1)(friend[y[i],y[i+1]])\n\nThe objective is to maximize the total friendship score, which is calculated by summing the friendship values between adjacent pairs of golfers in the schedule.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2341, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d13ef289-8446-44d0-95bd-a39e3d16e05c": {"__data__": {"id_": "d13ef289-8446-44d0-95bd-a39e3d16e05c", "embedding": null, "metadata": {"model_name": "project_scheduling"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "project_scheduling_beginner_expert", "node_type": "4", "metadata": {"model_name": "project_scheduling"}, "hash": "e686cac0baaa1640398469b344ce7e04b554744de3ae55d7aacec926ace999d2", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **House Building Problem**\n\nThis problem is about building a house. Imagine you have a list of tasks to complete, like laying foundations, building walls, installing doors and windows, and putting on a roof. Each task takes a certain amount of time to finish.\n\n**Main Variables:**\n\n* **Tasks**: These are the individual jobs that need to be done to build the house, like laying foundations or installing doors.\n* **Duration**: This is how long each task takes to complete.\n* **Start time**: This is when each task begins.\n* **Makespan**: This is the total time it takes to complete all the tasks.\n\n**Basic Restrictions or Rules:**\n\n* Some tasks can't start until others are finished. For example, you can't start building walls until the foundations are laid.\n* Some tasks can't happen at the same time. For example, you can't be building the interior walls and exterior walls at the same time.\n\n**Goal:**\n\nThe goal is to find the order and timing of the tasks that will allow you to build the house in the shortest amount of time possible.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Resource-Constrained Project Scheduling Problem (RCPSP)\n\ndescription: The Resource-Constrained Project Scheduling Problem (RCPSP) is a classic problem in operations research and project management. It involves scheduling a set of tasks with given durations and precedence relationships, subject to resource constraints, to minimize the total project duration (makespan).\n\nvariables: `start[t]` for `t in TASK`, where `start[t]` represents the start time of task `t`.\n\nThe decision variables `start[t]` represent the start time of each task, which determines the schedule of the project.\n\nconstraints: \n`start[pre[i,1]] + duration[pre[i,1]] <= start[pre[i,2]]` for `i in PREC`, \n`nonoverlap(start[t1],duration[t1],start[t2],duration[t2])` for `t1, t2 in CARPENTRY` where `t1 < t2`.\n\nThe first constraint enforces the precedence relationships between tasks, ensuring that a task cannot start before its predecessors have finished. The second constraint ensures that tasks that require the same resource (in this case, carpentry) do not overlap in time.\n\nobjective: Minimize `makespan = max(t in TASK)(start[t] + duration[t])`, which represents the total project duration.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2411, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "da7ea70a-b481-42b4-8872-b77a47e28ddb": {"__data__": {"id_": "da7ea70a-b481-42b4-8872-b77a47e28ddb", "embedding": null, "metadata": {"model_name": "QuasigroupCompletion"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasigroupCompletion_beginner_expert", "node_type": "4", "metadata": {"model_name": "QuasigroupCompletion"}, "hash": "5794ef7d14bd44fbe84259b2328699d3f25efe1d03e19c53c508e0ebfff0cdb0", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Problem Name:** Quasigroup with Holes (also known as Latin Square Completion)\n\n**What the problem is about:** Imagine you have a grid with some numbers already filled in, and some empty cells. Your task is to fill in the empty cells with numbers so that each row, column, and cell has each number only once.\n\n**Main variables:**\n\n* `N`: The size of the grid (e.g., 3x3, 4x4, etc.)\n* `start`: The initial grid with some numbers already filled in and some empty cells (represented by 0)\n* `puzzle`: The grid that we want to fill in with numbers\n\n**Basic restrictions or rules:**\n\n* Each row must have each number only once\n* Each column must have each number only once\n* Each cell can only have one number assigned to it\n* The numbers already filled in the `start` grid cannot be changed\n\n**Goal of the problem:** The goal is to find a way to fill in the empty cells in the grid so that all the rules are satisfied. There is no specific goal to minimize or maximize anything; we just want to find a valid solution that meets all the rules.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Latin Square Completion\n\ndescription: The Latin Square Completion problem is a classic problem in constraint programming. It involves completing a partially filled N x N grid with numbers from 1 to N, such that each row, column, and cell contains each number exactly once.\n\nvariables: puzzle[i,j] (Model 1) or puzzle[i,j,k] (Model 2)\n\nThe decision variables represent the values to be assigned to each cell in the grid. In Model 1, puzzle[i,j] represents the value assigned to the cell at row i and column j. In Model 2, puzzle[i,j,k] represents a binary variable indicating whether the value k is assigned to the cell at row i and column j.\n\nconstraints: \nfill initial board: \u2200i,j (if start[i,j] > 0 then puzzle[i,j] = start[i,j] else true endif) (Model 1)\n\u2200i,j (if start[i,j] > 0 then puzzle[i,j, start[i,j]] = 1 else true endif) (Model 2)\n\nThese constraints ensure that the initial values in the grid are preserved.\n\nAll different in rows: \u2200i (alldifferent([puzzle[i,j] | j in PuzzleRange])) (Model 1)\n\u2200i,k (\u2211j (puzzle[i,j,k]) == 1) (Model 2)\n\nThese constraints ensure that each row contains each number exactly once.\n\nAll different in columns: \u2200j (alldifferent([puzzle[i,j] | i in PuzzleRange])) (Model 1)\n\u2200j,k (\u2211i (puzzle[i,j,k]) == 1) (Model 2)\n\nThese constraints ensure that each column contains each number exactly once.\n\nEach cell must have a number assigned: \u2200i,j (\u2211k (puzzle[i,j,k]) == 1) (Model 2)\n\nThis constraint ensures that each cell contains exactly one number.\n\nobjective: satisfy\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2890, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "32f176d6-92c5-4941-b074-336ccf863065": {"__data__": {"id_": "32f176d6-92c5-4941-b074-336ccf863065", "embedding": null, "metadata": {"model_name": "QuasiGroupExistence"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasiGroupExistence_beginner_expert", "node_type": "4", "metadata": {"model_name": "QuasiGroupExistence"}, "hash": "b7b9bd4300d3a660dddde45be65675a1f3b37bfe05dde42bd6026dd611dc2870", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Quasigroup existence problem\n\n**What the problem is about:** Imagine you have a table with numbers from 1 to n, where n is a given number. You need to fill this table in a special way, so that each row and each column contains each number exactly once. Additionally, there are some rules about how the numbers in the table should be related to each other.\n\n**Main variables:**\n\n* `quasiGroup`: a table (or matrix) with numbers from 1 to n, where each row and column contains each number exactly once.\n* `qgDiagonal`: a list of numbers that represents the diagonal of the `quasiGroup` table.\n\n**Basic restrictions or rules:**\n\n* Each row and each column of the `quasiGroup` table should contain each number exactly once.\n* There are some specific rules about how the numbers in the table should be related to each other, such as `(b*a)*b = a*(b*a)` or `(j*i)*(i*j) = i`.\n* The diagonal of the `quasiGroup` table should also satisfy some specific rules.\n\n**Goal of the problem:** The goal is to find a `quasiGroup` table that satisfies all the rules and restrictions.\n\nNote that the problem is about finding a specific type of mathematical structure called a quasigroup, which is a set with a binary operation that satisfies certain properties. The problem is to find a quasigroup of a given order (i.e., with a given number of elements).\n                    ======\n                    Description 2:\n                    ---------\n                    name: Quasigroup Existence Problem\n\ndescription: The Quasigroup Existence Problem is a classic problem in combinatorial mathematics, which involves finding a multiplication table of size n x n, where each element is an integer from 1 to n, such that each row and column contains each element exactly once, and certain multiplication axioms hold.\n\nvariables: quasiGroup[row, col], qgDiagonal[i]\n\nThe decision variables are a 2D array quasiGroup, where quasiGroup[row, col] represents the element at row and column in the multiplication table, and a 1D array qgDiagonal, where qgDiagonal[i] represents the diagonal element at position i.\n\nconstraints: \nall_different([quasiGroup[row,col] | col in nDomain]) /\\ \nall_different([quasiGroup[row,col] | row in nDomain]) /\\ \nquasiGroup[i,i] = i /\\ \nquasiGroup[quasiGroup[j,i],quasiGroup[i,j]] = i /\\ \nall_different(qgDiagonal) /\\ \nquasiGroup[i,j] != quasiGroup[j,i] /\\ \n(quasiGroup[i,i]=j) -> (quasiGroup[j,j]=i) /\\ \nquasiGroup[i,n-1] + 2 >= i\n\nThe constraints ensure that:\n- Each row and column contains each element exactly once.\n- The diagonal elements are equal to their indices.\n- The multiplication axiom (b*a)*b = a*(b*a) holds.\n- The diagonal elements are all different.\n- The table is anti-Abelian, i.e., quasiGroup[i,j] is not equal to quasiGroup[j,i] for i != j.\n- If (i*i)=j then (j*j) = i.\n- Symmetry-breaking constraints to reduce the search space.\n\nobjective: The problem is a satisfaction problem, i.e., it does not have an objective function to minimize or maximize. The goal is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 3199, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8007fb48-f42c-47dd-b33a-44d6e8a80d8b": {"__data__": {"id_": "8007fb48-f42c-47dd-b33a-44d6e8a80d8b", "embedding": null, "metadata": {"model_name": "queens"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "queens_beginner_expert", "node_type": "4", "metadata": {"model_name": "queens"}, "hash": "0ba6635e3b707d6f85784d2f17454b5685f34824c464dd4eee0a185592d5d745", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **The N-Queens Problem**\n\n**What is it about?**\nImagine you have a chessboard with `n` rows and `n` columns. You want to place `n` queens on the board in such a way that no queen can attack another queen.\n\n**Main variables:**\n* `n`: the number of queens (and the size of the chessboard)\n* `queens`: an array of `n` variables, each representing the column where a queen is placed in a particular row\n\n**Basic restrictions or rules:**\n* Each queen must be placed in a different column (no two queens can be in the same column)\n* No queen can attack another queen diagonally (i.e., no two queens can be on the same diagonal)\n\n**Goal:**\nThe goal is to find a way to place all `n` queens on the board such that they do not attack each other.\n                    ======\n                    Description 2:\n                    ---------\n                    name: N-Queens Problem\n\ndescription: The N-Queens Problem is a classic problem in computer science and mathematics, where the goal is to place N queens on an NxN chessboard such that no queen attacks another queen.\n\nvariables: q (or queens) \u2208 {1, ..., n}^n, where q[i] represents the column index of the queen in the i-th row.\n\nconstraints: \n\u2200i, j \u2208 {1, ..., n} (i \u2260 j) : q[i] \u2260 q[j] \u2227 q[i] + i \u2260 q[j] + j \u2227 q[i] - i \u2260 q[j] - j\n\u2200i \u2208 {1, ..., n} : q[i] is distinct\n\nThe first constraint ensures that no two queens are in the same column, and no two queens are on the same diagonal. The second constraint ensures that all queens are distinct.\n\nobjective: The objective of the problem is to find a feasible solution that satisfies all the constraints, i.e., to place N queens on an NxN chessboard such that no queen attacks another queen. There is no objective function to minimize or maximize.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1823, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9f575d86-aef4-4a8c-a5ce-7624de1ce454": {"__data__": {"id_": "9f575d86-aef4-4a8c-a5ce-7624de1ce454", "embedding": null, "metadata": {"model_name": "rcpsp"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rcpsp_beginner_expert", "node_type": "4", "metadata": {"model_name": "rcpsp"}, "hash": "8241d9dbf135e371283de2d22a1057c58dc94cdc709391bfbbeb1d780f61f735", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Resource-Constrained Project Scheduling Problem**\n\nThis problem is about planning a set of tasks that need to be done, using a limited amount of resources, like machines or workers. Each task takes a certain amount of time to complete and uses a certain amount of resources.\n\n**Main variables:**\n\n* Tasks: These are the individual jobs that need to be done.\n* Resources: These are the machines, workers, or other things needed to complete the tasks.\n* Start time: This is when each task will begin.\n* Duration: This is how long each task will take to complete.\n* Resource usage: This is how much of each resource is needed for each task.\n\n**Basic restrictions or rules:**\n\n* Each task must be done after its predecessors (tasks that need to be finished before it can start).\n* Each resource has a limited capacity, and the total usage of that resource by all tasks cannot exceed that capacity.\n* Each task must start after its predecessors have finished.\n\n**Goal:**\n\nThe goal is to find a schedule that completes all tasks as quickly as possible, while following the rules and restrictions above. In other words, we want to minimize the total time it takes to complete all tasks.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Resource-Constrained Project Scheduling Problem (RCPSP)\n\ndescription: The Resource-Constrained Project Scheduling Problem (RCPSP) is a classic problem in operations research and project management. It involves scheduling a set of tasks with given durations and resource requirements, subject to resource availability constraints and precedence constraints between tasks. The goal is to find a schedule that minimizes the total project duration.\n\nvariables: s \u2208 TIME ^ TASK, where s[t] represents the start time of task t.\n\nThe decision variables are the start times of each task, which determine the schedule of the project.\n\nconstraints: \n\u2200p \u2208 PREC, s[pre[p,1]] + d[pre[p,1]] \u2264 s[pre[p,2]]\n\u2200r \u2208 RESOURCE, cumulative(s, d, [res[r,t]|t \u2208 TASK], L[r])\n\nThe first constraint enforces the precedence relationships between tasks, ensuring that a task cannot start before its predecessors have finished. The second constraint ensures that the resource usage of all tasks does not exceed the available resource limit at any time.\n\nobjective: minimize max(t \u2208 TASK)(s[t] + d[t])\n\nThe objective is to minimize the maximum completion time of all tasks, which represents the total project duration.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2570, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "90833a59-9f76-4f0e-b7a1-e1d6c6b055ec": {"__data__": {"id_": "90833a59-9f76-4f0e-b7a1-e1d6c6b055ec", "embedding": null, "metadata": {"model_name": "rehearsal"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rehearsal_beginner_expert", "node_type": "4", "metadata": {"model_name": "rehearsal"}, "hash": "8b15869553b0a7935f1b22636ad4005d194aa1be4b20c9c733e897060999f090", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Scheduling a Rehearsal\n\n**What the problem is about in everyday terms:** Imagine you are the conductor of an orchestra, and you need to schedule a rehearsal for a concert. There are 9 pieces of music to be rehearsed, and 5 musicians will be participating. Each musician is required for some pieces, but not all. You want to find the best order to rehearse the pieces so that the musicians don't have to wait too long between their performances.\n\n**Main variables and what they mean:**\n\n* `rehearsal_order`: the order in which the pieces will be rehearsed\n* `waiting_time`: the time each musician spends waiting between their performances\n* `total_waiting_time`: the total time all musicians spend waiting\n\n**Basic restrictions or rules of the problem:**\n\n* Each musician can arrive at the rehearsal just before their first piece and leave just after their last piece.\n* Each piece has a specific duration (length of time it takes to rehearse).\n* The order of the pieces must be determined so that each musician's waiting time is minimized.\n\n**Goal of the problem:** Find the order of the pieces that minimizes the total waiting time for all musicians.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Rehearsal Scheduling Problem\n\ndescription: The problem involves scheduling a rehearsal for a concert consisting of nine pieces of music with different durations, each requiring a different combination of five orchestra players. The goal is to find an order in which the pieces can be rehearsed to minimize the total time that players are waiting to play, i.e., the total time when players are present but not currently playing.\n\nvariables: rehearsal_order \u2208 {1, ..., num_pieces}^num_pieces, waiting_time \u2208 \u2124^num_players, p_from \u2208 {1, ..., num_pieces}^num_players, p_to \u2208 {1, ..., num_pieces}^num_players, total_waiting_time \u2208 \u2124\n\nThe decision variables are:\n- rehearsal_order: an array representing the order in which the pieces are rehearsed\n- waiting_time: an array representing the waiting time for each player\n- p_from and p_to: arrays representing the first and last pieces each player is involved in, respectively\n- total_waiting_time: the total waiting time for all players\n\nconstraints: \nall_different(rehearsal_order), \np_from[p] < p_to[p] \u2200p \u2208 {1, ..., num_players}, \nrehearsal[p, rehearsal_order[i]] = 0 \u2200p \u2208 {1, ..., num_players}, i < p_from[p], \nrehearsal[p, rehearsal_order[i]] = 0 \u2200p \u2208 {1, ..., num_players}, i > p_to[p], \nwaiting_time[p] = \u2211(i \u2208 {1, ..., num_pieces}) (duration[rehearsal_order[i]] * bool2int(i \u2265 p_from[p] \u2227 i \u2264 p_to[p] \u2227 rehearsal[p, rehearsal_order[i]] = 0)) \u2200p \u2208 {1, ..., num_players}, \nrehearsal_order[1] < rehearsal_order[num_pieces]\n\nThe constraints are:\n- all_different(rehearsal_order): ensures that each piece is rehearsed exactly once\n- p_from[p] < p_to[p]: ensures that the first piece each player is involved in is before the last piece\n- rehearsal[p, rehearsal_order[i]] = 0: ensures that players are not involved in pieces before their first or after their last piece\n- waiting_time[p] = ...: calculates the waiting time for each player\n- rehearsal_order[1] < rehearsal_order[num_pieces]: breaks symmetry by ensuring that the first piece is rehearsed before the last piece\n\nobjective: minimize total_waiting_time", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 3477, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b1f58f26-7b1b-4f3f-88e5-c8e9ed95a536": {"__data__": {"id_": "b1f58f26-7b1b-4f3f-88e5-c8e9ed95a536", "embedding": null, "metadata": {"model_name": "restart"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "restart_beginner_expert", "node_type": "4", "metadata": {"model_name": "restart"}, "hash": "252dd4323c415b99f6c3a8b00ad838b650bc29d3f08afc6ad6b6b3f5f99f0b9b", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **The Problem of the Ten Variables**\n\nThis problem is about assigning numbers to ten variables in a special way.\n\n**Main Variables:**\n\nThe problem has ten variables, labeled x[1] to x[10]. Each variable can take a value between 1 and 10.\n\n**Basic Restrictions or Rules:**\n\nThe rules are:\n\n* Each variable must have a different value than the others.\n* The values of variables x[2] to x[10] cannot be more than 9.\n* The value of variable x[1] must be at least 9.\n\n**Goal of the Problem:**\n\nThe goal is to find a way to assign numbers to the variables that satisfy all the rules. In other words, we want to find a solution that makes all the variables happy!\n\nNote that the three models are slightly different, but they all represent the same problem. The differences are in how the problem is solved, not in what the problem is about.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Permutation with Restrictions\n\ndescription: This problem involves finding a permutation of numbers from 1 to 10, where the first element is at least 9, and all elements from the second to the tenth are at most 9. The goal is to find a permutation that satisfies these restrictions.\n\nvariables: x = (x[1], x[2], ..., x[10]) \u2208 {1, 2, ..., 10}^10\nThese variables represent the elements of the permutation, where x[i] is the i-th element of the permutation.\n\nconstraints: \n\u2200i, j \u2208 {1, 2, ..., 10} where i < j, x[i] \u2260 x[j] (alldifferent constraint)\n\u2200i \u2208 {2, 3, ..., 10}, x[i] \u2264 9\nx[1] \u2265 9\nThe first constraint ensures that all elements in the permutation are distinct. The second constraint restricts the values of elements from the second to the tenth to be at most 9. The third constraint ensures that the first element is at least 9.\n\nobjective: satisfy\nThe objective of this problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific value.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2024, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "66d30a23-3825-424b-8f69-193f98bf99f4": {"__data__": {"id_": "66d30a23-3825-424b-8f69-193f98bf99f4", "embedding": null, "metadata": {"model_name": "RosteringProblem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "RosteringProblem_beginner_expert", "node_type": "4", "metadata": {"model_name": "RosteringProblem"}, "hash": "ca3de7c49d0e6d999a1d98b3ed05681df258bac74dba9e676b6d704222a1c4a9", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Nurse Scheduling Problem**\n\nThis problem is about creating a schedule for nurses to work in a hospital. Imagine you are the person in charge of making sure there are enough nurses working each day to take care of patients.\n\n**Main Variables:**\n\n* `plan1d`, `plan2d`, and `plan2dT`: These are arrays that represent the schedule of nurses. They show which shift each nurse is working on each day (early, late, night, or day off).\n* `shiftRequirements`: This is a matrix that shows how many nurses are needed for each shift on each day of the week.\n* `s_min` and `s_max`: These are the minimum and maximum number of days in a row that a nurse can work the same shift.\n\n**Basic Restrictions or Rules:**\n\n* Nurses need to work a certain number of days in a row with the same shift (between `s_min` and `s_max` days).\n* Weekend days (Saturday and Sunday) must have the same shift.\n* There must be at least 2 rest days every 2 weeks.\n* The order of shifts follows a rotating principle (e.g., after an early shift, the next shift can only be the same or a higher value, or a rest shift).\n* The number of nurses working each shift must meet the required staff numbers for that day.\n\n**Goal:**\n\nThe goal is to create a schedule that satisfies all these rules and restrictions, while also making sure that the hospital has enough nurses working each day to take care of patients.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Nurse Rostering Problem\n\ndescription: The Nurse Rostering Problem is a classic problem in constraint programming that involves creating a schedule for nurses to work in a hospital. The problem involves assigning shifts to nurses over a certain period of time, taking into account various constraints such as the number of nurses required for each shift, the minimum and maximum number of consecutive days a nurse can work, and the requirement for rest days.\n\nvariables: plan1d, plan2d, plan2dT, s_min_arrays, s_max_arrays\nplan1d, plan2d, and plan2dT are arrays of decision variables that represent the shift assignments for each nurse over the planning period. plan1d is a 1D array, while plan2d and plan2dT are 2D arrays that represent the same schedule in different formats. s_min_arrays and s_max_arrays are helper arrays used to model the minimum and maximum consecutive days constraints.\n\nconstraints: \nC_equalDays: plan2d[week, daysPerWeek - 1] == plan2d[week, daysPerWeek]\nC_shiftRepetitions: forall(day in 1..numberOfDays - s_min) (plan1d[day] != plan1d[day+1] -> all_equal(plan1d[day+1..day+s_min]))\nC_shiftRepetitions: forall(day in 1..numberOfWeeks * daysPerWeek - s_max) ((all_equal(plan1d[day..day+s_max])) -> (plan1d[day] != plan1d[day + s_max]))\nC_restDays: forall(day in 1..(numberOfWeeks - 2) * daysPerWeek) (count(j in plan1d[day..day + daysPerWeek * 2])(j=0) >= 2)\nC_shiftOrder: forall(day in 2..numberOfWeeks * daysPerWeek - 1) (plan1d[day] <= plan1d[day + 1] \\/ plan1d[day+1] == 0)\nC_shiftRequirements: forall(day in 1..daysPerWeek) ((global_cardinality(row(plan2dT,day),[0,1,2,3],row(shiftRequirements,day))))\n\nThese constraints ensure that: \n- weekend days have the same shift\n- there is a minimum and maximum number of consecutive days with the same shift\n- there are at least 2 rest days every 2 weeks\n- the order of shifts follows a forward rotating principle\n- the number of required staff for each shift is satisfied\n\nobjective: The objective of the problem is to find a feasible schedule that satisfies all the constraints, rather than to minimize or maximize a specific value.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 3678, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1fc4024d-6423-447f-858e-7e58c9f10a3a": {"__data__": {"id_": "1fc4024d-6423-447f-858e-7e58c9f10a3a", "embedding": null, "metadata": {"model_name": "sb"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sb_beginner_expert", "node_type": "4", "metadata": {"model_name": "sb"}, "hash": "d70f6bd37ceb72d79b728bdddbc69cba5afd3882cda2f58a59d52b3719e2844a", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Solitaire Battleships**\n\n**What is it about?**\nImagine you have a puzzle with a partially filled grid, and you need to fill in the rest of the grid with ships of different lengths. You are given the number of ships of each length and the number of ships in each row and column.\n\n**Main variables:**\n\n* `board`: a grid that represents the puzzle, where each cell can be a ship part (like a submarine, left end, right end, etc.) or water.\n* `fill`: a grid that shows which cells are part of a ship.\n* `npiece`: the number of each type of ship part (like submarines, left ends, etc.).\n\n**Basic restrictions or rules:**\n\n* The puzzle must respect the given hints (initially filled cells).\n* Ships cannot touch each other (there must be water between them).\n* Each ship must have the correct number of parts (like left and right ends, middle parts, etc.).\n* The number of ships in each row and column must match the given sums.\n\n**Goal:**\nThe goal is to find a solution that satisfies all the rules and restrictions, and then output the completed puzzle grid with the ship parts and the row and column sums.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Solitaire Battleships\n\ndescription: Solitaire Battleships is a puzzle where a partially filled board is given along with the number of ships in each row and column. The goal is to fill the board with ships of different lengths, respecting the given constraints.\n\nvariables: `board[i, j], fill[i, j], npiece[p]`\n\n* `board[i, j]`: a variable representing the type of piece (water, submarine, left/right/top/bottom of a ship, or middle of a ship) at position `(i, j)` on the board.\n* `fill[i, j]`: a binary variable indicating whether the piece at position `(i, j)` is part of a ship or not.\n* `npiece[p]`: a variable representing the number of pieces of type `p` on the board.\n\nconstraints: \n`hint[i, j] != 0 -> board[i, j] == hint[i, j], \nboard[i, 0] == w, board[i, width + 1] == w, \nboard[0, j] == w, board[height + 1, j] == w, \nfill[i, j] = bool2int(board[i, j] != w), \nspacing constraints, \nship shape constraints, \nsum up pieces, \npiece sum constraints, \ncount number of bigger ships, \nrow sums respected, \ncolumn sums respected`\n\n* `hint[i, j] != 0 -> board[i, j] == hint[i, j]`: ensure that the initial hints are respected.\n* `board[i, 0] == w, board[i, width + 1] == w, board[0, j] == w, board[height + 1, j] == w`: ensure that the extended rows and columns are empty.\n* `fill[i, j] = bool2int(board[i, j] != w)`: ensure that the fill array matches the board.\n* `spacing constraints`: ensure that there are gaps between ships.\n* `ship shape constraints`: ensure that ships are correctly formed.\n* `sum up pieces`: count the number of each type of piece.\n* `piece sum constraints`: ensure that the number of pieces of each type matches the given ship lengths.\n* `count number of bigger ships`: count the number of ships of each length.\n* `row sums respected`: ensure that the sum of pieces in each row matches the given row sum.\n* `column sums respected`: ensure that the sum of pieces in each column matches the given column sum.\n\nobjective: The objective is to satisfy all the constraints, i.e., to find a feasible solution. There is no objective function to minimize or maximize.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 3393, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "48c52e70-f43e-43f2-8e86-cd5b6d81d107": {"__data__": {"id_": "48c52e70-f43e-43f2-8e86-cd5b6d81d107", "embedding": null, "metadata": {"model_name": "schur"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "schur_beginner_expert", "node_type": "4", "metadata": {"model_name": "schur"}, "hash": "b73d5da02a5a756fd9d3c2ee8373f3d0ab394d22b08f255505cb716cd86b7766", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Schur's Numbers Problem\n\nThis problem is about distributing balls into boxes in a special way. Imagine you have a certain number of balls, each with a unique label from 1 to n, and you want to put them into a certain number of boxes.\n\nThe main variables are:\n- n: the number of balls\n- c: the number of boxes\n- box: an array that shows which box each ball goes into\n\nThe basic restrictions or rules of the problem are:\n- Each ball must go into a box\n- No box can contain three balls with labels that add up to each other (for example, balls 1, 2, and 3 cannot be in the same box because 1+2=3)\n\nThe goal of the problem is to find a way to distribute the balls into the boxes that follows these rules.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Schur's Numbers Problem\n\ndescription: The Schur's Numbers Problem is a classic problem in constraint programming that involves placing n balls labeled 1 to n into c boxes such that no box contains a triple of balls {x, y, z} where x + y = z.\n\nvariables: box = (box[1], ..., box[n]) \u2208 {1, ..., c}^n\nThe decision variables are the box assignments for each ball, where box[i] represents the box that ball i is placed in.\n\nconstraints: \u2200i \u2208 {1, ..., n-1}, \u2200j \u2208 {i+1, ..., n-i} : box[i] \u2260 box[j] \u2228 box[i] \u2260 box[i+j] \u2228 box[j] \u2260 box[i+j]\nThe constraints ensure that for any two balls i and j, if ball i is in box k, then ball j cannot be in box k, and ball i+j cannot be in box k.\n\nobjective: satisfy\nThe objective is to find a feasible solution that satisfies all the constraints, i.e., to determine if it is possible to place the balls in the boxes according to the given rules.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1775, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6267f07d-f1a6-4f1c-844c-4bf452fa805a": {"__data__": {"id_": "6267f07d-f1a6-4f1c-844c-4bf452fa805a", "embedding": null, "metadata": {"model_name": "setselect"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "setselect_beginner_expert", "node_type": "4", "metadata": {"model_name": "setselect"}, "hash": "9f404516a136e670e25ca3994d0392fd205eea508a1c58057ab095504ed84359", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **The Set Selection Problem**\n\n**What is it about?**\nImagine you have a bunch of items, and you want to choose a few of them. These items are grouped into smaller sets, and you have some rules to follow when making your selection.\n\n**Main variables:**\n\n* `n`: The total number of items.\n* `k`: The number of smaller sets that the items are grouped into.\n* `s`: The smaller sets themselves, each containing some of the items.\n* `x`: The selection of items you want to choose.\n\n**Basic restrictions or rules:**\n\n* You can only choose one item from each smaller set.\n* The total number of items you choose is limited (this limit is `u` in some models).\n\n**Goal:**\nThe goal is to choose the items that add up to the largest total value. In other words, you want to maximize the sum of the items you select.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Set Covering Problem\n\ndescription: The Set Covering Problem is a classic problem in computer science and operations research that involves finding a subset of elements that covers all subsets of a given set. In this problem, we have a set of elements and a collection of subsets of these elements. The goal is to select a subset of the elements such that each subset in the collection contains at most one element from the selected subset.\n\nvariables: x (Model 1), x (Model 2), x[1..u] (Model 3), x[1..u] (Model 4)\nThe decision variables represent the elements to be selected from the set of elements. In Models 1 and 2, x is a set of elements, while in Models 3 and 4, x is an array of variables representing the selected elements.\n\nconstraints: \ncard(x intersect s[i]) <= 1 (Model 1, 2), \ncard(x) = u (Model 2), \nx[i] < x[i+1] (Model 3), \nx[i] != x[j] (Model 3), \nsum(j in 1..u)(x[j] in s[i]) <= 1 (Model 3, 4), \nx[i] >= (x[i] != 0) + x[i+1] (Model 4)\nThe constraints ensure that each subset in the collection contains at most one element from the selected subset (card(x intersect s[i]) <= 1). In Model 2, the cardinality of the selected subset is fixed to u. In Model 3, the selected elements are distinct and in increasing order. In Model 4, the selected elements are also distinct, and the constraint ensures that the elements are in decreasing order.\n\nobjective: maximize sum(i in x)(i) (Model 1, 2), maximize sum(x) (Model 3, 4)\nThe objective is to maximize the sum of the selected elements.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2503, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5037c1c5-9780-4897-bb81-789ba80876d4": {"__data__": {"id_": "5037c1c5-9780-4897-bb81-789ba80876d4", "embedding": null, "metadata": {"model_name": "shipping"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "shipping_beginner_expert", "node_type": "4", "metadata": {"model_name": "shipping"}, "hash": "fb0dffdaeafb4a67548a6386bc6275dc71ebc34e7e6ed84462d98cbacd4a47b8", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Problem Name:** Warehouse-Factories Shipping Problem\n\n**What the problem is about:** Imagine you have several warehouses that need certain amounts of goods, and several factories that can produce those goods. You need to decide how much of each good to ship from each factory to each warehouse, so that each warehouse gets what it needs, and each factory doesn't produce more than it can. You also want to minimize the total cost of shipping.\n\n**Main variables:**\n\n* `W`: The number of warehouses.\n* `F`: The number of factories.\n* `demand`: An array that says how much of each good each warehouse needs.\n* `production`: An array that says how much of each good each factory can produce.\n* `cost`: An array that says how much it costs to ship one unit of each good from each factory to each warehouse.\n* `ship`: An array that says how much of each good to ship from each factory to each warehouse.\n\n**Basic restrictions or rules:**\n\n* Each warehouse must get at least as much of each good as it needs.\n* Each factory can't produce more than it can.\n* You can't ship a negative amount of goods.\n\n**Goal:** Minimize the total cost of shipping goods from factories to warehouses.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Transportation Problem\n\ndescription: The Transportation Problem is a classic problem in Operations Research and Management Science that involves finding the most cost-effective way to transport goods from a set of factories to a set of warehouses. Each factory has a limited production capacity, and each warehouse has a certain demand that must be met. The goal is to determine the optimal shipment quantities from each factory to each warehouse to minimize the total transportation cost.\n\nvariables: ship[f,w] (f \u2208 FACT, w \u2208 WARE) - The decision variables represent the quantity of goods to be shipped from factory f to warehouse w.\n\nconstraints: \n\u2200f \u2208 FACT, w \u2208 WARE : ship[f,w] \u2265 0 - Each shipment quantity must be non-negative.\n\u2200w \u2208 WARE : \u2211(f \u2208 FACT) ship[f,w] \u2265 demand[w] - The total quantity shipped to each warehouse must meet its demand.\n\u2200f \u2208 FACT : \u2211(w \u2208 WARE) ship[f,w] \u2264 production[f] - The total quantity shipped from each factory must not exceed its production capacity.\n\nobjective: Minimize \u2211(f \u2208 FACT, w \u2208 WARE) cost[f,w]*ship[f,w] - The objective is to minimize the total transportation cost, which is the sum of the product of the cost of shipping from each factory to each warehouse and the corresponding shipment quantity.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2623, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f60fdec3-676c-4a65-a02a-db16ae35dd4d": {"__data__": {"id_": "f60fdec3-676c-4a65-a02a-db16ae35dd4d", "embedding": null, "metadata": {"model_name": "simple-prod-planning"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "simple-prod-planning_beginner_expert", "node_type": "4", "metadata": {"model_name": "simple-prod-planning"}, "hash": "dd09900e8238db8ba9be7aee180e421e9993d9cba34950f4fd586c03ba60253d", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Problem Name:** Product Production Planning\n\n**What the problem is about:** Imagine you have a factory that produces different products, like toys, clothes, or food. You have limited resources, like machines, workers, and raw materials, to make these products. You want to decide how many units of each product to produce to make the most profit possible.\n\n**Main variables:**\n\n* `produce`: how many units of each product to make\n* `used`: how much of each resource is used to make the products\n\n**Basic restrictions or rules:**\n\n* You can't use more resources than you have available\n* You need a certain amount of each resource to make one unit of each product\n* You can't make a negative amount of any product\n\n**Goal:** Maximize the total profit by deciding how many units of each product to produce, while following the rules and restrictions.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Production Planning Problem\n\ndescription: The Production Planning Problem is a classic problem in Operations Research and Management Science. It involves determining the optimal production levels of different products to maximize profit, given limited resources and production constraints.\n\nvariables: produce[p] (p \u2208 Products), used[r] (r \u2208 Resources)\nThese variables represent the decision variables in the problem. produce[p] represents the quantity of product p to be produced, and used[r] represents the amount of resource r used in the production process.\n\nconstraints: \n\u2200r \u2208 Resources, used[r] = \u2211(p \u2208 Products)(consumption[p, r] * produce[p]) \u2227 used[r] \u2264 capacity[r]\nThese constraints ensure that the total amount of each resource used does not exceed the available capacity. The first part of the constraint calculates the total amount of resource r used, and the second part ensures that it does not exceed the capacity.\n\nobjective: Maximize \u2211(p \u2208 Products)(profit[p]*produce[p])\nThe objective of the problem is to maximize the total profit, which is calculated by summing the profit of each product multiplied by its production quantity.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2200, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "31c36fa2-d800-4eac-839e-987a1286ccdf": {"__data__": {"id_": "31c36fa2-d800-4eac-839e-987a1286ccdf", "embedding": null, "metadata": {"model_name": "sonet_problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sonet_problem_beginner_expert", "node_type": "4", "metadata": {"model_name": "sonet_problem"}, "hash": "b74ebc561dc3dbffbc58195b1135170bcb74927007f9dd20284120601b4f4679", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    SONET Problem\n\nThe SONET problem is about designing a network that connects certain nodes (think of them as computers or devices) in a way that uses the fewest resources possible.\n\nThe main variables are:\n\n* Rings: These are like circles that connect nodes together. Each ring can hold a certain number of nodes.\n* Nodes: These are the devices that need to be connected.\n* Demand: This is a list of which nodes need to be connected to each other.\n* Capacity nodes: This is the maximum number of nodes that can be on each ring.\n\nThe basic restrictions or rules of the problem are:\n\n* If two nodes need to be connected, they must be on the same ring.\n* Each ring can only hold a certain number of nodes, based on its capacity.\n\nThe goal of the problem is to use the fewest number of rings (and therefore the fewest resources) to connect all the nodes that need to be connected.\n                    ======\n                    Description 2:\n                    ---------\n                    name: SONET Problem\n\ndescription: The SONET problem is a network design problem where a network needs to be set up between a set of nodes, with some nodes requiring a connection. The nodes are connected by putting them on a ring, where all nodes on a ring can communicate. The goal is to set up a network using a minimal amount of Add-Drop Multiplexers (ADMs).\n\nvariables: $rings_{i,j} \\in \\{0,1\\}$ for $i \\in \\{1, \\ldots, r\\}$ and $j \\in \\{1, \\ldots, n\\}$. These variables represent the assignment of nodes to rings, where $rings_{i,j} = 1$ if node $j$ is assigned to ring $i$ and $0$ otherwise.\n\nconstraints: \n$\\sum_{i=1}^r rings_{i,j} + \\sum_{i=1}^r rings_{i,k} \\geq 2$ for all $j, k \\in \\{1, \\ldots, n\\}$ such that $j < k$ and $demand_{j,k} = 1$.\n$\\sum_{j=1}^n rings_{i,j} \\leq capacity\\_nodes_i$ for all $i \\in \\{1, \\ldots, r\\}$.\n\nThe first constraint ensures that if there is a demand between two nodes, then there exists a ring on which both nodes are installed. The second constraint ensures that the capacity of each ring is not exceeded.\n\nobjective: Minimize the total number of ADMs used, which is represented by the variable $z = \\sum_{i=1}^r \\sum_{j=1}^n rings_{i,j}$.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2252, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8760ac65-5154-4be7-8bb5-1f2d2cc1840b": {"__data__": {"id_": "8760ac65-5154-4be7-8bb5-1f2d2cc1840b", "embedding": null, "metadata": {"model_name": "square_pack"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "square_pack_beginner_expert", "node_type": "4", "metadata": {"model_name": "square_pack"}, "hash": "2bf1a2523a0dc932e3a9508e11e6692f216c4dc5ed1110606e0dadad7eeb7698", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Problem Name:** Square Packing Problem\n\n**What the problem is about:** Imagine you have a set of squares of different sizes, and you want to pack them into a rectangle (a box with a length and a width) in a way that they don't overlap with each other. You want to find the smallest rectangle that can fit all the squares.\n\n**Main variables:**\n\n* `n`: The number of squares.\n* `height` and `width`: The length and width of the rectangle.\n* `x` and `y`: The coordinates (positions) of each square in the rectangle.\n* `area`: The total area of the rectangle.\n\n**Basic restrictions or rules:**\n\n* Each square must fit inside the rectangle.\n* No two squares can overlap with each other.\n* The squares must be packed in a way that they don't stick out of the rectangle.\n\n**Goal of the problem:** Find the smallest rectangle (with the smallest area) that can fit all the squares without any overlaps.\n                    ======\n                    Description 2:\n                    ---------\n                    name: 2D Rectangular Packing Problem\n\ndescription: The 2D Rectangular Packing Problem is a classic problem in constraint programming where we are given a set of rectangles of different sizes and we need to pack them into a larger rectangle of minimum area, such that no two rectangles overlap and all rectangles are fully contained within the larger rectangle.\n\nvariables: height, width, area, x, y\n\nheight and width are the dimensions of the larger rectangle, area is the area of the larger rectangle, x and y are arrays of variables representing the x and y coordinates of the top-left corner of each rectangle.\n\nconstraints: \nx[s] + s <= width, y[s] + s <= height, \n(x[s1] + s1 <= x[s2] \\/ x[s2] + s2 <= x[s1] \\/ y[s1] + s1 <= y[s2] \\/ y[s2] + s2 <= y[s1])\n\nThe first two constraints ensure that each rectangle is fully contained within the larger rectangle. The third constraint ensures that no two rectangles overlap.\n\nobjective: minimize area", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2039, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9b656723-e1cd-42c9-9d34-ccb177763904": {"__data__": {"id_": "9b656723-e1cd-42c9-9d34-ccb177763904", "embedding": null, "metadata": {"model_name": "stableroommates"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "stableroommates_beginner_expert", "node_type": "4", "metadata": {"model_name": "stableroommates"}, "hash": "a6802947757cff27e4eb02a2e60b970bfaf607007cc116e66700e57f7a5c4ba5", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **The Stable Roommates Problem**\n\nThis problem is about finding a way to pair up people (called \"agents\") in a way that makes everyone happy.\n\n**Main Variables:**\n\n* `n`: The number of agents (people) involved.\n* `pref`: A list of preferences for each agent, showing who they would like to be paired with.\n* `a`: A list of assignments, showing who each agent is paired with.\n* `rank`: A list showing the ranking of each agent's preferences.\n\n**Basic Restrictions or Rules:**\n\n* Each agent has a list of preferences, and they cannot prefer themselves.\n* Each agent's preferences must be unique (they can't prefer the same person twice).\n* The ranking of each agent's preferences is determined by their list of preferences.\n\n**Goal:**\n\nThe goal is to find a way to pair up the agents in a way that satisfies everyone's preferences as much as possible. This means that if an agent prefers someone, they should be paired with that person if possible. The problem is trying to find a stable solution, where no agent would rather be paired with someone else if they had the chance.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Stable Roommates Problem\n\ndescription: The Stable Roommates Problem is a classic problem in constraint programming that involves finding a stable matching between a set of agents, where each agent has a preference order over the other agents. The goal is to find a matching such that there is no pair of agents who prefer each other to their current match.\n\nvariables: a[i] (i in AGENT)\n\nThe decision variables a[i] represent the ranking of agent i in the stable matching.\n\nconstraints:\n- a[i] <= npref[i] + 1 (i in AGENT)\n- a[i] > rank[i,j] -> a[j] < rank[j,i] (i in AGENT, p in 1..npref[i], j = pref[i,p])\n- a[i] = rank[i,j] -> a[j] = rank[j,i] (i in AGENT, p in 1..npref[i], j = pref[i,p])\n\nThe constraints ensure that each agent is matched with one of their top npref[i] preferences, and that the matching is stable. The first constraint ensures that each agent is matched with a rank no higher than their number of preferences plus one. The second and third constraints ensure that if agent i prefers agent j to their current match, then agent j must prefer their current match to agent i, and vice versa.\n\nobjective: satisfy\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific objective function.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2558, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "60a56f2c-939f-419d-ac47-c4678591eb3b": {"__data__": {"id_": "60a56f2c-939f-419d-ac47-c4678591eb3b", "embedding": null, "metadata": {"model_name": "steiner"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "steiner_beginner_expert", "node_type": "4", "metadata": {"model_name": "steiner"}, "hash": "73d4a2dd1c12df3efe66645888cb57a42b79fa15b29bd02997ca2464826079f9", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **The Ternary Steiner Problem**\n\n**What is it about?**\nImagine you have a set of items, like toys or balls, and you want to group them into sets of three in a special way.\n\n**Main variables:**\n* `N`: The total number of items (toys or balls).\n* `Sets`: A collection of groups, each containing three items.\n\n**Basic restrictions or rules:**\n* Each group must have exactly three items.\n* Any two groups can share at most one item.\n\n**Goal:**\nThe goal is to find a way to group all the items into sets of three, following the rules above, so that we have the desired number of groups (`NB`).\n\nIn simpler terms, we want to divide a set of items into groups of three, making sure that each group is unique and doesn't share too many items with other groups.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Ternary Steiner Problem\n\ndescription: The Ternary Steiner Problem is a classic problem in combinatorial mathematics that involves finding a collection of sets, each containing three elements, such that any two sets have at most one element in common.\n\nvariables: Sets = {S_1, S_2, ..., S_NB}, where S_i \u2286 {1, 2, ..., N}\n\nThe decision variables are the sets S_i, which are subsets of {1, 2, ..., N}, and NB is the number of sets, calculated as N*(N-1)/6.\n\nconstraints: \ncard(S_i) = 3 \u2200i \u2208 {1, 2, ..., NB}\ncard(S_i \u2229 S_j) \u2264 1 \u2200i, j \u2208 {1, 2, ..., NB} where i < j\ndecreasing(Sets)\n\nThe constraints ensure that each set S_i has exactly three elements, any two sets S_i and S_j have at most one element in common, and the sets are ordered in a decreasing manner (symmetry breaking).\n\nobjective: satisfy\n\nThe objective of the problem is to find a feasible solution that satisfies all the constraints, rather than optimizing a specific value. The problem is a satisfaction problem, where the goal is to find a valid assignment of values to the decision variables that meets all the constraints.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2040, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "09e314d4-f60e-4e32-ae33-6417ed6bab61": {"__data__": {"id_": "09e314d4-f60e-4e32-ae33-6417ed6bab61", "embedding": null, "metadata": {"model_name": "stoch_fjsp"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "stoch_fjsp_beginner_expert", "node_type": "4", "metadata": {"model_name": "stoch_fjsp"}, "hash": "9cbb7dfc2174aeee41ada796deeaf2898f87d7f37fee7d6a433104a7c4a305c0", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Stochastic General Assignment Problem**\n\n**What is the problem about in everyday terms?**\nImagine you have a set of tasks that need to be completed on different machines. Each task has a specific duration, and some tasks are optional. You want to assign these tasks to the machines in a way that minimizes the total time it takes to complete all the tasks.\n\n**What are the main variables and what do they mean?**\n\n* **Machines**: These are the devices that will perform the tasks.\n* **Jobs**: These are groups of tasks that need to be completed.\n* **Tasks**: These are the individual activities that need to be performed.\n* **Optional tasks**: These are tasks that may or may not be completed.\n* **Start time**: This is the time when a task starts.\n* **Duration**: This is the time it takes to complete a task.\n* **b**: This is a variable that indicates whether an optional task is executed or not.\n\n**What are the basic restrictions or rules of the problem?**\n\n* Each task must be assigned to a machine.\n* A task cannot start before the previous task in the same job is completed.\n* The duration of a task must be within a certain range.\n* Optional tasks have specific durations and may or may not be executed.\n* The total time it takes to complete all tasks on a machine cannot exceed a certain limit.\n\n**What is the goal of the problem?**\nThe goal is to minimize the expected total time it takes to complete all tasks, considering the uncertainty in the task durations.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Stochastic General Assignment Problem\n\ndescription: The Stochastic General Assignment Problem is a variant of the classic assignment problem, where tasks need to be assigned to machines and scheduled to minimize the expected makespan. The problem is stochastic because the processing times of the tasks are uncertain and are represented by multiple scenarios. The problem involves two stages: in the first stage, tasks are assigned to machines, and in the second stage, the tasks are scheduled on the machines based on the observed processing times.\n\nvariables: `start[s,t], dur[s,t], b[o], de_objective[s], objective`\n\n* `start[s,t]`: the start time of task `t` in scenario `s`\n* `dur[s,t]`: the duration of task `t` in scenario `s`\n* `b[o]`: a boolean variable indicating whether optional task `o` is executed\n* `de_objective[s]`: the makespan of scenario `s`\n* `objective`: the expected makespan over all scenarios\n\nconstraints: \n`start[s,i] + dur[s,i] <= start[s,i + 1], \ndur[s,t] = optt_dur[s,o] <-> b[o], \nsum(o in optts[t])(bool2int(b[o])) <= 1, \nexists(o in optts[t])(b[o]), \nb[o1] <-> not(b[o2]), \ncumulative(start, dur, b, 1), \nstart[s,last_task[j]] + dur[s,last_task[j]] <= de_objective[s], \nobjective = sum(s in SCENARIOS)(weights[s]*de_objective[s])`\n\n* Precedence relations: each task must start after its predecessor\n* Duration constraints: the duration of a task is equal to the duration of the selected optional task\n* Optional tasks' constraints: at most one optional task can be executed for each task, and if an optional task is executed, its duration is used\n* Resource constraints: the cumulative duration of tasks on each machine does not exceed the machine's capacity\n* Objective constraint: the makespan of each scenario is the maximum completion time of all tasks\n* Objective function: the expected makespan over all scenarios\n\nobjective: Minimize the expected makespan over all scenarios.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 3591, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c55e1a44-e9d6-41b4-961f-48f12424c8c5": {"__data__": {"id_": "c55e1a44-e9d6-41b4-961f-48f12424c8c5", "embedding": null, "metadata": {"model_name": "submultisetsum"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "submultisetsum_beginner_expert", "node_type": "4", "metadata": {"model_name": "submultisetsum"}, "hash": "7aee6879a108807d48800caff8077486c3fde88ba971f04f6f6d3878c35182d0", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **The Subset Sum Problem**\n\n**What the problem is about in everyday terms:**\nImagine you have a set of items, each with a specific weight or value. You want to select a subset of these items such that their total weight or value adds up to a specific target value.\n\n**Main variables and their meanings:**\n\n* `number`: an array of integers representing the weights or values of the items.\n* `target`: an integer representing the target value we want to reach.\n* `selected`: a set of integers representing the indices of the items we choose to include in our subset.\n\n**Basic restrictions or rules:**\n\n* We can only choose items from the given set.\n* The total weight or value of the selected items must equal the target value.\n\n**Goal of the problem:**\nFind a subset of items such that their total weight or value adds up to the target value.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Subset Sum Problem\n\ndescription: The Subset Sum Problem is a classic problem in computer science and mathematics that involves finding a subset of a given set of integers that sums up to a target value.\n\nvariables: selected \u2286 NUMBER\nThe decision variable is a set of indices selected from the set NUMBER, which represents the subset of numbers to be selected.\n\nconstraints: \u2211(i \u2208 selected) number[i] = target\nThe constraint ensures that the sum of the numbers corresponding to the selected indices is equal to the target value.\n\nobjective: satisfy\nThe objective of the problem is to find a feasible solution that satisfies the constraint, i.e., to find a subset of numbers that sums up to the target value.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1749, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "413fd4c3-f1ce-40c8-9fce-4a102e912125": {"__data__": {"id_": "413fd4c3-f1ce-40c8-9fce-4a102e912125", "embedding": null, "metadata": {"model_name": "table_seating"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "table_seating_beginner_expert", "node_type": "4", "metadata": {"model_name": "table_seating"}, "hash": "da08788b0de91acb0d9218033a4e6b48b86bad271ea7854d86aa8388366e6187", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **The Seating Arrangement Problem**\n\nThis problem is about arranging people at tables for a dinner or a party. Imagine you have a certain number of people and a certain number of tables, and each table can only fit a certain number of people.\n\n**Main Variables:**\n\n* `n`: The total number of people.\n* `T`: The number of tables.\n* `S`: The maximum number of people that can sit at each table.\n* `couples`: Pairs of people who want to sit together.\n* `key`: A set of special people who cannot sit together.\n* `table`: An array that shows which people are sitting at each table.\n* `seat`: An array that shows which table each person is sitting at.\n\n**Basic Restrictions or Rules:**\n\n* Each table can only fit a certain number of people (S).\n* Each person must sit at a table.\n* Couples want to sit together at the same table.\n* Special people in the `key` set cannot sit together.\n\n**Goal:**\n\nThe goal is to find a seating arrangement that minimizes the total table numbers of all couples. In other words, we want to find a way to seat the couples together at tables with the lowest possible table numbers.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Social Golfers Problem\n\ndescription: The Social Golfers Problem is a classic constraint satisfaction problem that involves assigning golfers to tables of a fixed size, subject to certain constraints. The problem is to find an assignment that minimizes the total sum of table numbers for all couples.\n\nvariables: table[t] (t in TABLE), seat[p] (p in PERSON)\n\nThe decision variables are table[t], which represents the set of people assigned to table t, and seat[p], which represents the table number assigned to person p.\n\nconstraints: \nforall(t in TABLE)(card(table[t]) <= S), \nforall(p in PERSON)(exists(t in TABLE)(p in table[t])), \nforall(c in index_set_1of2(couples))(not_same_table(couples[c,1],couples[c,2])), \nforall(p1,p2 in key where p1 < p2)(not_same_table(p1,p2)), \nforall(t in TABLE, p in PERSON)(p in table[t] <-> seat[p] = t)\n\nThe constraints ensure that each table has at most S people, each person is assigned to a table, couples are not assigned to the same table, people in the key set are not assigned to the same table, and the relationship between table and seat variables is maintained.\n\nobjective: minimize obj\n\nThe objective is to minimize the total sum of table numbers for all couples, where obj is the sum of table numbers for each couple.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2571, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "03cde710-c624-4179-8be7-259bf1a346f2": {"__data__": {"id_": "03cde710-c624-4179-8be7-259bf1a346f2", "embedding": null, "metadata": {"model_name": "teamselect"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "teamselect_beginner_expert", "node_type": "4", "metadata": {"model_name": "teamselect"}, "hash": "108e7bdf4f8001f82e8c434fd782c33084c473ef2ef0787865ff2cab2899eed2", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Team Selection Problem**\n\nThis problem is about selecting three teams of six players each from a pool of 11 players. The teams are named Xavier, Yuri, and Zena.\n\n**Main Variables:**\n\n* Xavier, Yuri, and Zena: These are the three teams, each consisting of six players.\n* PLAYER: This is the set of all 11 players.\n* GOALIE, DEFENCE, and OFFENCE: These are subsets of players with specific roles (goalie, defense, and offense).\n* value: This is a table that shows the value or score of each player.\n\n**Basic Restrictions or Rules:**\n\n* Each team must have exactly six players.\n* Each team must have at least one goalie, two defense players, and two offense players.\n* No more than two players can be shared between any two teams.\n\n**Goal:**\n\nThe goal is to select the teams in a way that maximizes the total value or score of all three teams.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Team Selection Problem\n\ndescription: The Team Selection Problem is a classic problem in constraint programming that involves selecting three teams of six players each from a pool of 11 players, such that each team has at least one goalie, two defenders, and two forwards, and the total value of the players in each team is maximized.\n\nvariables: Xavier, Yuri, Zena \u2286 {1, ..., 11} \nThese variables represent the sets of players selected for each of the three teams, Xavier, Yuri, and Zena.\n\nconstraints: \ncard(Xavier) = 6, card(Yuri) = 6, card(Zena) = 6 \nThese constraints ensure that each team has exactly six players.\n\ncard(Xavier \u2229 GOALIE) \u2265 1, card(Yuri \u2229 GOALIE) \u2265 1, card(Zena \u2229 GOALIE) \u2265 1 \nThese constraints ensure that each team has at least one goalie.\n\ncard(Xavier \u2229 DEFENCE) \u2265 2, card(Yuri \u2229 DEFENCE) \u2265 2, card(Zena \u2229 DEFENCE) \u2265 2 \nThese constraints ensure that each team has at least two defenders.\n\ncard(Xavier \u2229 OFFENCE) \u2265 2, card(Yuri \u2229 OFFENCE) \u2265 2, card(Zena \u2229 OFFENCE) \u2265 2 \nThese constraints ensure that each team has at least two forwards.\n\ncard(Xavier \u2229 Yuri) \u2264 2, card(Xavier \u2229 Zena) \u2264 2 \nThese constraints ensure that no more than two players are shared between any two teams.\n\nobjective: maximize \u2211(c in CAPTAIN)(\u2211(p in team[c])(value[c,p])) \nThe objective is to maximize the total value of the players in all three teams.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2389, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a710d984-d82b-48bb-952f-e2bc9f18dafd": {"__data__": {"id_": "a710d984-d82b-48bb-952f-e2bc9f18dafd", "embedding": null, "metadata": {"model_name": "template_design"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "template_design_beginner_expert", "node_type": "4", "metadata": {"model_name": "template_design"}, "hash": "9e806f530c118bcfebfff5a34ceb0f22345d23e9bc2b9e314513accfc86ebbef", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Template Design Problem**\n\nThis problem is about printing different variations of a product, like different flavors of a snack or different colors of a t-shirt. We need to decide how many of each variation to print and how to organize the printing process to minimize waste.\n\n**Main variables:**\n\n* `S`: The number of slots available on a printing template.\n* `t`: The number of printing templates.\n* `n`: The number of different variations of the product.\n* `d`: An array that tells us how many of each variation we need to print.\n* `p`: A 2D array that tells us how many slots on each template are allocated to each variation.\n* `R`: An array that tells us how many times each template is pressed (i.e., how many copies are made).\n* `Production`: The total number of items printed.\n* `Surplus`: The amount of waste or extra items printed.\n\n**Basic restrictions:**\n\n* Each template has `S` slots, and we need to allocate them to the different variations.\n* We need to print at least `d` items of each variation.\n* The total number of items printed (`Production`) is between `llower` and `lupper`, which are calculated based on the number of slots and the number of variations.\n* The surplus (waste) is limited by the total production.\n\n**Goal:**\n\nThe goal is to minimize the total production (i.e., the number of items printed) while meeting the demands for each variation and following the rules for allocating slots on the templates.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Template Design Problem\n\ndescription: The Template Design Problem is a classic problem in constraint programming that involves designing templates for printing variations of a product. The goal is to determine the optimal allocation of slots on each template to meet the demand for each variation while minimizing the total production.\n\nvariables: p[i, j], R[j], Production, Surplus\n\np[i, j] represents the number of slots allocated to variation i in template j. R[j] represents the number of pressings of template j. Production represents the total number of pressings. Surplus represents the excess production beyond the total demand.\n\nconstraints: \nProduction = sum(R[j]), \nProduction >= llower /\\ Production <= lupper, \nsum(p[i, j]) = S, \nsum(p[i, j]*R[j]) >= d[i], \nlex_lesseq([p[i,  j] | j in 1..t], [p[i+1,j] | j in 1..t]), \nsum(p[i, j]*R[j]) <= sum(p[i+1, j]*R[j]), \nSurplus = Production*S - sum(d[i]), \nsum(p[k, j]*R[j]-d[k]) <= Surplus, \nsum(p[m, j]*R[j]-d[m]) <= Surplus, \nR[1] <= Production div 2, \nR[2] >= Production div 2, \nR[1] <= Production div 3, \nR[2] <= Production div 2, \nR[3] >= Production div 3\n\nThese constraints ensure that the total production is the sum of the pressings, the production is within the bounds, each template has S slots, the demand for each variation is met, symmetry and pseudo-symmetry constraints are satisfied, the surplus is correctly calculated, and the run length constraints are satisfied.\n\nobjective: minimize Production", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 3110, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7d42eaba-f0b2-47b7-b14e-23c3695ed353": {"__data__": {"id_": "7d42eaba-f0b2-47b7-b14e-23c3695ed353", "embedding": null, "metadata": {"model_name": "toomany"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "toomany_beginner_expert", "node_type": "4", "metadata": {"model_name": "toomany"}, "hash": "b3b30ae57f5b680f7b4e8488ec5ef7ded7348415f74d99ffb56e0aa87d2759aa", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Problem Name:** TooMany\n\n**What the problem is about:** Imagine you have a factory with several machines that can produce different colored products (red, white, black, and blue) every day. Each machine can produce a certain amount of each color, and there are rules about how much of each color can be produced.\n\n**Main variables:**\n\n* `n`: The number of machines in the factory.\n* `k`: The total amount of products that can be produced per day.\n* `produce[m,c]`: The amount of color `c` produced by machine `m`.\n\n**Basic restrictions or rules:**\n\n* Each machine can produce at most `k` products per day.\n* The total amount of each color produced by all machines must be within a certain range (defined by `l` and `u`).\n* If a machine produces white and black products, it cannot produce blue products.\n* The amount of blue products produced by a machine cannot be more than the amount of red products.\n* The amount of red products produced by a machine must be a multiple of 4.\n* The amount of white products produced by a machine must be a multiple of 3.\n\n**Goal of the problem:** The goal is to maximize the total amount of products produced by all machines while following the rules and restrictions.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Production Planning Problem\n\ndescription: This problem involves planning the production of different colored items on multiple machines, subject to various constraints on the production capacity of each machine and the total production of each color. The goal is to maximize the total production across all machines and colors.\n\nvariables: produce[m,c] (m \u2208 MACHINE, c \u2208 COLOR)\n\nThe decision variables represent the amount of each color produced on each machine, where produce[m,c] is the amount of color c produced on machine m.\n\nconstraints: \n\u2200m \u2208 MACHINE: \u2211(c \u2208 COLOR)(produce[m,c]) \u2264 k\n\u2200c \u2208 COLOR: \u2211(m \u2208 MACHINE)(produce[m,c]) \u2265 l[c]\n\u2200c \u2208 COLOR: \u2211(m \u2208 MACHINE)(produce[m,c]) \u2264 u[c]\n\u2200m \u2208 MACHINE: produce[m,white] > 0 \u2227 produce[m,black] > 0 \u2192 produce[m,blue] = 0\n\u2200m \u2208 MACHINE: produce[m,blue] \u2264 produce[m,red]\n\u2200m \u2208 MACHINE: produce[m,red] mod 4 = 0\n\u2200m \u2208 MACHINE: produce[m,white] mod 3 = 0\n\nThe constraints ensure that:\n- Each machine does not produce more than k units in total.\n- The total production of each color meets the lower bound l[c] and does not exceed the upper bound u[c].\n- If a machine produces both white and black, it cannot produce blue.\n- The production of blue on a machine does not exceed the production of red on the same machine.\n- The production of red on a machine is a multiple of 4.\n- The production of white on a machine is a multiple of 3.\n\nobjective: Maximize \u2211(m \u2208 MACHINE, c \u2208 COLOR)(produce[m,c])\n\nThe objective is to maximize the total production across all machines and colors.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2924, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ef56d123-cf49-4fe5-a326-73e64a01a3c1": {"__data__": {"id_": "ef56d123-cf49-4fe5-a326-73e64a01a3c1", "embedding": null, "metadata": {"model_name": "traffic_lights_table"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "traffic_lights_table_beginner_expert", "node_type": "4", "metadata": {"model_name": "traffic_lights_table"}, "hash": "c01fc789e427b83f4f99507b8665dcdc08b2215d44abd3afdbc07bb8d76539c7", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Traffic Light Problem**\n\nThis problem is about controlling traffic lights at a four-way junction. Imagine you're standing at a crossroads where four roads meet, and there are traffic lights for both cars and pedestrians.\n\n**Main Variables:**\n\n* `V1` to `V4`: These represent the traffic lights for cars, which can be red, red-yellow, green, or yellow.\n* `P1` to `P4`: These represent the traffic lights for pedestrians, which can be red or green.\n\n**Basic Restrictions or Rules:**\n\n* The traffic lights for cars and pedestrians at each intersection must follow certain rules, such as:\n\t+ When the car light is red, the pedestrian light must be red too.\n\t+ When the car light is green, the pedestrian light must be green too.\n\t+ When the car light is red-yellow, the pedestrian light must be yellow, and so on.\n\n**Goal:**\n\nThe goal is to find a sequence of traffic light settings that satisfy these rules and ensure safe and efficient traffic flow.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Traffic Lights Problem\n\ndescription: The Traffic Lights Problem is a classic constraint satisfaction problem that involves finding a valid configuration of traffic lights at a four-way junction. The problem consists of eight traffic lights, four for vehicles and four for pedestrians, each with a specific domain of possible states (red, red-yellow, green, and yellow for vehicles, and red and green for pedestrians). The goal is to find an assignment of states to the traffic lights that satisfies certain constraints, ensuring safe and efficient traffic flow.\n\nvariables: V = (V1, V2, V3, V4) \u2208 {r, ry, g, y}\u2074, P = (P1, P2, P3, P4) \u2208 {r, g}\u2074\nThe decision variables V and P represent the states of the traffic lights for vehicles and pedestrians, respectively, at each of the four intersections.\n\nconstraints: \u2200i, j \u2208 {1, 2, 3, 4} where j = (1+i) mod 4, (Vi, Pi, Vj, Pj) \u2208 {(r, r, g, g), (ry, r, y, r), (g, g, r, r), (y, r, ry, r)}\nThe constraints ensure that the traffic lights are configured in a way that allows safe and efficient traffic flow. Specifically, they enforce the rules that when a vehicle light is red, the corresponding pedestrian light is also red, and when a vehicle light is green, the corresponding pedestrian light is also green.\n\nobjective: satisfy\nThe objective of the problem is to find a feasible assignment of states to the traffic lights that satisfies all the constraints, without any specific optimization goal.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2593, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2d4b7fbf-183a-4a3e-8f8f-b0d58c0212c0": {"__data__": {"id_": "2d4b7fbf-183a-4a3e-8f8f-b0d58c0212c0", "embedding": null, "metadata": {"model_name": "TTPPV"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "TTPPV_beginner_expert", "node_type": "4", "metadata": {"model_name": "TTPPV"}, "hash": "588759dd749f0073748469f581d9578337b3ee62d5d836e1af3efef0d258b9d8", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    **Traveling Tournament Problem**\n\nThis problem is about scheduling a tournament where multiple teams play each other in a round-robin format, meaning each team plays every other team once. The twist is that each game has already been assigned a specific venue (home or away), and we want to find the schedule that minimizes the total travel distance for all teams.\n\n**Main Variables:**\n\n* `nbTeams`: The number of teams participating in the tournament.\n* `opponent[i,k]`: The team that team `i` plays against in round `k`.\n* `venue[i,k]`: Whether team `i` plays at home (1) or away (2) in round `k`.\n* `travel[i,k]`: The distance team `i` travels to play in round `k` (including the return journey after the last round).\n\n**Basic Restrictions:**\n\n* A team cannot play against itself.\n* If team `i` plays team `j` in round `k`, then team `j` plays team `i` in the same round.\n* Each team plays every other team exactly once.\n* No team can have more than three consecutive home games or away games.\n\n**Goal:**\n\nThe goal is to find a schedule that minimizes the total travel distance for all teams.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Traveling Tournament Problem with Predefined Venues\n\ndescription: The Traveling Tournament Problem with Predefined Venues is a classical problem in constraint programming that involves scheduling a round-robin tournament for a set of teams, where each team plays every other team exactly once, and the venue of each game has already been decided. The goal is to find a schedule that minimizes the total travel distance of all teams.\n\nvariables: opponent[i,k], venue[i,k], travel[i,k]\n\nThe decision variables are:\n- opponent[i,k]: the opponent of team i in round k\n- venue[i,k]: 1 if team i plays at home in round k, 2 otherwise\n- travel[i,k]: the distance travelled by team i to go play in round k (includes travelling back home after the last round)\n\nconstraints: \nopponent[i,k] != i, \nopponent[opponent[i,k],k] = i, \nalldifferent([opponent[i,k] | k in Rounds]), \nalldifferent([opponent[i,k] | i in Teams]), \nregular( [venue[i,k] | k in Rounds], nbStates, 2, delta, 1, States), \nopponent[1,1] < opponent[1,nbRounds], \nvenue[i,k] = pv[i,opponent[i,k]], \ntravel constraints (5 constraints)\n\nThe constraints are:\n- a team cannot play against itself\n- in round k, i plays j means j plays i\n- for each team i, all opponents are different\n- for each round k, all opponents are different\n- for each team i, there can be at most 3 consecutive home games and at most 3 consecutive away games\n- symmetry breaking: distances are symmetric so reversing the rounds yields a schedule of same cost\n- the venue of each game has already been decided\n- the travel variables are defined wrt venues of current- and next-round games\n\nobjective: minimize totalTravel", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2942, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "566c8757-1aff-49da-9c8d-82c455356942": {"__data__": {"id_": "566c8757-1aff-49da-9c8d-82c455356942", "embedding": null, "metadata": {"model_name": "vessel-loading"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "vessel-loading_beginner_expert", "node_type": "4", "metadata": {"model_name": "vessel-loading"}, "hash": "07231b2bd4da7906caa83ad10c244e919b34a7c9b7bdee3f2cd63d3e514b97b5", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Vessel Loading\n\nThis problem is about loading containers onto a ship's deck. Imagine you have a bunch of boxes of different sizes and types, and you need to fit them onto a rectangular deck.\n\nThe main variables are:\n\n* The width and length of the deck\n* The number of containers and their classes (types)\n* The width, length, and class of each container\n* The minimum separation required between containers of different classes\n* The position of each container on the deck (left, right, bottom, and top coordinates)\n* The orientation of each container (whether it's turned 90 degrees or not)\n\nThe basic restrictions or rules of the problem are:\n\n* Each container must fit within the deck's boundaries\n* Containers cannot overlap with each other\n* Containers of different classes must be separated by a minimum distance\n\nThe goal of the problem is to find a way to load all the containers onto the deck while following these rules.\n\nNote: The output section of the code is used to print a visual representation of the loaded containers, but it's not essential to understanding the problem itself.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Vessel Loading Problem\n\ndescription: The Vessel Loading Problem is a classic problem in constraint programming that involves loading a set of containers of different sizes and classes onto a vessel with a fixed deck width and length, subject to certain constraints. The goal is to find an arrangement of containers on the deck that maximizes the use of space while satisfying the constraints.\n\nvariables: \nLeft[c], Right[c], Bottom[c], Top[c] \u2208 {0, ..., deck_width} \u00d7 {0, ..., deck_length}, orientation[c] \u2208 {1, 2}\n\nThese variables represent the position and orientation of each container c on the deck. Left[c] and Right[c] are the leftmost and rightmost points of container c, respectively, while Bottom[c] and Top[c] are the bottommost and topmost points, respectively. The orientation variable determines whether the container is placed horizontally (orientation[c] = 1) or vertically (orientation[c] = 2).\n\nconstraints: \n\u2200c \u2208 Containers, Right[c] = Left[c] + ElemWidth[orientation[c]] \u2227 Top[c] = Bottom[c] + ElemLength[orientation[c]]\n\u2200c, k \u2208 Containers, c < k, Left[c] \u2265 Right[k] + separation[class[c], class[k]] \u2228 ... (three more disjuncts)\n\nThe first constraint ensures that the width and length of each container are correctly calculated based on its orientation. The second constraint ensures that containers of different classes are separated by a minimum distance, specified by the separation matrix.\n\nobjective: \nThere is no explicit objective function in this model. The goal is to find a feasible arrangement of containers that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 2870, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c4c1ac9d-fb86-43c6-9f4e-714007b2e02b": {"__data__": {"id_": "c4c1ac9d-fb86-43c6-9f4e-714007b2e02b", "embedding": null, "metadata": {"model_name": "warehouses"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "warehouses_beginner_expert", "node_type": "4", "metadata": {"model_name": "warehouses"}, "hash": "f7bf16bd5a9d14f09b22acd0fe51d853124c9907d68919937a8dd2c5ccec81be", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Warehouse Allocation Problem\n\nThis problem is about a company that wants to build warehouses to supply goods to stores. The company needs to decide which warehouses to build and which stores each warehouse should supply to minimize the total cost.\n\nThe main variables are:\n\n* Warehouses: These are the places where the company will store goods.\n* Stores: These are the places where the company will send goods from the warehouses.\n* Capacity: This is the number of stores that each warehouse can supply.\n* Cost: This is the cost of building a warehouse and transporting goods from the warehouse to the stores.\n\nThe basic restrictions or rules of the problem are:\n\n* Each warehouse can only supply a certain number of stores based on its capacity.\n* Each store must be supplied by only one warehouse.\n* The company wants to minimize the total cost, which includes the cost of building warehouses and transporting goods.\n\nThe goal of the problem is to find the best way to allocate warehouses to stores to minimize the total cost.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Warehouse Allocation Problem\n\ndescription: The Warehouse Allocation Problem is a classic problem in operations research and logistics. It involves determining the optimal allocation of warehouses to supply stores with goods, while minimizing the overall cost, which includes the construction cost of warehouses and the transportation cost from warehouses to stores.\n\nvariables: \nsupplier[i] \u2208 {1, ..., n_suppliers}, open[i] \u2208 {true, false}, cost[i] \u2208 {1, ..., MaxCost}, tot \u2208 {1, ..., MaxTotal}\n\nThe decision variables are:\n- supplier[i]: the warehouse that supplies store i\n- open[i]: a boolean indicating whether warehouse i is constructed or not\n- cost[i]: the transportation cost from the warehouse that supplies store i to store i\n- tot: the total cost, which is the sum of the construction costs of the warehouses and the transportation costs from the warehouses to the stores\n\nconstraints: \n\u2211(i in 1..n_suppliers) (building_cost * bool2int(open[i])) + \u2211(i in 1..n_stores) (cost[i]) = tot\ncost_matrix[i,supplier[i]] = cost[i]\ncount(supplier,i,use) \u2227 use \u2264 capacity[i]\n(exists (j in 1..n_stores) (supplier[j] == i)) == open[i]\n\nThe constraints are:\n- The total cost is the sum of the construction costs of the warehouses and the transportation costs from the warehouses to the stores\n- The transportation cost from the warehouse that supplies store i to store i is equal to the cost_matrix value at the corresponding row and column\n- The number of stores supplied by warehouse i does not exceed its capacity\n- A warehouse is constructed if and only if it supplies at least one store\n\nobjective: \nminimize tot\n\nThe objective is to minimize the total cost, which is the sum of the construction costs of the warehouses and the transportation costs from the warehouses to the stores.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 3014, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "73337856-f433-4527-bcd7-bb46331d6a2b": {"__data__": {"id_": "73337856-f433-4527-bcd7-bb46331d6a2b", "embedding": null, "metadata": {"model_name": "water_buckets1"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "water_buckets1_beginner_expert", "node_type": "4", "metadata": {"model_name": "water_buckets1"}, "hash": "b7bd492e5c6d78c3d05195987b043bf9732ccefc20fea7d83550d3e752927e38", "class_name": "RelatedNodeInfo"}}, "text": "Description 1:\n                    ------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Water Buckets Problem\n\n**What the problem is about in everyday terms:** Imagine you have three buckets of different sizes (8, 5, and 3 pints) and you want to divide a certain amount of water between them in a specific way. You can pour water from one bucket to another, but you want to do it in the fewest number of steps possible.\n\n**Main variables and what they mean:**\n\n* `state`: an array that represents the amount of water in each bucket at each step\n* `goal_step`: the number of steps it takes to reach the desired goal\n* `buckets`: the three buckets of different sizes\n* `capacity`: the maximum amount of water each bucket can hold\n* `start` and `goal`: the initial and desired amounts of water in each bucket\n\n**Basic restrictions or rules of the problem:**\n\n* The total amount of water remains the same at each step\n* The amount of water in each bucket can only change by pouring water from one bucket to another\n* After each step, either the source bucket becomes empty or the target bucket becomes full\n* The goal is to reach the desired amounts of water in each bucket in the fewest number of steps possible\n\n**Goal of the problem:** Minimize the number of steps (`goal_step`) it takes to reach the desired goal.\n\nNote that Model 2 appears to be a different problem, but it's actually a reformulation of the same Water Buckets Problem using a different modeling approach.\n                    ======\n                    Description 2:\n                    ---------\n                    name: Water Buckets Problem\n\ndescription: The Water Buckets Problem is a classic problem in constraint programming. It involves dividing a certain amount of water into two buckets of specific capacities using a series of pouring operations. The goal is to find the minimum number of transfers required to achieve a specific goal configuration of water in the buckets.\n\nvariables: `state[steps, buckets]`, `goal_step`\n\nThe decision variables are `state[steps, buckets]`, which represents the amount of water in each bucket at each time step, and `goal_step`, which represents the minimum number of steps required to reach the goal configuration.\n\nconstraints: \n`start[b] <= capacity[b]`, `goal[b] <= capacity[b]`, \n`sum(b in buckets)(start[b]) = sum(b in buckets)(goal[b])`, \n`state[1,b]=start[b]`, `state[goal_step,b] = goal[b]`, \n`sum(b in buckets)(bool2int(state[step,b] != state[step+1, b])) = 2`, \n`sum(b in buckets)(state[step,b]) = sum(b in buckets)(state[step+1,b])`, \n`((state[step, b1] != state[step+1, b1]) /\\ (state[step, b2] != state[step, b2])) -> (state[step+1,b1] = 0 \\/ state[step+1,b1] = capacity[b1] \\/ state[step+1,b2] = 0 \\/ state[step+1,b2] = capacity[b2])`\n\nThe constraints ensure that the initial and goal configurations are within the capacity of the buckets, the total amount of water is conserved, the initial and goal configurations are reached, exactly two buckets change in each step, the total amount of water is conserved in each step, and the pouring operation is valid (i.e., the source bucket becomes empty or the target bucket becomes full).\n\nobjective: `minimize goal_step`\n\nThe objective is to minimize the number of steps required to reach the goal configuration.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 3347, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"all_interval_beginner_expert": {"node_ids": ["10a41c3b-825b-437d-9603-32ba9a8109fb"], "metadata": {"model_name": "all_interval"}}, "assign_beginner_expert": {"node_ids": ["502510e6-38a7-4f69-80f3-e7b5fd36b3f1"], "metadata": {"model_name": "assign"}}, "aust_color_beginner_expert": {"node_ids": ["4ea733f0-ef9b-45ce-9133-e561ab85407d"], "metadata": {"model_name": "aust_color"}}, "bibd_beginner_expert": {"node_ids": ["eaf3b20c-6c20-47bf-95f1-9751559b7b5c"], "metadata": {"model_name": "bibd"}}, "bus_scheduling_csplib_beginner_expert": {"node_ids": ["aeeb0fa8-de5f-42cf-ae23-aa57d34654af"], "metadata": {"model_name": "bus_scheduling_csplib"}}, "car_beginner_expert": {"node_ids": ["b382bc22-daf9-4074-88c4-74ae612b0152"], "metadata": {"model_name": "car"}}, "carpet_cutting_beginner_expert": {"node_ids": ["eb87af12-3413-4931-b4c7-ce06229d7cb0"], "metadata": {"model_name": "carpet_cutting"}}, "cell_block_beginner_expert": {"node_ids": ["13644c23-51d7-497c-b413-0e596d99578e"], "metadata": {"model_name": "cell_block"}}, "clique_beginner_expert": {"node_ids": ["a9200264-3493-4081-a936-f164b53dd568"], "metadata": {"model_name": "clique"}}, "cluster_beginner_expert": {"node_ids": ["c6cd639e-6b0e-4e96-952b-c05a0d4a89d2"], "metadata": {"model_name": "cluster"}}, "compatible_assignment_beginner_expert": {"node_ids": ["a69b543f-2323-45d2-9147-06e7a484fbc1"], "metadata": {"model_name": "compatible_assignment"}}, "constrained_connected_beginner_expert": {"node_ids": ["7a92bcc8-ddb9-41e1-8a96-ecedf3eb747e"], "metadata": {"model_name": "constrained_connected"}}, "crazy_sets_beginner_expert": {"node_ids": ["36a1cf45-c299-449d-82ad-a436ed119432"], "metadata": {"model_name": "crazy_sets"}}, "crossfigure_beginner_expert": {"node_ids": ["c96c9bcc-b8bb-4755-bfc0-aaf3a818979c"], "metadata": {"model_name": "crossfigure"}}, "curriculum_beginner_expert": {"node_ids": ["564060f0-af90-421e-8f1a-ee30cf9e957b"], "metadata": {"model_name": "curriculum"}}, "diamond_free_degree_sequence_beginner_expert": {"node_ids": ["31d4889c-203a-4ca4-b3f0-2989f1ec8720"], "metadata": {"model_name": "diamond_free_degree_sequence"}}, "doublechannel_beginner_expert": {"node_ids": ["3de27e3f-d51b-4219-ba6c-47518d3b1855"], "metadata": {"model_name": "doublechannel"}}, "fractions_beginner_expert": {"node_ids": ["f21ae6b8-2269-4cd6-a51e-3d952387a666"], "metadata": {"model_name": "fractions"}}, "golfers_beginner_expert": {"node_ids": ["b6b5bf31-c85b-4bda-91f3-5ea35c333f6a"], "metadata": {"model_name": "golfers"}}, "golomb_beginner_expert": {"node_ids": ["b54533e8-e76c-4cbc-83d7-826257e2ec23"], "metadata": {"model_name": "golomb"}}, "graph_beginner_expert": {"node_ids": ["91d12d56-bdf2-4c0f-9071-e33a01698ec4"], "metadata": {"model_name": "graph"}}, "itemset_mining_beginner_expert": {"node_ids": ["a2141adc-f942-4133-9ee0-29133809f49e"], "metadata": {"model_name": "itemset_mining"}}, "jobshop_beginner_expert": {"node_ids": ["4ab0855e-03ec-4271-bc5d-6c83520be420"], "metadata": {"model_name": "jobshop"}}, "K4xP2Graceful_beginner_expert": {"node_ids": ["9f80b197-588b-4250-93cd-6139f70fca12"], "metadata": {"model_name": "K4xP2Graceful"}}, "killer_sudoku_beginner_expert": {"node_ids": ["f1501c1b-dbb5-47fb-b8c4-b62776d02787"], "metadata": {"model_name": "killer_sudoku"}}, "knapsack_beginner_expert": {"node_ids": ["4031cb6b-f2fd-4d2d-a074-9f9b1fb8a879"], "metadata": {"model_name": "knapsack"}}, "langford_beginner_expert": {"node_ids": ["919a8845-f00f-413f-b82d-bb122f665cc2"], "metadata": {"model_name": "langford"}}, "loan_beginner_expert": {"node_ids": ["a0f71dd3-2577-4c74-afd4-f2a41c55bbe0"], "metadata": {"model_name": "loan"}}, "ltsp_beginner_expert": {"node_ids": ["441f92ef-4998-4014-a630-2276a79f8eab"], "metadata": {"model_name": "ltsp"}}, "magic_hexagon_beginner_expert": {"node_ids": ["9bcaca8d-87ad-4e82-83c9-3519d6186f7d"], "metadata": {"model_name": "magic_hexagon"}}, "magic_sequence_beginner_expert": {"node_ids": ["2d6c539e-bed2-4de0-b4b0-c3c49e80c89f"], "metadata": {"model_name": "magic_sequence"}}, "maximum_density_still_life_beginner_expert": {"node_ids": ["5c9b6aaf-6639-4a08-9512-a17bc3b672c6"], "metadata": {"model_name": "maximum_density_still_life"}}, "mip_beginner_expert": {"node_ids": ["bdd3450b-722b-4d06-876d-6e354c285337"], "metadata": {"model_name": "mip"}}, "missing_solution_beginner_expert": {"node_ids": ["1cc311cd-0939-49d7-9810-ef181b1b85d1"], "metadata": {"model_name": "missing_solution"}}, "nonogram_create_automaton2_beginner_expert": {"node_ids": ["17562cb6-b29c-4d38-9656-fed7bcd463e5"], "metadata": {"model_name": "nonogram_create_automaton2"}}, "nurses_beginner_expert": {"node_ids": ["6c0f0626-9c1f-46f1-a260-90ca703d6834"], "metadata": {"model_name": "nurses"}}, "opd_beginner_expert": {"node_ids": ["bf60802e-6c34-405f-8415-fbff0aac98c6"], "metadata": {"model_name": "opd"}}, "partition_beginner_expert": {"node_ids": ["08844db2-f742-4667-a653-dde01e76e51a"], "metadata": {"model_name": "partition"}}, "photo_beginner_expert": {"node_ids": ["f87ba9d8-bd1f-4208-bc54-9eeba153bfe4"], "metadata": {"model_name": "photo"}}, "project_scheduling_beginner_expert": {"node_ids": ["d13ef289-8446-44d0-95bd-a39e3d16e05c"], "metadata": {"model_name": "project_scheduling"}}, "QuasigroupCompletion_beginner_expert": {"node_ids": ["da7ea70a-b481-42b4-8872-b77a47e28ddb"], "metadata": {"model_name": "QuasigroupCompletion"}}, "QuasiGroupExistence_beginner_expert": {"node_ids": ["32f176d6-92c5-4941-b074-336ccf863065"], "metadata": {"model_name": "QuasiGroupExistence"}}, "queens_beginner_expert": {"node_ids": ["8007fb48-f42c-47dd-b33a-44d6e8a80d8b"], "metadata": {"model_name": "queens"}}, "rcpsp_beginner_expert": {"node_ids": ["9f575d86-aef4-4a8c-a5ce-7624de1ce454"], "metadata": {"model_name": "rcpsp"}}, "rehearsal_beginner_expert": {"node_ids": ["90833a59-9f76-4f0e-b7a1-e1d6c6b055ec"], "metadata": {"model_name": "rehearsal"}}, "restart_beginner_expert": {"node_ids": ["b1f58f26-7b1b-4f3f-88e5-c8e9ed95a536"], "metadata": {"model_name": "restart"}}, "RosteringProblem_beginner_expert": {"node_ids": ["66d30a23-3825-424b-8f69-193f98bf99f4"], "metadata": {"model_name": "RosteringProblem"}}, "sb_beginner_expert": {"node_ids": ["1fc4024d-6423-447f-858e-7e58c9f10a3a"], "metadata": {"model_name": "sb"}}, "schur_beginner_expert": {"node_ids": ["48c52e70-f43e-43f2-8e86-cd5b6d81d107"], "metadata": {"model_name": "schur"}}, "setselect_beginner_expert": {"node_ids": ["6267f07d-f1a6-4f1c-844c-4bf452fa805a"], "metadata": {"model_name": "setselect"}}, "shipping_beginner_expert": {"node_ids": ["5037c1c5-9780-4897-bb81-789ba80876d4"], "metadata": {"model_name": "shipping"}}, "simple-prod-planning_beginner_expert": {"node_ids": ["f60fdec3-676c-4a65-a02a-db16ae35dd4d"], "metadata": {"model_name": "simple-prod-planning"}}, "sonet_problem_beginner_expert": {"node_ids": ["31c36fa2-d800-4eac-839e-987a1286ccdf"], "metadata": {"model_name": "sonet_problem"}}, "square_pack_beginner_expert": {"node_ids": ["8760ac65-5154-4be7-8bb5-1f2d2cc1840b"], "metadata": {"model_name": "square_pack"}}, "stableroommates_beginner_expert": {"node_ids": ["9b656723-e1cd-42c9-9d34-ccb177763904"], "metadata": {"model_name": "stableroommates"}}, "steiner_beginner_expert": {"node_ids": ["60a56f2c-939f-419d-ac47-c4678591eb3b"], "metadata": {"model_name": "steiner"}}, "stoch_fjsp_beginner_expert": {"node_ids": ["09e314d4-f60e-4e32-ae33-6417ed6bab61"], "metadata": {"model_name": "stoch_fjsp"}}, "submultisetsum_beginner_expert": {"node_ids": ["c55e1a44-e9d6-41b4-961f-48f12424c8c5"], "metadata": {"model_name": "submultisetsum"}}, "table_seating_beginner_expert": {"node_ids": ["413fd4c3-f1ce-40c8-9fce-4a102e912125"], "metadata": {"model_name": "table_seating"}}, "teamselect_beginner_expert": {"node_ids": ["03cde710-c624-4179-8be7-259bf1a346f2"], "metadata": {"model_name": "teamselect"}}, "template_design_beginner_expert": {"node_ids": ["a710d984-d82b-48bb-952f-e2bc9f18dafd"], "metadata": {"model_name": "template_design"}}, "toomany_beginner_expert": {"node_ids": ["7d42eaba-f0b2-47b7-b14e-23c3695ed353"], "metadata": {"model_name": "toomany"}}, "traffic_lights_table_beginner_expert": {"node_ids": ["ef56d123-cf49-4fe5-a326-73e64a01a3c1"], "metadata": {"model_name": "traffic_lights_table"}}, "TTPPV_beginner_expert": {"node_ids": ["2d4b7fbf-183a-4a3e-8f8f-b0d58c0212c0"], "metadata": {"model_name": "TTPPV"}}, "vessel-loading_beginner_expert": {"node_ids": ["566c8757-1aff-49da-9c8d-82c455356942"], "metadata": {"model_name": "vessel-loading"}}, "warehouses_beginner_expert": {"node_ids": ["c4c1ac9d-fb86-43c6-9f4e-714007b2e02b"], "metadata": {"model_name": "warehouses"}}, "water_buckets1_beginner_expert": {"node_ids": ["73337856-f433-4527-bcd7-bb46331d6a2b"], "metadata": {"model_name": "water_buckets1"}}}}