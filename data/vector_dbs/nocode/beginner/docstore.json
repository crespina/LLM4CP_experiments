{"docstore/metadata": {"all_interval_beginner": {"doc_hash": "aaf4b00f7bb0e53a205e0a54aa8a8f48a6252b44612a61ca57508a653d5d8e6c"}, "assign_beginner": {"doc_hash": "45aab47657256ccda8465540557bff4c424fe8492c9f9691881f24a1ab151b73"}, "aust_color_beginner": {"doc_hash": "4fd5e7dca9472204d7dcf0e027f5fa52fd5b3ba1854db55ecd8d371510bac6fb"}, "bibd_beginner": {"doc_hash": "e17e950b3ac51beb40589b6661a3873aa05135beaea02cc722071c83fc2ab92c"}, "bus_scheduling_csplib_beginner": {"doc_hash": "54effe0b9f125e014390e3d4fd6443b45127436f4fc6af8c70be64345e2e5ad4"}, "car_beginner": {"doc_hash": "91d7893915e61d771d50598b48ed8de4a73638f901bea94ec3023f20f950d98d"}, "carpet_cutting_beginner": {"doc_hash": "9500ee2ab3aff18d871b5d606d34e9c169807dcc17a5c0e57d1a54a40d9760d9"}, "cell_block_beginner": {"doc_hash": "f10b9e7b0d92d36da224a39d312c2a5df4841b727e20d383e8da5abad83b8db8"}, "clique_beginner": {"doc_hash": "7db0763fba0a0a3db8e5fb1bd8e9d124271f92c320b43bb9ef170605d63b3817"}, "cluster_beginner": {"doc_hash": "c241e909824058675d30a9a175883d7e2e6ced43e69666f5af1c5755063ad7a4"}, "compatible_assignment_beginner": {"doc_hash": "0655d45b5c812c285fef1f2a2fa715258a7e2ab9514f19ba44c95c9ccde4898b"}, "constrained_connected_beginner": {"doc_hash": "35b9463c75dbd3e7decfee699369acb4e3f615eb8a487885da2916b44ea56e1f"}, "crazy_sets_beginner": {"doc_hash": "a3ec6a0551ddfcf027c3fa478afc5c783688bf66baa7b767bb30c38da0047602"}, "crossfigure_beginner": {"doc_hash": "5ee1c48fc13794a10fb553984e2270ba55d5adcbce9f273d8899277085b6f46f"}, "curriculum_beginner": {"doc_hash": "fb6f504391c7f74a1843b1cbe36275b7148d5e8cfc924f6e438eb3f3c3e50351"}, "diamond_free_degree_sequence_beginner": {"doc_hash": "0ba3f3e0047d6658da997050a326a1cfceb98ae805e296f54d19dd43242f7171"}, "doublechannel_beginner": {"doc_hash": "4604d610d322c03ee95eb248e05dc440847efd43f0d38c19918baa11c02d54a7"}, "fractions_beginner": {"doc_hash": "c2524becb0f733bc12d9d4bcfba8fad5b357a17c82c22c7f7c341080376fb2ac"}, "golfers_beginner": {"doc_hash": "1561e3cf7cf484740a64afde3b05fc66d71fca4e34f3c0bb5d9bc3e0a1dbe6ab"}, "golomb_beginner": {"doc_hash": "f7f31ae808c6421627d5e3662275c51e8f9f7be592f55a22adf95231ed68d426"}, "graph_beginner": {"doc_hash": "e25a9c6a3b668ec8af72dd6289740f71adedc54f2fb2a13993ab413bdf7b692c"}, "itemset_mining_beginner": {"doc_hash": "08730a81d70e1040b938145ed2e8206f2565ed9527caa181fd90c6f5adcdbfc6"}, "jobshop_beginner": {"doc_hash": "e94302e148d4934353e81a71fe5153463c4bbf13fa3e6bfa1f7338e266c7f671"}, "K4xP2Graceful_beginner": {"doc_hash": "762aafef834a304f5b0f8e37ae5b82760c65096b29e70c641ba303d2b4a55ad3"}, "killer_sudoku_beginner": {"doc_hash": "f46fce5b8c988f45d576d28491dd8131afee7a4c2f3d3ff3eee9e4b7fee844bc"}, "knapsack_beginner": {"doc_hash": "a3c9457ee1972b8fa125ab7ec6e854da9cde33893988e45ee68040c5acba9be7"}, "langford_beginner": {"doc_hash": "2d8cd18b8e31c063032d4a298c979478227d115d089c87f7cfb35654ac523847"}, "loan_beginner": {"doc_hash": "e66f44bfa025c1a49afee5c40a2b6b2f89fc8ad7a2957106ec3ce5add26b65f5"}, "ltsp_beginner": {"doc_hash": "67408219b927a51b43d2039bd54d1507554444876ad08f5b48d6d357a49735f6"}, "magic_hexagon_beginner": {"doc_hash": "ddec0bef7a56d3baa4665e392a5541d9b7cc4731f1a33a6964c48507c9c1d063"}, "magic_sequence_beginner": {"doc_hash": "3596d5e27c894b3d6d8dd85f1f0b0e1fd98e07564eb3f097769e5301b7ce7172"}, "maximum_density_still_life_beginner": {"doc_hash": "8975f001d574c11df49e649890b4088ef5702ec191c6cb32f89df7f3d7c51035"}, "mip_beginner": {"doc_hash": "4c9d15e98fa8962426be68775648aabec7a5391c2addbbd806d74649ee4db3fe"}, "missing_solution_beginner": {"doc_hash": "0403d35eb2a784f004bd4d8057e2975f723cc0179504539d1e5cb7707bef907c"}, "nonogram_create_automaton2_beginner": {"doc_hash": "1b7b9650d717ca75887606bac5efe302b57fd9236437b1a241ce8bc1b3de9217"}, "nurses_beginner": {"doc_hash": "4212cd99d582c777813949e999497bd71df92d7ec79918252503a7ce3a42f527"}, "opd_beginner": {"doc_hash": "1178b7a23ce6974af3d906a0068f6d54a46dca84e825cc5ce527f755687fc6bd"}, "partition_beginner": {"doc_hash": "5e3d5c2c3308b25974b62222fe793562479a34e0dc0c6da74ce911ea82b45681"}, "photo_beginner": {"doc_hash": "0afcfec781d24f0b570fe05f7cd290f1fb53ae288b0e775e238987cd80a0d7f0"}, "project_scheduling_beginner": {"doc_hash": "5757415c7e183cea650fd3113e33259d2be95ddf5b5556309483ebef7f9fdfb4"}, "QuasigroupCompletion_beginner": {"doc_hash": "99ea3252455a8ca439195d065844be0b42f5f2a1e39ad95ff0fd4f4de87188ed"}, "QuasiGroupExistence_beginner": {"doc_hash": "f95f94f18834f2130c019a5208d33f991eeb09901b85ff45b24e07f65baf8a52"}, "queens_beginner": {"doc_hash": "acf515063db5e5d07a4b8a1932bf5d47acb1714cda16a7fe7567d67778dd2d4a"}, "rcpsp_beginner": {"doc_hash": "ff7cd4b7518cfbc84f6c4052b5502fa2007d891af77f03727e98db5d00e5af88"}, "rehearsal_beginner": {"doc_hash": "3b2c7757ad40e7765b37202d5394c88cf84cf62c0f0443008ec1c21f6cc08861"}, "restart_beginner": {"doc_hash": "1cd93c099cfbbe580cd4fe482dbf1ee38c99dc777b172d1d78c28fdbc3a9bf0c"}, "RosteringProblem_beginner": {"doc_hash": "1aa5b7e2cc26c8b8cdbceeb2742516b8bae95d493298c62e0d121ec056e407ef"}, "sb_beginner": {"doc_hash": "a140e112e0339cc4691247d631fb1f96db08d8c7b69e2a608385d360417a3d2f"}, "schur_beginner": {"doc_hash": "524970d8d478e563e252aceb99c471ac406c919921f444559c3e215d5a0aa149"}, "setselect_beginner": {"doc_hash": "2e5ce8dbd0c87ba71d36f8459b85fb9bc54e84601ab8ed789800fc049b0c97e6"}, "shipping_beginner": {"doc_hash": "41523080436eacad913597cc3707dd54917caf61b282e1d6f9da5075c9a88df9"}, "simple-prod-planning_beginner": {"doc_hash": "57c94290db2e88935f36bfe203bc158560f862da94e069c4bc2af75b92df6155"}, "sonet_problem_beginner": {"doc_hash": "bbab5432cf2a567952d3c100759e0bcd9bc31431f5ee422b0cd45294a1956307"}, "square_pack_beginner": {"doc_hash": "cb554696852a7ba7455f3d823a832773df3ef24ffd023550408addfa0445e5e6"}, "stableroommates_beginner": {"doc_hash": "6e447cd2add82f4347956c7471f81427825464ebafda8492f95bc3755adb37b7"}, "steiner_beginner": {"doc_hash": "711f958e57c5a207405b373d76b484a5d907cfca073ecd9b6d688359d2b6b601"}, "stoch_fjsp_beginner": {"doc_hash": "2576f5b89d93ca89b27b9d6ec77352d9d17743d3fc21f026db009a5325ca47ee"}, "submultisetsum_beginner": {"doc_hash": "d2bab57c813ee5489ec8be0a0d49f7366c576dfe85a22ab69daedee0a9c08073"}, "table_seating_beginner": {"doc_hash": "7a3175ba6229428bd42445d2c42aabcead5495622c74d83a6900ed8b23f0261d"}, "teamselect_beginner": {"doc_hash": "9360996e283542c55fa24d318d3f33f6a546a009468f236ff7367732d1bc8f33"}, "template_design_beginner": {"doc_hash": "bc24d40030b580be9ee11076d003c05326dcccf2b6a68d1d1459a2dab1769d8d"}, "toomany_beginner": {"doc_hash": "56591eaf42edd2e61b3d700b568959ea5982aaa6973fea3950c296ac1744c4a1"}, "traffic_lights_table_beginner": {"doc_hash": "a90f2243c471c341fb8fa697b4b932582ba82b3c4970523ccc9748fafe75df93"}, "TTPPV_beginner": {"doc_hash": "8cffdae8404772fcdaaec085b2814828dc8478cf020d620c4b598c3c90374c34"}, "vessel-loading_beginner": {"doc_hash": "455c460f555a28c3dcc4bf31fcacf0c89d541db37803d4dcb651aa2496a8c492"}, "warehouses_beginner": {"doc_hash": "ab03093c47b77d101878eff5d6b1bfcda1d4117e3557ab02dc8701274df203b3"}, "water_buckets1_beginner": {"doc_hash": "cbec92d1d607404a73e40718a66c0b8a2ecd6992dad32ba6d367a7e0378d230f"}, "7a282f3c-6006-433c-820a-54a1b4ad0717": {"doc_hash": "29e354260480710212cb8a08185a6ecb58852ad7f9918a28907d939e4b5ac1e2", "ref_doc_id": "all_interval_beginner"}, "38bc7257-ea7c-48e5-a0eb-fbab0a7b7e6c": {"doc_hash": "36cd57947f58a24db5d197378fb131aa2355eef1e05ba8a119db443f2cb5653d", "ref_doc_id": "assign_beginner"}, "de0e3c1d-249e-419b-8f66-e2922e289a5a": {"doc_hash": "347721d4d2bba0b5e7165c9655d34eca3b6cb23b24b74c3eb59f749039150d0e", "ref_doc_id": "aust_color_beginner"}, "cf16060e-2ba2-4fbc-9f45-eff90b096978": {"doc_hash": "2c23f6a77ec03177fcb0bc2ca843a8852b7769ab7d5bea3c6944f3a8f58e68a5", "ref_doc_id": "bibd_beginner"}, "1c66519b-cd9c-4e51-999f-6e771d7ad947": {"doc_hash": "f6c3feaa5709f69c0e0a82ff88f3a44e96ac25da446c8bc216d19f40cd0f1b19", "ref_doc_id": "bus_scheduling_csplib_beginner"}, "b5a2ae50-2108-4306-9674-9b9fdc689538": {"doc_hash": "24eb1374d2a831e1a3174564cd1848a81b2feeaa4f9913e897422b7f57eaeffc", "ref_doc_id": "car_beginner"}, "1b27f5dc-befe-4558-bc03-0e200c99ae28": {"doc_hash": "e336f0c150e4b55358731c9c712c32a1e8d5d97631b871bea2c072d0980175ad", "ref_doc_id": "carpet_cutting_beginner"}, "192b98b3-88ea-4b58-9e22-cbaae970cf5b": {"doc_hash": "ce6f512d82adf5d08eb3bfa42b933e4753d0bb0c0e7bf3d6cd330b141a5373f6", "ref_doc_id": "cell_block_beginner"}, "670d6155-4fa3-471c-849a-c18d35293349": {"doc_hash": "e671e13d82a3f7b47e76c1c0b7fb616f9ffce0585946d29c935a334f9309a8b0", "ref_doc_id": "clique_beginner"}, "d9c00ad0-bfef-416b-a5d9-fb6349c0e5a5": {"doc_hash": "9d6399efea4d4c306c926800f37451125c383b2b7434315f8af950bae5babc83", "ref_doc_id": "cluster_beginner"}, "b3bccc56-5d6a-4465-a323-9743cb7e13e8": {"doc_hash": "6a0d42740d130acd96efd061b3a8b7a19cb7db1088815b380479f1ecbee7e86e", "ref_doc_id": "compatible_assignment_beginner"}, "72c61436-8d5d-4b7e-b05b-c5dbb460d118": {"doc_hash": "0cd06013f748add447a9c7b7c199b984458c4fa53eef95c5afc3f000434fc1d7", "ref_doc_id": "constrained_connected_beginner"}, "4f01f33b-a4a2-44a1-95d5-36fe06874945": {"doc_hash": "e9e73d257f4217404e31acaa34afbbff6380794393bdd302a3d644a3ef302ee2", "ref_doc_id": "crazy_sets_beginner"}, "6a4f19ff-8767-4add-b56a-a0931bed394d": {"doc_hash": "f308113e89a5a26790604cbea8122e5bac79c8c78560a0d3e5f5e690652e354e", "ref_doc_id": "crossfigure_beginner"}, "e3bd58be-b09b-48a3-b916-f0dfd38fef34": {"doc_hash": "457be4cd7a90a5ed329887ffdff6a55a7e71dd0362b5e86f73c1b09a2d950b3e", "ref_doc_id": "curriculum_beginner"}, "84a79840-ba59-4a3b-b654-06fb591b1939": {"doc_hash": "9cfb0983998ebb0e873a7a3f7304a05c435880a6d4d836926e879e84a7d4004c", "ref_doc_id": "diamond_free_degree_sequence_beginner"}, "efb5e89b-2814-4b20-b758-44b58e00d5ff": {"doc_hash": "6fbd54239edd03cb0db26b610bbfaaeb51b3ed422059c82564b56829b226eaf9", "ref_doc_id": "doublechannel_beginner"}, "dffceb46-4caa-4099-93b0-92f66fd92861": {"doc_hash": "cf13dd04d2f987c39c137eb279b65453b2a92c3c53660ed112a646da62a4ee9c", "ref_doc_id": "fractions_beginner"}, "f9040410-23ea-42ad-a8da-a5813603ada9": {"doc_hash": "761015b551990e7fa0e0aaa6adc202741bfa0dc8a8f0693ac04d50c4cf2e285f", "ref_doc_id": "golfers_beginner"}, "5482edd3-840a-4a37-a807-68ab1843a20b": {"doc_hash": "211cf40f1f1b575d2518030b99bee750dac75818df0dbb60e3112de434d37478", "ref_doc_id": "golomb_beginner"}, "ec0f9b6e-9dbd-4dfb-9a8c-f68de8ffcebb": {"doc_hash": "71e0c7d58eaabdda488864cedc3cd126d23ea6814b423f244f81c36e63354614", "ref_doc_id": "graph_beginner"}, "c2bd883f-93a3-4330-a0b4-57410f81c6f1": {"doc_hash": "fb2774e12751a3e53e13c922caa698c338ee68fde5c9a4975e7f96c7d3ed1bc2", "ref_doc_id": "itemset_mining_beginner"}, "b7ae399c-8379-4edf-914b-638a4cf4ab35": {"doc_hash": "55fada46de783f040e93e3f832577a804cb6c2318c2c3216ac701b1024322c24", "ref_doc_id": "jobshop_beginner"}, "ded61cf7-0046-4a14-a7be-07c76f337cab": {"doc_hash": "60016b833e97de86cb02e8e9e754dad22770ae08ad7d315b17fcae482887875d", "ref_doc_id": "K4xP2Graceful_beginner"}, "27c72c65-f7d2-4cf7-ad49-d78d30c3aa43": {"doc_hash": "b5f706296d0bd9a7aa1b53e48de9a3a6c1d8888fc583e4a9e262eb331f22301d", "ref_doc_id": "killer_sudoku_beginner"}, "4467eab3-c3cc-413f-a759-558199515760": {"doc_hash": "52a8a009df7c254da0fc2e69661bfdc5b7e3dd5336c4f9b5dc57a777732dcf1f", "ref_doc_id": "knapsack_beginner"}, "24af84b7-a264-4cda-b2a6-b170ff48f323": {"doc_hash": "b60d3d805a2e5bc73f2bd8a6f628d8a2ffc1d14d5308e5dac0a470330274e99b", "ref_doc_id": "langford_beginner"}, "422c9037-5bfd-4cdb-af00-2a20faea8e34": {"doc_hash": "1b4a3766884d46f3b44caf834e8e3eff4156cd90d42bdec0483dde0026dad1f6", "ref_doc_id": "loan_beginner"}, "a1750cd1-eae1-4cf8-9f6c-9ce05854af80": {"doc_hash": "4ee536d1117892ba550df36c291ff120821ff585b7a91ca2fd8dc8433c747f96", "ref_doc_id": "ltsp_beginner"}, "6a73104f-9e36-4551-93f2-56f5f462f5f8": {"doc_hash": "13ddf67655bdbbd6f863b7fdc761cc641ec6b24ebd1ace852534ac6699f043a2", "ref_doc_id": "magic_hexagon_beginner"}, "9569f4c0-4335-46e3-9fbf-d7f4b7458722": {"doc_hash": "97a79fa236f9daeb7515887c214f7edc30970cf68fd578f77595a11db5a11c11", "ref_doc_id": "magic_sequence_beginner"}, "e46404eb-9079-4658-a12d-9eb4afe4bc09": {"doc_hash": "2bc259181404d230f1f6124ca1e288cd93c89fe9f24dd6fa6c356e9a373aa2ee", "ref_doc_id": "maximum_density_still_life_beginner"}, "0479ed3d-59e1-46c9-b9fd-f0f24f105518": {"doc_hash": "bdd4773817d3d9812f4408fd0a781ab33e5f3a17ad03584eb71eeea27be3cfb8", "ref_doc_id": "mip_beginner"}, "0b65a57d-c559-4897-9409-2831a8e530f3": {"doc_hash": "3013f8c47468608e2b2575b1be2c9413181c8c3db8affd66a7f67dab1a9178f7", "ref_doc_id": "missing_solution_beginner"}, "f2966efd-ce8e-4874-83f5-0cea183ec6a2": {"doc_hash": "5ef9faa1df3decff6575842364d6b7d0e907108dc304df3c2705a48d7f53ff15", "ref_doc_id": "nonogram_create_automaton2_beginner"}, "bf76992c-935d-4233-a4b9-7a65d0b6a93d": {"doc_hash": "f03b1c6150bfb94b70f12a1c87dfacaf13e57a3c59c5c739c881384c063f2641", "ref_doc_id": "nurses_beginner"}, "81d79f4d-a0ec-4007-af68-847ded83536f": {"doc_hash": "bc01e05a3bcda064ba299600950d70af0772312e9e9f0dd59af4dd70b2cc9a17", "ref_doc_id": "opd_beginner"}, "2715be99-61b5-4664-94ce-87ad66d45263": {"doc_hash": "41bb536e511d6eaa780165a2fdd1785cc0d9548bcbc034e442e084ed9c2cb172", "ref_doc_id": "partition_beginner"}, "3ef1035d-709a-425b-a3c3-734a80e29209": {"doc_hash": "9eede69df1b2a6bdd61593185a1a7163166db8be726bfdb71d536892a90266d6", "ref_doc_id": "photo_beginner"}, "fdee7291-4bee-4c2d-b28e-30ab98a533c2": {"doc_hash": "a9f4cd6aefa9fd8df8743e3608ea1384e70a99b4694dd701ab75305159cac662", "ref_doc_id": "project_scheduling_beginner"}, "1c44cd22-62d5-4fc0-9b4f-2955334be8e7": {"doc_hash": "91e6488b5ee914839e0d4d9dc81819c608d61a8278ae521c9384f6fbc402497f", "ref_doc_id": "QuasigroupCompletion_beginner"}, "79b4455a-f750-4171-8f32-1c84a3d99dd8": {"doc_hash": "1aec5cb517c6dca8b6b088a459fe76a46cf7f55d0032f1d8c6e4bde867c12fe7", "ref_doc_id": "QuasiGroupExistence_beginner"}, "23fb4f42-982f-4e2b-a7ba-2a900c78bea8": {"doc_hash": "514e2eac2976722f5ae81b63cc495cddb9aa99932f34410aca195201c6f98a95", "ref_doc_id": "queens_beginner"}, "d57961b0-7604-444f-9418-b4a2137b3961": {"doc_hash": "e42035f8d7484f701abb4889e433b741995b83db2fa92622e59ee9d77b43db1b", "ref_doc_id": "rcpsp_beginner"}, "97acf8ea-577b-47ea-b19b-8171e81ce767": {"doc_hash": "42091f880feb04d504bdaec2460d297119e4e668a8115cd6127b1ff811723f35", "ref_doc_id": "rehearsal_beginner"}, "c187b8ca-71de-427a-b730-21d695c97305": {"doc_hash": "70bf19cda1e3fbe2abf84715b345cd0563086dbf8b949741648ce49c8ccce883", "ref_doc_id": "restart_beginner"}, "9a919f76-075d-46f4-8b68-2f8af0f01d55": {"doc_hash": "ec62ec9207c574bb6acfaa9aa1c69609fd157527a540a1c82a52303650462b2a", "ref_doc_id": "RosteringProblem_beginner"}, "134210d5-d16f-4d5e-8868-c6582460e9b7": {"doc_hash": "5934b8d5d0c96d3265bdd005102c4eb87d67254f3cca381a2908645366311c40", "ref_doc_id": "sb_beginner"}, "3224a6eb-add9-4648-a5a7-bef78418c1b7": {"doc_hash": "776753996988eb936019e2c836a49a118c29c57c9ce3a88d6ab848587716691d", "ref_doc_id": "schur_beginner"}, "4fd5d53b-01f3-4a82-9da2-fa545e94e112": {"doc_hash": "c4e29d13966ce1461ae2bd4facc80b5dd206d9b995b816f17e2ff835b28063f6", "ref_doc_id": "setselect_beginner"}, "4aed6317-cf4c-4ec8-9fad-12ad0fd99cc1": {"doc_hash": "2e849ab3efa29145b7724c73b9e022428600a8239f57f68a0178a0d032994b4c", "ref_doc_id": "shipping_beginner"}, "0344e1e1-10bf-45b3-92c2-5b67e23375cd": {"doc_hash": "38a9f5d7740fdaa3548029af9eb98bb13e55015afa102328069d3b8c090518fe", "ref_doc_id": "simple-prod-planning_beginner"}, "c3104dcb-cca7-4438-a00c-a28d02579bdd": {"doc_hash": "e46e328b634e8bfb9edaf56cb6435a6a9b5889c1e7b6c337700bb5f6a65a7794", "ref_doc_id": "sonet_problem_beginner"}, "918c8927-0e43-4cc5-88cc-77b88657bd62": {"doc_hash": "62a7906e19865ff5a4737b964f2c8a01998ba04492cccd4d478e63c2a43faef8", "ref_doc_id": "square_pack_beginner"}, "3672d5af-30f6-4305-9be4-ea94836364ba": {"doc_hash": "8a5d63838716e7f4b3dd2835561f787200675d5a00bc7fcac8e8cd4f3e48263d", "ref_doc_id": "stableroommates_beginner"}, "abef35a2-972a-4faa-aa3a-a7ca09aa7e3c": {"doc_hash": "3b262677d1d773c357c33a6b94b0ee556edb5089b037c8842e4c9d699112b4e1", "ref_doc_id": "steiner_beginner"}, "a6cd0d7f-9964-4592-a74b-46c6dc275289": {"doc_hash": "c434e77e8273dfbd1d8bbaf26d1a101943b02336ff67953234644ad5987aa342", "ref_doc_id": "stoch_fjsp_beginner"}, "96dd0502-4b06-48cf-ab56-b330deaa0c0b": {"doc_hash": "778e8dcebaf48b116fd904813d9b0a04f0e0443970fe14107a65a9c22ceebb23", "ref_doc_id": "submultisetsum_beginner"}, "718147e4-1624-4a0d-849f-a258ef76a3f2": {"doc_hash": "a8e102fe6e6f91d3b5721f6a17fc3c0ae58eb7e0ff7b13d78800ca43577a6b5b", "ref_doc_id": "table_seating_beginner"}, "be3b14c9-2865-4b59-b23e-10774abe9b45": {"doc_hash": "eb0ec930a83a6d4dff03ad4a7eab3a69b06268231132849da0a95811af08ec7e", "ref_doc_id": "teamselect_beginner"}, "4b112781-93f8-4b0f-9fa5-f456aea0f182": {"doc_hash": "0f523d9495ca4b5e125bee288dcfcfbd508b36c36f8df5a61188c57b11109edb", "ref_doc_id": "template_design_beginner"}, "2c95db74-0ff5-4b55-85d7-191a0a7fbd50": {"doc_hash": "701829fff7612f14aa03a7c584fffa63dfe44e4794dc48fa15a3594b9f911c61", "ref_doc_id": "toomany_beginner"}, "ec701746-38dd-482f-a1ea-169ca0bf640d": {"doc_hash": "1422741f447e81f1cc0f68993064a51c029ab48fa745994a355909a48a960cfd", "ref_doc_id": "traffic_lights_table_beginner"}, "49f75f4d-7ea0-4662-a547-df57234b5dce": {"doc_hash": "4bac253d55a82c7435509e7d3e92b3072643b2e71ef9275e813162be9c1c0640", "ref_doc_id": "TTPPV_beginner"}, "33282e11-ae77-44ac-b54d-9772351212d7": {"doc_hash": "0298deb02ff81159bca65ec48fb362d990d2cdcb5c79b85eda636083a32a4e32", "ref_doc_id": "vessel-loading_beginner"}, "71a5e752-edbc-42e3-a679-2916be4ee562": {"doc_hash": "7e9e14d56c3ccbe7372e19706c61c528f5f92912dbbb46d5468e65702f0ff32d", "ref_doc_id": "warehouses_beginner"}, "d9a5dd1a-f1e6-4fe4-bd00-7f238a6eca7b": {"doc_hash": "0f93e926861cb1fb73b83c9c26b6ad9e4b7929a17bc7a4eca3815dc4090a6e30", "ref_doc_id": "water_buckets1_beginner"}}, "docstore/data": {"7a282f3c-6006-433c-820a-54a1b4ad0717": {"__data__": {"id_": "7a282f3c-6006-433c-820a-54a1b4ad0717", "embedding": null, "metadata": {"model_name": "all_interval"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "all_interval_beginner", "node_type": "4", "metadata": {"model_name": "all_interval"}, "hash": "aaf4b00f7bb0e53a205e0a54aa8a8f48a6252b44612a61ca57508a653d5d8e6c", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** All-Interval Series Problem\n\n**What the problem is about in everyday terms:** Imagine you have 12 different musical notes (like C, C#, D, etc.). You want to arrange these notes in a special order so that each note appears only once, and the distance between each pair of adjacent notes is different from the distance between any other pair of adjacent notes. For example, if the distance between the first two notes is 2 semitones, then there should be no other pair of adjacent notes with a distance of 2 semitones.\n\n**Main variables and what they mean:**\n\n* `x` or `series`: an array of 12 variables, each representing a musical note (0 to 11). This array represents the order in which the notes will be played.\n* `diffs` or `differences`: an array of variables representing the distance between each pair of adjacent notes.\n\n**Basic restrictions or rules of the problem:**\n\n* Each note must appear only once in the series.\n* The distance between each pair of adjacent notes must be different from the distance between any other pair of adjacent notes.\n\n**Goal of the problem:** Find an arrangement of the 12 notes that satisfies the above rules.\n\nNote that the different models provided are different ways of solving the same problem, but the underlying problem remains the same.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1432, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "38bc7257-ea7c-48e5-a0eb-fbab0a7b7e6c": {"__data__": {"id_": "38bc7257-ea7c-48e5-a0eb-fbab0a7b7e6c", "embedding": null, "metadata": {"model_name": "assign"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "assign_beginner", "node_type": "4", "metadata": {"model_name": "assign"}, "hash": "45aab47657256ccda8465540557bff4c424fe8492c9f9691881f24a1ab151b73", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **The Assignment Problem**\n\n**What is it about?**\nImagine you have a group of workers and a list of tasks that need to be done. Each worker can do one task, and each task can be done by one worker. The problem is to assign each worker to a task in a way that maximizes the total profit or benefit.\n\n**Main variables:**\n\n* `WORK` (or `DOM`): a set of workers\n* `TASK` (or `COD`): a set of tasks\n* `x` (or `task` or `worker`): a variable that represents the assignment of a worker to a task\n* `profit`: a table that shows the profit or benefit of assigning a worker to a task\n* `obj`: the total profit or benefit of the assignment\n\n**Basic restrictions or rules:**\n\n* Each worker can do only one task.\n* Each task can be done by only one worker.\n* The assignment must be done in a way that maximizes the total profit or benefit.\n\n**Goal:**\nThe goal is to find an assignment of workers to tasks that maximizes the total profit or benefit.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1019, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "de0e3c1d-249e-419b-8f66-e2922e289a5a": {"__data__": {"id_": "de0e3c1d-249e-419b-8f66-e2922e289a5a", "embedding": null, "metadata": {"model_name": "aust_color"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "aust_color_beginner", "node_type": "4", "metadata": {"model_name": "aust_color"}, "hash": "4fd5e7dca9472204d7dcf0e027f5fa52fd5b3ba1854db55ecd8d371510bac6fb", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **The Australian Map Colouring Problem**\n\nThis problem is about colouring a map of Australia with different colours. Imagine you have a map of Australia with six states: Western Australia (WA), Northern Territory (NT), South Australia (SA), Queensland (Q), New South Wales (NSW), and Victoria (V), plus Tasmania (T).\n\n**Main variables:**\n\n* wa, nt, sa, q, nsw, v, and t: These are the colours assigned to each state.\n\n**Basic restrictions or rules:**\n\n* Each state must have a different colour from its neighbouring states.\n\n**Goal:**\n\n* Find a way to colour the map of Australia using a certain number of colours (4 or more) such that no two neighbouring states have the same colour.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 768, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cf16060e-2ba2-4fbc-9f45-eff90b096978": {"__data__": {"id_": "cf16060e-2ba2-4fbc-9f45-eff90b096978", "embedding": null, "metadata": {"model_name": "bibd"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bibd_beginner", "node_type": "4", "metadata": {"model_name": "bibd"}, "hash": "e17e950b3ac51beb40589b6661a3873aa05135beaea02cc722071c83fc2ab92c", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Balanced Incomplete Block Design (BIBD)\n\nThis problem is about creating a special kind of table with certain properties. Imagine you have a bunch of people, and you want to divide them into groups to play games or do activities together. You want to make sure that each person plays with the same number of other people, and each group has the same number of people. Also, you want to make sure that any two people play together in the same group a certain number of times.\n\nThe main variables are:\n\n* v: the number of people\n* k: the number of people in each group\n* lambda: the number of times any two people play together in the same group\n* b: the number of groups (calculated based on v, k, and lambda)\n* r: the number of groups each person is in (calculated based on v, k, and lambda)\n* m: a table that shows which people are in which groups (this is the main thing we're trying to figure out)\n\nThe basic restrictions or rules of the problem are:\n\n* Each person is in the same number of groups (r)\n* Each group has the same number of people (k)\n* Any two people play together in the same group the same number of times (lambda)\n\nThe goal of the problem is to find a table (m) that satisfies all these rules.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1297, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1c66519b-cd9c-4e51-999f-6e771d7ad947": {"__data__": {"id_": "1c66519b-cd9c-4e51-999f-6e771d7ad947", "embedding": null, "metadata": {"model_name": "bus_scheduling_csplib"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bus_scheduling_csplib_beginner", "node_type": "4", "metadata": {"model_name": "bus_scheduling_csplib"}, "hash": "54effe0b9f125e014390e3d4fd6443b45127436f4fc6af8c70be64345e2e5ad4", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Bus Driver Scheduling Problem\n\nThis problem is about creating a schedule for bus drivers to cover all the tasks (like driving routes) with the minimum number of drivers needed.\n\nThe main variables are:\n\n* Tasks (or pieces of work): these are the bus routes or driving jobs that need to be covered.\n* Shifts: these are the possible schedules for the bus drivers, which cover some of the tasks.\n* x: this is a variable that decides which shifts to choose for the drivers.\n* tot_shifts: this is the total number of shifts (or drivers) needed to cover all the tasks.\n\nThe basic restrictions or rules of the problem are:\n\n* Each task must be covered by exactly one shift (or driver).\n* Each shift can cover multiple tasks.\n* We want to use the minimum number of shifts (or drivers) to cover all the tasks.\n\nThe goal of the problem is to minimize the total number of shifts (or drivers) needed to cover all the tasks.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 995, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b5a2ae50-2108-4306-9674-9b9fdc689538": {"__data__": {"id_": "b5a2ae50-2108-4306-9674-9b9fdc689538", "embedding": null, "metadata": {"model_name": "car"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "car_beginner", "node_type": "4", "metadata": {"model_name": "car"}, "hash": "91d7893915e61d771d50598b48ed8de4a73638f901bea94ec3023f20f950d98d", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Car Sequencing Problem**\n\nThis problem is about arranging cars on a production line in a specific order. Imagine a factory that produces cars with different features, such as sunroofs, leather seats, or navigation systems. The goal is to sequence the cars in a way that minimizes the total number of changes needed to switch between different features.\n\n**Main Variables:**\n\n* `slot`: represents the type of car (e.g., sedan, SUV, etc.) assigned to each production slot.\n* `setup`: indicates whether a specific feature (e.g., sunroof) is installed on a car in a particular slot.\n\n**Basic Restrictions or Rules:**\n\n* Each type of car has a specific number of units to be produced.\n* Certain features require a minimum number of consecutive cars to be produced together (e.g., a sunroof requires 3 consecutive cars).\n* The production line has a limited capacity for each feature (e.g., only 5 cars with leather seats can be produced in a row).\n\n**Goal:**\n\nThe goal is to minimize the total number of changes needed to switch between different car types and features while satisfying the production requirements and restrictions.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1212, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1b27f5dc-befe-4558-bc03-0e200c99ae28": {"__data__": {"id_": "1b27f5dc-befe-4558-bc03-0e200c99ae28", "embedding": null, "metadata": {"model_name": "carpet_cutting"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "carpet_cutting_beginner", "node_type": "4", "metadata": {"model_name": "carpet_cutting"}, "hash": "9500ee2ab3aff18d871b5d606d34e9c169807dcc17a5c0e57d1a54a40d9760d9", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Carpet Cutting Problem\n\n**What the problem is about in everyday terms:** Imagine you have a roll of carpet and you need to cut it to fit different rooms in a house. Each room has a specific shape and size, and you want to use the minimum amount of carpet possible to cover all the rooms.\n\n**Main variables and what they mean:**\n\n* `n`: The number of rooms in the house.\n* `m`: The number of different rectangle shapes that can be used to cut the carpet.\n* `ROOM`: A set of integers representing the rooms in the house.\n* `ROFF`: A set of integers representing the different rectangle shapes.\n* `d`: An array of integers representing the definitions of the rectangle shapes (x-offset, y-offset, x-size, y-size).\n* `shape`: An array of sets of integers representing the shapes that can be used for each room.\n* `h`: The height of the roll of carpet.\n* `maxl`: The maximum length of the roll of carpet.\n* `x` and `y`: Arrays of variables representing the x and y coordinates of the top-left corner of each room.\n* `rot`: An array of variables representing the rotation of each room (0, 90, 180, or 270 degrees).\n* `l`: A variable representing the length of carpet used.\n\n**Basic restrictions or rules of the problem:**\n\n* Each room must be covered by a single piece of carpet.\n* The carpet must be cut from the roll in a way that minimizes waste.\n* The shapes of the rooms and the carpet pieces must fit together without overlapping.\n\n**Goal of the problem:** The goal is to find the minimum length of carpet needed to cover all the rooms.\n\nIn summary, the Carpet Cutting Problem is about finding the most efficient way to cut a roll of carpet to fit different rooms in a house, using the minimum amount of carpet possible.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1870, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "192b98b3-88ea-4b58-9e22-cbaae970cf5b": {"__data__": {"id_": "192b98b3-88ea-4b58-9e22-cbaae970cf5b", "embedding": null, "metadata": {"model_name": "cell_block"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cell_block_beginner", "node_type": "4", "metadata": {"model_name": "cell_block"}, "hash": "f10b9e7b0d92d36da224a39d312c2a5df4841b727e20d383e8da5abad83b8db8", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Here is the explanation of the problem:\n\n**Prisoner Allocation Problem**\n\nThis problem is about allocating prisoners to cells in a prison. Imagine a prison with a certain number of rows and columns of cells. Each prisoner needs to be assigned to a specific cell.\n\n**Main Variables:**\n\n* `k`: The total number of prisoners.\n* `PRISONER`: A set of prisoners, each identified by a unique number from 1 to `k`.\n* `n` and `m`: The number of rows and columns of cells in the prison, respectively.\n* `r` and `c`: Variables that represent the row and column of each prisoner's cell, respectively.\n* `danger`: A set of prisoners who are considered dangerous.\n* `female` and `male`: Sets of female and male prisoners, respectively.\n* `cost`: A table that shows the cost of assigning each prisoner to each cell.\n\n**Basic Restrictions or Rules:**\n\n* Each prisoner must be assigned to a unique cell.\n* Prisoners who are considered dangerous should not be placed next to each other.\n* Female prisoners should be placed in the top half of the prison, while male prisoners should be placed in the bottom half.\n\n**Goal:**\n\nThe goal is to assign prisoners to cells in a way that minimizes the total cost of the assignments. The cost is calculated by summing up the costs of assigning each prisoner to their assigned cell.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1387, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "670d6155-4fa3-471c-849a-c18d35293349": {"__data__": {"id_": "670d6155-4fa3-471c-849a-c18d35293349", "embedding": null, "metadata": {"model_name": "clique"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "clique_beginner", "node_type": "4", "metadata": {"model_name": "clique"}, "hash": "7db0763fba0a0a3db8e5fb1bd8e9d124271f92c320b43bb9ef170605d63b3817", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Maximum Clique Problem\n\nThis problem is about finding a group of friends in a social network where everyone in the group knows each other.\n\nThe main variables are:\n\n* `c`: an array that says whether each person is in the group or not (true or false)\n* `size`: the total number of people in the group\n\nThe basic restrictions or rules of the problem are:\n\n* If two people don't know each other, they can't both be in the group\n* We want to find the largest possible group of friends\n\nThe goal of the problem is to find the largest group of friends (maximize `size`).", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 648, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d9c00ad0-bfef-416b-a5d9-fb6349c0e5a5": {"__data__": {"id_": "d9c00ad0-bfef-416b-a5d9-fb6349c0e5a5", "embedding": null, "metadata": {"model_name": "cluster"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cluster_beginner", "node_type": "4", "metadata": {"model_name": "cluster"}, "hash": "c241e909824058675d30a9a175883d7e2e6ced43e69666f5af1c5755063ad7a4", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Problem Name:** Clustering Problem\n\n**What the problem is about:** Imagine you have a bunch of points on a map, and you want to group them into clusters so that points in the same cluster are close to each other.\n\n**Main Variables:**\n\n* `n`: The number of points on the map.\n* `POINT`: A set of points, each represented by a number from 1 to `n`.\n* `dist`: A table that shows the distance between each pair of points.\n* `k`: The number of clusters you want to create.\n* `CLUSTER`: A set of cluster numbers, from 1 to `k`.\n* `x`: An array that assigns each point to a cluster number.\n* `maxdiam`: The maximum distance between points in the same cluster.\n\n**Basic Restrictions or Rules:**\n\n* Points in the same cluster should be close to each other (within `maxdiam` distance).\n* Each cluster should have at least one point.\n* Clusters should be numbered in a way that points in cluster `i` are all closer to each other than points in cluster `i+1`.\n\n**Goal of the Problem:** The goal is to find a way to cluster the points so that the total distance between points in the same cluster is as small as possible, while also making sure that points in different clusters are far enough apart.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1273, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b3bccc56-5d6a-4465-a323-9743cb7e13e8": {"__data__": {"id_": "b3bccc56-5d6a-4465-a323-9743cb7e13e8", "embedding": null, "metadata": {"model_name": "compatible_assignment"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "compatible_assignment_beginner", "node_type": "4", "metadata": {"model_name": "compatible_assignment"}, "hash": "0655d45b5c812c285fef1f2a2fa715258a7e2ab9514f19ba44c95c9ccde4898b", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Problem Name:** Task Assignment Problem\n\n**What the problem is about:** Imagine you have a set of tasks that need to be done, and a set of workers who can do these tasks. Each task has a certain profit associated with it, and each worker can do a specific set of tasks. The problem is to assign tasks to workers in a way that maximizes the total profit.\n\n**Main variables:**\n\n* `task`: an array that assigns a task to each worker\n* `worker`: an array that assigns a worker to each task\n* `profit`: a 2D array that stores the profit of each task for each worker\n* `compatible`: a 2D array that indicates whether two workers can work together on consecutive tasks\n\n**Basic restrictions or rules:**\n\n* Each task must be assigned to a worker\n* Each worker can only do one task at a time\n* If two workers are assigned to consecutive tasks, they must be compatible with each other\n\n**Goal:** The goal is to maximize the total profit by assigning tasks to workers in a way that satisfies the above rules.\n\nIn simple terms, the problem is about finding the best way to assign tasks to workers to get the most profit, while making sure that workers who need to work together can do so.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1262, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "72c61436-8d5d-4b7e-b05b-c5dbb460d118": {"__data__": {"id_": "72c61436-8d5d-4b7e-b05b-c5dbb460d118", "embedding": null, "metadata": {"model_name": "constrained_connected"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "constrained_connected_beginner", "node_type": "4", "metadata": {"model_name": "constrained_connected"}, "hash": "35b9463c75dbd3e7decfee699369acb4e3f615eb8a487885da2916b44ea56e1f", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Constrained Clustering**\n\nThis problem is about grouping things together in a way that follows certain rules.\n\n**Main Variables:**\n\n* `selected`: a set of connections between things (called edges)\n* `rep`: a way to represent each group (called a cluster)\n\n**Basic Restrictions or Rules:**\n\n* If two things are connected (an edge), they must be in the same group (cluster)\n* Certain pairs of things cannot be in the same group (given by `first` and `second` arrays)\n\n**Goal:**\n\nThe goal is to find the largest number of connections (edges) that can be included while following the rules, and to group the things together in a way that makes sense.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 732, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4f01f33b-a4a2-44a1-95d5-36fe06874945": {"__data__": {"id_": "4f01f33b-a4a2-44a1-95d5-36fe06874945", "embedding": null, "metadata": {"model_name": "crazy_sets"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crazy_sets_beginner", "node_type": "4", "metadata": {"model_name": "crazy_sets"}, "hash": "a3ec6a0551ddfcf027c3fa478afc5c783688bf66baa7b767bb30c38da0047602", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Problem Name:** Unknown (no specific name is given)\n\n**What the problem is about in everyday terms:** Imagine you have a set of numbers from 1 to 10, and you want to divide these numbers into 4 groups, each containing 4 numbers. The goal is to create these groups in a way that no three groups have a common number.\n\n**Main variables and what they mean:**\n\n* `n`: the maximum value in the set of numbers (in this case, 10)\n* `c`: the number of elements in each group (in this case, 4)\n* `m`: the number of groups (in this case, 4)\n* `s`: an array of sets, where each set represents a group of numbers\n* `x`: a 2D array of numbers, where each row represents a group and each column represents a position in the group\n\n**Basic restrictions or rules of the problem:**\n\n* Each group must have exactly 4 numbers.\n* No three groups can have a common number.\n* The numbers in each group must be in increasing order.\n* The numbers in each group must be unique.\n\n**Goal of the problem:** The goal is to find a way to divide the numbers into groups that satisfy all the rules and restrictions.\n\nNote: The problem is not trying to minimize or maximize anything, it's just trying to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1317, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6a4f19ff-8767-4add-b56a-a0931bed394d": {"__data__": {"id_": "6a4f19ff-8767-4add-b56a-a0931bed394d", "embedding": null, "metadata": {"model_name": "crossfigure"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "crossfigure_beginner", "node_type": "4", "metadata": {"model_name": "crossfigure"}, "hash": "5ee1c48fc13794a10fb553984e2270ba55d5adcbce9f273d8899277085b6f46f", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Crossfigure problem\n\n**What the problem is about in everyday terms:** Imagine you have a grid of numbers, like a crossword puzzle, but instead of words, you have numerical clues to fill in. The clues are given in the form of mathematical equations, and you need to figure out the correct numbers to put in each box to satisfy all the equations.\n\n**What the main variables are and what they mean:**\n\n* `M` is a 9x9 grid of numbers, where each number is between 0 and 9.\n* `A1`, `A4`, ..., `A30` are variables that represent the answers to the \"across\" clues.\n* `D1`, `D2`, ..., `D28` are variables that represent the answers to the \"down\" clues.\n\n**What the basic restrictions or rules of the problem are:**\n\n* Each number in the grid `M` must be between 0 and 9.\n* The numbers in the grid must satisfy the mathematical equations given in the clues.\n* Some numbers in the grid are fixed to be 0 (these are the \"black boxes\").\n\n**What the goal of the problem is:** The goal is to find a solution that satisfies all the mathematical equations and fills in the entire grid `M` with numbers between 0 and 9.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1252, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e3bd58be-b09b-48a3-b916-f0dfd38fef34": {"__data__": {"id_": "e3bd58be-b09b-48a3-b916-f0dfd38fef34", "embedding": null, "metadata": {"model_name": "curriculum"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "curriculum_beginner", "node_type": "4", "metadata": {"model_name": "curriculum"}, "hash": "fb6f504391c7f74a1843b1cbe36275b7148d5e8cfc924f6e438eb3f3c3e50351", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    The Balanced Academic Curriculum Problem.\n\nThis problem is about creating a schedule for a set of university courses. Each course has a certain number of credits, and students can only take a certain number of credits and courses per period. The goal is to assign each course to a period in a way that minimizes the total number of credits per period.\n\nThe main variables are:\n\n* Courses: these are the university courses that need to be scheduled.\n* Periods: these are the time slots when the courses can be taught.\n* Course load: this is the number of credits each course is worth.\n* Course period: this is the period when each course is taught.\n* Load: this is the total number of credits for all courses in a period.\n\nThe basic restrictions or rules of the problem are:\n\n* Each course must be assigned to a period.\n* A course cannot be taught before its prerequisites (i.e., courses that must be taken before it).\n* Students can only take a certain number of credits and courses per period.\n* The total number of credits per period should be within a certain range.\n\nThe goal of the problem is to minimize the total number of credits per period, while satisfying all the above rules.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1271, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "84a79840-ba59-4a3b-b654-06fb591b1939": {"__data__": {"id_": "84a79840-ba59-4a3b-b654-06fb591b1939", "embedding": null, "metadata": {"model_name": "diamond_free_degree_sequence"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "diamond_free_degree_sequence_beginner", "node_type": "4", "metadata": {"model_name": "diamond_free_degree_sequence"}, "hash": "0ba3f3e0047d6658da997050a326a1cfceb98ae805e296f54d19dd43242f7171", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Diamond-free Degree Sequence**\n\n**What is the problem about?**\nImagine you have a bunch of friends, and some of them are friends with each other. You want to know how many friends each person has, and how those friendships are connected, without having any groups of four friends who are all friends with each other (this is called a \"diamond\").\n\n**Main variables:**\n\n* `x`: a table that shows if two friends are friends with each other (1 if they are, 0 if they're not)\n* `degrees`: a list that shows how many friends each person has\n\n**Basic restrictions or rules:**\n\n* Each person has at least one friend (no one is alone)\n* The number of friends each person has is a multiple of 3 (e.g., 3, 6, 9, etc.)\n* The total number of friendships is a multiple of 6\n* There are no groups of four friends who are all friends with each other (no \"diamonds\")\n\n**Goal:**\nFind all possible ways to assign friends to each person, following the rules above, and without having any \"diamonds\".", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1065, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "efb5e89b-2814-4b20-b758-44b58e00d5ff": {"__data__": {"id_": "efb5e89b-2814-4b20-b758-44b58e00d5ff", "embedding": null, "metadata": {"model_name": "doublechannel"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "doublechannel_beginner", "node_type": "4", "metadata": {"model_name": "doublechannel"}, "hash": "4604d610d322c03ee95eb248e05dc440847efd43f0d38c19918baa11c02d54a7", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Problem Name:** Ship Scheduling\n\n**What the problem is about:** Imagine a busy port with multiple channels where ships come and go. We need to schedule when each ship enters and leaves the port through which channel, so that they don't crash into each other.\n\n**Main variables:**\n\n* `SHIP`: Each ship is represented by a number.\n* `CHANNEL`: Each channel in the port is represented by a number.\n* `start`: The time when each ship starts to enter or leave the port.\n* `end`: The time when each ship finishes entering or leaving the port.\n* `channel`: The channel assigned to each ship.\n* `next`: The next ship that will use the same channel.\n\n**Basic restrictions or rules:**\n\n* Each ship must enter and leave the port through one of the channels.\n* Ships must not collide with each other in the same channel.\n* There must be a safe distance (called \"leeway\") between two ships in the same channel.\n* Each channel has a limited length, and ships take different times to traverse it.\n\n**Goal of the problem:** We want to find a schedule that minimizes the total difference between the desired start time and the actual start time for all ships. In other words, we want to make sure that each ship starts entering or leaving the port as close as possible to its desired time.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1358, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dffceb46-4caa-4099-93b0-92f66fd92861": {"__data__": {"id_": "dffceb46-4caa-4099-93b0-92f66fd92861", "embedding": null, "metadata": {"model_name": "fractions"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fractions_beginner", "node_type": "4", "metadata": {"model_name": "fractions"}, "hash": "c2524becb0f733bc12d9d4bcfba8fad5b357a17c82c22c7f7c341080376fb2ac", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Fractions problem\n\n**What the problem is about:** Imagine you have 9 distinct digits (from 1 to 9) that you want to use to create three fractions that add up to 1. The fractions are created by combining the digits in a specific way.\n\n**Main variables and their meanings:**\n\n* A, B, C, D, E, F, G, H, I: These are the 9 distinct digits (from 1 to 9) that we want to use to create the fractions.\n* D1, D2, D3: These are the denominators (the numbers at the bottom) of the three fractions.\n\n**Basic restrictions or rules:**\n\n* Each digit can only be used once.\n* The digits must be combined in a specific way to create the fractions.\n* The three fractions must add up to 1.\n\n**Goal of the problem:** Find a way to combine the 9 digits to create three fractions that add up to 1, while following the rules and restrictions mentioned above.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 985, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f9040410-23ea-42ad-a8da-a5813603ada9": {"__data__": {"id_": "f9040410-23ea-42ad-a8da-a5813603ada9", "embedding": null, "metadata": {"model_name": "golfers"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golfers_beginner", "node_type": "4", "metadata": {"model_name": "golfers"}, "hash": "1561e3cf7cf484740a64afde3b05fc66d71fca4e34f3c0bb5d9bc3e0a1dbe6ab", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Social Golfers Problem\n\n**What the problem is about in everyday terms:** Imagine a group of golfers who want to play golf together in small groups over several rounds. The goal is to arrange the golfers into groups for each round such that each golfer plays with different people in each round, and no two golfers play together more than once.\n\n**Main variables and what they mean:**\n\n* `n_groups`: The number of groups that the golfers will be divided into.\n* `n_per_group`: The number of golfers in each group.\n* `n_rounds`: The number of rounds that the golfers will play.\n* `golfers`: The set of all golfers.\n* `rounds`: The set of all rounds.\n* `places` or `groups`: The set of all possible positions or groups that a golfer can be assigned to.\n\n**Basic restrictions or rules of the problem:**\n\n* Each group must have the same number of golfers.\n* Each golfer must play with different people in each round.\n* No two golfers can play together more than once.\n\n**Goal of the problem:** The goal is to find an arrangement of golfers into groups for each round that satisfies the above rules and restrictions.\n\nNote that the different models provided are different ways of representing the same problem, but the overall problem remains the same.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1396, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5482edd3-840a-4a37-a807-68ab1843a20b": {"__data__": {"id_": "5482edd3-840a-4a37-a807-68ab1843a20b", "embedding": null, "metadata": {"model_name": "golomb"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "golomb_beginner", "node_type": "4", "metadata": {"model_name": "golomb"}, "hash": "f7f31ae808c6421627d5e3662275c51e8f9f7be592f55a22adf95231ed68d426", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Golomb Ruler Problem\n\nThis problem is about creating a special kind of ruler with marks on it. Imagine a ruler with some marks on it, and we want to find the best way to place these marks so that the ruler is as short as possible.\n\nThe main variables are:\n\n* `m`: the number of marks on the ruler\n* `mark`: an array that stores the positions of the marks on the ruler\n* `differences`: an array that stores the differences between the positions of the marks\n\nThe basic restrictions or rules of the problem are:\n\n* The marks must be placed in order from left to right (i.e., the first mark is at position 0, and each subsequent mark is to the right of the previous one)\n* All the differences between the positions of the marks must be unique (i.e., no two differences can be the same)\n\nThe goal of the problem is to find the shortest ruler that satisfies these rules. In other words, we want to minimize the length of the ruler.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1010, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ec0f9b6e-9dbd-4dfb-9a8c-f68de8ffcebb": {"__data__": {"id_": "ec0f9b6e-9dbd-4dfb-9a8c-f68de8ffcebb", "embedding": null, "metadata": {"model_name": "graph"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "graph_beginner", "node_type": "4", "metadata": {"model_name": "graph"}, "hash": "e25a9c6a3b668ec8af72dd6289740f71adedc54f2fb2a13993ab413bdf7b692c", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Graph Numbering Problem**\n\nThis problem is about labeling the vertices of a graph with numbers from 1 to 8, such that each number is used only once.\n\n**Main Variables:**\n\n* a, b, c, d, e, f, g, h: These are the labels or numbers assigned to the vertices of the graph.\n\n**Basic Restrictions or Rules:**\n\n* Each number from 1 to 8 can only be used once.\n* The numbers assigned to adjacent vertices (connected by an edge) must differ by at least 2.\n\n**Goal:**\n\nThe goal is to find an assignment of numbers to the vertices that satisfies the above rules. There is no specific objective to minimize or maximize, the goal is simply to find a valid solution.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 737, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c2bd883f-93a3-4330-a0b4-57410f81c6f1": {"__data__": {"id_": "c2bd883f-93a3-4330-a0b4-57410f81c6f1", "embedding": null, "metadata": {"model_name": "itemset_mining"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "itemset_mining_beginner", "node_type": "4", "metadata": {"model_name": "itemset_mining"}, "hash": "08730a81d70e1040b938145ed2e8206f2565ed9527caa181fd90c6f5adcdbfc6", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Problem Name:** Item Selection Problem\n\n**What the problem is about:** Imagine you have a list of items (like bread, butter, cheese, etc.) and you want to choose some of them to buy. You also have some bundles of items that are often bought together (like butter, cheese, and milk). You want to choose a set of items that covers most of these bundles and also has a total price above a certain minimum.\n\n**Main variables:**\n\n* `Items`: the set of items you choose to buy\n* `TDB`: the bundles of items that are often bought together\n* `itemprice`: the price of each item\n* `minUtility`: the minimum total price you want to achieve\n\n**Basic restrictions or rules:**\n\n* You want to choose a set of items that covers at least a certain number of bundles (defined by `Freq`)\n* The total price of the chosen items should be at least `minUtility`\n\n**Goal of the problem:** Find a set of items that covers most of the bundles and has a total price above the minimum, while satisfying the rules above.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1078, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b7ae399c-8379-4edf-914b-638a4cf4ab35": {"__data__": {"id_": "b7ae399c-8379-4edf-914b-638a4cf4ab35", "embedding": null, "metadata": {"model_name": "jobshop"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "jobshop_beginner", "node_type": "4", "metadata": {"model_name": "jobshop"}, "hash": "e94302e148d4934353e81a71fe5153463c4bbf13fa3e6bfa1f7338e266c7f671", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Job Shop Scheduling\n\n**What the problem is about in everyday terms:** Imagine you have a workshop with multiple machines, and you need to perform a series of tasks (or jobs) on these machines. Each task has a specific duration and requires a specific machine. The goal is to schedule these tasks in a way that minimizes the total time it takes to complete all the tasks.\n\n**Main variables and what they mean:**\n\n* `n`: The number of jobs (or tasks) to be performed.\n* `m`: The number of machines in the workshop.\n* `JOB`: A set of integers representing the jobs (1 to `n`).\n* `MACH`: A set of integers representing the machines (1 to `m`).\n* `TASK`: A set of integers representing the tasks (1 to `m`).\n* `d`: An array that stores the duration of each task.\n* `mc`: An array that stores the machine required for each task.\n* `s`: An array of variables that represents the start time of each task.\n* `makespan`: A variable that represents the total time it takes to complete all the tasks.\n\n**Basic restrictions or rules of the problem:**\n\n* Each task must be performed in a specific order (e.g., task 1 must be completed before task 2).\n* Each machine can only perform one task at a time.\n* The start time of each task must be greater than or equal to the completion time of the previous task.\n\n**Goal of the problem:** The goal is to minimize the `makespan`, which is the total time it takes to complete all the tasks.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1569, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ded61cf7-0046-4a14-a7be-07c76f337cab": {"__data__": {"id_": "ded61cf7-0046-4a14-a7be-07c76f337cab", "embedding": null, "metadata": {"model_name": "K4xP2Graceful"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "K4xP2Graceful_beginner", "node_type": "4", "metadata": {"model_name": "K4xP2Graceful"}, "hash": "762aafef834a304f5b0f8e37ae5b82760c65096b29e70c641ba303d2b4a55ad3", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **K4P2 Graceful Graph**\n\nThis problem is about creating a special kind of graph, which is like a network of connected points.\n\n**Main variables:**\n\n* **nodes**: These are the points in the graph, and we need to assign a number to each one.\n* **graph**: This is the connection between the points, telling us which points are connected to each other.\n* **edges**: These are the connections between the points, and we need to assign a number to each connection.\n\n**Basic restrictions or rules:**\n\n* The difference between the numbers of two connected points must be equal to the number of the connection between them.\n* All connections must have different numbers.\n* All points must have different numbers.\n\n**Goal:**\n\nThe goal is to find a way to assign numbers to the points and connections so that all the rules are satisfied.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 910, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "27c72c65-f7d2-4cf7-ad49-d78d30c3aa43": {"__data__": {"id_": "27c72c65-f7d2-4cf7-ad49-d78d30c3aa43", "embedding": null, "metadata": {"model_name": "killer_sudoku"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "killer_sudoku_beginner", "node_type": "4", "metadata": {"model_name": "killer_sudoku"}, "hash": "f46fce5b8c988f45d576d28491dd8131afee7a4c2f3d3ff3eee9e4b7fee844bc", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Killer Sudoku\n\n**What the problem is about in everyday terms:** Killer Sudoku is a puzzle game that combines elements of Sudoku and Kakuro. The goal is to fill a 9x9 grid with numbers from 1 to 9, following certain rules.\n\n**Main variables and what they mean:**\n\n* `x[i, j]`: represents the number in the cell at row `i` and column `j` of the grid.\n* `P` and `segments`: represent the \"cages\" or groups of cells that have specific sum constraints.\n* `num_p` and `num_segments`: represent the number of cages or segments in the puzzle.\n* `num_hints`: represents the maximum number of hints or cells in each cage.\n\n**Basic restrictions or rules of the problem:**\n\n* Each row, column, and 3x3 sub-grid (called a \"nonet\") must contain each number from 1 to 9 exactly once.\n* The sum of the numbers in each cage must match the given sum for that cage.\n* No number can appear more than once in a cage.\n\n**Goal of the problem:** The goal is to find a solution that satisfies all the constraints and rules, filling the entire grid with numbers from 1 to 9.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1198, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4467eab3-c3cc-413f-a759-558199515760": {"__data__": {"id_": "4467eab3-c3cc-413f-a759-558199515760", "embedding": null, "metadata": {"model_name": "knapsack"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "knapsack_beginner", "node_type": "4", "metadata": {"model_name": "knapsack"}, "hash": "a3c9457ee1972b8fa125ab7ec6e854da9cde33893988e45ee68040c5acba9be7", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Knapsack Problem**\n\nThis problem is about packing objects of different sizes and values into a bag with a limited capacity. Imagine you're going on a trip and you have a small bag that can only hold so much weight. You have several items you want to bring, each with a different weight and importance to you. You want to pack the most important items that fit in the bag without exceeding its weight limit.\n\n**Main variables:**\n\n* `n`: the number of objects\n* `capacity`: the maximum weight the bag can hold\n* `profit` (or `value`): how important each object is to you\n* `size`: how much each object weighs\n* `x`: which objects to pack in the bag (how many of each object to take)\n\n**Basic restrictions or rules:**\n\n* You can't pack more objects than you have.\n* The total weight of the packed objects can't exceed the bag's capacity.\n* You can't pack a fraction of an object (you either take it or leave it).\n\n**Goal:**\n\nThe goal is to pack the objects that give you the most importance (or value) while staying within the bag's weight limit.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1129, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "24af84b7-a264-4cda-b2a6-b170ff48f323": {"__data__": {"id_": "24af84b7-a264-4cda-b2a6-b170ff48f323", "embedding": null, "metadata": {"model_name": "langford"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "langford_beginner", "node_type": "4", "metadata": {"model_name": "langford"}, "hash": "2d8cd18b8e31c063032d4a298c979478227d115d089c87f7cfb35654ac523847", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Langford's Problem\n\n**What the problem is about in everyday terms:** Imagine you have a set of numbers from 1 to n, and you want to arrange them in a sequence in a special way. Each number should appear m times in the sequence. The rule is that if a number k appears, the next time it appears, it should be k+1 positions later in the sequence.\n\n**Main variables and what they mean:**\n\n* n: the highest number in the set (e.g., if n=4, the set is {1, 2, 3, 4})\n* m: how many times each number should appear in the sequence\n* x (or y): the sequence of numbers, where each number is a position in the sequence\n\n**Basic restrictions or rules of the problem:**\n\n* Each number from 1 to n should appear m times in the sequence.\n* If a number k appears, the next time it appears, it should be k+1 positions later in the sequence.\n\n**Goal of the problem:** The goal is to find a sequence that satisfies the rules above.\n\nNote that the different models are just different ways of representing the same problem, and the explanation above applies to all of them.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1201, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "422c9037-5bfd-4cdb-af00-2a20faea8e34": {"__data__": {"id_": "422c9037-5bfd-4cdb-af00-2a20faea8e34", "embedding": null, "metadata": {"model_name": "loan"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "loan_beginner", "node_type": "4", "metadata": {"model_name": "loan"}, "hash": "e66f44bfa025c1a49afee5c40a2b6b2f89fc8ad7a2957106ec3ce5add26b65f5", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Loan Repayment Problem\n\nThis problem is about borrowing money and paying it back with interest over a year.\n\nThe main variables are:\n- R: the amount of money you pay back each quarter (like a monthly payment, but every 3 months)\n- P: the amount of money you borrow initially\n- I: the interest rate, which is like a fee for borrowing money\n- B1, B2, B3, B4: these are like snapshots of how much you still owe after each quarter\n\nThe basic rules are:\n- You borrow some money (P) and promise to pay it back with some extra (I) as interest.\n- Each quarter, you pay back some money (R), and the amount you still owe changes based on the interest rate.\n\nThe goal of the problem is to find a way to pay back the loan over a year, with the given interest rate, and see how much you still owe at the end.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 879, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a1750cd1-eae1-4cf8-9f6c-9ce05854af80": {"__data__": {"id_": "a1750cd1-eae1-4cf8-9f6c-9ce05854af80", "embedding": null, "metadata": {"model_name": "ltsp"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ltsp_beginner", "node_type": "4", "metadata": {"model_name": "ltsp"}, "hash": "67408219b927a51b43d2039bd54d1507554444876ad08f5b48d6d357a49735f6", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Traveling Salesman Problem**\n\nThis problem is about planning a route for a salesman who needs to visit a certain number of cities and return to the starting point.\n\n**Main variables:**\n\n* `n`: the number of cities\n* `coord`: the coordinates of each city (think of it like the address of each city)\n* `order`: the order in which the salesman visits each city\n* `city`: the city at each position in the order\n\n**Basic restrictions or rules:**\n\n* The salesman must visit each city exactly once\n* The salesman must follow the precedences (rules) that specify which city must be visited before another city\n* The salesman must return to the starting point at the end of the route\n\n**Goal:**\n\nThe goal is to find the shortest possible route that visits all cities and returns to the starting point, while following the precedences and rules. In other words, we want to minimize the total distance traveled by the salesman.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1002, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6a73104f-9e36-4551-93f2-56f5f462f5f8": {"__data__": {"id_": "6a73104f-9e36-4551-93f2-56f5f462f5f8", "embedding": null, "metadata": {"model_name": "magic_hexagon"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_hexagon_beginner", "node_type": "4", "metadata": {"model_name": "magic_hexagon"}, "hash": "ddec0bef7a56d3baa4665e392a5541d9b7cc4731f1a33a6964c48507c9c1d063", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Magic Hexagon\n\nThis problem is about creating a special kind of hexagon (a six-sided shape) with numbers inside it. Imagine a hexagon divided into smaller triangles, and each triangle has a number in it.\n\nThe main variables are the numbers that go inside the triangles. There are 19 numbers in total, and they are represented by letters like a, b, c, and so on.\n\nThe basic rules of the problem are:\n\n* Each triangle must have a different number in it.\n* The numbers in each row of triangles must add up to 38.\n* The numbers in each column of triangles must also add up to 38.\n* Some specific triangles have to have smaller numbers than others.\n\nThe goal of the problem is to find a way to arrange the numbers in the triangles so that all the rules are followed.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 845, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9569f4c0-4335-46e3-9fbf-d7f4b7458722": {"__data__": {"id_": "9569f4c0-4335-46e3-9fbf-d7f4b7458722", "embedding": null, "metadata": {"model_name": "magic_sequence"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_sequence_beginner", "node_type": "4", "metadata": {"model_name": "magic_sequence"}, "hash": "3596d5e27c894b3d6d8dd85f1f0b0e1fd98e07564eb3f097769e5301b7ce7172", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Magic Sequence and Magic Square\n\n**What the problem is about in everyday terms:** This problem is about finding a special kind of sequence or arrangement of numbers that has certain properties. In the case of the magic sequence, it's a sequence of numbers where each number appears a certain number of times, and that number is equal to the value of the number itself. For example, if the sequence has a 6, it means the number 6 appears 6 times in the sequence. In the case of the magic square, it's an arrangement of numbers in a square grid where each row, column, and diagonal adds up to the same total.\n\n**Main variables and what they mean:**\n\n* `s` or `magic`: an array of variables that represent the magic sequence or square.\n* `n`: the length of the sequence or the size of the square.\n* `total`: the total sum of the numbers in the magic square.\n\n**Basic restrictions or rules of the problem:**\n\n* In the magic sequence, each number appears a certain number of times, and that number is equal to the value of the number itself.\n* In the magic square, each row, column, and diagonal adds up to the same total.\n* Each cell in the magic square can only contain one number.\n\n**Goal of the problem:**\n\n* Find a magic sequence or square that satisfies the rules and restrictions.\n* In some cases, the goal is to find all possible solutions or to count the number of solutions.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1529, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e46404eb-9079-4658-a12d-9eb4afe4bc09": {"__data__": {"id_": "e46404eb-9079-4658-a12d-9eb4afe4bc09", "embedding": null, "metadata": {"model_name": "maximum_density_still_life"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "maximum_density_still_life_beginner", "node_type": "4", "metadata": {"model_name": "maximum_density_still_life"}, "hash": "8975f001d574c11df49e649890b4088ef5702ec191c6cb32f89df7f3d7c51035", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Problem Name:** Maximum Density Still Life\n\n**What the problem is about:** Imagine you have a grid of cells that can be either alive (represented by 1) or dead (represented by 0). The goal is to find a pattern of alive and dead cells that follows certain rules and has the maximum number of alive cells.\n\n**Main variables:**\n\n* `grid`: a 2D array that represents the grid of cells, where each cell can be either alive (1) or dead (0).\n* `z`: the total number of alive cells in the grid.\n\n**Basic restrictions or rules:**\n\n* Cells in the outermost rows and columns of the grid must be dead.\n* A cell becomes alive if it has exactly three alive neighbors.\n* An alive cell must have either two or three alive neighbors to stay alive.\n* The pattern of alive and dead cells must be symmetrical in certain ways.\n\n**Goal:** The goal is to maximize the number of alive cells (`z`) in the grid while following the rules above.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1003, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0479ed3d-59e1-46c9-b9fd-f0f24f105518": {"__data__": {"id_": "0479ed3d-59e1-46c9-b9fd-f0f24f105518", "embedding": null, "metadata": {"model_name": "mip"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "mip_beginner", "node_type": "4", "metadata": {"model_name": "mip"}, "hash": "4c9d15e98fa8962426be68775648aabec7a5391c2addbbd806d74649ee4db3fe", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Problem Name:** Resource Allocation Problem\n\n**What the problem is about in everyday terms:** Imagine you have three types of resources (let's call them B, C, and D) and you want to allocate them in the best way possible to maximize your profit or benefit. You have some limitations on how much of each resource you can use, and you want to find the optimal combination that gives you the highest return.\n\n**Main variables and what they mean:**\n\n* B, C, and D: These are the three types of resources you have. They can be thought of as quantities of something (e.g., money, materials, labor).\n* x and y: In some models, these are used instead of B and C, but they represent the same idea - quantities of resources.\n\n**Basic restrictions or rules of the problem:**\n\n* You can't use more resources than you have available (represented by the \"less than or equal to\" constraints).\n* You can't use a negative amount of resources (represented by the \"greater than or equal to 0\" constraints).\n\n**Goal of the problem:**\n\n* Maximize the total benefit or profit you get from allocating the resources. This is represented by the \"maximize\" objective function, which combines the resources in a specific way to give you a total value.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1310, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0b65a57d-c559-4897-9409-2831a8e530f3": {"__data__": {"id_": "0b65a57d-c559-4897-9409-2831a8e530f3", "embedding": null, "metadata": {"model_name": "missing_solution"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "missing_solution_beginner", "node_type": "4", "metadata": {"model_name": "missing_solution"}, "hash": "0403d35eb2a784f004bd4d8057e2975f723cc0179504539d1e5cb7707bef907c", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Seating Arrangement Problem**\n\nThis problem is about arranging people in a line, like in a queue or at a table, in a specific order.\n\n**Main Variables:**\n\n* `n`: The number of people.\n* `gender`: An array that stores the gender of each person (male or female).\n* `age`: An array that stores the age of each person.\n* `order`: An array that stores the order in which the people should be arranged.\n\n**Basic Restrictions or Rules:**\n\n* The people should be arranged in a line, one after the other.\n* Males and females should alternate in the line (i.e., a male should be followed by a female, and vice versa).\n* The age difference between two people sitting next to each other should not be more than 10 years.\n\n**Goal:**\n\nThe goal is to find an arrangement of people that satisfies all the above rules. There is no specific goal to minimize or maximize anything; we just want to find a valid arrangement.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 989, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f2966efd-ce8e-4874-83f5-0cea183ec6a2": {"__data__": {"id_": "f2966efd-ce8e-4874-83f5-0cea183ec6a2", "embedding": null, "metadata": {"model_name": "nonogram_create_automaton2"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "nonogram_create_automaton2_beginner", "node_type": "4", "metadata": {"model_name": "nonogram_create_automaton2"}, "hash": "1b7b9650d717ca75887606bac5efe302b57fd9236437b1a241ce8bc1b3de9217", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Nonogram Problem**\n\n**What is it about?**\nThe Nonogram problem is about creating a picture using a set of rules. Imagine you have a grid of squares, and you need to fill some of them with colors (let's say black and white) to create a specific image. The rules tell you how many consecutive squares of each color should be in each row and column.\n\n**Main variables:**\n\n* `x` or `A`: a 2D array that represents the grid of squares, where each square can be either 1 (white) or 2 (black).\n* `rows` and `cols`: 2D arrays that contain the rules for each row and column, respectively.\n* `row_rules` and `col_rules`: 2D arrays that contain the specific rules for each row and column.\n\n**Basic restrictions or rules:**\n\n* Each row and column must follow the rules specified in `rows` and `cols`, respectively.\n* The rules specify how many consecutive squares of each color should be in each row and column.\n\n**Goal:**\nThe goal is to find a valid configuration of the grid that satisfies all the rules, creating a specific image.\n\nIn simpler terms, the problem is about solving a puzzle where you need to fill a grid with black and white squares according to some rules, and the goal is to create a specific picture.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1294, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bf76992c-935d-4233-a4b9-7a65d0b6a93d": {"__data__": {"id_": "bf76992c-935d-4233-a4b9-7a65d0b6a93d", "embedding": null, "metadata": {"model_name": "nurses"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "nurses_beginner", "node_type": "4", "metadata": {"model_name": "nurses"}, "hash": "4212cd99d582c777813949e999497bd71df92d7ec79918252503a7ce3a42f527", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Nurse Scheduling Problem.\n\nThis problem is about creating a schedule for nurses to work at a hospital. Imagine you are the manager of a hospital and you need to create a schedule for your nurses to work over a certain number of days.\n\nThe main variables are:\n\n* Nurses (represented by numbers 1 to k): These are the people who will be working at the hospital.\n* Days (represented by numbers 1 to m): These are the days of the week/month that the nurses will be working.\n* Shifts (represented by numbers 1 to 3): These are the different types of shifts that the nurses can work, such as day shift, night shift, or a day off.\n\nThe basic restrictions or rules of the problem are:\n\n* If a nurse works a night shift two days in a row, they must have a day off on the third day.\n* If a nurse works a night shift, they cannot work a day shift the next day.\n* There must be a certain number of nurses working the night shift each day (between a lower and upper bound).\n\nThe goal of the problem is to create a schedule that satisfies all these rules and restrictions.\n\nNote that the two models are essentially the same, with the second model being a slightly different implementation of the same problem.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1279, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "81d79f4d-a0ec-4007-af68-847ded83536f": {"__data__": {"id_": "81d79f4d-a0ec-4007-af68-847ded83536f", "embedding": null, "metadata": {"model_name": "opd"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "opd_beginner", "node_type": "4", "metadata": {"model_name": "opd"}, "hash": "1178b7a23ce6974af3d906a0068f6d54a46dca84e825cc5ce527f755687fc6bd", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Design of Collateralised Debt Obligations Squared (CDO^2) Transactions\n\n**What the problem is about in everyday terms:** Imagine you have a set of boxes (v) and each box can hold a certain number of items (r). You want to put items into the boxes in a way that each box has exactly r items, and the items in each box are distributed in a way that is as different as possible from the items in every other box.\n\n**Main variables and what they mean:**\n\n* v: the number of boxes\n* b: the maximum number of items that can be put into each box\n* r: the exact number of items that each box should have\n* m: a matrix that shows which items are in each box (0 means the item is not in the box, 1 means it is)\n* objective (also called lambda): a measure of how different the items in each box are from the items in every other box\n\n**Basic restrictions or rules of the problem:**\n\n* Each box must have exactly r items\n* The items in each box should be distributed in a way that is as different as possible from the items in every other box\n\n**Goal of the problem:** Find a way to put items into the boxes that minimizes the objective (lambda), which means making the items in each box as different as possible from the items in every other box.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1385, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2715be99-61b5-4664-94ce-87ad66d45263": {"__data__": {"id_": "2715be99-61b5-4664-94ce-87ad66d45263", "embedding": null, "metadata": {"model_name": "partition"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "partition_beginner", "node_type": "4", "metadata": {"model_name": "partition"}, "hash": "5e3d5c2c3308b25974b62222fe793562479a34e0dc0c6da74ce911ea82b45681", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Partition Problem**\n\nThis problem is about dividing a set of numbers into two groups, so that the sum of the numbers in each group is equal, and the sum of the squares of the numbers in each group is also equal.\n\n**Main Variables:**\n\n* `x` and `y` are the two groups of numbers.\n* `n` is the number of numbers in each group.\n\n**Basic Restrictions:**\n\n* Each group must have the same number of numbers (`n`).\n* The numbers in each group must be different from each other.\n* The sum of the numbers in each group must be equal.\n* The sum of the squares of the numbers in each group must be equal.\n\n**Goal:**\n\nThe goal is to find two groups of numbers that satisfy all the restrictions above.\n\nIn simpler terms, imagine you have a set of numbers, and you want to divide them into two groups, so that the total value of each group is the same, and the total value of the squares of each group is also the same.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 991, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3ef1035d-709a-425b-a3c3-734a80e29209": {"__data__": {"id_": "3ef1035d-709a-425b-a3c3-734a80e29209", "embedding": null, "metadata": {"model_name": "photo"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "photo_beginner", "node_type": "4", "metadata": {"model_name": "photo"}, "hash": "0afcfec781d24f0b570fe05f7cd290f1fb53ae288b0e775e238987cd80a0d7f0", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Social Golfers Problem.\n\nThis problem is about organizing a group of people to play golf together in a way that makes everyone happy. Imagine you have a group of friends who want to play golf together, and you want to arrange them into pairs to play together.\n\nThe main variables are:\n\n* PERSON: This represents each individual person in the group.\n* POS: This represents the position or pair that each person will play in.\n* friend: This is a table that shows how much each person likes to play with each other person.\n* x and y: These are variables that will be used to decide who plays with whom.\n\nThe basic restrictions or rules of the problem are:\n\n* Each person must play with someone.\n* No two people can play in the same position (pair).\n* The goal is to make sure that people play with their friends as much as possible.\n\nThe goal of the problem is to maximize the total happiness of all the golfers, which is measured by how much they like to play with the person they are paired with.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1079, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fdee7291-4bee-4c2d-b28e-30ab98a533c2": {"__data__": {"id_": "fdee7291-4bee-4c2d-b28e-30ab98a533c2", "embedding": null, "metadata": {"model_name": "project_scheduling"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "project_scheduling_beginner", "node_type": "4", "metadata": {"model_name": "project_scheduling"}, "hash": "5757415c7e183cea650fd3113e33259d2be95ddf5b5556309483ebef7f9fdfb4", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **House Building Problem**\n\nThis problem is about building a house. Imagine you have a list of tasks to complete, like laying foundations, building walls, installing doors and windows, and putting on a roof. Each task takes a certain amount of time to finish.\n\n**Main Variables:**\n\n* **Tasks**: These are the individual jobs that need to be done to build the house, like laying foundations or installing doors.\n* **Duration**: This is how long each task takes to complete.\n* **Start time**: This is when each task begins.\n* **Makespan**: This is the total time it takes to complete all the tasks.\n\n**Basic Restrictions or Rules:**\n\n* Some tasks can't start until others are finished. For example, you can't start building walls until the foundations are laid.\n* Some tasks can't happen at the same time. For example, you can't be building the interior walls and exterior walls at the same time.\n\n**Goal:**\n\nThe goal is to find the order and timing of the tasks that will allow you to build the house in the shortest amount of time possible.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1124, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1c44cd22-62d5-4fc0-9b4f-2955334be8e7": {"__data__": {"id_": "1c44cd22-62d5-4fc0-9b4f-2955334be8e7", "embedding": null, "metadata": {"model_name": "QuasigroupCompletion"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasigroupCompletion_beginner", "node_type": "4", "metadata": {"model_name": "QuasigroupCompletion"}, "hash": "99ea3252455a8ca439195d065844be0b42f5f2a1e39ad95ff0fd4f4de87188ed", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Problem Name:** Quasigroup with Holes (also known as Latin Square Completion)\n\n**What the problem is about:** Imagine you have a grid with some numbers already filled in, and some empty cells. Your task is to fill in the empty cells with numbers so that each row, column, and cell has each number only once.\n\n**Main variables:**\n\n* `N`: The size of the grid (e.g., 3x3, 4x4, etc.)\n* `start`: The initial grid with some numbers already filled in and some empty cells (represented by 0)\n* `puzzle`: The grid that we want to fill in with numbers\n\n**Basic restrictions or rules:**\n\n* Each row must have each number only once\n* Each column must have each number only once\n* Each cell can only have one number assigned to it\n* The numbers already filled in the `start` grid cannot be changed\n\n**Goal of the problem:** The goal is to find a way to fill in the empty cells in the grid so that all the rules are satisfied. There is no specific goal to minimize or maximize anything; we just want to find a valid solution that meets all the rules.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1123, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "79b4455a-f750-4171-8f32-1c84a3d99dd8": {"__data__": {"id_": "79b4455a-f750-4171-8f32-1c84a3d99dd8", "embedding": null, "metadata": {"model_name": "QuasiGroupExistence"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "QuasiGroupExistence_beginner", "node_type": "4", "metadata": {"model_name": "QuasiGroupExistence"}, "hash": "f95f94f18834f2130c019a5208d33f991eeb09901b85ff45b24e07f65baf8a52", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Quasigroup existence problem\n\n**What the problem is about:** Imagine you have a table with numbers from 1 to n, where n is a given number. You need to fill this table in a special way, so that each row and each column contains each number exactly once. Additionally, there are some rules about how the numbers in the table should be related to each other.\n\n**Main variables:**\n\n* `quasiGroup`: a table (or matrix) with numbers from 1 to n, where each row and column contains each number exactly once.\n* `qgDiagonal`: a list of numbers that represents the diagonal of the `quasiGroup` table.\n\n**Basic restrictions or rules:**\n\n* Each row and each column of the `quasiGroup` table should contain each number exactly once.\n* There are some specific rules about how the numbers in the table should be related to each other, such as `(b*a)*b = a*(b*a)` or `(j*i)*(i*j) = i`.\n* The diagonal of the `quasiGroup` table should also satisfy some specific rules.\n\n**Goal of the problem:** The goal is to find a `quasiGroup` table that satisfies all the rules and restrictions.\n\nNote that the problem is about finding a specific type of mathematical structure called a quasigroup, which is a set with a binary operation that satisfies certain properties. The problem is to find a quasigroup of a given order (i.e., with a given number of elements).", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1486, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "23fb4f42-982f-4e2b-a7ba-2a900c78bea8": {"__data__": {"id_": "23fb4f42-982f-4e2b-a7ba-2a900c78bea8", "embedding": null, "metadata": {"model_name": "queens"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "queens_beginner", "node_type": "4", "metadata": {"model_name": "queens"}, "hash": "acf515063db5e5d07a4b8a1932bf5d47acb1714cda16a7fe7567d67778dd2d4a", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **The N-Queens Problem**\n\n**What is it about?**\nImagine you have a chessboard with `n` rows and `n` columns. You want to place `n` queens on the board in such a way that no queen can attack another queen.\n\n**Main variables:**\n* `n`: the number of queens (and the size of the chessboard)\n* `queens`: an array of `n` variables, each representing the column where a queen is placed in a particular row\n\n**Basic restrictions or rules:**\n* Each queen must be placed in a different column (no two queens can be in the same column)\n* No queen can attack another queen diagonally (i.e., no two queens can be on the same diagonal)\n\n**Goal:**\nThe goal is to find a way to place all `n` queens on the board such that they do not attack each other.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 820, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d57961b0-7604-444f-9418-b4a2137b3961": {"__data__": {"id_": "d57961b0-7604-444f-9418-b4a2137b3961", "embedding": null, "metadata": {"model_name": "rcpsp"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rcpsp_beginner", "node_type": "4", "metadata": {"model_name": "rcpsp"}, "hash": "ff7cd4b7518cfbc84f6c4052b5502fa2007d891af77f03727e98db5d00e5af88", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Resource-Constrained Project Scheduling Problem**\n\nThis problem is about planning a set of tasks that need to be done, using a limited amount of resources, like machines or workers. Each task takes a certain amount of time to complete and uses a certain amount of resources.\n\n**Main variables:**\n\n* Tasks: These are the individual jobs that need to be done.\n* Resources: These are the machines, workers, or other things needed to complete the tasks.\n* Start time: This is when each task will begin.\n* Duration: This is how long each task will take to complete.\n* Resource usage: This is how much of each resource is needed for each task.\n\n**Basic restrictions or rules:**\n\n* Each task must be done after its predecessors (tasks that need to be finished before it can start).\n* Each resource has a limited capacity, and the total usage of that resource by all tasks cannot exceed that capacity.\n* Each task must start after its predecessors have finished.\n\n**Goal:**\n\nThe goal is to find a schedule that completes all tasks as quickly as possible, while following the rules and restrictions above. In other words, we want to minimize the total time it takes to complete all tasks.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1265, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "97acf8ea-577b-47ea-b19b-8171e81ce767": {"__data__": {"id_": "97acf8ea-577b-47ea-b19b-8171e81ce767", "embedding": null, "metadata": {"model_name": "rehearsal"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rehearsal_beginner", "node_type": "4", "metadata": {"model_name": "rehearsal"}, "hash": "3b2c7757ad40e7765b37202d5394c88cf84cf62c0f0443008ec1c21f6cc08861", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Scheduling a Rehearsal\n\n**What the problem is about in everyday terms:** Imagine you are the conductor of an orchestra, and you need to schedule a rehearsal for a concert. There are 9 pieces of music to be rehearsed, and 5 musicians will be participating. Each musician is required for some pieces, but not all. You want to find the best order to rehearse the pieces so that the musicians don't have to wait too long between their performances.\n\n**Main variables and what they mean:**\n\n* `rehearsal_order`: the order in which the pieces will be rehearsed\n* `waiting_time`: the time each musician spends waiting between their performances\n* `total_waiting_time`: the total time all musicians spend waiting\n\n**Basic restrictions or rules of the problem:**\n\n* Each musician can arrive at the rehearsal just before their first piece and leave just after their last piece.\n* Each piece has a specific duration (length of time it takes to rehearse).\n* The order of the pieces must be determined so that each musician's waiting time is minimized.\n\n**Goal of the problem:** Find the order of the pieces that minimizes the total waiting time for all musicians.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1301, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c187b8ca-71de-427a-b730-21d695c97305": {"__data__": {"id_": "c187b8ca-71de-427a-b730-21d695c97305", "embedding": null, "metadata": {"model_name": "restart"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "restart_beginner", "node_type": "4", "metadata": {"model_name": "restart"}, "hash": "1cd93c099cfbbe580cd4fe482dbf1ee38c99dc777b172d1d78c28fdbc3a9bf0c", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **The Problem of the Ten Variables**\n\nThis problem is about assigning numbers to ten variables in a special way.\n\n**Main Variables:**\n\nThe problem has ten variables, labeled x[1] to x[10]. Each variable can take a value between 1 and 10.\n\n**Basic Restrictions or Rules:**\n\nThe rules are:\n\n* Each variable must have a different value than the others.\n* The values of variables x[2] to x[10] cannot be more than 9.\n* The value of variable x[1] must be at least 9.\n\n**Goal of the Problem:**\n\nThe goal is to find a way to assign numbers to the variables that satisfy all the rules. In other words, we want to find a solution that makes all the variables happy!\n\nNote that the three models are slightly different, but they all represent the same problem. The differences are in how the problem is solved, not in what the problem is about.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 917, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9a919f76-075d-46f4-8b68-2f8af0f01d55": {"__data__": {"id_": "9a919f76-075d-46f4-8b68-2f8af0f01d55", "embedding": null, "metadata": {"model_name": "RosteringProblem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "RosteringProblem_beginner", "node_type": "4", "metadata": {"model_name": "RosteringProblem"}, "hash": "1aa5b7e2cc26c8b8cdbceeb2742516b8bae95d493298c62e0d121ec056e407ef", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Nurse Scheduling Problem**\n\nThis problem is about creating a schedule for nurses to work in a hospital. Imagine you are the person in charge of making sure there are enough nurses working each day to take care of patients.\n\n**Main Variables:**\n\n* `plan1d`, `plan2d`, and `plan2dT`: These are arrays that represent the schedule of nurses. They show which shift each nurse is working on each day (early, late, night, or day off).\n* `shiftRequirements`: This is a matrix that shows how many nurses are needed for each shift on each day of the week.\n* `s_min` and `s_max`: These are the minimum and maximum number of days in a row that a nurse can work the same shift.\n\n**Basic Restrictions or Rules:**\n\n* Nurses need to work a certain number of days in a row with the same shift (between `s_min` and `s_max` days).\n* Weekend days (Saturday and Sunday) must have the same shift.\n* There must be at least 2 rest days every 2 weeks.\n* The order of shifts follows a rotating principle (e.g., after an early shift, the next shift can only be the same or a higher value, or a rest shift).\n* The number of nurses working each shift must meet the required staff numbers for that day.\n\n**Goal:**\n\nThe goal is to create a schedule that satisfies all these rules and restrictions, while also making sure that the hospital has enough nurses working each day to take care of patients.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1454, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "134210d5-d16f-4d5e-8868-c6582460e9b7": {"__data__": {"id_": "134210d5-d16f-4d5e-8868-c6582460e9b7", "embedding": null, "metadata": {"model_name": "sb"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sb_beginner", "node_type": "4", "metadata": {"model_name": "sb"}, "hash": "a140e112e0339cc4691247d631fb1f96db08d8c7b69e2a608385d360417a3d2f", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Solitaire Battleships**\n\n**What is it about?**\nImagine you have a puzzle with a partially filled grid, and you need to fill in the rest of the grid with ships of different lengths. You are given the number of ships of each length and the number of ships in each row and column.\n\n**Main variables:**\n\n* `board`: a grid that represents the puzzle, where each cell can be a ship part (like a submarine, left end, right end, etc.) or water.\n* `fill`: a grid that shows which cells are part of a ship.\n* `npiece`: the number of each type of ship part (like submarines, left ends, etc.).\n\n**Basic restrictions or rules:**\n\n* The puzzle must respect the given hints (initially filled cells).\n* Ships cannot touch each other (there must be water between them).\n* Each ship must have the correct number of parts (like left and right ends, middle parts, etc.).\n* The number of ships in each row and column must match the given sums.\n\n**Goal:**\nThe goal is to find a solution that satisfies all the rules and restrictions, and then output the completed puzzle grid with the ship parts and the row and column sums.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1188, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3224a6eb-add9-4648-a5a7-bef78418c1b7": {"__data__": {"id_": "3224a6eb-add9-4648-a5a7-bef78418c1b7", "embedding": null, "metadata": {"model_name": "schur"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "schur_beginner", "node_type": "4", "metadata": {"model_name": "schur"}, "hash": "524970d8d478e563e252aceb99c471ac406c919921f444559c3e215d5a0aa149", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Schur's Numbers Problem\n\nThis problem is about distributing balls into boxes in a special way. Imagine you have a certain number of balls, each with a unique label from 1 to n, and you want to put them into a certain number of boxes.\n\nThe main variables are:\n- n: the number of balls\n- c: the number of boxes\n- box: an array that shows which box each ball goes into\n\nThe basic restrictions or rules of the problem are:\n- Each ball must go into a box\n- No box can contain three balls with labels that add up to each other (for example, balls 1, 2, and 3 cannot be in the same box because 1+2=3)\n\nThe goal of the problem is to find a way to distribute the balls into the boxes that follows these rules.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 784, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4fd5d53b-01f3-4a82-9da2-fa545e94e112": {"__data__": {"id_": "4fd5d53b-01f3-4a82-9da2-fa545e94e112", "embedding": null, "metadata": {"model_name": "setselect"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "setselect_beginner", "node_type": "4", "metadata": {"model_name": "setselect"}, "hash": "2e5ce8dbd0c87ba71d36f8459b85fb9bc54e84601ab8ed789800fc049b0c97e6", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **The Set Selection Problem**\n\n**What is it about?**\nImagine you have a bunch of items, and you want to choose a few of them. These items are grouped into smaller sets, and you have some rules to follow when making your selection.\n\n**Main variables:**\n\n* `n`: The total number of items.\n* `k`: The number of smaller sets that the items are grouped into.\n* `s`: The smaller sets themselves, each containing some of the items.\n* `x`: The selection of items you want to choose.\n\n**Basic restrictions or rules:**\n\n* You can only choose one item from each smaller set.\n* The total number of items you choose is limited (this limit is `u` in some models).\n\n**Goal:**\nThe goal is to choose the items that add up to the largest total value. In other words, you want to maximize the sum of the items you select.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 886, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4aed6317-cf4c-4ec8-9fad-12ad0fd99cc1": {"__data__": {"id_": "4aed6317-cf4c-4ec8-9fad-12ad0fd99cc1", "embedding": null, "metadata": {"model_name": "shipping"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "shipping_beginner", "node_type": "4", "metadata": {"model_name": "shipping"}, "hash": "41523080436eacad913597cc3707dd54917caf61b282e1d6f9da5075c9a88df9", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Problem Name:** Warehouse-Factories Shipping Problem\n\n**What the problem is about:** Imagine you have several warehouses that need certain amounts of goods, and several factories that can produce those goods. You need to decide how much of each good to ship from each factory to each warehouse, so that each warehouse gets what it needs, and each factory doesn't produce more than it can. You also want to minimize the total cost of shipping.\n\n**Main variables:**\n\n* `W`: The number of warehouses.\n* `F`: The number of factories.\n* `demand`: An array that says how much of each good each warehouse needs.\n* `production`: An array that says how much of each good each factory can produce.\n* `cost`: An array that says how much it costs to ship one unit of each good from each factory to each warehouse.\n* `ship`: An array that says how much of each good to ship from each factory to each warehouse.\n\n**Basic restrictions or rules:**\n\n* Each warehouse must get at least as much of each good as it needs.\n* Each factory can't produce more than it can.\n* You can't ship a negative amount of goods.\n\n**Goal:** Minimize the total cost of shipping goods from factories to warehouses.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1262, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0344e1e1-10bf-45b3-92c2-5b67e23375cd": {"__data__": {"id_": "0344e1e1-10bf-45b3-92c2-5b67e23375cd", "embedding": null, "metadata": {"model_name": "simple-prod-planning"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "simple-prod-planning_beginner", "node_type": "4", "metadata": {"model_name": "simple-prod-planning"}, "hash": "57c94290db2e88935f36bfe203bc158560f862da94e069c4bc2af75b92df6155", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Problem Name:** Product Production Planning\n\n**What the problem is about:** Imagine you have a factory that produces different products, like toys, clothes, or food. You have limited resources, like machines, workers, and raw materials, to make these products. You want to decide how many units of each product to produce to make the most profit possible.\n\n**Main variables:**\n\n* `produce`: how many units of each product to make\n* `used`: how much of each resource is used to make the products\n\n**Basic restrictions or rules:**\n\n* You can't use more resources than you have available\n* You need a certain amount of each resource to make one unit of each product\n* You can't make a negative amount of any product\n\n**Goal:** Maximize the total profit by deciding how many units of each product to produce, while following the rules and restrictions.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 934, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c3104dcb-cca7-4438-a00c-a28d02579bdd": {"__data__": {"id_": "c3104dcb-cca7-4438-a00c-a28d02579bdd", "embedding": null, "metadata": {"model_name": "sonet_problem"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "sonet_problem_beginner", "node_type": "4", "metadata": {"model_name": "sonet_problem"}, "hash": "bbab5432cf2a567952d3c100759e0bcd9bc31431f5ee422b0cd45294a1956307", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    SONET Problem\n\nThe SONET problem is about designing a network that connects certain nodes (think of them as computers or devices) in a way that uses the fewest resources possible.\n\nThe main variables are:\n\n* Rings: These are like circles that connect nodes together. Each ring can hold a certain number of nodes.\n* Nodes: These are the devices that need to be connected.\n* Demand: This is a list of which nodes need to be connected to each other.\n* Capacity nodes: This is the maximum number of nodes that can be on each ring.\n\nThe basic restrictions or rules of the problem are:\n\n* If two nodes need to be connected, they must be on the same ring.\n* Each ring can only hold a certain number of nodes, based on its capacity.\n\nThe goal of the problem is to use the fewest number of rings (and therefore the fewest resources) to connect all the nodes that need to be connected.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 959, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "918c8927-0e43-4cc5-88cc-77b88657bd62": {"__data__": {"id_": "918c8927-0e43-4cc5-88cc-77b88657bd62", "embedding": null, "metadata": {"model_name": "square_pack"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "square_pack_beginner", "node_type": "4", "metadata": {"model_name": "square_pack"}, "hash": "cb554696852a7ba7455f3d823a832773df3ef24ffd023550408addfa0445e5e6", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Problem Name:** Square Packing Problem\n\n**What the problem is about:** Imagine you have a set of squares of different sizes, and you want to pack them into a rectangle (a box with a length and a width) in a way that they don't overlap with each other. You want to find the smallest rectangle that can fit all the squares.\n\n**Main variables:**\n\n* `n`: The number of squares.\n* `height` and `width`: The length and width of the rectangle.\n* `x` and `y`: The coordinates (positions) of each square in the rectangle.\n* `area`: The total area of the rectangle.\n\n**Basic restrictions or rules:**\n\n* Each square must fit inside the rectangle.\n* No two squares can overlap with each other.\n* The squares must be packed in a way that they don't stick out of the rectangle.\n\n**Goal of the problem:** Find the smallest rectangle (with the smallest area) that can fit all the squares without any overlaps.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 979, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3672d5af-30f6-4305-9be4-ea94836364ba": {"__data__": {"id_": "3672d5af-30f6-4305-9be4-ea94836364ba", "embedding": null, "metadata": {"model_name": "stableroommates"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "stableroommates_beginner", "node_type": "4", "metadata": {"model_name": "stableroommates"}, "hash": "6e447cd2add82f4347956c7471f81427825464ebafda8492f95bc3755adb37b7", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **The Stable Roommates Problem**\n\nThis problem is about finding a way to pair up people (called \"agents\") in a way that makes everyone happy.\n\n**Main Variables:**\n\n* `n`: The number of agents (people) involved.\n* `pref`: A list of preferences for each agent, showing who they would like to be paired with.\n* `a`: A list of assignments, showing who each agent is paired with.\n* `rank`: A list showing the ranking of each agent's preferences.\n\n**Basic Restrictions or Rules:**\n\n* Each agent has a list of preferences, and they cannot prefer themselves.\n* Each agent's preferences must be unique (they can't prefer the same person twice).\n* The ranking of each agent's preferences is determined by their list of preferences.\n\n**Goal:**\n\nThe goal is to find a way to pair up the agents in a way that satisfies everyone's preferences as much as possible. This means that if an agent prefers someone, they should be paired with that person if possible. The problem is trying to find a stable solution, where no agent would rather be paired with someone else if they had the chance.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1159, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "abef35a2-972a-4faa-aa3a-a7ca09aa7e3c": {"__data__": {"id_": "abef35a2-972a-4faa-aa3a-a7ca09aa7e3c", "embedding": null, "metadata": {"model_name": "steiner"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "steiner_beginner", "node_type": "4", "metadata": {"model_name": "steiner"}, "hash": "711f958e57c5a207405b373d76b484a5d907cfca073ecd9b6d688359d2b6b601", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **The Ternary Steiner Problem**\n\n**What is it about?**\nImagine you have a set of items, like toys or balls, and you want to group them into sets of three in a special way.\n\n**Main variables:**\n* `N`: The total number of items (toys or balls).\n* `Sets`: A collection of groups, each containing three items.\n\n**Basic restrictions or rules:**\n* Each group must have exactly three items.\n* Any two groups can share at most one item.\n\n**Goal:**\nThe goal is to find a way to group all the items into sets of three, following the rules above, so that we have the desired number of groups (`NB`).\n\nIn simpler terms, we want to divide a set of items into groups of three, making sure that each group is unique and doesn't share too many items with other groups.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 836, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a6cd0d7f-9964-4592-a74b-46c6dc275289": {"__data__": {"id_": "a6cd0d7f-9964-4592-a74b-46c6dc275289", "embedding": null, "metadata": {"model_name": "stoch_fjsp"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "stoch_fjsp_beginner", "node_type": "4", "metadata": {"model_name": "stoch_fjsp"}, "hash": "2576f5b89d93ca89b27b9d6ec77352d9d17743d3fc21f026db009a5325ca47ee", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Stochastic General Assignment Problem**\n\n**What is the problem about in everyday terms?**\nImagine you have a set of tasks that need to be completed on different machines. Each task has a specific duration, and some tasks are optional. You want to assign these tasks to the machines in a way that minimizes the total time it takes to complete all the tasks.\n\n**What are the main variables and what do they mean?**\n\n* **Machines**: These are the devices that will perform the tasks.\n* **Jobs**: These are groups of tasks that need to be completed.\n* **Tasks**: These are the individual activities that need to be performed.\n* **Optional tasks**: These are tasks that may or may not be completed.\n* **Start time**: This is the time when a task starts.\n* **Duration**: This is the time it takes to complete a task.\n* **b**: This is a variable that indicates whether an optional task is executed or not.\n\n**What are the basic restrictions or rules of the problem?**\n\n* Each task must be assigned to a machine.\n* A task cannot start before the previous task in the same job is completed.\n* The duration of a task must be within a certain range.\n* Optional tasks have specific durations and may or may not be executed.\n* The total time it takes to complete all tasks on a machine cannot exceed a certain limit.\n\n**What is the goal of the problem?**\nThe goal is to minimize the expected total time it takes to complete all tasks, considering the uncertainty in the task durations.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1558, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "96dd0502-4b06-48cf-ab56-b330deaa0c0b": {"__data__": {"id_": "96dd0502-4b06-48cf-ab56-b330deaa0c0b", "embedding": null, "metadata": {"model_name": "submultisetsum"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "submultisetsum_beginner", "node_type": "4", "metadata": {"model_name": "submultisetsum"}, "hash": "d2bab57c813ee5489ec8be0a0d49f7366c576dfe85a22ab69daedee0a9c08073", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **The Subset Sum Problem**\n\n**What the problem is about in everyday terms:**\nImagine you have a set of items, each with a specific weight or value. You want to select a subset of these items such that their total weight or value adds up to a specific target value.\n\n**Main variables and their meanings:**\n\n* `number`: an array of integers representing the weights or values of the items.\n* `target`: an integer representing the target value we want to reach.\n* `selected`: a set of integers representing the indices of the items we choose to include in our subset.\n\n**Basic restrictions or rules:**\n\n* We can only choose items from the given set.\n* The total weight or value of the selected items must equal the target value.\n\n**Goal of the problem:**\nFind a subset of items such that their total weight or value adds up to the target value.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 925, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "718147e4-1624-4a0d-849f-a258ef76a3f2": {"__data__": {"id_": "718147e4-1624-4a0d-849f-a258ef76a3f2", "embedding": null, "metadata": {"model_name": "table_seating"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "table_seating_beginner", "node_type": "4", "metadata": {"model_name": "table_seating"}, "hash": "7a3175ba6229428bd42445d2c42aabcead5495622c74d83a6900ed8b23f0261d", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **The Seating Arrangement Problem**\n\nThis problem is about arranging people at tables for a dinner or a party. Imagine you have a certain number of people and a certain number of tables, and each table can only fit a certain number of people.\n\n**Main Variables:**\n\n* `n`: The total number of people.\n* `T`: The number of tables.\n* `S`: The maximum number of people that can sit at each table.\n* `couples`: Pairs of people who want to sit together.\n* `key`: A set of special people who cannot sit together.\n* `table`: An array that shows which people are sitting at each table.\n* `seat`: An array that shows which table each person is sitting at.\n\n**Basic Restrictions or Rules:**\n\n* Each table can only fit a certain number of people (S).\n* Each person must sit at a table.\n* Couples want to sit together at the same table.\n* Special people in the `key` set cannot sit together.\n\n**Goal:**\n\nThe goal is to find a seating arrangement that minimizes the total table numbers of all couples. In other words, we want to find a way to seat the couples together at tables with the lowest possible table numbers.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1188, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "be3b14c9-2865-4b59-b23e-10774abe9b45": {"__data__": {"id_": "be3b14c9-2865-4b59-b23e-10774abe9b45", "embedding": null, "metadata": {"model_name": "teamselect"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "teamselect_beginner", "node_type": "4", "metadata": {"model_name": "teamselect"}, "hash": "9360996e283542c55fa24d318d3f33f6a546a009468f236ff7367732d1bc8f33", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Team Selection Problem**\n\nThis problem is about selecting three teams of six players each from a pool of 11 players. The teams are named Xavier, Yuri, and Zena.\n\n**Main Variables:**\n\n* Xavier, Yuri, and Zena: These are the three teams, each consisting of six players.\n* PLAYER: This is the set of all 11 players.\n* GOALIE, DEFENCE, and OFFENCE: These are subsets of players with specific roles (goalie, defense, and offense).\n* value: This is a table that shows the value or score of each player.\n\n**Basic Restrictions or Rules:**\n\n* Each team must have exactly six players.\n* Each team must have at least one goalie, two defense players, and two offense players.\n* No more than two players can be shared between any two teams.\n\n**Goal:**\n\nThe goal is to select the teams in a way that maximizes the total value or score of all three teams.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 926, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4b112781-93f8-4b0f-9fa5-f456aea0f182": {"__data__": {"id_": "4b112781-93f8-4b0f-9fa5-f456aea0f182", "embedding": null, "metadata": {"model_name": "template_design"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "template_design_beginner", "node_type": "4", "metadata": {"model_name": "template_design"}, "hash": "bc24d40030b580be9ee11076d003c05326dcccf2b6a68d1d1459a2dab1769d8d", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Template Design Problem**\n\nThis problem is about printing different variations of a product, like different flavors of a snack or different colors of a t-shirt. We need to decide how many of each variation to print and how to organize the printing process to minimize waste.\n\n**Main variables:**\n\n* `S`: The number of slots available on a printing template.\n* `t`: The number of printing templates.\n* `n`: The number of different variations of the product.\n* `d`: An array that tells us how many of each variation we need to print.\n* `p`: A 2D array that tells us how many slots on each template are allocated to each variation.\n* `R`: An array that tells us how many times each template is pressed (i.e., how many copies are made).\n* `Production`: The total number of items printed.\n* `Surplus`: The amount of waste or extra items printed.\n\n**Basic restrictions:**\n\n* Each template has `S` slots, and we need to allocate them to the different variations.\n* We need to print at least `d` items of each variation.\n* The total number of items printed (`Production`) is between `llower` and `lupper`, which are calculated based on the number of slots and the number of variations.\n* The surplus (waste) is limited by the total production.\n\n**Goal:**\n\nThe goal is to minimize the total production (i.e., the number of items printed) while meeting the demands for each variation and following the rules for allocating slots on the templates.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1522, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2c95db74-0ff5-4b55-85d7-191a0a7fbd50": {"__data__": {"id_": "2c95db74-0ff5-4b55-85d7-191a0a7fbd50", "embedding": null, "metadata": {"model_name": "toomany"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "toomany_beginner", "node_type": "4", "metadata": {"model_name": "toomany"}, "hash": "56591eaf42edd2e61b3d700b568959ea5982aaa6973fea3950c296ac1744c4a1", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Problem Name:** TooMany\n\n**What the problem is about:** Imagine you have a factory with several machines that can produce different colored products (red, white, black, and blue) every day. Each machine can produce a certain amount of each color, and there are rules about how much of each color can be produced.\n\n**Main variables:**\n\n* `n`: The number of machines in the factory.\n* `k`: The total amount of products that can be produced per day.\n* `produce[m,c]`: The amount of color `c` produced by machine `m`.\n\n**Basic restrictions or rules:**\n\n* Each machine can produce at most `k` products per day.\n* The total amount of each color produced by all machines must be within a certain range (defined by `l` and `u`).\n* If a machine produces white and black products, it cannot produce blue products.\n* The amount of blue products produced by a machine cannot be more than the amount of red products.\n* The amount of red products produced by a machine must be a multiple of 4.\n* The amount of white products produced by a machine must be a multiple of 3.\n\n**Goal of the problem:** The goal is to maximize the total amount of products produced by all machines while following the rules and restrictions.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1291, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ec701746-38dd-482f-a1ea-169ca0bf640d": {"__data__": {"id_": "ec701746-38dd-482f-a1ea-169ca0bf640d", "embedding": null, "metadata": {"model_name": "traffic_lights_table"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "traffic_lights_table_beginner", "node_type": "4", "metadata": {"model_name": "traffic_lights_table"}, "hash": "a90f2243c471c341fb8fa697b4b932582ba82b3c4970523ccc9748fafe75df93", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Traffic Light Problem**\n\nThis problem is about controlling traffic lights at a four-way junction. Imagine you're standing at a crossroads where four roads meet, and there are traffic lights for both cars and pedestrians.\n\n**Main Variables:**\n\n* `V1` to `V4`: These represent the traffic lights for cars, which can be red, red-yellow, green, or yellow.\n* `P1` to `P4`: These represent the traffic lights for pedestrians, which can be red or green.\n\n**Basic Restrictions or Rules:**\n\n* The traffic lights for cars and pedestrians at each intersection must follow certain rules, such as:\n\t+ When the car light is red, the pedestrian light must be red too.\n\t+ When the car light is green, the pedestrian light must be green too.\n\t+ When the car light is red-yellow, the pedestrian light must be yellow, and so on.\n\n**Goal:**\n\nThe goal is to find a sequence of traffic light settings that satisfy these rules and ensure safe and efficient traffic flow.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1033, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "49f75f4d-7ea0-4662-a547-df57234b5dce": {"__data__": {"id_": "49f75f4d-7ea0-4662-a547-df57234b5dce", "embedding": null, "metadata": {"model_name": "TTPPV"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "TTPPV_beginner", "node_type": "4", "metadata": {"model_name": "TTPPV"}, "hash": "8cffdae8404772fcdaaec085b2814828dc8478cf020d620c4b598c3c90374c34", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    **Traveling Tournament Problem**\n\nThis problem is about scheduling a tournament where multiple teams play each other in a round-robin format, meaning each team plays every other team once. The twist is that each game has already been assigned a specific venue (home or away), and we want to find the schedule that minimizes the total travel distance for all teams.\n\n**Main Variables:**\n\n* `nbTeams`: The number of teams participating in the tournament.\n* `opponent[i,k]`: The team that team `i` plays against in round `k`.\n* `venue[i,k]`: Whether team `i` plays at home (1) or away (2) in round `k`.\n* `travel[i,k]`: The distance team `i` travels to play in round `k` (including the return journey after the last round).\n\n**Basic Restrictions:**\n\n* A team cannot play against itself.\n* If team `i` plays team `j` in round `k`, then team `j` plays team `i` in the same round.\n* Each team plays every other team exactly once.\n* No team can have more than three consecutive home games or away games.\n\n**Goal:**\n\nThe goal is to find a schedule that minimizes the total travel distance for all teams.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1179, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "33282e11-ae77-44ac-b54d-9772351212d7": {"__data__": {"id_": "33282e11-ae77-44ac-b54d-9772351212d7", "embedding": null, "metadata": {"model_name": "vessel-loading"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "vessel-loading_beginner", "node_type": "4", "metadata": {"model_name": "vessel-loading"}, "hash": "455c460f555a28c3dcc4bf31fcacf0c89d541db37803d4dcb651aa2496a8c492", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Vessel Loading\n\nThis problem is about loading containers onto a ship's deck. Imagine you have a bunch of boxes of different sizes and types, and you need to fit them onto a rectangular deck.\n\nThe main variables are:\n\n* The width and length of the deck\n* The number of containers and their classes (types)\n* The width, length, and class of each container\n* The minimum separation required between containers of different classes\n* The position of each container on the deck (left, right, bottom, and top coordinates)\n* The orientation of each container (whether it's turned 90 degrees or not)\n\nThe basic restrictions or rules of the problem are:\n\n* Each container must fit within the deck's boundaries\n* Containers cannot overlap with each other\n* Containers of different classes must be separated by a minimum distance\n\nThe goal of the problem is to find a way to load all the containers onto the deck while following these rules.\n\nNote: The output section of the code is used to print a visual representation of the loaded containers, but it's not essential to understanding the problem itself.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1179, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "71a5e752-edbc-42e3-a679-2916be4ee562": {"__data__": {"id_": "71a5e752-edbc-42e3-a679-2916be4ee562", "embedding": null, "metadata": {"model_name": "warehouses"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "warehouses_beginner", "node_type": "4", "metadata": {"model_name": "warehouses"}, "hash": "ab03093c47b77d101878eff5d6b1bfcda1d4117e3557ab02dc8701274df203b3", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Warehouse Allocation Problem\n\nThis problem is about a company that wants to build warehouses to supply goods to stores. The company needs to decide which warehouses to build and which stores each warehouse should supply to minimize the total cost.\n\nThe main variables are:\n\n* Warehouses: These are the places where the company will store goods.\n* Stores: These are the places where the company will send goods from the warehouses.\n* Capacity: This is the number of stores that each warehouse can supply.\n* Cost: This is the cost of building a warehouse and transporting goods from the warehouse to the stores.\n\nThe basic restrictions or rules of the problem are:\n\n* Each warehouse can only supply a certain number of stores based on its capacity.\n* Each store must be supplied by only one warehouse.\n* The company wants to minimize the total cost, which includes the cost of building warehouses and transporting goods.\n\nThe goal of the problem is to find the best way to allocate warehouses to stores to minimize the total cost.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1112, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d9a5dd1a-f1e6-4fe4-bd00-7f238a6eca7b": {"__data__": {"id_": "d9a5dd1a-f1e6-4fe4-bd00-7f238a6eca7b", "embedding": null, "metadata": {"model_name": "water_buckets1"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "water_buckets1_beginner", "node_type": "4", "metadata": {"model_name": "water_buckets1"}, "hash": "cbec92d1d607404a73e40718a66c0b8a2ecd6992dad32ba6d367a7e0378d230f", "class_name": "RelatedNodeInfo"}}, "text": "Description:\n                    ---------\n                    Here is the explanation of the problem:\n\n**Name of the problem:** Water Buckets Problem\n\n**What the problem is about in everyday terms:** Imagine you have three buckets of different sizes (8, 5, and 3 pints) and you want to divide a certain amount of water between them in a specific way. You can pour water from one bucket to another, but you want to do it in the fewest number of steps possible.\n\n**Main variables and what they mean:**\n\n* `state`: an array that represents the amount of water in each bucket at each step\n* `goal_step`: the number of steps it takes to reach the desired goal\n* `buckets`: the three buckets of different sizes\n* `capacity`: the maximum amount of water each bucket can hold\n* `start` and `goal`: the initial and desired amounts of water in each bucket\n\n**Basic restrictions or rules of the problem:**\n\n* The total amount of water remains the same at each step\n* The amount of water in each bucket can only change by pouring water from one bucket to another\n* After each step, either the source bucket becomes empty or the target bucket becomes full\n* The goal is to reach the desired amounts of water in each bucket in the fewest number of steps possible\n\n**Goal of the problem:** Minimize the number of steps (`goal_step`) it takes to reach the desired goal.\n\nNote that Model 2 appears to be a different problem, but it's actually a reformulation of the same Water Buckets Problem using a different modeling approach.", "mimetype": "text/plain", "start_char_idx": 21, "end_char_idx": 1534, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"all_interval_beginner": {"node_ids": ["7a282f3c-6006-433c-820a-54a1b4ad0717"], "metadata": {"model_name": "all_interval"}}, "assign_beginner": {"node_ids": ["38bc7257-ea7c-48e5-a0eb-fbab0a7b7e6c"], "metadata": {"model_name": "assign"}}, "aust_color_beginner": {"node_ids": ["de0e3c1d-249e-419b-8f66-e2922e289a5a"], "metadata": {"model_name": "aust_color"}}, "bibd_beginner": {"node_ids": ["cf16060e-2ba2-4fbc-9f45-eff90b096978"], "metadata": {"model_name": "bibd"}}, "bus_scheduling_csplib_beginner": {"node_ids": ["1c66519b-cd9c-4e51-999f-6e771d7ad947"], "metadata": {"model_name": "bus_scheduling_csplib"}}, "car_beginner": {"node_ids": ["b5a2ae50-2108-4306-9674-9b9fdc689538"], "metadata": {"model_name": "car"}}, "carpet_cutting_beginner": {"node_ids": ["1b27f5dc-befe-4558-bc03-0e200c99ae28"], "metadata": {"model_name": "carpet_cutting"}}, "cell_block_beginner": {"node_ids": ["192b98b3-88ea-4b58-9e22-cbaae970cf5b"], "metadata": {"model_name": "cell_block"}}, "clique_beginner": {"node_ids": ["670d6155-4fa3-471c-849a-c18d35293349"], "metadata": {"model_name": "clique"}}, "cluster_beginner": {"node_ids": ["d9c00ad0-bfef-416b-a5d9-fb6349c0e5a5"], "metadata": {"model_name": "cluster"}}, "compatible_assignment_beginner": {"node_ids": ["b3bccc56-5d6a-4465-a323-9743cb7e13e8"], "metadata": {"model_name": "compatible_assignment"}}, "constrained_connected_beginner": {"node_ids": ["72c61436-8d5d-4b7e-b05b-c5dbb460d118"], "metadata": {"model_name": "constrained_connected"}}, "crazy_sets_beginner": {"node_ids": ["4f01f33b-a4a2-44a1-95d5-36fe06874945"], "metadata": {"model_name": "crazy_sets"}}, "crossfigure_beginner": {"node_ids": ["6a4f19ff-8767-4add-b56a-a0931bed394d"], "metadata": {"model_name": "crossfigure"}}, "curriculum_beginner": {"node_ids": ["e3bd58be-b09b-48a3-b916-f0dfd38fef34"], "metadata": {"model_name": "curriculum"}}, "diamond_free_degree_sequence_beginner": {"node_ids": ["84a79840-ba59-4a3b-b654-06fb591b1939"], "metadata": {"model_name": "diamond_free_degree_sequence"}}, "doublechannel_beginner": {"node_ids": ["efb5e89b-2814-4b20-b758-44b58e00d5ff"], "metadata": {"model_name": "doublechannel"}}, "fractions_beginner": {"node_ids": ["dffceb46-4caa-4099-93b0-92f66fd92861"], "metadata": {"model_name": "fractions"}}, "golfers_beginner": {"node_ids": ["f9040410-23ea-42ad-a8da-a5813603ada9"], "metadata": {"model_name": "golfers"}}, "golomb_beginner": {"node_ids": ["5482edd3-840a-4a37-a807-68ab1843a20b"], "metadata": {"model_name": "golomb"}}, "graph_beginner": {"node_ids": ["ec0f9b6e-9dbd-4dfb-9a8c-f68de8ffcebb"], "metadata": {"model_name": "graph"}}, "itemset_mining_beginner": {"node_ids": ["c2bd883f-93a3-4330-a0b4-57410f81c6f1"], "metadata": {"model_name": "itemset_mining"}}, "jobshop_beginner": {"node_ids": ["b7ae399c-8379-4edf-914b-638a4cf4ab35"], "metadata": {"model_name": "jobshop"}}, "K4xP2Graceful_beginner": {"node_ids": ["ded61cf7-0046-4a14-a7be-07c76f337cab"], "metadata": {"model_name": "K4xP2Graceful"}}, "killer_sudoku_beginner": {"node_ids": ["27c72c65-f7d2-4cf7-ad49-d78d30c3aa43"], "metadata": {"model_name": "killer_sudoku"}}, "knapsack_beginner": {"node_ids": ["4467eab3-c3cc-413f-a759-558199515760"], "metadata": {"model_name": "knapsack"}}, "langford_beginner": {"node_ids": ["24af84b7-a264-4cda-b2a6-b170ff48f323"], "metadata": {"model_name": "langford"}}, "loan_beginner": {"node_ids": ["422c9037-5bfd-4cdb-af00-2a20faea8e34"], "metadata": {"model_name": "loan"}}, "ltsp_beginner": {"node_ids": ["a1750cd1-eae1-4cf8-9f6c-9ce05854af80"], "metadata": {"model_name": "ltsp"}}, "magic_hexagon_beginner": {"node_ids": ["6a73104f-9e36-4551-93f2-56f5f462f5f8"], "metadata": {"model_name": "magic_hexagon"}}, "magic_sequence_beginner": {"node_ids": ["9569f4c0-4335-46e3-9fbf-d7f4b7458722"], "metadata": {"model_name": "magic_sequence"}}, "maximum_density_still_life_beginner": {"node_ids": ["e46404eb-9079-4658-a12d-9eb4afe4bc09"], "metadata": {"model_name": "maximum_density_still_life"}}, "mip_beginner": {"node_ids": ["0479ed3d-59e1-46c9-b9fd-f0f24f105518"], "metadata": {"model_name": "mip"}}, "missing_solution_beginner": {"node_ids": ["0b65a57d-c559-4897-9409-2831a8e530f3"], "metadata": {"model_name": "missing_solution"}}, "nonogram_create_automaton2_beginner": {"node_ids": ["f2966efd-ce8e-4874-83f5-0cea183ec6a2"], "metadata": {"model_name": "nonogram_create_automaton2"}}, "nurses_beginner": {"node_ids": ["bf76992c-935d-4233-a4b9-7a65d0b6a93d"], "metadata": {"model_name": "nurses"}}, "opd_beginner": {"node_ids": ["81d79f4d-a0ec-4007-af68-847ded83536f"], "metadata": {"model_name": "opd"}}, "partition_beginner": {"node_ids": ["2715be99-61b5-4664-94ce-87ad66d45263"], "metadata": {"model_name": "partition"}}, "photo_beginner": {"node_ids": ["3ef1035d-709a-425b-a3c3-734a80e29209"], "metadata": {"model_name": "photo"}}, "project_scheduling_beginner": {"node_ids": ["fdee7291-4bee-4c2d-b28e-30ab98a533c2"], "metadata": {"model_name": "project_scheduling"}}, "QuasigroupCompletion_beginner": {"node_ids": ["1c44cd22-62d5-4fc0-9b4f-2955334be8e7"], "metadata": {"model_name": "QuasigroupCompletion"}}, "QuasiGroupExistence_beginner": {"node_ids": ["79b4455a-f750-4171-8f32-1c84a3d99dd8"], "metadata": {"model_name": "QuasiGroupExistence"}}, "queens_beginner": {"node_ids": ["23fb4f42-982f-4e2b-a7ba-2a900c78bea8"], "metadata": {"model_name": "queens"}}, "rcpsp_beginner": {"node_ids": ["d57961b0-7604-444f-9418-b4a2137b3961"], "metadata": {"model_name": "rcpsp"}}, "rehearsal_beginner": {"node_ids": ["97acf8ea-577b-47ea-b19b-8171e81ce767"], "metadata": {"model_name": "rehearsal"}}, "restart_beginner": {"node_ids": ["c187b8ca-71de-427a-b730-21d695c97305"], "metadata": {"model_name": "restart"}}, "RosteringProblem_beginner": {"node_ids": ["9a919f76-075d-46f4-8b68-2f8af0f01d55"], "metadata": {"model_name": "RosteringProblem"}}, "sb_beginner": {"node_ids": ["134210d5-d16f-4d5e-8868-c6582460e9b7"], "metadata": {"model_name": "sb"}}, "schur_beginner": {"node_ids": ["3224a6eb-add9-4648-a5a7-bef78418c1b7"], "metadata": {"model_name": "schur"}}, "setselect_beginner": {"node_ids": ["4fd5d53b-01f3-4a82-9da2-fa545e94e112"], "metadata": {"model_name": "setselect"}}, "shipping_beginner": {"node_ids": ["4aed6317-cf4c-4ec8-9fad-12ad0fd99cc1"], "metadata": {"model_name": "shipping"}}, "simple-prod-planning_beginner": {"node_ids": ["0344e1e1-10bf-45b3-92c2-5b67e23375cd"], "metadata": {"model_name": "simple-prod-planning"}}, "sonet_problem_beginner": {"node_ids": ["c3104dcb-cca7-4438-a00c-a28d02579bdd"], "metadata": {"model_name": "sonet_problem"}}, "square_pack_beginner": {"node_ids": ["918c8927-0e43-4cc5-88cc-77b88657bd62"], "metadata": {"model_name": "square_pack"}}, "stableroommates_beginner": {"node_ids": ["3672d5af-30f6-4305-9be4-ea94836364ba"], "metadata": {"model_name": "stableroommates"}}, "steiner_beginner": {"node_ids": ["abef35a2-972a-4faa-aa3a-a7ca09aa7e3c"], "metadata": {"model_name": "steiner"}}, "stoch_fjsp_beginner": {"node_ids": ["a6cd0d7f-9964-4592-a74b-46c6dc275289"], "metadata": {"model_name": "stoch_fjsp"}}, "submultisetsum_beginner": {"node_ids": ["96dd0502-4b06-48cf-ab56-b330deaa0c0b"], "metadata": {"model_name": "submultisetsum"}}, "table_seating_beginner": {"node_ids": ["718147e4-1624-4a0d-849f-a258ef76a3f2"], "metadata": {"model_name": "table_seating"}}, "teamselect_beginner": {"node_ids": ["be3b14c9-2865-4b59-b23e-10774abe9b45"], "metadata": {"model_name": "teamselect"}}, "template_design_beginner": {"node_ids": ["4b112781-93f8-4b0f-9fa5-f456aea0f182"], "metadata": {"model_name": "template_design"}}, "toomany_beginner": {"node_ids": ["2c95db74-0ff5-4b55-85d7-191a0a7fbd50"], "metadata": {"model_name": "toomany"}}, "traffic_lights_table_beginner": {"node_ids": ["ec701746-38dd-482f-a1ea-169ca0bf640d"], "metadata": {"model_name": "traffic_lights_table"}}, "TTPPV_beginner": {"node_ids": ["49f75f4d-7ea0-4662-a547-df57234b5dce"], "metadata": {"model_name": "TTPPV"}}, "vessel-loading_beginner": {"node_ids": ["33282e11-ae77-44ac-b54d-9772351212d7"], "metadata": {"model_name": "vessel-loading"}}, "warehouses_beginner": {"node_ids": ["71a5e752-edbc-42e3-a679-2916be4ee562"], "metadata": {"model_name": "warehouses"}}, "water_buckets1_beginner": {"node_ids": ["d9a5dd1a-f1e6-4fe4-bd00-7f238a6eca7b"], "metadata": {"model_name": "water_buckets1"}}}}